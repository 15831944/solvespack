<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo1.20171224004528.1"><vh>@settings</vh>
<v t="leo1.20171224004528.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo1.20171224004528.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo1.20171224010119.1"><vh>@button cmake</vh></v>
<v t="leo1.20171224010128.1"><vh>@button mingw32-make</vh></v>
<v t="leo1.20171224082621.1" a="E"><vh>@path ./../</vh>
<v t="leo1.20171224082630.1"><vh>@edit README.md</vh></v>
</v>
<v t="leo1.20171224004715.1"><vh>git clone solvespace source codes</vh></v>
<v t="leo1.20171224004519.1"><vh>@path ./../extlib/angle</vh>
<v t="leo1.20171224010556.1"><vh>comment out dlls</vh></v>
<v t="leo1.20171224004928.1"><vh>@edit CMakeLists.txt</vh></v>
</v>
<v t="leo1.20171224221039.1"><vh>import src cpp</vh>
<v t="leo1.20171224221219.1" a="E"><vh>imported files</vh>
<v t="leo1.20171224221326.1"><vh>import log</vh></v>
<v t="leo1.20171224221220.1" a="E"><vh>@path ./../src</vh>
<v t="leo1.20171224221913.1"><vh>binary space partitioning</vh></v>
<v t="leo1.20171224221220.2" a="E"><vh>@@clean bsp.cpp</vh>
<v t="leo1.20171224221220.3"><vh>void SBsp3::InsertInPlane</vh></v>
<v t="leo1.20171224221220.4"><vh>void SBsp3::InsertHow</vh></v>
<v t="leo1.20171224221220.5"><vh>class BspUtil</vh>
<v t="leo1.20171224221220.6"><vh>static BspUtil</vh></v>
<v t="leo1.20171224221220.7"><vh>void AllocOn</vh></v>
<v t="leo1.20171224221220.8"><vh>void AllocTriangle</vh></v>
<v t="leo1.20171224221220.9"><vh>void AllocTriangles</vh></v>
<v t="leo1.20171224221220.10"><vh>void AllocQuad</vh></v>
<v t="leo1.20171224221220.11"><vh>void AllocClassify</vh></v>
<v t="leo1.20171224221220.12"><vh>void AllocVertices</vh></v>
<v t="leo1.20171224221220.13"><vh>void ClassifyTriangle</vh></v>
<v t="leo1.20171224221220.14"><vh>bool ClassifyConvex</vh></v>
<v t="leo1.20171224221220.15"><vh>bool ClassifyConvexVertices</vh></v>
<v t="leo1.20171224221220.16"><vh>void ProcessEdgeInsert</vh></v>
<v t="leo1.20171224221220.17"><vh>bool SplitIntoTwoTriangles</vh></v>
<v t="leo1.20171224221220.18"><vh>bool SplitIntoTwoPieces</vh></v>
<v t="leo1.20171224221220.19"><vh>static SBsp3</vh></v>
</v>
<v t="leo1.20171224221220.20"><vh>void SBsp3::InsertConvexHow</vh></v>
<v t="leo1.20171224221220.21"><vh>void SBsp3::Insert</vh></v>
<v t="leo1.20171224221220.22"><vh>void SBsp3::GenerateInPaintOrder</vh></v>
<v t="leo1.20171224221220.23"><vh>void SBsp2::InsertEdge</vh></v>
<v t="leo1.20171224221220.24"><vh>void SBsp2::InsertTriangleHow</vh></v>
<v t="leo1.20171224221220.25"><vh>void SBsp2::InsertTriangle</vh></v>
</v>
<v t="leo1.20171224221220.26"><vh>@@clean clipboard.cpp</vh>
<v t="leo1.20171224221220.27"><vh>void SolveSpaceUI::Clipboard::Clear</vh></v>
<v t="leo1.20171224221220.28"><vh>bool SolveSpaceUI::Clipboard::ContainsEntity</vh></v>
<v t="leo1.20171224221220.29"><vh>void GraphicsWindow::DeleteSelection</vh></v>
<v t="leo1.20171224221220.30"><vh>void GraphicsWindow::CopySelection</vh></v>
<v t="leo1.20171224221220.31"><vh>void GraphicsWindow::PasteClipboard</vh>
<v t="leo1.20171224221220.32"><vh>auto mapPoint</vh></v>
</v>
<v t="leo1.20171224221220.33"><vh>void GraphicsWindow::MenuClipboard</vh></v>
<v t="leo1.20171224221220.34"><vh>bool TextWindow::EditControlDoneForPaste</vh></v>
<v t="leo1.20171224221220.35"><vh>void TextWindow::ScreenChangePasteTransformed</vh></v>
<v t="leo1.20171224221220.36"><vh>void TextWindow::ScreenPasteTransformed</vh></v>
<v t="leo1.20171224221220.37"><vh>void TextWindow::ShowPasteTransformed</vh></v>
</v>
<v t="leo1.20171224221220.38"><vh>@@clean confscreen.cpp</vh>
<v t="leo1.20171224221220.39"><vh>void TextWindow::ScreenChangeLightDirection</vh></v>
<v t="leo1.20171224221220.40"><vh>void TextWindow::ScreenChangeLightIntensity</vh></v>
<v t="leo1.20171224221220.41"><vh>void TextWindow::ScreenChangeColor</vh></v>
<v t="leo1.20171224221220.42"><vh>void TextWindow::ScreenChangeChordTolerance</vh></v>
<v t="leo1.20171224221220.43"><vh>void TextWindow::ScreenChangeMaxSegments</vh></v>
<v t="leo1.20171224221220.44"><vh>void TextWindow::ScreenChangeExportChordTolerance</vh></v>
<v t="leo1.20171224221220.45"><vh>void TextWindow::ScreenChangeExportMaxSegments</vh></v>
<v t="leo1.20171224221220.46"><vh>void TextWindow::ScreenChangeCameraTangent</vh></v>
<v t="leo1.20171224221220.47"><vh>void TextWindow::ScreenChangeGridSpacing</vh></v>
<v t="leo1.20171224221220.48"><vh>void TextWindow::ScreenChangeDigitsAfterDecimal</vh></v>
<v t="leo1.20171224221220.49"><vh>void TextWindow::ScreenChangeExportScale</vh></v>
<v t="leo1.20171224221220.50"><vh>void TextWindow::ScreenChangeExportOffset</vh></v>
<v t="leo1.20171224221220.51"><vh>void TextWindow::ScreenChangeFixExportColors</vh></v>
<v t="leo1.20171224221220.52"><vh>void TextWindow::ScreenChangeBackFaces</vh></v>
<v t="leo1.20171224221220.53"><vh>void TextWindow::ScreenChangeShowContourAreas</vh></v>
<v t="leo1.20171224221220.54"><vh>void TextWindow::ScreenChangeCheckClosedContour</vh></v>
<v t="leo1.20171224221220.55"><vh>void TextWindow::ScreenChangeShadedTriangles</vh></v>
<v t="leo1.20171224221220.56"><vh>void TextWindow::ScreenChangePwlCurves</vh></v>
<v t="leo1.20171224221220.57"><vh>void TextWindow::ScreenChangeCanvasSizeAuto</vh></v>
<v t="leo1.20171224221220.58"><vh>void TextWindow::ScreenChangeCanvasSize</vh></v>
<v t="leo1.20171224221220.59"><vh>void TextWindow::ScreenChangeGCodeParameter</vh></v>
<v t="leo1.20171224221220.60"><vh>void TextWindow::ScreenChangeAutosaveInterval</vh></v>
<v t="leo1.20171224221220.61"><vh>void TextWindow::ShowConfiguration</vh></v>
<v t="leo1.20171224221220.62"><vh>bool TextWindow::EditControlDoneForConfiguration</vh></v>
</v>
<v t="leo1.20171224221220.63"><vh>@@clean constraint.cpp</vh>
<v t="leo1.20171224221220.64"><vh>void Constraint::DeleteAllConstraintsFor</vh></v>
<v t="leo1.20171224221220.65"><vh>bool other</vh></v>
<v t="leo1.20171224221220.66"><vh>void Constraint::MenuConstrain</vh>
<v t="leo1.20171224221220.67"><vh>const raint</vh></v>
</v>
</v>
<v t="leo1.20171224221220.68"><vh>@@clean constrainteq.cpp</vh>
<v t="leo1.20171224221220.69"><vh>bool ConstraintBase::HasLabel</vh></v>
<v t="leo1.20171224221220.70"><vh>void ConstraintBase::ModifyToSatisfy</vh></v>
<v t="leo1.20171224221220.71"><vh>void ConstraintBase::AddEq</vh></v>
<v t="leo1.20171224221220.72"><vh>void ConstraintBase::AddEq</vh></v>
<v t="leo1.20171224221220.73"><vh>void ConstraintBase::Generate</vh></v>
<v t="leo1.20171224221220.74"><vh>void ConstraintBase::GenerateEquations</vh></v>
</v>
<v t="leo1.20171224221220.75"><vh>@@clean describescreen.cpp</vh>
<v t="leo1.20171224221220.76"><vh>void TextWindow::ScreenUnselectAll</vh></v>
<v t="leo1.20171224221220.77"><vh>void TextWindow::ScreenEditTtfText</vh></v>
<v t="leo1.20171224221220.78"><vh>void TextWindow::ScreenSetTtfFont</vh></v>
<v t="leo1.20171224221220.79"><vh>void TextWindow::ScreenConstraintShowAsRadius</vh></v>
<v t="leo1.20171224221220.80"><vh>void TextWindow::DescribeSelection</vh>
<v t="leo1.20171224221220.81"><vh>auto it</vh></v>
</v>
<v t="leo1.20171224221220.82"><vh>void TextWindow::GoToScreen</vh></v>
</v>
<v t="leo1.20171224221221.1" a="E"><vh>@@clean draw.cpp</vh>
<v t="leo1.20171224221221.2"><vh>bool GraphicsWindow::Selection::Equals</vh></v>
<v t="leo1.20171224221221.3"><vh>bool GraphicsWindow::Selection::IsEmpty</vh></v>
<v t="leo1.20171224221221.4"><vh>bool GraphicsWindow::Selection::HasEndpoints</vh></v>
<v t="leo1.20171224221221.5"><vh>void GraphicsWindow::Selection::Clear</vh></v>
<v t="leo1.20171224221221.6"><vh>void GraphicsWindow::Selection::Draw</vh>
<v t="leo1.20171224221221.7"><vh>auto it</vh></v>
</v>
<v t="leo1.20171224221221.8"><vh>void GraphicsWindow::ClearSelection</vh></v>
<v t="leo1.20171224221221.9"><vh>void GraphicsWindow::ClearNonexistentSelectionItems</vh></v>
<v t="leo1.20171224221221.10"><vh>bool GraphicsWindow::IsSelected</vh></v>
<v t="leo1.20171224221221.11"><vh>bool GraphicsWindow::IsSelected</vh></v>
<v t="leo1.20171224221221.12"><vh>void GraphicsWindow::MakeUnselected</vh></v>
<v t="leo1.20171224221221.13"><vh>void GraphicsWindow::MakeUnselected</vh></v>
<v t="leo1.20171224221221.14"><vh>void GraphicsWindow::MakeSelected</vh></v>
<v t="leo1.20171224221221.15"><vh>void GraphicsWindow::MakeSelected</vh></v>
<v t="leo1.20171224221221.16"><vh>void GraphicsWindow::MakeSelected</vh></v>
<v t="leo1.20171224221221.17"><vh>void GraphicsWindow::SelectByMarquee</vh></v>
<v t="leo1.20171224221221.18"><vh>void GraphicsWindow::GroupSelection</vh></v>
<v t="leo1.20171224221221.19"><vh>void GraphicsWindow::HitTestMakeSelection</vh></v>
<v t="leo1.20171224221221.20"><vh>void GraphicsWindow::NormalizeProjectionVectors</vh></v>
<v t="leo1.20171224221221.21"><vh>void GraphicsWindow::DrawSnapGrid</vh>
<v t="leo1.20171224221221.22"><vh>double umin</vh></v>
</v>
<v t="leo1.20171224221221.23"><vh>void GraphicsWindow::DrawEntities</vh></v>
<v t="leo1.20171224221221.24"><vh>void GraphicsWindow::DrawPersistent</vh></v>
<v t="leo1.20171224221221.25"><vh>void GraphicsWindow::Draw</vh></v>
<v t="leo1.20171224221221.26"><vh>void GraphicsWindow::Paint</vh></v>
</v>
<v t="leo1.20171224221221.27"><vh>@@clean drawconstraint.cpp</vh>
<v t="leo1.20171224221221.28"><vh>void Constraint::DoLine</vh></v>
<v t="leo1.20171224221221.29"><vh>void Constraint::DoStippledLine</vh></v>
<v t="leo1.20171224221221.30"><vh>void Constraint::DoLabel</vh>
<v t="leo1.20171224221221.31"><vh>double swidth</vh></v>
</v>
<v t="leo1.20171224221221.32"><vh>void Constraint::DoProjectedPoint</vh></v>
<v t="leo1.20171224221221.33"><vh>void Constraint::DoProjectedPoint</vh></v>
<v t="leo1.20171224221221.34"><vh>int Constraint::DoLineTrimmedAgainstBox</vh>
<v t="leo1.20171224221221.35"><vh>double swidth</vh></v>
</v>
<v t="leo1.20171224221221.36"><vh>void Constraint::DoArrow</vh></v>
<v t="leo1.20171224221221.37"><vh>void Constraint::DoLineWithArrows</vh></v>
<v t="leo1.20171224221221.38"><vh>void Constraint::DoEqualLenTicks</vh></v>
<v t="leo1.20171224221221.39"><vh>void Constraint::DoEqualRadiusTicks</vh></v>
<v t="leo1.20171224221221.40"><vh>void Constraint::DoArcForAngle</vh></v>
<v t="leo1.20171224221221.41"><vh>bool Constraint::IsVisible</vh></v>
<v t="leo1.20171224221221.42"><vh>bool Constraint::DoLineExtend</vh></v>
<v t="leo1.20171224221221.43"><vh>void Constraint::DoLayout</vh></v>
<v t="leo1.20171224221221.44"><vh>void Constraint::Draw</vh></v>
<v t="leo1.20171224221221.45"><vh>void Constraint::GetReferencePoints</vh></v>
<v t="leo1.20171224221221.46"><vh>bool Constraint::IsStylable</vh></v>
<v t="leo1.20171224221221.47"><vh>bool Constraint::HasLabel</vh></v>
</v>
<v t="leo1.20171224221221.48"><vh>@@clean drawentity.cpp</vh>
<v t="leo1.20171224221221.49"><vh>void Entity::GenerateEdges</vh></v>
<v t="leo1.20171224221221.50"><vh>void Entity::GetReferencePoints</vh></v>
<v t="leo1.20171224221221.51"><vh>int Entity::GetPositionOfPoint</vh></v>
<v t="leo1.20171224221221.52"><vh>bool Entity::IsStylable</vh></v>
<v t="leo1.20171224221221.53"><vh>bool Entity::IsVisible</vh></v>
<v t="leo1.20171224221221.54"><vh>void Entity::CalculateNumerical</vh></v>
<v t="leo1.20171224221221.55"><vh>void Entity::ComputeInterpolatingSpline</vh></v>
<v t="leo1.20171224221221.56"><vh>void Entity::GenerateBezierCurves</vh></v>
<v t="leo1.20171224221221.57"><vh>void Entity::Draw</vh></v>
</v>
<v t="leo1.20171224221221.58"><vh>@@clean entity.cpp</vh>
<v t="leo1.20171224221221.59"><vh>bool EntityBase::HasVector</vh></v>
<v t="leo1.20171224221221.60"><vh>bool EntityBase::IsCircle</vh></v>
<v t="leo1.20171224221221.61"><vh>void EntityBase::ArcGetAngles</vh></v>
<v t="leo1.20171224221221.62"><vh>bool EntityBase::IsWorkplane</vh></v>
<v t="leo1.20171224221221.63"><vh>void EntityBase::WorkplaneGetPlaneExprs</vh></v>
<v t="leo1.20171224221221.64"><vh>bool EntityBase::IsDistance</vh></v>
<v t="leo1.20171224221221.65"><vh>void EntityBase::DistanceForceTo</vh></v>
<v t="leo1.20171224221221.66"><vh>bool EntityBase::IsPoint</vh></v>
<v t="leo1.20171224221221.67"><vh>bool EntityBase::IsNormal</vh></v>
<v t="leo1.20171224221221.68"><vh>void EntityBase::NormalForceTo</vh></v>
<v t="leo1.20171224221221.69"><vh>void EntityBase::PointForceParamTo</vh></v>
<v t="leo1.20171224221221.70"><vh>void EntityBase::PointForceTo</vh></v>
<v t="leo1.20171224221221.71"><vh>void EntityBase::PointGetExprsInWorkplane</vh></v>
<v t="leo1.20171224221221.72"><vh>void EntityBase::PointForceQuaternionTo</vh></v>
<v t="leo1.20171224221221.73"><vh>bool EntityBase::IsFace</vh></v>
<v t="leo1.20171224221221.74"><vh>bool EntityBase::HasEndpoints</vh></v>
<v t="leo1.20171224221221.75"><vh>void EntityBase::RectGetPointsExprs</vh></v>
<v t="leo1.20171224221221.76"><vh>void EntityBase::AddEq</vh></v>
<v t="leo1.20171224221221.77"><vh>void EntityBase::GenerateEquations</vh></v>
</v>
<v t="leo1.20171224221221.78"><vh>@@clean export.cpp</vh>
<v t="leo1.20171224221221.79"><vh>void SolveSpaceUI::ExportSectionTo</vh></v>
<v t="leo1.20171224221221.80"><vh>class GetEdgesCanvas</vh>
<v t="leo1.20171224221221.81"><vh>const Camera</vh></v>
<v t="leo1.20171224221221.82"><vh>void DrawLine</vh></v>
<v t="leo1.20171224221221.83"><vh>void DrawEdges</vh></v>
<v t="leo1.20171224221221.84"><vh>void DrawVectorText</vh></v>
<v t="leo1.20171224221221.85"><vh>void DrawQuad</vh></v>
<v t="leo1.20171224221221.86"><vh>bool DrawBeziers</vh></v>
<v t="leo1.20171224221221.87"><vh>void DrawOutlines</vh></v>
<v t="leo1.20171224221221.88"><vh>void DrawPoint</vh></v>
<v t="leo1.20171224221221.89"><vh>void DrawPolygon</vh></v>
<v t="leo1.20171224221221.90"><vh>void DrawMesh</vh></v>
<v t="leo1.20171224221221.91"><vh>void DrawFaces</vh></v>
<v t="leo1.20171224221221.92"><vh>void DrawPixmap</vh></v>
<v t="leo1.20171224221221.93"><vh>void InvalidatePixmap</vh></v>
</v>
<v t="leo1.20171224221221.94"><vh>void SolveSpaceUI::ExportViewOrWireframeTo</vh></v>
<v t="leo1.20171224221221.95"><vh>void SolveSpaceUI::ExportWireframeCurves</vh></v>
<v t="leo1.20171224221221.96"><vh>void SolveSpaceUI::ExportLinesAndMesh</vh></v>
<v t="leo1.20171224221221.97"><vh>void VectorFileWriter::SetModelviewProjection</vh></v>
<v t="leo1.20171224221221.98"><vh>void VectorFileWriter::OutputLinesAndMesh</vh></v>
<v t="leo1.20171224221221.99"><vh>void VectorFileWriter::BezierAsPwl</vh></v>
<v t="leo1.20171224221221.100"><vh>void VectorFileWriter::BezierAsNonrationalCubic</vh></v>
<v t="leo1.20171224221221.101"><vh>void SolveSpaceUI::ExportMeshTo</vh></v>
<v t="leo1.20171224221221.102"><vh>void SolveSpaceUI::ExportMeshAsStlTo</vh></v>
<v t="leo1.20171224221221.103"><vh>void SolveSpaceUI::ExportMeshAsObjTo</vh></v>
<v t="leo1.20171224221221.104"><vh>void SolveSpaceUI::ExportMeshAsThreeJsTo</vh></v>
<v t="leo1.20171224221221.105"><vh>void SolveSpaceUI::ExportAsPngTo</vh></v>
</v>
<v t="leo1.20171224221222.1"><vh>@@clean exportstep.cpp</vh></v>
<v t="leo1.20171224221222.3"><vh>@@clean exportvector.cpp</vh>
<v t="leo1.20171224221222.4"><vh>class DxfWriteInterface</vh>
<v t="leo1.20171224221222.5"><vh>static DRW_Coord</vh></v>
<v t="leo1.20171224221222.6"><vh>void writeTextstyles</vh></v>
<v t="leo1.20171224221222.7"><vh>void writeLayers</vh></v>
<v t="leo1.20171224221222.8"><vh>void writeLTypes</vh></v>
<v t="leo1.20171224221222.9"><vh>void writePolylines</vh>
<v t="leo1.20171224221222.10"><vh>auto startFunc</vh></v>
<v t="leo1.20171224221222.11"><vh>auto nextFunc</vh></v>
<v t="leo1.20171224221222.12"><vh>auto endFunc</vh></v>
<v t="leo1.20171224221222.13"><vh>auto aloneFunc</vh></v>
</v>
<v t="leo1.20171224221222.14"><vh>void writeEntities</vh></v>
<v t="leo1.20171224221222.15"><vh>int findDxfColor</vh></v>
<v t="leo1.20171224221222.16"><vh>void assignEntityDefaults</vh></v>
<v t="leo1.20171224221222.17"><vh>void assignDimensionDefaults</vh></v>
<v t="leo1.20171224221222.18"><vh>void writeLine</vh></v>
<v t="leo1.20171224221222.19"><vh>void writeArc</vh></v>
<v t="leo1.20171224221222.20"><vh>void writeBezierAsPwl</vh></v>
<v t="leo1.20171224221222.21"><vh>void makeKnotsFor</vh></v>
<v t="leo1.20171224221222.22"><vh>void writeSpline</vh></v>
<v t="leo1.20171224221222.23"><vh>void writeBezier</vh></v>
<v t="leo1.20171224221222.24"><vh>void writeAlignedDimension</vh></v>
<v t="leo1.20171224221222.25"><vh>void writeLinearDimension</vh></v>
<v t="leo1.20171224221222.26"><vh>void writeRadialDimension</vh></v>
<v t="leo1.20171224221222.27"><vh>void writeDiametricDimension</vh></v>
<v t="leo1.20171224221222.28"><vh>void writeAngularDimension</vh></v>
<v t="leo1.20171224221222.29"><vh>void writeText</vh></v>
</v>
<v t="leo1.20171224221222.30"><vh>bool DxfFileWriter::OutputConstraints</vh></v>
<v t="leo1.20171224221222.31"><vh>void DxfFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.32"><vh>void DxfFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.33"><vh>void DxfFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.34"><vh>void DxfFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.35"><vh>void DxfFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.36"><vh>void DxfFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.37"><vh>bool DxfFileWriter::NeedToOutput</vh></v>
<v t="leo1.20171224221222.38"><vh>const char *DxfFileWriter::lineTypeName(StipplePattern stippleType) {</vh></v>
<v t="leo1.20171224221222.39"><vh>static std::string</vh></v>
<v t="leo1.20171224221222.40"><vh>void EpsFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.41"><vh>void EpsFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.42"><vh>void EpsFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.43"><vh>void EpsFileWriter::MaybeMoveTo</vh></v>
<v t="leo1.20171224221222.44"><vh>void EpsFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.45"><vh>void EpsFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.46"><vh>void EpsFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.47"><vh>void PdfFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.48"><vh>void PdfFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.49"><vh>void PdfFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.50"><vh>void PdfFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.51"><vh>void PdfFileWriter::MaybeMoveTo</vh></v>
<v t="leo1.20171224221222.52"><vh>void PdfFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.53"><vh>void PdfFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.54"><vh>void SvgFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.55"><vh>void SvgFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.56"><vh>void SvgFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.57"><vh>void SvgFileWriter::MaybeMoveTo</vh></v>
<v t="leo1.20171224221222.58"><vh>void SvgFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.59"><vh>void SvgFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.60"><vh>void SvgFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.61"><vh>void HpglFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.62"><vh>void HpglFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.63"><vh>void HpglFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.64"><vh>void HpglFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.65"><vh>void HpglFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.66"><vh>void HpglFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.67"><vh>void GCodeFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.68"><vh>void GCodeFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.69"><vh>void GCodeFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.70"><vh>void GCodeFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.71"><vh>void GCodeFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.72"><vh>void GCodeFileWriter::FinishAndCloseFile</vh></v>
<v t="leo1.20171224221222.73"><vh>void Step2dFileWriter::StartFile</vh></v>
<v t="leo1.20171224221222.74"><vh>void Step2dFileWriter::Triangle</vh></v>
<v t="leo1.20171224221222.75"><vh>void Step2dFileWriter::StartPath</vh></v>
<v t="leo1.20171224221222.76"><vh>void Step2dFileWriter::FinishPath</vh></v>
<v t="leo1.20171224221222.77"><vh>void Step2dFileWriter::Bezier</vh></v>
<v t="leo1.20171224221222.78"><vh>void Step2dFileWriter::FinishAndCloseFile</vh></v>
</v>
<v t="leo1.20171224221222.79"><vh>@@clean expr.cpp</vh>
<v t="leo1.20171224221222.80"><vh>int Expr::Children</vh></v>
<v t="leo1.20171224221222.81"><vh>int Expr::Nodes</vh></v>
<v t="leo1.20171224221222.82"><vh>bool Expr::DependsOn</vh></v>
<v t="leo1.20171224221222.83"><vh>bool Expr::Tol</vh></v>
<v t="leo1.20171224221222.84"><vh>void Expr::Substitute</vh></v>
<v t="leo1.20171224221222.85"><vh>class ExprParser</vh>
<v t="leo1.20171224221222.86"><vh>class Token</vh></v>
</v>
<v t="leo1.20171224221222.87"><vh>char ExprParser::ReadChar</vh></v>
<v t="leo1.20171224221222.88"><vh>char ExprParser::PeekChar</vh></v>
<v t="leo1.20171224221222.89"><vh>void ExprParser::SkipSpace</vh></v>
<v t="leo1.20171224221222.90"><vh>int ExprParser::Precedence</vh></v>
<v t="leo1.20171224221222.91"><vh>bool ExprParser::Reduce</vh></v>
<v t="leo1.20171224221222.92"><vh>bool ExprParser::Parse</vh></v>
</v>
<v t="leo1.20171224221222.93"><vh>@@clean file.cpp</vh>
<v t="leo1.20171224221222.94"><vh>int StrStartsWith</vh></v>
<v t="leo1.20171224221222.95"><vh>void SolveSpaceUI::ClearExisting</vh></v>
<v t="leo1.20171224221222.96"><vh>void SolveSpaceUI::NewFile</vh></v>
<v t="leo1.20171224221222.97"><vh>const SolveSpaceUI::SaveTable</vh></v>
<v t="leo1.20171224221222.98"><vh>void SolveSpaceUI::SaveUsingTable</vh></v>
<v t="leo1.20171224221222.99"><vh>bool SolveSpaceUI::SaveToFile</vh></v>
<v t="leo1.20171224221222.100"><vh>void SolveSpaceUI::LoadUsingTable</vh></v>
<v t="leo1.20171224221222.101"><vh>bool SolveSpaceUI::LoadFromFile</vh></v>
<v t="leo1.20171224221222.102"><vh>void SolveSpaceUI::UpgradeLegacyData</vh>
<v t="leo1.20171224221222.103"><vh>auto AllParamsExistFor</vh></v>
</v>
<v t="leo1.20171224221222.104"><vh>bool SolveSpaceUI::LoadEntitiesFromFile</vh></v>
<v t="leo1.20171224221222.105"><vh>bool SolveSpaceUI::ReloadAllLinked</vh></v>
<v t="leo1.20171224221222.106"><vh>bool SolveSpaceUI::ReloadLinkedImage</vh></v>
</v>
<v t="leo1.20171224221222.107"><vh>@@clean generate.cpp</vh>
<v t="leo1.20171224221222.108"><vh>void SolveSpaceUI::MarkGroupDirtyByEntity</vh></v>
<v t="leo1.20171224221222.109"><vh>void SolveSpaceUI::MarkGroupDirty</vh></v>
<v t="leo1.20171224221222.110"><vh>bool SolveSpaceUI::PruneOrphans</vh></v>
<v t="leo1.20171224221222.111"><vh>bool SolveSpaceUI::GroupsInOrder</vh></v>
<v t="leo1.20171224221222.112"><vh>bool SolveSpaceUI::GroupExists</vh></v>
<v t="leo1.20171224221222.113"><vh>bool SolveSpaceUI::EntityExists</vh></v>
<v t="leo1.20171224221222.114"><vh>bool SolveSpaceUI::PruneGroups</vh></v>
<v t="leo1.20171224221222.115"><vh>bool SolveSpaceUI::PruneRequests</vh></v>
<v t="leo1.20171224221222.116"><vh>bool SolveSpaceUI::PruneConstraints</vh></v>
<v t="leo1.20171224221222.117"><vh>void SolveSpaceUI::GenerateAll</vh></v>
<v t="leo1.20171224221222.118"><vh>void SolveSpaceUI::ForceReferences</vh>
<v t="leo1.20171224221222.119"><vh>const struct</vh></v>
</v>
<v t="leo1.20171224221222.120"><vh>void SolveSpaceUI::UpdateCenterOfMass</vh></v>
<v t="leo1.20171224221222.121"><vh>void SolveSpaceUI::MarkDraggedParams</vh></v>
<v t="leo1.20171224221222.122"><vh>void SolveSpaceUI::SolveGroupAndReport</vh>
<v t="leo1.20171224221222.123"><vh>bool isOkay</vh></v>
</v>
<v t="leo1.20171224221222.124"><vh>void SolveSpaceUI::WriteEqSystemForGroup</vh></v>
<v t="leo1.20171224221222.125"><vh>void SolveSpaceUI::SolveGroup</vh></v>
<v t="leo1.20171224221222.126"><vh>bool SolveSpaceUI::ActiveGroupsOkay</vh></v>
</v>
<v t="leo1.20171224221222.127"><vh>@@clean graphicswin.cpp</vh>
<v t="leo1.20171224221222.128"><vh>const GraphicsWindow::MenuEntry</vh></v>
<v t="leo1.20171224221223.1"><vh>void GraphicsWindow::Init</vh></v>
<v t="leo1.20171224221223.2"><vh>void GraphicsWindow::AnimateOntoWorkplane</vh></v>
<v t="leo1.20171224221223.3"><vh>void GraphicsWindow::AnimateOnto</vh>
<v t="leo1.20171224221223.4"><vh>int 32_t</vh></v>
</v>
<v t="leo1.20171224221223.5"><vh>void GraphicsWindow::HandlePointForZoomToFit</vh></v>
<v t="leo1.20171224221223.6"><vh>void GraphicsWindow::LoopOverPoints</vh></v>
<v t="leo1.20171224221223.7"><vh>void GraphicsWindow::ZoomToFit</vh></v>
<v t="leo1.20171224221223.8"><vh>void GraphicsWindow::MenuView</vh>
<v t="leo1.20171224221223.9"><vh>const Vector</vh></v>
<v t="leo1.20171224221223.10"><vh>double d</vh></v>
</v>
<v t="leo1.20171224221223.11"><vh>void GraphicsWindow::EnsureValidActives</vh></v>
<v t="leo1.20171224221223.12"><vh>void GraphicsWindow::SetWorkplaneFreeIn3d</vh></v>
<v t="leo1.20171224221223.13"><vh>bool GraphicsWindow::LockedInWorkplane</vh></v>
<v t="leo1.20171224221223.14"><vh>void GraphicsWindow::ForceTextWindowShown</vh></v>
<v t="leo1.20171224221223.15"><vh>void GraphicsWindow::DeleteTaggedRequests</vh></v>
<v t="leo1.20171224221223.16"><vh>void GraphicsWindow::MenuEdit</vh></v>
<v t="leo1.20171224221223.17"><vh>void GraphicsWindow::MenuRequest</vh></v>
<v t="leo1.20171224221223.18"><vh>void GraphicsWindow::ClearSuper</vh></v>
<v t="leo1.20171224221223.19"><vh>void GraphicsWindow::ToggleBool</vh></v>
<v t="leo1.20171224221223.20"><vh>bool GraphicsWindow::SuggestLineConstraint</vh></v>
</v>
<v t="leo1.20171224221223.21"><vh>@@clean group.cpp</vh>
<v t="leo1.20171224221223.22"><vh>void Group::Clear</vh></v>
<v t="leo1.20171224221223.23"><vh>void Group::AddParam</vh></v>
<v t="leo1.20171224221223.24"><vh>bool Group::IsVisible</vh></v>
<v t="leo1.20171224221223.25"><vh>int Group::GetNumConstraints</vh></v>
<v t="leo1.20171224221223.26"><vh>void Group::ExtrusionForceVectorTo</vh></v>
<v t="leo1.20171224221223.27"><vh>void Group::MenuGroup</vh></v>
<v t="leo1.20171224221223.28"><vh>void Group::TransformImportedBy</vh></v>
<v t="leo1.20171224221223.29"><vh>bool Group::IsForcedToMeshBySource</vh></v>
<v t="leo1.20171224221223.30"><vh>bool Group::IsForcedToMesh</vh></v>
<v t="leo1.20171224221223.31"><vh>void Group::Activate</vh></v>
<v t="leo1.20171224221223.32"><vh>void Group::Generate</vh></v>
<v t="leo1.20171224221223.33"><vh>bool Group::IsSolvedOkay</vh></v>
<v t="leo1.20171224221223.34"><vh>void Group::AddEq</vh></v>
<v t="leo1.20171224221223.35"><vh>void Group::GenerateEquations</vh></v>
<v t="leo1.20171224221223.36"><vh>void Group::MakeExtrusionLines</vh></v>
<v t="leo1.20171224221223.37"><vh>void Group::MakeLatheCircles</vh></v>
<v t="leo1.20171224221223.38"><vh>void Group::MakeExtrusionTopBottomFaces</vh></v>
<v t="leo1.20171224221223.39"><vh>void Group::CopyEntity</vh></v>
</v>
<v t="leo1.20171224221223.40"><vh>@@clean groupmesh.cpp</vh>
<v t="leo1.20171224221224.1"><vh>void Group::AssembleLoops</vh></v>
<v t="leo1.20171224221224.2"><vh>void Group::GenerateLoops</vh></v>
<v t="leo1.20171224221224.3"><vh>void SShell::RemapFaces</vh></v>
<v t="leo1.20171224221224.4"><vh>void SMesh::RemapFaces</vh></v>
<v t="leo1.20171224221224.5"><vh>void Group::GenerateForStepAndRepeat</vh></v>
<v t="leo1.20171224221224.6"><vh>void Group::GenerateForBoolean</vh></v>
<v t="leo1.20171224221224.7"><vh>void Group::GenerateShellAndMesh</vh></v>
<v t="leo1.20171224221224.8"><vh>void Group::GenerateDisplayItems</vh></v>
<v t="leo1.20171224221224.9"><vh>bool Group::IsMeshGroup</vh></v>
<v t="leo1.20171224221224.10"><vh>void Group::DrawMesh</vh></v>
<v t="leo1.20171224221224.11"><vh>void Group::Draw</vh></v>
<v t="leo1.20171224221224.12"><vh>void Group::DrawPolyError</vh></v>
<v t="leo1.20171224221224.13"><vh>void Group::DrawFilledPaths</vh></v>
<v t="leo1.20171224221224.14"><vh>void Group::DrawContourAreaLabels</vh></v>
</v>
<v t="leo1.20171224221224.15"><vh>@@clean importdxf.cpp</vh>
<v t="leo1.20171224221224.16"><vh>static std::string</vh></v>
<v t="leo1.20171224221224.17"><vh>class DxfImport</vh>
<v t="leo1.20171224221224.18"><vh>void invertXTransform</vh></v>
<v t="leo1.20171224221224.19"><vh>void multBlockTransform</vh></v>
<v t="leo1.20171224221224.20"><vh>void clearBlockTransform</vh></v>
<v t="leo1.20171224221224.21"><vh>void blockTransformArc</vh></v>
<v t="leo1.20171224221224.22"><vh>double angleTo</vh></v>
<v t="leo1.20171224221224.23"><vh>bool addPendingBlockEntity</vh></v>
<v t="leo1.20171224221224.24"><vh>void addEntity</vh></v>
<v t="leo1.20171224221224.25"><vh>int getColor</vh></v>
<v t="leo1.20171224221224.26"><vh>void configureRequest</vh></v>
<v t="leo1.20171224221224.27"><vh>bool operator</vh></v>
<v t="leo1.20171224221224.28"><vh>void processPoint</vh></v>
<v t="leo1.20171224221224.29"><vh>void addLayer</vh></v>
<v t="leo1.20171224221224.30"><vh>void addBlock</vh></v>
<v t="leo1.20171224221224.31"><vh>void endBlock</vh></v>
<v t="leo1.20171224221224.32"><vh>void addPoint</vh></v>
<v t="leo1.20171224221224.33"><vh>void addLine</vh></v>
<v t="leo1.20171224221224.34"><vh>void addArc</vh></v>
<v t="leo1.20171224221224.35"><vh>void addCircle</vh></v>
<v t="leo1.20171224221224.36"><vh>void addLWPolyline</vh></v>
<v t="leo1.20171224221224.37"><vh>void addPolyline</vh></v>
<v t="leo1.20171224221224.38"><vh>void addSpline</vh></v>
<v t="leo1.20171224221224.39"><vh>void addInsert</vh></v>
<v t="leo1.20171224221224.40"><vh>void addMText</vh></v>
<v t="leo1.20171224221224.41"><vh>void addText</vh></v>
<v t="leo1.20171224221224.42"><vh>void addDimAlign</vh></v>
<v t="leo1.20171224221224.43"><vh>void addDimLinear</vh></v>
<v t="leo1.20171224221224.44"><vh>void addDimAngular</vh></v>
<v t="leo1.20171224221224.45"><vh>bool asRadius</vh></v>
<v t="leo1.20171224221224.46"><vh>void addDimRadial</vh></v>
<v t="leo1.20171224221224.47"><vh>void addDimDiametric</vh></v>
<v t="leo1.20171224221224.48"><vh>void addDimAngular3P</vh></v>
</v>
<v t="leo1.20171224221224.49"><vh>class DxfCheck3D</vh>
<v t="leo1.20171224221224.50"><vh>void addEntity</vh></v>
<v t="leo1.20171224221224.51"><vh>void addPoint</vh></v>
<v t="leo1.20171224221224.52"><vh>void addLine</vh></v>
<v t="leo1.20171224221224.53"><vh>void addArc</vh></v>
<v t="leo1.20171224221224.54"><vh>void addCircle</vh></v>
<v t="leo1.20171224221224.55"><vh>void addPolyline</vh></v>
<v t="leo1.20171224221224.56"><vh>void addSpline</vh></v>
<v t="leo1.20171224221224.57"><vh>void addInsert</vh></v>
<v t="leo1.20171224221224.58"><vh>void addMText</vh></v>
<v t="leo1.20171224221224.59"><vh>void addText</vh></v>
<v t="leo1.20171224221224.60"><vh>void addDimAlign</vh></v>
<v t="leo1.20171224221224.61"><vh>void addDimLinear</vh></v>
<v t="leo1.20171224221224.62"><vh>void addDimAngular</vh></v>
<v t="leo1.20171224221224.63"><vh>void addDimRadial</vh></v>
<v t="leo1.20171224221224.64"><vh>void addDimDiametric</vh></v>
<v t="leo1.20171224221224.65"><vh>void addDimAngular3P</vh></v>
<v t="leo1.20171224221224.66"><vh>void checkCoord</vh></v>
</v>
<v t="leo1.20171224221224.67"><vh>void ImportDwgDxf</vh></v>
<v t="leo1.20171224221224.68"><vh>void ImportDxf</vh></v>
<v t="leo1.20171224221224.69"><vh>void ImportDwg</vh></v>
</v>
<v t="leo1.20171224221224.70"><vh>@@clean lib.cpp</vh>
<v t="leo1.20171224221224.71"><vh>void Group::GenerateEquations</vh></v>
<v t="leo1.20171224221224.72"><vh>void SolveSpace::CnfFreezeInt</vh></v>
<v t="leo1.20171224221224.73"><vh>void SolveSpace::DoMessageBox</vh></v>
<v t="leo1.20171224221224.74"><vh>extern "C" {</vh>
<v t="leo1.20171224221224.75"><vh>void Slvs_QuaternionU</vh></v>
<v t="leo1.20171224221224.76"><vh>void Slvs_QuaternionV</vh></v>
<v t="leo1.20171224221224.77"><vh>void Slvs_QuaternionN</vh></v>
<v t="leo1.20171224221224.78"><vh>void Slvs_MakeQuaternion</vh></v>
<v t="leo1.20171224221224.79"><vh>void Slvs_Solve</vh></v>
</v>
</v>
<v t="leo1.20171224221224.80"><vh>@@clean mesh.cpp</vh>
<v t="leo1.20171224221224.81"><vh>void SMesh::Clear</vh></v>
<v t="leo1.20171224221224.82"><vh>void SMesh::AddTriangle</vh></v>
<v t="leo1.20171224221224.83"><vh>void SMesh::AddTriangle</vh></v>
<v t="leo1.20171224221224.84"><vh>void SMesh::AddTriangle</vh></v>
<v t="leo1.20171224221224.85"><vh>void SMesh::DoBounding</vh></v>
<v t="leo1.20171224221224.86"><vh>void SMesh::GetBounding</vh></v>
<v t="leo1.20171224221224.87"><vh>void SMesh::MakeEdgesInPlaneInto</vh></v>
<v t="leo1.20171224221224.88"><vh>void SMesh::MakeOutlinesInto</vh></v>
<v t="leo1.20171224221224.89"><vh>void SMesh::Simplify</vh></v>
<v t="leo1.20171224221224.90"><vh>void SMesh::AddAgainstBsp</vh></v>
<v t="leo1.20171224221224.91"><vh>void SMesh::MakeFromUnionOf</vh></v>
<v t="leo1.20171224221224.92"><vh>void SMesh::MakeFromDifferenceOf</vh></v>
<v t="leo1.20171224221224.93"><vh>void SMesh::MakeFromCopyOf</vh></v>
<v t="leo1.20171224221224.94"><vh>void SMesh::MakeFromAssemblyOf</vh></v>
<v t="leo1.20171224221224.95"><vh>void SMesh::MakeFromTransformationOf</vh></v>
<v t="leo1.20171224221224.96"><vh>bool SMesh::IsEmpty</vh></v>
<v t="leo1.20171224221224.97"><vh>double a</vh></v>
<v t="leo1.20171224221224.98"><vh>double a</vh></v>
<v t="leo1.20171224221224.99"><vh>void SKdNode::ClearTags</vh></v>
<v t="leo1.20171224221224.100"><vh>void SKdNode::AddTriangle</vh>
<v t="leo1.20171224221224.101"><vh>double ta</vh></v>
</v>
<v t="leo1.20171224221224.102"><vh>void SKdNode::MakeMeshInto</vh></v>
<v t="leo1.20171224221224.103"><vh>void SKdNode::ListTrianglesInto</vh></v>
<v t="leo1.20171224221224.104"><vh>void SKdNode::SnapToVertex</vh></v>
<v t="leo1.20171224221224.105"><vh>void SKdNode::SnapToMesh</vh></v>
<v t="leo1.20171224221224.106"><vh>void SKdNode::SplitLinesAgainstTriangle</vh>
<v t="leo1.20171224221224.107"><vh>double da</vh></v>
<v t="leo1.20171224221224.108"><vh>double d</vh></v>
<v t="leo1.20171224221224.109"><vh>double da</vh></v>
</v>
<v t="leo1.20171224221224.110"><vh>void SKdNode::OcclusionTestLine</vh>
<v t="leo1.20171224221224.111"><vh>double ac</vh></v>
</v>
<v t="leo1.20171224221224.112"><vh>void SKdNode::FindEdgeOn</vh>
<v t="leo1.20171224221224.113"><vh>double ac</vh></v>
</v>
<v t="leo1.20171224221224.114"><vh>bool CheckAndAddTrianglePair</vh></v>
<v t="leo1.20171224221224.115"><vh>void SKdNode::MakeCertainEdgesInto</vh></v>
<v t="leo1.20171224221224.116"><vh>void SKdNode::MakeOutlinesInto</vh></v>
<v t="leo1.20171224221224.117"><vh>bool SOutline::IsVisible</vh></v>
<v t="leo1.20171224221224.118"><vh>void SOutlineList::Clear</vh></v>
<v t="leo1.20171224221224.119"><vh>void SOutlineList::AddEdge</vh></v>
<v t="leo1.20171224221224.120"><vh>void SOutlineList::ListTaggedInto</vh></v>
<v t="leo1.20171224221224.121"><vh>void SOutlineList::MakeFromCopyOf</vh></v>
<v t="leo1.20171224221224.122"><vh>void SMesh::PrecomputeTransparency</vh>
<v t="leo1.20171224221224.123"><vh>bool opaquea</vh></v>
</v>
</v>
<v t="leo1.20171224221224.124"><vh>@@clean modify.cpp</vh>
<v t="leo1.20171224221225.1"><vh>void GraphicsWindow::ReplacePointInConstraints</vh></v>
<v t="leo1.20171224221225.2"><vh>void GraphicsWindow::RemoveConstraintsForPointBeingDeleted</vh></v>
<v t="leo1.20171224221225.3"><vh>void GraphicsWindow::FixConstraintsForRequestBeingDeleted</vh></v>
<v t="leo1.20171224221225.4"><vh>void GraphicsWindow::FixConstraintsForPointBeingDeleted</vh></v>
<v t="leo1.20171224221225.5"><vh>void GraphicsWindow::ParametricCurve::MakeFromEntity</vh></v>
<v t="leo1.20171224221225.6"><vh>bool extraConstraints</vh></v>
<v t="leo1.20171224221225.7"><vh>void GraphicsWindow::ParametricCurve::ConstrainPointIfCoincident</vh></v>
<v t="leo1.20171224221225.8"><vh>void GraphicsWindow::MakeTangentArc</vh></v>
<v t="leo1.20171224221225.9"><vh>void GraphicsWindow::SplitLinesOrCurves</vh></v>
</v>
<v t="leo1.20171224221225.10"><vh>@@clean mouse.cpp</vh>
<v t="leo1.20171224221227.1"><vh>void GraphicsWindow::UpdateDraggedPoint</vh></v>
<v t="leo1.20171224221227.2"><vh>void GraphicsWindow::UpdateDraggedNum</vh></v>
<v t="leo1.20171224221227.3"><vh>void GraphicsWindow::AddPointToDraggedList</vh></v>
<v t="leo1.20171224221227.4"><vh>void GraphicsWindow::StartDraggingByEntity</vh></v>
<v t="leo1.20171224221227.5"><vh>void GraphicsWindow::StartDraggingBySelection</vh></v>
<v t="leo1.20171224221227.6"><vh>void GraphicsWindow::MouseMoved</vh></v>
<v t="leo1.20171224221227.7"><vh>void GraphicsWindow::ClearPending</vh></v>
<v t="leo1.20171224221227.8"><vh>bool GraphicsWindow::IsFromPending</vh></v>
<v t="leo1.20171224221227.9"><vh>void GraphicsWindow::AddToPending</vh></v>
<v t="leo1.20171224221227.10"><vh>void GraphicsWindow::ReplacePending</vh></v>
<v t="leo1.20171224221227.11"><vh>void GraphicsWindow::MouseMiddleOrRightDown</vh></v>
<v t="leo1.20171224221227.12"><vh>void GraphicsWindow::ContextMenuListStyles</vh></v>
<v t="leo1.20171224221227.13"><vh>void GraphicsWindow::MouseRightUp</vh></v>
<v t="leo1.20171224221227.14"><vh>bool GraphicsWindow::ConstrainPointByHovered</vh></v>
<v t="leo1.20171224221227.15"><vh>void GraphicsWindow::MouseLeftDown</vh></v>
<v t="leo1.20171224221227.16"><vh>void GraphicsWindow::MouseLeftUp</vh></v>
<v t="leo1.20171224221227.17"><vh>void GraphicsWindow::MouseLeftDoubleClick</vh></v>
<v t="leo1.20171224221227.18"><vh>void GraphicsWindow::EditControlDone</vh></v>
<v t="leo1.20171224221227.19"><vh>bool GraphicsWindow::KeyDown</vh></v>
<v t="leo1.20171224221227.20"><vh>void GraphicsWindow::MouseScroll</vh></v>
<v t="leo1.20171224221227.21"><vh>void GraphicsWindow::MouseLeave</vh></v>
<v t="leo1.20171224221227.22"><vh>void GraphicsWindow::SpaceNavigatorMoved</vh></v>
<v t="leo1.20171224221227.23"><vh>void GraphicsWindow::SpaceNavigatorButtonUp</vh></v>
</v>
<v t="leo1.20171224221227.24"><vh>@@clean polygon.cpp</vh>
<v t="leo1.20171224221228.1"><vh>double altA</vh></v>
<v t="leo1.20171224221228.2"><vh>bool STriangle::ContainsPointProjd</vh></v>
<v t="leo1.20171224221228.3"><vh>bool STriangle::Raytrace</vh></v>
<v t="leo1.20171224221228.4"><vh>void STriangle::FlipNormal</vh></v>
<v t="leo1.20171224221228.5"><vh>bool SEdge::EdgeCrosses</vh></v>
<v t="leo1.20171224221228.6"><vh>void SEdgeList::Clear</vh></v>
<v t="leo1.20171224221228.7"><vh>void SEdgeList::AddEdge</vh></v>
<v t="leo1.20171224221228.8"><vh>bool SEdgeList::AssembleContour</vh></v>
<v t="leo1.20171224221228.9"><vh>bool SEdgeList::AssemblePolygon</vh></v>
<v t="leo1.20171224221228.10"><vh>int SEdgeList::AnyEdgeCrossings</vh></v>
<v t="leo1.20171224221228.11"><vh>bool SEdgeList::ContainsEdgeFrom</vh></v>
<v t="leo1.20171224221228.12"><vh>bool SEdgeList::ContainsEdge</vh></v>
<v t="leo1.20171224221228.13"><vh>void SEdgeList::CullExtraneousEdges</vh></v>
<v t="leo1.20171224221228.14"><vh>int SKdNodeEdges::AnyEdgeCrossings</vh></v>
<v t="leo1.20171224221228.15"><vh>int ByTAlongLine</vh>
<v t="leo1.20171224221228.16"><vh>double ta</vh></v>
</v>
<v t="leo1.20171224221228.17"><vh>void SPointList::Clear</vh></v>
<v t="leo1.20171224221228.18"><vh>bool SPointList::ContainsPoint</vh></v>
<v t="leo1.20171224221228.19"><vh>int SPointList::IndexForPoint</vh></v>
<v t="leo1.20171224221228.20"><vh>void SPointList::IncrementTagFor</vh></v>
<v t="leo1.20171224221228.21"><vh>void SPointList::Add</vh></v>
<v t="leo1.20171224221228.22"><vh>void SContour::AddPoint</vh></v>
<v t="leo1.20171224221228.23"><vh>void SContour::MakeEdgesInto</vh></v>
<v t="leo1.20171224221228.24"><vh>void SContour::CopyInto</vh></v>
<v t="leo1.20171224221228.25"><vh>void SContour::FindPointWithMinX</vh></v>
<v t="leo1.20171224221228.26"><vh>bool SContour::IsClockwiseProjdToNormal</vh></v>
<v t="leo1.20171224221228.27"><vh>bool SContour::ContainsPointProjdToNormal</vh></v>
<v t="leo1.20171224221228.28"><vh>void SContour::Reverse</vh></v>
<v t="leo1.20171224221228.29"><vh>void SPolygon::Clear</vh></v>
<v t="leo1.20171224221228.30"><vh>void SPolygon::AddEmptyContour</vh></v>
<v t="leo1.20171224221228.31"><vh>void SPolygon::MakeEdgesInto</vh></v>
<v t="leo1.20171224221228.32"><vh>bool SPolygon::ContainsPoint</vh></v>
<v t="leo1.20171224221228.33"><vh>int SPolygon::WindingNumberForPoint</vh></v>
<v t="leo1.20171224221228.34"><vh>void SPolygon::FixContourDirections</vh></v>
<v t="leo1.20171224221228.35"><vh>bool SPolygon::IsEmpty</vh></v>
<v t="leo1.20171224221228.36"><vh>bool SPolygon::SelfIntersecting</vh></v>
<v t="leo1.20171224221228.37"><vh>void SPolygon::InverseTransformInto</vh></v>
<v t="leo1.20171224221228.38"><vh>void SPolygon::OffsetInto</vh></v>
<v t="leo1.20171224221228.39"><vh>bool IntersectionOfLines</vh></v>
<v t="leo1.20171224221228.40"><vh>void SContour::OffsetInto</vh></v>
</v>
<v t="leo1.20171224221228.41"><vh>@@clean polyline.cpp</vh>
<v t="leo1.20171224221228.42"><vh>bool PolylineBuilder::Vertex::GetNext</vh>
<v t="leo1.20171224221228.43"><vh>auto it</vh></v>
</v>
<v t="leo1.20171224221228.44"><vh>bool PolylineBuilder::Vertex::GetNext</vh></v>
<v t="leo1.20171224221228.45"><vh>bool PolylineBuilder::Edge::GetStartAndNext</vh></v>
<v t="leo1.20171224221228.46"><vh>void PolylineBuilder::Clear</vh></v>
<v t="leo1.20171224221228.47"><vh>void PolylineBuilder::Generate</vh></v>
<v t="leo1.20171224221228.48"><vh>void PolylineBuilder::MakeFromEdges</vh></v>
<v t="leo1.20171224221228.49"><vh>void PolylineBuilder::MakeFromOutlines</vh></v>
<v t="leo1.20171224221228.50"><vh>void PolylineBuilder::GenerateEdges</vh>
<v t="leo1.20171224221228.51"><vh>auto startFunc</vh></v>
<v t="leo1.20171224221228.52"><vh>auto nextFunc</vh></v>
<v t="leo1.20171224221228.53"><vh>auto aloneFunc</vh></v>
</v>
<v t="leo1.20171224221228.54"><vh>void PolylineBuilder::GenerateOutlines</vh>
<v t="leo1.20171224221228.55"><vh>auto startFunc</vh></v>
<v t="leo1.20171224221228.56"><vh>auto nextFunc</vh></v>
<v t="leo1.20171224221228.57"><vh>auto aloneFunc</vh></v>
</v>
</v>
<v t="leo1.20171224221228.58"><vh>@@clean request.cpp</vh>
<v t="leo1.20171224221228.59"><vh>const EntReqMapping</vh></v>
<v t="leo1.20171224221228.60"><vh>void CopyEntityInfo</vh></v>
<v t="leo1.20171224221228.61"><vh>bool EntReqTable::GetRequestInfo</vh></v>
<v t="leo1.20171224221228.62"><vh>bool EntReqTable::GetEntityInfo</vh></v>
<v t="leo1.20171224221228.63"><vh>void Request::Generate</vh></v>
<v t="leo1.20171224221228.64"><vh>int Request::IndexOfPoint</vh></v>
</v>
<v t="leo1.20171224221228.65"><vh>@@clean resource.cpp</vh>
<v t="leo1.20171224221228.66"><vh>void Pixmap::SetPixel</vh></v>
<v t="leo1.20171224221228.67"><vh>void Pixmap::ConvertTo</vh></v>
<v t="leo1.20171224221228.68"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221228.69"><vh>bool Pixmap::WritePng</vh></v>
<v t="leo1.20171224221228.70"><vh>bool Pixmap::WritePng</vh></v>
<v t="leo1.20171224221228.71"><vh>bool Pixmap::Equals</vh></v>
<v t="leo1.20171224221228.72"><vh>class ASCIIReader</vh>
<v t="leo1.20171224221228.73"><vh>static ASCIIReader</vh></v>
<v t="leo1.20171224221228.74"><vh>bool AtEnd</vh></v>
<v t="leo1.20171224221228.75"><vh>bool SkipSpace</vh></v>
<v t="leo1.20171224221228.76"><vh>char PeekChar</vh></v>
<v t="leo1.20171224221228.77"><vh>char ReadChar</vh></v>
<v t="leo1.20171224221228.78"><vh>bool TryChar</vh></v>
<v t="leo1.20171224221228.79"><vh>void ExpectChar</vh></v>
<v t="leo1.20171224221228.80"><vh>bool TryString</vh></v>
<v t="leo1.20171224221228.81"><vh>void ExpectString</vh></v>
<v t="leo1.20171224221228.82"><vh>void SkipUntilEol</vh></v>
<v t="leo1.20171224221228.83"><vh>double ReadFloatDecimal</vh></v>
<v t="leo1.20171224221228.84"><vh>bool TryRegex</vh></v>
<v t="leo1.20171224221228.85"><vh>void ExpectRegex</vh></v>
</v>
<v t="leo1.20171224221228.86"><vh>static uint8_t</vh></v>
<v t="leo1.20171224221228.87"><vh>void BitmapFont::AddGlyph</vh></v>
<v t="leo1.20171224221228.88"><vh>const BitmapFont::Glyph</vh>
<v t="leo1.20171224221228.89"><vh>auto first</vh></v>
</v>
<v t="leo1.20171224221228.90"><vh>void BitmapFont::LocateGlyph</vh></v>
<v t="leo1.20171224221228.91"><vh>void MakePwlArc</vh></v>
<v t="leo1.20171224221228.92"><vh>void MakePwlBulge</vh></v>
<v t="leo1.20171224221228.93"><vh>void GetGlyphBBox</vh></v>
<v t="leo1.20171224221229.1"><vh>const VectorFont::Glyph</vh>
<v t="leo1.20171224221229.2"><vh>auto first</vh></v>
</v>
<v t="leo1.20171224221229.3"><vh>void VectorFont::Trace</vh></v>
<v t="leo1.20171224221229.4"><vh>void VectorFont::Trace</vh></v>
<v t="leo1.20171224221229.5"><vh>class PluralExpr</vh>
<v t="leo1.20171224221229.6"><vh>class Token</vh></v>
</v>
<v t="leo1.20171224221229.7"><vh>int PluralExpr::Token::Precedence</vh></v>
<v t="leo1.20171224221229.8"><vh>void PluralExpr::Reduce</vh></v>
<v t="leo1.20171224221229.9"><vh>void PluralExpr::Eval</vh></v>
<v t="leo1.20171224221229.10"><vh>unsigned PluralExpr::Eval</vh></v>
<v t="leo1.20171224221229.11"><vh>class TranslationKey</vh></v>
<v t="leo1.20171224221229.12"><vh>bool operator</vh></v>
<v t="leo1.20171224221229.13"><vh>class GettextParser</vh></v>
<v t="leo1.20171224221229.14"><vh>void GettextParser::SkipSpace</vh></v>
<v t="leo1.20171224221229.15"><vh>void GettextParser::ParseHeader</vh></v>
<v t="leo1.20171224221229.16"><vh>void GettextParser::Parse</vh></v>
<v t="leo1.20171224221229.17"><vh>class Translation</vh></v>
<v t="leo1.20171224221229.18"><vh>const std::string</vh></v>
<v t="leo1.20171224221229.19"><vh>const std::string</vh></v>
<v t="leo1.20171224221229.20"><vh>const std::set</vh></v>
<v t="leo1.20171224221229.21"><vh>bool SetLocale</vh></v>
<v t="leo1.20171224221229.22"><vh>bool SetLocale</vh></v>
<v t="leo1.20171224221229.23"><vh>bool SetLocale</vh></v>
<v t="leo1.20171224221229.24"><vh>const std::string</vh></v>
<v t="leo1.20171224221229.25"><vh>const std::string</vh></v>
<v t="leo1.20171224221229.26"><vh>const std::string</vh></v>
<v t="leo1.20171224221229.27"><vh>const std::string</vh></v>
</v>
<v t="leo1.20171224221229.28"><vh>@@clean solvespace.cpp</vh>
<v t="leo1.20171224221229.29"><vh>void SolveSpaceUI::Init</vh></v>
<v t="leo1.20171224221229.30"><vh>bool SolveSpaceUI::LoadAutosaveFor</vh></v>
<v t="leo1.20171224221229.31"><vh>bool SolveSpaceUI::Load</vh></v>
<v t="leo1.20171224221229.32"><vh>void SolveSpaceUI::Exit</vh></v>
<v t="leo1.20171224221229.33"><vh>void SolveSpaceUI::ScheduleGenerateAll</vh></v>
<v t="leo1.20171224221229.34"><vh>void SolveSpaceUI::ScheduleShowTW</vh></v>
<v t="leo1.20171224221229.35"><vh>void SolveSpaceUI::DoLater</vh></v>
<v t="leo1.20171224221229.36"><vh>const char *SolveSpaceUI::UnitName() {</vh></v>
<v t="leo1.20171224221229.37"><vh>int SolveSpaceUI::GetMaxSegments</vh></v>
<v t="leo1.20171224221229.38"><vh>int SolveSpaceUI::UnitDigitsAfterDecimal</vh></v>
<v t="leo1.20171224221229.39"><vh>void SolveSpaceUI::SetUnitDigitsAfterDecimal</vh></v>
<v t="leo1.20171224221229.40"><vh>void SolveSpaceUI::AfterNewFile</vh></v>
<v t="leo1.20171224221229.41"><vh>void SolveSpaceUI::RemoveFromRecentList</vh></v>
<v t="leo1.20171224221229.42"><vh>void SolveSpaceUI::AddToRecentList</vh></v>
<v t="leo1.20171224221229.43"><vh>bool SolveSpaceUI::GetFilenameAndSave</vh></v>
<v t="leo1.20171224221229.44"><vh>bool SolveSpaceUI::Autosave</vh></v>
<v t="leo1.20171224221229.45"><vh>void SolveSpaceUI::RemoveAutosave</vh></v>
<v t="leo1.20171224221229.46"><vh>bool SolveSpaceUI::OkayToStartNewFile</vh></v>
<v t="leo1.20171224221229.47"><vh>void SolveSpaceUI::UpdateWindowTitle</vh></v>
<v t="leo1.20171224221229.48"><vh>void SolveSpaceUI::MenuFile</vh></v>
<v t="leo1.20171224221229.49"><vh>void SolveSpaceUI::MenuAnalyze</vh></v>
<v t="leo1.20171224221229.50"><vh>void SolveSpaceUI::ShowNakedEdges</vh></v>
<v t="leo1.20171224221229.51"><vh>void SolveSpaceUI::MenuHelp</vh></v>
<v t="leo1.20171224221229.52"><vh>void SolveSpaceUI::Clear</vh></v>
<v t="leo1.20171224221229.53"><vh>void Sketch::Clear</vh></v>
<v t="leo1.20171224221229.54"><vh>auto includePoint</vh></v>
</v>
<v t="leo1.20171224221229.55"><vh>@@clean style.cpp</vh>
<v t="leo1.20171224221229.56"><vh>const Style::Default</vh></v>
<v t="leo1.20171224221229.57"><vh>void Style::CreateAllDefaultStyles</vh></v>
<v t="leo1.20171224221229.58"><vh>void Style::CreateDefaultStyle</vh></v>
<v t="leo1.20171224221229.59"><vh>void Style::FillDefaultStyle</vh></v>
<v t="leo1.20171224221229.60"><vh>void Style::LoadFactoryDefaults</vh></v>
<v t="leo1.20171224221229.61"><vh>void Style::FreezeDefaultStyles</vh></v>
<v t="leo1.20171224221229.62"><vh>void Style::AssignSelectionToStyle</vh></v>
<v t="leo1.20171224221229.63"><vh>bool Style::Exportable</vh></v>
<v t="leo1.20171224221229.64"><vh>void TextWindow::ScreenShowListOfStyles</vh></v>
<v t="leo1.20171224221229.65"><vh>void TextWindow::ScreenShowStyleInfo</vh></v>
<v t="leo1.20171224221229.66"><vh>void TextWindow::ScreenLoadFactoryDefaultStyles</vh></v>
<v t="leo1.20171224221229.67"><vh>void TextWindow::ScreenCreateCustomStyle</vh></v>
<v t="leo1.20171224221229.68"><vh>void TextWindow::ScreenChangeBackgroundColor</vh></v>
<v t="leo1.20171224221229.69"><vh>void TextWindow::ShowListOfStyles</vh></v>
<v t="leo1.20171224221229.70"><vh>void TextWindow::ScreenChangeStyleName</vh></v>
<v t="leo1.20171224221229.71"><vh>void TextWindow::ScreenDeleteStyle</vh></v>
<v t="leo1.20171224221229.72"><vh>void TextWindow::ScreenChangeStylePatternType</vh></v>
<v t="leo1.20171224221229.73"><vh>void TextWindow::ScreenChangeStyleMetric</vh></v>
<v t="leo1.20171224221229.74"><vh>void TextWindow::ScreenChangeStyleTextAngle</vh></v>
<v t="leo1.20171224221229.75"><vh>void TextWindow::ScreenChangeStyleColor</vh></v>
<v t="leo1.20171224221229.76"><vh>void TextWindow::ScreenChangeStyleYesNo</vh></v>
<v t="leo1.20171224221229.77"><vh>bool TextWindow::EditControlDoneForStyles</vh></v>
<v t="leo1.20171224221229.78"><vh>void TextWindow::ShowStyleInfo</vh>
<v t="leo1.20171224221229.79"><vh>const char *patternsSource[patternCount] = {</vh></v>
</v>
<v t="leo1.20171224221229.80"><vh>void TextWindow::ScreenAssignSelectionToStyle</vh></v>
</v>
<v t="leo1.20171224221229.81"><vh>@@clean system.cpp</vh>
<v t="leo1.20171224221229.82"><vh>bool System::WriteJacobian</vh></v>
<v t="leo1.20171224221229.83"><vh>void System::EvalJacobian</vh></v>
<v t="leo1.20171224221229.84"><vh>bool System::IsDragged</vh></v>
<v t="leo1.20171224221229.85"><vh>void System::SolveBySubstitution</vh></v>
<v t="leo1.20171224221229.86"><vh>int System::CalculateRank</vh></v>
<v t="leo1.20171224221229.87"><vh>bool System::TestRank</vh></v>
<v t="leo1.20171224221229.88"><vh>bool System::SolveLinearSystem</vh></v>
<v t="leo1.20171224221229.89"><vh>bool System::SolveLeastSquares</vh></v>
<v t="leo1.20171224221229.90"><vh>bool System::NewtonSolve</vh></v>
<v t="leo1.20171224221229.91"><vh>void System::WriteEquationsExceptFor</vh></v>
<v t="leo1.20171224221229.92"><vh>void System::FindWhichToRemoveToFixJacobian</vh></v>
<v t="leo1.20171224221229.93"><vh>bool andFindBad</vh></v>
<v t="leo1.20171224221229.94"><vh>bool andFindBad</vh></v>
<v t="leo1.20171224221229.95"><vh>void System::Clear</vh></v>
<v t="leo1.20171224221229.96"><vh>void System::MarkParamsFree</vh></v>
<v t="leo1.20171224221229.97"><vh>int System::CalculateDof</vh></v>
</v>
<v t="leo1.20171224221229.98"><vh>@@clean textscreens.cpp</vh>
<v t="leo1.20171224221229.99"><vh>void TextWindow::ScreenHome</vh></v>
<v t="leo1.20171224221229.100"><vh>void TextWindow::ShowHeader</vh></v>
<v t="leo1.20171224221229.101"><vh>void TextWindow::ScreenSelectGroup</vh></v>
<v t="leo1.20171224221229.102"><vh>void TextWindow::ScreenToggleGroupShown</vh></v>
<v t="leo1.20171224221229.103"><vh>void TextWindow::ScreenShowGroupsSpecial</vh></v>
<v t="leo1.20171224221229.104"><vh>void TextWindow::ScreenActivateGroup</vh></v>
<v t="leo1.20171224221229.105"><vh>void TextWindow::ReportHowGroupSolved</vh></v>
<v t="leo1.20171224221229.106"><vh>void TextWindow::ScreenHowGroupSolved</vh></v>
<v t="leo1.20171224221229.107"><vh>void TextWindow::ScreenShowConfiguration</vh></v>
<v t="leo1.20171224221229.108"><vh>void TextWindow::ScreenShowEditView</vh></v>
<v t="leo1.20171224221229.109"><vh>void TextWindow::ScreenGoToWebsite</vh></v>
<v t="leo1.20171224221229.110"><vh>void TextWindow::ShowListOfGroups</vh>
<v t="leo1.20171224221229.111"><vh>const char *radioTrue  = " " RADIO_TRUE  " ", Printf</vh></v>
</v>
<v t="leo1.20171224221229.112"><vh>void TextWindow::ScreenHoverConstraint</vh></v>
<v t="leo1.20171224221229.113"><vh>void TextWindow::ScreenHoverRequest</vh></v>
<v t="leo1.20171224221229.114"><vh>void TextWindow::ScreenSelectConstraint</vh></v>
<v t="leo1.20171224221229.115"><vh>void TextWindow::ScreenSelectRequest</vh></v>
<v t="leo1.20171224221229.116"><vh>void TextWindow::ScreenChangeGroupOption</vh></v>
<v t="leo1.20171224221229.117"><vh>void TextWindow::ScreenColor</vh></v>
<v t="leo1.20171224221229.118"><vh>void TextWindow::ScreenOpacity</vh></v>
<v t="leo1.20171224221229.119"><vh>void TextWindow::ScreenChangeExprA</vh></v>
<v t="leo1.20171224221229.120"><vh>void TextWindow::ScreenChangeGroupName</vh></v>
<v t="leo1.20171224221229.121"><vh>void TextWindow::ScreenChangeGroupScale</vh></v>
<v t="leo1.20171224221229.122"><vh>void TextWindow::ScreenDeleteGroup</vh></v>
<v t="leo1.20171224221229.123"><vh>void TextWindow::ShowGroupInfo</vh></v>
<v t="leo1.20171224221229.124"><vh>void TextWindow::ScreenAllowRedundant</vh></v>
<v t="leo1.20171224221229.125"><vh>void TextWindow::ShowGroupSolveInfo</vh></v>
<v t="leo1.20171224221229.126"><vh>void TextWindow::ScreenStepDimFinish</vh></v>
<v t="leo1.20171224221229.127"><vh>void TextWindow::ScreenStepDimSteps</vh></v>
<v t="leo1.20171224221229.128"><vh>void TextWindow::ScreenStepDimGo</vh></v>
<v t="leo1.20171224221229.129"><vh>void TextWindow::ShowStepDimension</vh></v>
<v t="leo1.20171224221229.130"><vh>void TextWindow::ScreenChangeTangentArc</vh></v>
<v t="leo1.20171224221229.131"><vh>void TextWindow::ShowTangentArc</vh></v>
<v t="leo1.20171224221229.132"><vh>void TextWindow::EditControlDone</vh></v>
</v>
<v t="leo1.20171224221229.133"><vh>@@clean textwin.cpp</vh>
<v t="leo1.20171224221229.134"><vh>class Button</vh></v>
<v t="leo1.20171224221229.135"><vh>class SpacerButton</vh>
<v t="leo1.20171224221229.136"><vh>void Draw</vh></v>
<v t="leo1.20171224221229.137"><vh>void Click</vh></v>
<v t="leo1.20171224221229.138"><vh>void Draw</vh></v>
</v>
<v t="leo1.20171224221229.139"><vh>class FacesButton</vh></v>
<v t="leo1.20171224221229.140"><vh>class OccludedLinesButton</vh>
<v t="leo1.20171224221229.141"><vh>void Draw</vh></v>
<v t="leo1.20171224221229.142"><vh>void Click</vh></v>
</v>
<v t="leo1.20171224221229.143"><vh>static ShowHideButton</vh></v>
<v t="leo1.20171224221229.144"><vh>const TextWindow::Color</vh></v>
<v t="leo1.20171224221229.145"><vh>const TextWindow::Color</vh></v>
<v t="leo1.20171224221229.146"><vh>void TextWindow::MakeColorTable</vh></v>
<v t="leo1.20171224221229.147"><vh>void TextWindow::Init</vh></v>
<v t="leo1.20171224221229.148"><vh>void TextWindow::ClearSuper</vh></v>
<v t="leo1.20171224221229.149"><vh>void TextWindow::HideEditControl</vh></v>
<v t="leo1.20171224221229.150"><vh>void TextWindow::ShowEditControl</vh></v>
<v t="leo1.20171224221229.151"><vh>void TextWindow::ShowEditControlWithColorPicker</vh></v>
<v t="leo1.20171224221229.152"><vh>void TextWindow::ClearScreen</vh></v>
<v t="leo1.20171224221229.153"><vh>void TextWindow::Printf</vh></v>
<v t="leo1.20171224221229.154"><vh>void TextWindow::Show</vh></v>
<v t="leo1.20171224221229.155"><vh>void TextWindow::TimerCallback</vh></v>
<v t="leo1.20171224221229.156"><vh>void TextWindow::DrawOrHitTestIcons</vh></v>
<v t="leo1.20171224221229.157"><vh>void TextWindow::ColorPickerDone</vh></v>
<v t="leo1.20171224221229.158"><vh>bool TextWindow::DrawOrHitTestColorPicker</vh>
<v t="leo1.20171224221229.159"><vh>const RgbaColor</vh></v>
<v t="leo1.20171224221229.160"><vh>int pxm</vh></v>
<v t="leo1.20171224221229.161"><vh>int cx</vh></v>
</v>
<v t="leo1.20171224221229.162"><vh>void TextWindow::Paint</vh></v>
<v t="leo1.20171224221229.163"><vh>void TextWindow::MouseEvent</vh></v>
<v t="leo1.20171224221229.164"><vh>void TextWindow::MouseLeave</vh></v>
<v t="leo1.20171224221229.165"><vh>void TextWindow::ScrollbarEvent</vh></v>
</v>
<v t="leo1.20171224221230.1"><vh>@@clean toolbar.cpp</vh>
<v t="leo1.20171224221230.2"><vh>static ToolIcon</vh></v>
<v t="leo1.20171224221230.3"><vh>void GraphicsWindow::ToolbarDraw</vh></v>
<v t="leo1.20171224221230.4"><vh>bool GraphicsWindow::ToolbarMouseMoved</vh></v>
<v t="leo1.20171224221230.5"><vh>bool GraphicsWindow::ToolbarMouseDown</vh></v>
<v t="leo1.20171224221230.6"><vh>bool GraphicsWindow::ToolbarDrawOrHitTest</vh>
<v t="leo1.20171224221230.7"><vh>bool withinToolbar</vh></v>
</v>
<v t="leo1.20171224221230.8"><vh>void GraphicsWindow::TimerCallback</vh></v>
</v>
<v t="leo1.20171224221230.9"><vh>@@clean ttf.cpp</vh>
<v t="leo1.20171224221230.10"><vh>const struct</vh></v>
<v t="leo1.20171224221230.11"><vh>extern "C" const char *ft_error_string(int err) {</vh></v>
<v t="leo1.20171224221230.12"><vh>void TtfFontList::LoadAll</vh></v>
<v t="leo1.20171224221230.13"><vh>void TtfFontList::PlotString</vh></v>
<v t="leo1.20171224221230.14"><vh>bool TtfFont::LoadFromFile</vh></v>
<v t="leo1.20171224221230.15"><vh>typedef struct</vh></v>
<v t="leo1.20171224221230.16"><vh>static Vector</vh></v>
<v t="leo1.20171224221230.17"><vh>int MoveTo</vh></v>
<v t="leo1.20171224221230.18"><vh>int LineTo</vh></v>
<v t="leo1.20171224221230.19"><vh>int ConicTo</vh></v>
<v t="leo1.20171224221230.20"><vh>int CubicTo</vh></v>
<v t="leo1.20171224221230.21"><vh>void TtfFont::PlotString</vh></v>
</v>
<v t="leo1.20171224221230.22"><vh>@@clean undoredo.cpp</vh>
<v t="leo1.20171224221230.23"><vh>void SolveSpaceUI::UndoRemember</vh></v>
<v t="leo1.20171224221230.24"><vh>void SolveSpaceUI::UndoUndo</vh></v>
<v t="leo1.20171224221230.25"><vh>void SolveSpaceUI::UndoRedo</vh></v>
<v t="leo1.20171224221230.26"><vh>void SolveSpaceUI::UndoEnableMenus</vh></v>
<v t="leo1.20171224221230.27"><vh>void SolveSpaceUI::PushFromCurrentOnto</vh></v>
<v t="leo1.20171224221230.28"><vh>void SolveSpaceUI::PopOntoCurrentFrom</vh></v>
<v t="leo1.20171224221230.29"><vh>void SolveSpaceUI::UndoClearStack</vh></v>
<v t="leo1.20171224221230.30"><vh>void SolveSpaceUI::UndoClearState</vh></v>
</v>
<v t="leo1.20171224221230.31"><vh>@@clean util.cpp</vh>
<v t="leo1.20171224221230.32"><vh>char 32_t</vh></v>
<v t="leo1.20171224221230.33"><vh>int 64_t</vh></v>
<v t="leo1.20171224221230.34"><vh>void SolveSpace::MakeMatrix</vh></v>
<v t="leo1.20171224221230.35"><vh>void SolveSpace::MultMatrix</vh></v>
<v t="leo1.20171224221230.36"><vh>void DoStringForMessageBox</vh></v>
<v t="leo1.20171224221230.37"><vh>void SolveSpace::Error</vh></v>
<v t="leo1.20171224221230.38"><vh>void SolveSpace::Message</vh></v>
<v t="leo1.20171224221230.39"><vh>void BandedMatrix::Solve</vh></v>
<v t="leo1.20171224221230.40"><vh>bool Vector::Equals</vh></v>
<v t="leo1.20171224221230.41"><vh>bool Vector::EqualsExactly</vh></v>
<v t="leo1.20171224221230.42"><vh>bool Vector::OnLineSegment</vh></v>
<v t="leo1.20171224221230.43"><vh>void Vector::MakeMaxMin</vh></v>
<v t="leo1.20171224221230.44"><vh>bool Vector::OutsideAndNotOn</vh></v>
<v t="leo1.20171224221230.45"><vh>bool Vector::BoundingBoxesDisjoint</vh></v>
<v t="leo1.20171224221230.46"><vh>bool Vector::BoundingBoxIntersectsLine</vh></v>
<v t="leo1.20171224221230.47"><vh>double det2</vh></v>
<v t="leo1.20171224221230.48"><vh>double det3</vh></v>
<v t="leo1.20171224221230.49"><vh>double det</vh></v>
<v t="leo1.20171224221230.50"><vh>bool VectorPred::operator</vh></v>
<v t="leo1.20171224221230.51"><vh>bool Point2d::Equals</vh></v>
<v t="leo1.20171224221230.52"><vh>void BBox::Include</vh></v>
<v t="leo1.20171224221230.53"><vh>bool BBox::Overlaps</vh></v>
<v t="leo1.20171224221230.54"><vh>bool BBox::Contains</vh></v>
<v t="leo1.20171224221230.55"><vh>const std::vector</vh></v>
</v>
<v t="leo1.20171224221230.56"><vh>@@clean view.cpp</vh>
<v t="leo1.20171224221230.57"><vh>void TextWindow::ShowEditView</vh></v>
<v t="leo1.20171224221230.58"><vh>void TextWindow::ScreenChangeViewScale</vh></v>
<v t="leo1.20171224221230.59"><vh>void TextWindow::ScreenChangeViewToFullScale</vh></v>
<v t="leo1.20171224221230.60"><vh>void TextWindow::ScreenChangeViewOrigin</vh></v>
<v t="leo1.20171224221230.61"><vh>void TextWindow::ScreenChangeViewProjection</vh></v>
<v t="leo1.20171224221230.62"><vh>bool TextWindow::EditControlDoneForView</vh></v>
</v>
<v t="leo1.20171224221230.63"><vh>@path platform</vh>
<v t="leo1.20171224221230.64"><vh>@@clean climain.cpp</vh>
<v t="leo1.20171224221230.65"><vh>void ShowUsage</vh>
<v t="leo1.20171224221230.66"><vh>auto FormatListFromFileFilter</vh></v>
</v>
<v t="leo1.20171224221230.67"><vh>bool RunCommand</vh>
<v t="leo1.20171224221230.68"><vh>auto ParseInputFile</vh></v>
<v t="leo1.20171224221230.69"><vh>auto ParseOutputPattern</vh></v>
<v t="leo1.20171224221230.70"><vh>auto ParseViewDirection</vh></v>
<v t="leo1.20171224221230.71"><vh>auto ParseChordTolerance</vh></v>
<v t="leo1.20171224221230.72"><vh>auto ParseSize</vh></v>
</v>
<v t="leo1.20171224221230.73"><vh>int main</vh></v>
</v>
<v t="leo1.20171224221230.74"><vh>@@clean gtkmain.cpp</vh>
<v t="leo1.20171224221232.1"><vh>static std::string</vh></v>
<v t="leo1.20171224221232.2"><vh>void CnfLoad</vh></v>
<v t="leo1.20171224221232.3"><vh>void CnfSave</vh></v>
<v t="leo1.20171224221232.4"><vh>void CnfFreezeInt</vh></v>
<v t="leo1.20171224221232.5"><vh>void CnfFreezeFloat</vh></v>
<v t="leo1.20171224221232.6"><vh>float CnfThawFloat</vh></v>
<v t="leo1.20171224221232.7"><vh>void CnfFreezeString</vh></v>
<v t="leo1.20171224221232.8"><vh>void CnfFreezeWindowPos</vh></v>
<v t="leo1.20171224221232.9"><vh>void CnfThawWindowPos</vh></v>
<v t="leo1.20171224221232.10"><vh>bool TimerCallback</vh></v>
<v t="leo1.20171224221232.11"><vh>void SetTimerFor</vh></v>
<v t="leo1.20171224221232.12"><vh>bool AutosaveTimerCallback</vh></v>
<v t="leo1.20171224221232.13"><vh>void SetAutosaveTimerFor</vh></v>
<v t="leo1.20171224221232.14"><vh>bool LaterCallback</vh></v>
<v t="leo1.20171224221232.15"><vh>void ScheduleLater</vh></v>
<v t="leo1.20171224221232.16"><vh>class EditorOverlay</vh>
<v t="leo1.20171224221232.17"><vh>void start_editing</vh></v>
<v t="leo1.20171224221232.18"><vh>void stop_editing</vh></v>
<v t="leo1.20171224221232.19"><vh>bool is_editing</vh></v>
<v t="leo1.20171224221232.20"><vh>bool on_key_press_event</vh></v>
<v t="leo1.20171224221232.21"><vh>bool on_key_release_event</vh></v>
<v t="leo1.20171224221232.22"><vh>void on_size_allocate</vh></v>
<v t="leo1.20171224221232.23"><vh>void on_activate</vh></v>
</v>
<v t="leo1.20171224221232.24"><vh>class GraphicsWidget</vh>
<v t="leo1.20171224221232.25"><vh>void on_resize</vh></v>
<v t="leo1.20171224221232.26"><vh>bool on_render</vh></v>
<v t="leo1.20171224221232.27"><vh>bool on_motion_notify_event</vh></v>
<v t="leo1.20171224221232.28"><vh>bool on_button_press_event</vh></v>
<v t="leo1.20171224221232.29"><vh>bool on_button_release_event</vh></v>
<v t="leo1.20171224221232.30"><vh>bool on_scroll_event</vh></v>
<v t="leo1.20171224221232.31"><vh>bool on_leave_notify_event</vh></v>
<v t="leo1.20171224221232.32"><vh>void ij_to_xy</vh></v>
</v>
<v t="leo1.20171224221232.33"><vh>class GraphicsWindowGtk</vh>
<v t="leo1.20171224221232.34"><vh>bool is_fullscreen</vh></v>
<v t="leo1.20171224221232.35"><vh>void on_show</vh></v>
<v t="leo1.20171224221232.36"><vh>void on_hide</vh></v>
<v t="leo1.20171224221232.37"><vh>bool on_delete_event</vh></v>
<v t="leo1.20171224221232.38"><vh>bool on_window_state_event</vh></v>
<v t="leo1.20171224221232.39"><vh>bool on_key_press_event</vh></v>
<v t="leo1.20171224221232.40"><vh>void on_editing_done</vh></v>
</v>
<v t="leo1.20171224221232.41"><vh>void GetGraphicsWindowSize</vh></v>
<v t="leo1.20171224221232.42"><vh>void InvalidateGraphics</vh></v>
<v t="leo1.20171224221232.43"><vh>void PaintGraphics</vh></v>
<v t="leo1.20171224221232.44"><vh>void SetCurrentFilename</vh></v>
<v t="leo1.20171224221232.45"><vh>void ToggleFullScreen</vh></v>
<v t="leo1.20171224221232.46"><vh>bool FullScreenIsActive</vh></v>
<v t="leo1.20171224221232.47"><vh>void ShowGraphicsEditControl</vh></v>
<v t="leo1.20171224221232.48"><vh>void HideGraphicsEditControl</vh></v>
<v t="leo1.20171224221232.49"><vh>bool GraphicsEditControlIsVisible</vh></v>
<v t="leo1.20171224221232.50"><vh>class ContextMenuItem</vh>
<v t="leo1.20171224221232.51"><vh>void on_activate</vh></v>
<v t="leo1.20171224221232.52"><vh>bool on_button_press_event</vh></v>
</v>
<v t="leo1.20171224221232.53"><vh>void AddContextMenuItem</vh></v>
<v t="leo1.20171224221232.54"><vh>void CreateContextSubmenu</vh></v>
<v t="leo1.20171224221232.55"><vh>void set_active</vh></v>
<v t="leo1.20171224221232.56"><vh>void on_activate</vh></v>
<v t="leo1.20171224221232.57"><vh>void InitMainMenu</vh></v>
<v t="leo1.20171224221232.58"><vh>void EnableMenuByCmd</vh></v>
<v t="leo1.20171224221232.59"><vh>void CheckMenuByCmd</vh></v>
<v t="leo1.20171224221232.60"><vh>void RadioMenuByCmd</vh></v>
<v t="leo1.20171224221232.61"><vh>class RecentMenuItem</vh>
<v t="leo1.20171224221232.62"><vh>void on_activate</vh></v>
</v>
<v t="leo1.20171224221232.63"><vh>void RefreshRecentMenu</vh></v>
<v t="leo1.20171224221232.64"><vh>void RefreshRecentMenus</vh></v>
<v t="leo1.20171224221232.65"><vh>static std::string</vh></v>
<v t="leo1.20171224221232.66"><vh>bool GetOpenFile</vh></v>
<v t="leo1.20171224221232.67"><vh>void ChooserFilterChanged</vh></v>
<v t="leo1.20171224221232.68"><vh>bool GetSaveFile</vh></v>
<v t="leo1.20171224221232.69"><vh>bool canCancel</vh></v>
<v t="leo1.20171224221232.70"><vh>class TextWidget</vh>
<v t="leo1.20171224221232.71"><vh>void set_cursor_hand</vh></v>
<v t="leo1.20171224221232.72"><vh>bool on_render</vh></v>
<v t="leo1.20171224221232.73"><vh>bool on_motion_notify_event</vh></v>
<v t="leo1.20171224221232.74"><vh>bool on_button_press_event</vh></v>
<v t="leo1.20171224221232.75"><vh>bool on_scroll_event</vh></v>
<v t="leo1.20171224221232.76"><vh>bool on_leave_notify_event</vh></v>
</v>
<v t="leo1.20171224221232.77"><vh>class TextWindowGtk</vh>
<v t="leo1.20171224221232.78"><vh>void on_show</vh></v>
<v t="leo1.20171224221232.79"><vh>void on_hide</vh></v>
<v t="leo1.20171224221232.80"><vh>bool on_delete_event</vh></v>
<v t="leo1.20171224221232.81"><vh>void on_scrollbar_value_changed</vh></v>
<v t="leo1.20171224221232.82"><vh>void on_editing_done</vh></v>
<v t="leo1.20171224221232.83"><vh>bool on_editor_motion_notify_event</vh></v>
<v t="leo1.20171224221232.84"><vh>bool on_editor_button_press_event</vh></v>
</v>
<v t="leo1.20171224221232.85"><vh>void ShowTextWindow</vh></v>
<v t="leo1.20171224221232.86"><vh>void GetTextWindowSize</vh></v>
<v t="leo1.20171224221232.87"><vh>void InvalidateText</vh></v>
<v t="leo1.20171224221232.88"><vh>void MoveTextScrollbarTo</vh></v>
<v t="leo1.20171224221232.89"><vh>void SetMousePointerToHand</vh></v>
<v t="leo1.20171224221232.90"><vh>void ShowTextEditControl</vh></v>
<v t="leo1.20171224221232.91"><vh>void HideTextEditControl</vh></v>
<v t="leo1.20171224221232.92"><vh>bool TextEditControlIsVisible</vh></v>
<v t="leo1.20171224221232.93"><vh>void DoMessageBox</vh></v>
<v t="leo1.20171224221232.94"><vh>void OpenWebsite</vh></v>
<v t="leo1.20171224221232.95"><vh>static GdkFilterReturn</vh></v>
<v t="leo1.20171224221232.96"><vh>void RefreshLocale</vh></v>
<v t="leo1.20171224221232.97"><vh>void ExitNow</vh></v>
<v t="leo1.20171224221232.98"><vh>int main</vh></v>
</v>
<v t="leo1.20171224221232.99"><vh>@@clean headless.cpp</vh>
<v t="leo1.20171224221233.1"><vh>class Setting</vh>
<v t="leo1.20171224221233.2"><vh>void CheckType</vh></v>
</v>
<v t="leo1.20171224221233.3"><vh>void CnfFreezeInt</vh></v>
<v t="leo1.20171224221233.4"><vh>void CnfFreezeFloat</vh></v>
<v t="leo1.20171224221233.5"><vh>float CnfThawFloat</vh></v>
<v t="leo1.20171224221233.6"><vh>void CnfFreezeString</vh></v>
<v t="leo1.20171224221233.7"><vh>void SetTimerFor</vh></v>
<v t="leo1.20171224221233.8"><vh>void SetAutosaveTimerFor</vh></v>
<v t="leo1.20171224221233.9"><vh>void ScheduleLater</vh></v>
<v t="leo1.20171224221233.10"><vh>void GetGraphicsWindowSize</vh></v>
<v t="leo1.20171224221233.11"><vh>void InvalidateGraphics</vh></v>
<v t="leo1.20171224221233.12"><vh>void PaintGraphics</vh></v>
<v t="leo1.20171224221233.13"><vh>void SetCurrentFilename</vh></v>
<v t="leo1.20171224221233.14"><vh>void ToggleFullScreen</vh></v>
<v t="leo1.20171224221233.15"><vh>bool FullScreenIsActive</vh></v>
<v t="leo1.20171224221233.16"><vh>void ShowGraphicsEditControl</vh></v>
<v t="leo1.20171224221233.17"><vh>void HideGraphicsEditControl</vh></v>
<v t="leo1.20171224221233.18"><vh>bool GraphicsEditControlIsVisible</vh></v>
<v t="leo1.20171224221233.19"><vh>void AddContextMenuItem</vh></v>
<v t="leo1.20171224221233.20"><vh>void CreateContextSubmenu</vh></v>
<v t="leo1.20171224221233.21"><vh>void EnableMenuByCmd</vh></v>
<v t="leo1.20171224221233.22"><vh>void CheckMenuByCmd</vh></v>
<v t="leo1.20171224221233.23"><vh>void RadioMenuByCmd</vh></v>
<v t="leo1.20171224221233.24"><vh>void RefreshRecentMenus</vh></v>
<v t="leo1.20171224221233.25"><vh>void ShowTextWindow</vh></v>
<v t="leo1.20171224221233.26"><vh>void GetTextWindowSize</vh></v>
<v t="leo1.20171224221233.27"><vh>void InvalidateText</vh></v>
<v t="leo1.20171224221233.28"><vh>void MoveTextScrollbarTo</vh></v>
<v t="leo1.20171224221233.29"><vh>void SetMousePointerToHand</vh></v>
<v t="leo1.20171224221233.30"><vh>void ShowTextEditControl</vh></v>
<v t="leo1.20171224221233.31"><vh>void HideTextEditControl</vh></v>
<v t="leo1.20171224221233.32"><vh>bool TextEditControlIsVisible</vh></v>
<v t="leo1.20171224221233.33"><vh>bool GetOpenFile</vh></v>
<v t="leo1.20171224221233.34"><vh>bool GetSaveFile</vh></v>
<v t="leo1.20171224221233.35"><vh>bool canCancel</vh></v>
<v t="leo1.20171224221233.36"><vh>void DoMessageBox</vh></v>
<v t="leo1.20171224221233.37"><vh>void OpenWebsite</vh></v>
<v t="leo1.20171224221233.38"><vh>void RefreshLocale</vh></v>
<v t="leo1.20171224221233.39"><vh>void ExitNow</vh></v>
</v>
<v t="leo1.20171224221233.40"><vh>@@clean platform.cpp</vh>
<v t="leo1.20171224221233.41"><vh>static std::vector</vh></v>
<v t="leo1.20171224221233.42"><vh>static std::string</vh></v>
<v t="leo1.20171224221233.43"><vh>bool Path::HasExtension</vh></v>
<v t="leo1.20171224221233.44"><vh>void FindPrefix</vh></v>
<v t="leo1.20171224221233.45"><vh>bool Path::IsAbsolute</vh></v>
<v t="leo1.20171224221233.46"><vh>static std::string</vh></v>
<v t="leo1.20171224221233.47"><vh>bool Path::Equals</vh></v>
<v t="leo1.20171224221233.48"><vh>void RemoveFile</vh></v>
<v t="leo1.20171224221233.49"><vh>bool ReadFile</vh></v>
<v t="leo1.20171224221233.50"><vh>bool WriteFile</vh></v>
<v t="leo1.20171224221233.51"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) {</vh></v>
<v t="leo1.20171224221233.52"><vh>static Platform::Path</vh></v>
<v t="leo1.20171224221233.53"><vh>static Platform::Path</vh></v>
<v t="leo1.20171224221233.54"><vh>static Platform::Path</vh></v>
<v t="leo1.20171224221233.55"><vh>static Platform::Path</vh></v>
<v t="leo1.20171224221233.56"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) {</vh></v>
</v>
<v t="leo1.20171224221233.57"><vh>@@clean unixutil.cpp</vh>
<v t="leo1.20171224221233.58"><vh>void dbp</vh></v>
<v t="leo1.20171224221233.59"><vh>void assert_failure</vh></v>
<v t="leo1.20171224221233.60"><vh>typedef struct</vh></v>
<v t="leo1.20171224221233.61"><vh>void *AllocTemporary(size_t n)</vh></v>
<v t="leo1.20171224221233.62"><vh>void FreeTemporary</vh></v>
<v t="leo1.20171224221233.63"><vh>void FreeAllTemporary</vh></v>
<v t="leo1.20171224221233.64"><vh>void *MemAlloc(size_t n) {</vh></v>
<v t="leo1.20171224221233.65"><vh>void MemFree</vh></v>
</v>
<v t="leo1.20171224221233.66"><vh>@@clean w32main.cpp</vh>
<v t="leo1.20171224221233.67"><vh>static struct</vh></v>
<v t="leo1.20171224221233.68"><vh>static LRESULT</vh></v>
<v t="leo1.20171224221233.69"><vh>void SolveSpace::DoMessageBox</vh></v>
<v t="leo1.20171224221233.70"><vh>void SolveSpace::AddContextMenuItem</vh></v>
<v t="leo1.20171224221233.71"><vh>void SolveSpace::CreateContextSubmenu</vh></v>
<v t="leo1.20171224221233.72"><vh>void SolveSpace::SetTimerFor</vh></v>
<v t="leo1.20171224221233.73"><vh>void SolveSpace::ScheduleLater</vh></v>
<v t="leo1.20171224221233.74"><vh>void CALLBACK</vh></v>
<v t="leo1.20171224221233.75"><vh>void SolveSpace::SetAutosaveTimerFor</vh></v>
<v t="leo1.20171224221233.76"><vh>void GetWindowSize</vh></v>
<v t="leo1.20171224221233.77"><vh>void SolveSpace::GetGraphicsWindowSize</vh></v>
<v t="leo1.20171224221233.78"><vh>void SolveSpace::GetTextWindowSize</vh></v>
<v t="leo1.20171224221233.79"><vh>void SolveSpace::OpenWebsite</vh></v>
<v t="leo1.20171224221233.80"><vh>void SolveSpace::ExitNow</vh></v>
<v t="leo1.20171224221233.81"><vh>static HKEY</vh></v>
<v t="leo1.20171224221233.82"><vh>void SolveSpace::CnfFreezeInt</vh></v>
<v t="leo1.20171224221233.83"><vh>void SolveSpace::CnfFreezeFloat</vh>
<v t="leo1.20171224221233.84"><vh>static _assert</vh></v>
</v>
<v t="leo1.20171224221233.85"><vh>void FreezeWindowPos</vh></v>
<v t="leo1.20171224221233.86"><vh>float SolveSpace::CnfThawFloat</vh></v>
<v t="leo1.20171224221233.87"><vh>void ThawWindowPos</vh></v>
<v t="leo1.20171224221233.88"><vh>void SolveSpace::SetCurrentFilename</vh></v>
<v t="leo1.20171224221233.89"><vh>void SolveSpace::SetMousePointerToHand</vh></v>
<v t="leo1.20171224221233.90"><vh>void PaintTextWnd</vh></v>
<v t="leo1.20171224221233.91"><vh>void SolveSpace::MoveTextScrollbarTo</vh></v>
<v t="leo1.20171224221233.92"><vh>void HandleTextWindowScrollBar</vh></v>
<v t="leo1.20171224221233.93"><vh>void MouseWheel</vh></v>
<v t="leo1.20171224221233.94"><vh>int tooNarrow</vh></v>
<v t="leo1.20171224221233.95"><vh>static std::string</vh></v>
<v t="leo1.20171224221233.96"><vh>bool ProcessKeyDown</vh></v>
<v t="leo1.20171224221233.97"><vh>void SolveSpace::ShowTextWindow</vh></v>
<v t="leo1.20171224221233.98"><vh>void CreateGlContext</vh></v>
<v t="leo1.20171224221233.99"><vh>void CreateGlContext</vh></v>
<v t="leo1.20171224221233.100"><vh>void SolveSpace::PaintGraphics</vh></v>
<v t="leo1.20171224221233.101"><vh>void SolveSpace::InvalidateGraphics</vh></v>
<v t="leo1.20171224221233.102"><vh>void SolveSpace::ToggleFullScreen</vh></v>
<v t="leo1.20171224221233.103"><vh>bool SolveSpace::FullScreenIsActive</vh></v>
<v t="leo1.20171224221233.104"><vh>void SolveSpace::InvalidateText</vh></v>
<v t="leo1.20171224221233.105"><vh>void ShowEditControl</vh></v>
<v t="leo1.20171224221233.106"><vh>void SolveSpace::ShowTextEditControl</vh></v>
<v t="leo1.20171224221233.107"><vh>void SolveSpace::HideTextEditControl</vh></v>
<v t="leo1.20171224221233.108"><vh>bool SolveSpace::TextEditControlIsVisible</vh></v>
<v t="leo1.20171224221233.109"><vh>void SolveSpace::ShowGraphicsEditControl</vh></v>
<v t="leo1.20171224221233.110"><vh>void SolveSpace::HideGraphicsEditControl</vh></v>
<v t="leo1.20171224221233.111"><vh>bool SolveSpace::GraphicsEditControlIsVisible</vh></v>
<v t="leo1.20171224221233.112"><vh>static std::string</vh></v>
<v t="leo1.20171224221233.113"><vh>bool OpenSaveFile</vh></v>
<v t="leo1.20171224221233.114"><vh>bool SolveSpace::GetOpenFile</vh></v>
<v t="leo1.20171224221233.115"><vh>bool SolveSpace::GetSaveFile</vh></v>
<v t="leo1.20171224221233.116"><vh>bool canCancel</vh>
<v t="leo1.20171224221233.117"><vh>int r</vh></v>
</v>
<v t="leo1.20171224221233.118"><vh>void MenuByCmd</vh></v>
<v t="leo1.20171224221233.119"><vh>void SolveSpace::CheckMenuByCmd</vh></v>
<v t="leo1.20171224221233.120"><vh>void SolveSpace::RadioMenuByCmd</vh></v>
<v t="leo1.20171224221233.121"><vh>void SolveSpace::EnableMenuByCmd</vh></v>
<v t="leo1.20171224221233.122"><vh>void DoRecent</vh></v>
<v t="leo1.20171224221233.123"><vh>void SolveSpace::RefreshRecentMenus</vh></v>
<v t="leo1.20171224221233.124"><vh>void CreateMainWindows</vh></v>
<v t="leo1.20171224221233.125"><vh>void SolveSpace::RefreshLocale</vh></v>
<v t="leo1.20171224221233.126"><vh>bool ProcessSpaceNavigatorMsg</vh></v>
<v t="leo1.20171224221233.127"><vh>int WINAPI</vh></v>
</v>
<v t="leo1.20171224221233.128"><vh>@@clean w32util.cpp</vh>
<v t="leo1.20171224221233.129"><vh>void dbp</vh></v>
<v t="leo1.20171224221233.130"><vh>void assert_failure</vh></v>
<v t="leo1.20171224221233.131"><vh>void *AllocTemporary(size_t n)</vh></v>
<v t="leo1.20171224221233.132"><vh>void FreeTemporary</vh></v>
<v t="leo1.20171224221233.133"><vh>void FreeAllTemporary</vh></v>
<v t="leo1.20171224221233.134"><vh>void *MemAlloc(size_t n) {</vh></v>
<v t="leo1.20171224221233.135"><vh>void MemFree</vh></v>
<v t="leo1.20171224221233.136"><vh>void vl</vh></v>
</v>
</v>
<v t="leo1.20171224221233.137"><vh>@path render</vh>
<v t="leo1.20171224221233.138"><vh>@@clean gl3shader.cpp</vh>
<v t="leo1.20171224221233.139"><vh>static GLuint</vh></v>
<v t="leo1.20171224221233.140"><vh>void Shader::Init</vh></v>
<v t="leo1.20171224221233.141"><vh>void Shader::Clear</vh></v>
<v t="leo1.20171224221233.142"><vh>void Shader::SetUniformMatrix</vh></v>
<v t="leo1.20171224221233.143"><vh>void Shader::SetUniformVector</vh></v>
<v t="leo1.20171224221233.144"><vh>void Shader::SetUniformVector</vh></v>
<v t="leo1.20171224221233.145"><vh>void Shader::SetUniformColor</vh></v>
<v t="leo1.20171224221233.146"><vh>void Shader::SetUniformFloat</vh></v>
<v t="leo1.20171224221233.147"><vh>void Shader::SetUniformInt</vh></v>
<v t="leo1.20171224221233.148"><vh>void Shader::SetUniformTextureUnit</vh></v>
<v t="leo1.20171224221233.149"><vh>void Shader::Enable</vh></v>
<v t="leo1.20171224221233.150"><vh>void Shader::Disable</vh></v>
<v t="leo1.20171224221233.151"><vh>void MeshRenderer::Init</vh></v>
<v t="leo1.20171224221233.152"><vh>void MeshRenderer::Clear</vh></v>
<v t="leo1.20171224221233.153"><vh>void MeshRenderer::Remove</vh></v>
<v t="leo1.20171224221233.154"><vh>void MeshRenderer::Draw</vh></v>
<v t="leo1.20171224221233.155"><vh>void MeshRenderer::Draw</vh></v>
<v t="leo1.20171224221233.156"><vh>void MeshRenderer::SetModelview</vh></v>
<v t="leo1.20171224221233.157"><vh>void MeshRenderer::SetProjection</vh></v>
<v t="leo1.20171224221233.158"><vh>void MeshRenderer::UseShaded</vh></v>
<v t="leo1.20171224221233.159"><vh>void MeshRenderer::UseFilled</vh></v>
<v t="leo1.20171224221233.160"><vh>double Frac</vh></v>
<v t="leo1.20171224221233.161"><vh>static RgbaColor</vh></v>
<v t="leo1.20171224221233.162"><vh>void StippleAtlas::Init</vh></v>
<v t="leo1.20171224221233.163"><vh>void StippleAtlas::Clear</vh></v>
<v t="leo1.20171224221233.164"><vh>void EdgeRenderer::Init</vh></v>
<v t="leo1.20171224221233.165"><vh>void EdgeRenderer::Clear</vh></v>
<v t="leo1.20171224221233.166"><vh>void EdgeRenderer::Remove</vh></v>
<v t="leo1.20171224221233.167"><vh>void EdgeRenderer::Draw</vh></v>
<v t="leo1.20171224221233.168"><vh>void EdgeRenderer::Draw</vh></v>
<v t="leo1.20171224221233.169"><vh>void EdgeRenderer::SetModelview</vh></v>
<v t="leo1.20171224221233.170"><vh>void EdgeRenderer::SetProjection</vh></v>
<v t="leo1.20171224221233.171"><vh>void EdgeRenderer::SetStroke</vh></v>
<v t="leo1.20171224221233.172"><vh>void OutlineRenderer::Init</vh></v>
<v t="leo1.20171224221233.173"><vh>void OutlineRenderer::Clear</vh></v>
<v t="leo1.20171224221233.174"><vh>void OutlineRenderer::Remove</vh></v>
<v t="leo1.20171224221233.175"><vh>void OutlineRenderer::Draw</vh></v>
<v t="leo1.20171224221233.176"><vh>void OutlineRenderer::Draw</vh></v>
<v t="leo1.20171224221233.177"><vh>void OutlineRenderer::SetModelview</vh></v>
<v t="leo1.20171224221233.178"><vh>void OutlineRenderer::SetProjection</vh></v>
<v t="leo1.20171224221233.179"><vh>void OutlineRenderer::SetStroke</vh></v>
<v t="leo1.20171224221233.180"><vh>void SIndexedMesh::AddPoint</vh></v>
<v t="leo1.20171224221233.181"><vh>void SIndexedMesh::AddQuad</vh></v>
<v t="leo1.20171224221233.182"><vh>void SIndexedMesh::AddPixmap</vh></v>
<v t="leo1.20171224221233.183"><vh>void SIndexedMesh::Clear</vh></v>
<v t="leo1.20171224221233.184"><vh>void IndexedMeshRenderer::Init</vh></v>
<v t="leo1.20171224221233.185"><vh>void IndexedMeshRenderer::Clear</vh></v>
<v t="leo1.20171224221233.186"><vh>void IndexedMeshRenderer::Remove</vh></v>
<v t="leo1.20171224221233.187"><vh>void IndexedMeshRenderer::Draw</vh></v>
<v t="leo1.20171224221233.188"><vh>void IndexedMeshRenderer::Draw</vh></v>
<v t="leo1.20171224221233.189"><vh>bool IndexedMeshRenderer::NeedsTexture</vh></v>
<v t="leo1.20171224221233.190"><vh>void IndexedMeshRenderer::SetModelview</vh></v>
<v t="leo1.20171224221233.191"><vh>void IndexedMeshRenderer::SetProjection</vh></v>
<v t="leo1.20171224221233.192"><vh>void IndexedMeshRenderer::UseFilled</vh></v>
<v t="leo1.20171224221233.193"><vh>void IndexedMeshRenderer::UsePoint</vh></v>
</v>
<v t="leo1.20171224221233.194"><vh>@@clean render.cpp</vh>
<v t="leo1.20171224221234.1"><vh>void Camera::LoadIdentity</vh></v>
<v t="leo1.20171224221234.2"><vh>void Camera::NormalizeProjectionVectors</vh></v>
<v t="leo1.20171224221234.3"><vh>bool Canvas::Stroke::Equals</vh></v>
<v t="leo1.20171224221234.4"><vh>bool Canvas::Fill::Equals</vh></v>
<v t="leo1.20171224221234.5"><vh>void Canvas::Clear</vh></v>
<v t="leo1.20171224221234.6"><vh>const Camera</vh></v>
<v t="leo1.20171224221234.7"><vh>void UiCanvas::DrawLine</vh></v>
<v t="leo1.20171224221234.8"><vh>void UiCanvas::DrawRect</vh></v>
<v t="leo1.20171224221234.9"><vh>void UiCanvas::DrawPixmap</vh></v>
<v t="leo1.20171224221234.10"><vh>void UiCanvas::DrawBitmapChar</vh></v>
<v t="leo1.20171224221234.11"><vh>void UiCanvas::DrawBitmapText</vh></v>
<v t="leo1.20171224221234.12"><vh>void ObjectPicker::DoCompare</vh></v>
<v t="leo1.20171224221234.13"><vh>void ObjectPicker::DoQuad</vh>
<v t="leo1.20171224221234.14"><vh>double minNegative</vh></v>
</v>
<v t="leo1.20171224221234.15"><vh>void ObjectPicker::DrawLine</vh></v>
<v t="leo1.20171224221234.16"><vh>void ObjectPicker::DrawEdges</vh></v>
<v t="leo1.20171224221234.17"><vh>void ObjectPicker::DrawOutlines</vh></v>
<v t="leo1.20171224221234.18"><vh>void ObjectPicker::DrawVectorText</vh></v>
<v t="leo1.20171224221234.19"><vh>void ObjectPicker::DrawPoint</vh></v>
<v t="leo1.20171224221234.20"><vh>void ObjectPicker::DrawPolygon</vh></v>
<v t="leo1.20171224221234.21"><vh>void ObjectPicker::DrawMesh</vh></v>
<v t="leo1.20171224221234.22"><vh>void ObjectPicker::DrawFaces</vh></v>
<v t="leo1.20171224221234.23"><vh>void ObjectPicker::DrawPixmap</vh></v>
<v t="leo1.20171224221234.24"><vh>bool ObjectPicker::Pick</vh></v>
</v>
<v t="leo1.20171224221234.25"><vh>@@clean render2d.cpp</vh>
<v t="leo1.20171224221235.1"><vh>static Vector</vh></v>
<v t="leo1.20171224221235.2"><vh>void SurfaceRenderer::DrawLine</vh></v>
<v t="leo1.20171224221235.3"><vh>void SurfaceRenderer::DrawEdges</vh></v>
<v t="leo1.20171224221235.4"><vh>bool SurfaceRenderer::DrawBeziers</vh></v>
<v t="leo1.20171224221235.5"><vh>void SurfaceRenderer::DrawOutlines</vh></v>
<v t="leo1.20171224221235.6"><vh>void SurfaceRenderer::DrawVectorText</vh>
<v t="leo1.20171224221235.7"><vh>auto traceEdge</vh></v>
</v>
<v t="leo1.20171224221235.8"><vh>void SurfaceRenderer::DrawQuad</vh></v>
<v t="leo1.20171224221235.9"><vh>void SurfaceRenderer::DrawPoint</vh></v>
<v t="leo1.20171224221235.10"><vh>void SurfaceRenderer::DrawPolygon</vh></v>
<v t="leo1.20171224221235.11"><vh>void SurfaceRenderer::DrawMesh</vh></v>
<v t="leo1.20171224221235.12"><vh>void SurfaceRenderer::DrawFaces</vh></v>
<v t="leo1.20171224221235.13"><vh>void SurfaceRenderer::DrawPixmap</vh></v>
<v t="leo1.20171224221235.14"><vh>void SurfaceRenderer::InvalidatePixmap</vh></v>
<v t="leo1.20171224221235.15"><vh>void SurfaceRenderer::CalculateBBox</vh></v>
<v t="leo1.20171224221235.16"><vh>void SurfaceRenderer::ConvertBeziersToEdges</vh></v>
<v t="leo1.20171224221235.17"><vh>void SurfaceRenderer::CullOccludedStrokes</vh></v>
<v t="leo1.20171224221235.18"><vh>void SurfaceRenderer::OutputInPaintOrder</vh>
<v t="leo1.20171224221235.19"><vh>const Layer</vh></v>
<v t="leo1.20171224221235.20"><vh>int aZIndex</vh></v>
</v>
<v t="leo1.20171224221235.21"><vh>void SurfaceRenderer::Clear</vh></v>
<v t="leo1.20171224221235.22"><vh>void SurfaceRenderer::OutputBezierAsNonrationalCubic</vh></v>
</v>
<v t="leo1.20171224221235.23"><vh>@@clean rendercairo.cpp</vh>
<v t="leo1.20171224221235.24"><vh>void CairoRenderer::OutputStart</vh></v>
<v t="leo1.20171224221235.25"><vh>void CairoRenderer::OutputEnd</vh></v>
<v t="leo1.20171224221235.26"><vh>void CairoRenderer::SelectStroke</vh></v>
<v t="leo1.20171224221235.27"><vh>void CairoRenderer::MoveTo</vh></v>
<v t="leo1.20171224221235.28"><vh>void CairoRenderer::FinishPath</vh></v>
<v t="leo1.20171224221235.29"><vh>void CairoRenderer::OutputBezier</vh>
<v t="leo1.20171224221235.30"><vh>double theta0</vh></v>
</v>
<v t="leo1.20171224221235.31"><vh>void CairoRenderer::OutputTriangle</vh></v>
</v>
<v t="leo1.20171224221235.32"><vh>@@clean rendergl.cpp</vh>
<v t="leo1.20171224221235.33"><vh>void GlOffscreen::Clear</vh></v>
<v t="leo1.20171224221235.34"><vh>bool GlOffscreen::Render</vh>
<v t="leo1.20171224221235.35"><vh>bool framebufferComplete</vh></v>
</v>
</v>
<v t="leo1.20171224221235.36"><vh>@@clean rendergl1.cpp</vh>
<v t="leo1.20171224221235.37"><vh>bool HasIntelThinLineQuirk</vh></v>
<v t="leo1.20171224221235.38"><vh>bool HasGl1V1Quirk</vh></v>
<v t="leo1.20171224221235.39"><vh>static inline</vh></v>
<v t="leo1.20171224221235.40"><vh>static inline</vh></v>
<v t="leo1.20171224221235.41"><vh>void ssglLineWidth</vh></v>
<v t="leo1.20171224221235.42"><vh>static inline</vh></v>
<v t="leo1.20171224221235.43"><vh>static inline</vh></v>
<v t="leo1.20171224221235.44"><vh>void ssglDepthRange</vh></v>
<v t="leo1.20171224221235.45"><vh>void ssglFillPattern</vh></v>
<v t="leo1.20171224221235.46"><vh>class OpenGl1Renderer</vh></v>
<v t="leo1.20171224221235.47"><vh>void OpenGl1Renderer::SelectPrimitive</vh></v>
<v t="leo1.20171224221235.48"><vh>void OpenGl1Renderer::UnSelectPrimitive</vh></v>
<v t="leo1.20171224221235.49"><vh>int RoundUpToPowerOfTwo</vh></v>
<v t="leo1.20171224221235.50"><vh>void OpenGl1Renderer::SelectTexture</vh></v>
<v t="leo1.20171224221235.51"><vh>void OpenGl1Renderer::DoFatLineEndcap</vh>
<v t="leo1.20171224221235.52"><vh>double Circle</vh></v>
</v>
<v t="leo1.20171224221235.53"><vh>void OpenGl1Renderer::DoFatLine</vh></v>
<v t="leo1.20171224221235.54"><vh>void OpenGl1Renderer::DoLine</vh></v>
<v t="leo1.20171224221235.55"><vh>void OpenGl1Renderer::DoPoint</vh></v>
<v t="leo1.20171224221235.56"><vh>void OpenGl1Renderer::DoStippledLine</vh></v>
<v t="leo1.20171224221235.57"><vh>void OpenGl1Renderer::DrawLine</vh></v>
<v t="leo1.20171224221235.58"><vh>void OpenGl1Renderer::DrawEdges</vh></v>
<v t="leo1.20171224221235.59"><vh>void OpenGl1Renderer::DrawOutlines</vh></v>
<v t="leo1.20171224221235.60"><vh>void OpenGl1Renderer::DrawVectorText</vh></v>
<v t="leo1.20171224221235.61"><vh>void OpenGl1Renderer::DrawQuad</vh></v>
<v t="leo1.20171224221235.62"><vh>void OpenGl1Renderer::DrawPoint</vh></v>
<v t="leo1.20171224221235.63"><vh>void SSGL_CALLBACK</vh></v>
<v t="leo1.20171224221235.64"><vh>void SSGL_CALLBACK</vh></v>
<v t="leo1.20171224221235.65"><vh>void OpenGl1Renderer::DrawPolygon</vh></v>
<v t="leo1.20171224221235.66"><vh>void OpenGl1Renderer::DrawMesh</vh></v>
<v t="leo1.20171224221235.67"><vh>void OpenGl1Renderer::DrawFaces</vh></v>
<v t="leo1.20171224221235.68"><vh>void OpenGl1Renderer::DrawPixmap</vh>
<v t="leo1.20171224221235.69"><vh>double xfactor</vh></v>
</v>
<v t="leo1.20171224221235.70"><vh>void OpenGl1Renderer::InvalidatePixmap</vh></v>
<v t="leo1.20171224221235.71"><vh>void OpenGl1Renderer::UpdateProjection</vh></v>
<v t="leo1.20171224221235.72"><vh>void OpenGl1Renderer::NewFrame</vh></v>
<v t="leo1.20171224221235.73"><vh>void OpenGl1Renderer::FlushFrame</vh></v>
<v t="leo1.20171224221235.74"><vh>void OpenGl1Renderer::GetIdent</vh></v>
<v t="leo1.20171224221235.75"><vh>void OpenGl1Renderer::SetCamera</vh></v>
<v t="leo1.20171224221235.76"><vh>void OpenGl1Renderer::SetLighting</vh></v>
</v>
<v t="leo1.20171224221235.77"><vh>@@clean rendergl3.cpp</vh>
<v t="leo1.20171224221236.1"><vh>class TextureCache</vh>
<v t="leo1.20171224221236.2"><vh>bool Lookup</vh></v>
<v t="leo1.20171224221236.3"><vh>void CleanupUnused</vh></v>
</v>
<v t="leo1.20171224221236.4"><vh>class OpenGl2Renderer</vh></v>
<v t="leo1.20171224221236.5"><vh>void ssglDepthRange</vh></v>
<v t="leo1.20171224221236.6"><vh>void OpenGl2Renderer::SelectMask</vh></v>
<v t="leo1.20171224221236.7"><vh>void OpenGl2Renderer::InvalidatePixmap</vh></v>
<v t="leo1.20171224221236.8"><vh>void OpenGl2Renderer::SelectTexture</vh></v>
<v t="leo1.20171224221236.9"><vh>void OpenGl2Renderer::DoLine</vh></v>
<v t="leo1.20171224221236.10"><vh>void OpenGl2Renderer::DoPoint</vh></v>
<v t="leo1.20171224221236.11"><vh>void OpenGl2Renderer::DoStippledLine</vh></v>
<v t="leo1.20171224221236.12"><vh>void OpenGl2Renderer::Init</vh></v>
<v t="leo1.20171224221236.13"><vh>void OpenGl2Renderer::DrawLine</vh></v>
<v t="leo1.20171224221236.14"><vh>void OpenGl2Renderer::DrawEdges</vh></v>
<v t="leo1.20171224221236.15"><vh>void OpenGl2Renderer::DrawOutlines</vh></v>
<v t="leo1.20171224221236.16"><vh>void OpenGl2Renderer::DrawVectorText</vh></v>
<v t="leo1.20171224221236.17"><vh>void OpenGl2Renderer::DrawQuad</vh></v>
<v t="leo1.20171224221236.18"><vh>void OpenGl2Renderer::DrawPoint</vh></v>
<v t="leo1.20171224221236.19"><vh>void OpenGl2Renderer::DrawPolygon</vh></v>
<v t="leo1.20171224221236.20"><vh>void OpenGl2Renderer::DrawMesh</vh></v>
<v t="leo1.20171224221236.21"><vh>void OpenGl2Renderer::DrawFaces</vh></v>
<v t="leo1.20171224221236.22"><vh>void OpenGl2Renderer::DrawPixmap</vh></v>
<v t="leo1.20171224221236.23"><vh>void OpenGl2Renderer::UpdateProjection</vh></v>
<v t="leo1.20171224221236.24"><vh>void OpenGl2Renderer::NewFrame</vh></v>
<v t="leo1.20171224221236.25"><vh>void OpenGl2Renderer::FlushFrame</vh></v>
<v t="leo1.20171224221236.26"><vh>void OpenGl2Renderer::Clear</vh></v>
<v t="leo1.20171224221236.27"><vh>void OpenGl2Renderer::GetIdent</vh></v>
<v t="leo1.20171224221236.28"><vh>void OpenGl2Renderer::SetCamera</vh></v>
<v t="leo1.20171224221236.29"><vh>void OpenGl2Renderer::SetLighting</vh></v>
<v t="leo1.20171224221236.30"><vh>class DrawCall</vh></v>
<v t="leo1.20171224221236.31"><vh>class EdgeDrawCall</vh>
<v t="leo1.20171224221236.32"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221236.33"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.34"><vh>void Remove</vh></v>
</v>
<v t="leo1.20171224221236.35"><vh>class OutlineDrawCall</vh>
<v t="leo1.20171224221236.36"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221236.37"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.38"><vh>void Remove</vh></v>
</v>
<v t="leo1.20171224221236.39"><vh>class PointDrawCall</vh>
<v t="leo1.20171224221236.40"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221236.41"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.42"><vh>void Remove</vh></v>
</v>
<v t="leo1.20171224221236.43"><vh>class PixmapDrawCall</vh>
<v t="leo1.20171224221236.44"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221236.45"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.46"><vh>void Remove</vh></v>
</v>
<v t="leo1.20171224221236.47"><vh>class MeshDrawCall</vh>
<v t="leo1.20171224221236.48"><vh>static std::shared_ptr</vh></v>
<v t="leo1.20171224221236.49"><vh>void DrawFace</vh></v>
<v t="leo1.20171224221236.50"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.51"><vh>void Remove</vh></v>
</v>
<v t="leo1.20171224221236.52"><vh>bool operator</vh>
<v t="leo1.20171224221236.53"><vh>const Canvas::Layer</vh></v>
<v t="leo1.20171224221236.54"><vh>int aLayerIndex</vh></v>
</v>
<v t="leo1.20171224221236.55"><vh>class OpenGl2RendererBatch</vh>
<v t="leo1.20171224221236.56"><vh>void Clear</vh></v>
<v t="leo1.20171224221236.57"><vh>void Clear</vh></v>
<v t="leo1.20171224221236.58"><vh>void DrawLine</vh></v>
<v t="leo1.20171224221236.59"><vh>void DrawEdges</vh></v>
<v t="leo1.20171224221236.60"><vh>bool DrawBeziers</vh></v>
<v t="leo1.20171224221236.61"><vh>void DrawOutlines</vh></v>
<v t="leo1.20171224221236.62"><vh>void DrawVectorText</vh></v>
<v t="leo1.20171224221236.63"><vh>void DrawQuad</vh></v>
<v t="leo1.20171224221236.64"><vh>void DrawPoint</vh></v>
<v t="leo1.20171224221236.65"><vh>void DrawPolygon</vh></v>
<v t="leo1.20171224221236.66"><vh>void DrawMesh</vh></v>
<v t="leo1.20171224221236.67"><vh>void DrawFaces</vh></v>
<v t="leo1.20171224221236.68"><vh>void DrawPixmap</vh></v>
<v t="leo1.20171224221236.69"><vh>void InvalidatePixmap</vh></v>
<v t="leo1.20171224221236.70"><vh>void Finalize</vh></v>
<v t="leo1.20171224221236.71"><vh>void Draw</vh></v>
<v t="leo1.20171224221236.72"><vh>void Clear</vh></v>
</v>
</v>
</v>
<v t="leo1.20171224221236.73"><vh>@path srf</vh>
<v t="leo1.20171224221236.74"><vh>@@clean boolean.cpp</vh>
<v t="leo1.20171224221236.75"><vh>void SShell::MakeFromUnionOf</vh></v>
<v t="leo1.20171224221236.76"><vh>void SShell::MakeFromDifferenceOf</vh></v>
<v t="leo1.20171224221236.77"><vh>int ByTAlongLine</vh>
<v t="leo1.20171224221236.78"><vh>double ta</vh></v>
</v>
<v t="leo1.20171224221236.79"><vh>void SShell::CopyCurvesSplitAgainst</vh></v>
<v t="leo1.20171224221236.80"><vh>void SSurface::TrimFromEdgeList</vh></v>
<v t="leo1.20171224221236.81"><vh>bool KeepRegion</vh></v>
<v t="leo1.20171224221236.82"><vh>bool KeepEdge</vh></v>
<v t="leo1.20171224221236.83"><vh>void DEBUGEDGELIST</vh></v>
<v t="leo1.20171224221236.84"><vh>void SSurface::FindChainAvoiding</vh>
<v t="leo1.20171224221236.85"><vh>bool startOkay</vh></v>
</v>
<v t="leo1.20171224221236.86"><vh>void SSurface::EdgeNormalsWithinSurface</vh></v>
<v t="leo1.20171224221236.87"><vh>void SShell::CopySurfacesTrimAgainst</vh></v>
<v t="leo1.20171224221236.88"><vh>void SShell::MakeIntersectionCurvesAgainst</vh></v>
<v t="leo1.20171224221236.89"><vh>void SShell::CleanupAfterBoolean</vh></v>
<v t="leo1.20171224221236.90"><vh>void SShell::RewriteSurfaceHandlesForCurves</vh></v>
<v t="leo1.20171224221236.91"><vh>void SShell::MakeFromAssemblyOf</vh></v>
<v t="leo1.20171224221236.92"><vh>void SShell::MakeFromBoolean</vh></v>
<v t="leo1.20171224221236.93"><vh>void SShell::MakeClassifyingBsps</vh></v>
<v t="leo1.20171224221236.94"><vh>void SSurface::MakeClassifyingBsp</vh></v>
<v t="leo1.20171224221236.95"><vh>int ByLength</vh>
<v t="leo1.20171224221236.96"><vh>double la</vh></v>
</v>
<v t="leo1.20171224221236.97"><vh>void SBspUv::ScalePoints</vh></v>
<v t="leo1.20171224221236.98"><vh>void SBspUv::InsertEdge</vh>
<v t="leo1.20171224221236.99"><vh>double dea</vh></v>
</v>
</v>
<v t="leo1.20171224221236.100"><vh>@@clean curve.cpp</vh>
<v t="leo1.20171224221236.101"><vh>void SBezier::Reverse</vh></v>
<v t="leo1.20171224221236.102"><vh>void SBezier::ScaleSelfBy</vh></v>
<v t="leo1.20171224221236.103"><vh>void SBezier::GetBoundingProjd</vh></v>
<v t="leo1.20171224221236.104"><vh>bool SBezier::IsInPlane</vh></v>
<v t="leo1.20171224221236.105"><vh>bool SBezier::IsCircle</vh>
<v t="leo1.20171224221236.106"><vh>double rd0</vh></v>
<v t="leo1.20171224221236.107"><vh>double thetaa</vh></v>
</v>
<v t="leo1.20171224221236.108"><vh>bool SBezier::IsRational</vh></v>
<v t="leo1.20171224221236.109"><vh>bool SBezier::Equals</vh></v>
<v t="leo1.20171224221236.110"><vh>void SBezierList::Clear</vh></v>
<v t="leo1.20171224221236.111"><vh>void SBezierList::ScaleSelfBy</vh></v>
<v t="leo1.20171224221236.112"><vh>void SBezierList::CullIdenticalBeziers</vh></v>
<v t="leo1.20171224221236.113"><vh>void SBezierList::AllIntersectionsWith</vh></v>
<v t="leo1.20171224221236.114"><vh>void SBezier::AllIntersectionsWith</vh></v>
<v t="leo1.20171224221236.115"><vh>bool SBezierList::GetPlaneContainingBeziers</vh></v>
<v t="leo1.20171224221236.116"><vh>void SBezierLoop::Reverse</vh></v>
<v t="leo1.20171224221236.117"><vh>void SBezierLoop::GetBoundingProjd</vh></v>
<v t="leo1.20171224221236.118"><vh>void SBezierLoop::MakePwlInto</vh></v>
<v t="leo1.20171224221236.119"><vh>bool SBezierLoop::IsClosed</vh></v>
<v t="leo1.20171224221236.120"><vh>double chordTol</vh></v>
<v t="leo1.20171224221236.121"><vh>void SBezierLoopSet::GetBoundingProjd</vh></v>
<v t="leo1.20171224221236.122"><vh>void SBezierLoopSet::MakePwlInto</vh></v>
<v t="leo1.20171224221236.123"><vh>void SBezierLoopSet::Clear</vh></v>
<v t="leo1.20171224221236.124"><vh>void SBezierLoopSetSet::FindOuterFacesFrom</vh></v>
<v t="leo1.20171224221236.125"><vh>void SBezierLoopSetSet::AddOpenPath</vh></v>
<v t="leo1.20171224221236.126"><vh>void SBezierLoopSetSet::Clear</vh></v>
<v t="leo1.20171224221236.127"><vh>void SCurve::Clear</vh></v>
<v t="leo1.20171224221236.128"><vh>void SCurve::RemoveShortSegments</vh></v>
</v>
<v t="leo1.20171224221236.129"><vh>@@clean merge.cpp</vh>
<v t="leo1.20171224221236.130"><vh>void SShell::MergeCoincidentSurfaces</vh>
<v t="leo1.20171224221236.131"><vh>double umax</vh></v>
</v>
</v>
<v t="leo1.20171224221236.132"><vh>@@clean ratpoly.cpp</vh>
<v t="leo1.20171224221236.133"><vh>void SBezier::ClosestPointTo</vh></v>
<v t="leo1.20171224221236.134"><vh>bool SBezier::PointOnThisAndCurve</vh></v>
<v t="leo1.20171224221236.135"><vh>void SBezier::SplitAt</vh></v>
<v t="leo1.20171224221236.136"><vh>void SBezier::MakePwlInto</vh></v>
<v t="leo1.20171224221236.137"><vh>void SBezier::MakePwlInto</vh></v>
<v t="leo1.20171224221236.138"><vh>void SBezier::MakePwlInto</vh></v>
<v t="leo1.20171224221236.139"><vh>void SBezier::MakePwlInto</vh></v>
<v t="leo1.20171224221236.140"><vh>void SBezier::MakePwlWorker</vh></v>
<v t="leo1.20171224221236.141"><vh>void SBezier::MakePwlInitialWorker</vh>
<v t="leo1.20171224221236.142"><vh>double d</vh></v>
</v>
<v t="leo1.20171224221236.143"><vh>void SBezier::MakeNonrationalCubicInto</vh></v>
<v t="leo1.20171224221236.144"><vh>void SSurface::TangentsAt</vh>
<v t="leo1.20171224221236.145"><vh>double den</vh></v>
</v>
<v t="leo1.20171224221236.146"><vh>void SSurface::ClosestPointTo</vh></v>
<v t="leo1.20171224221236.147"><vh>void SSurface::ClosestPointTo</vh></v>
<v t="leo1.20171224221236.148"><vh>bool SSurface::ClosestPointNewton</vh></v>
<v t="leo1.20171224221236.149"><vh>bool SSurface::PointIntersectingLine</vh></v>
<v t="leo1.20171224221236.150"><vh>void SSurface::PointOnSurfaces</vh></v>
</v>
<v t="leo1.20171224221236.151"><vh>@@clean raycast.cpp</vh>
<v t="leo1.20171224221236.152"><vh>double mag</vh></v>
<v t="leo1.20171224221236.153"><vh>void SSurface::WeightControlPoints</vh></v>
<v t="leo1.20171224221236.154"><vh>void SSurface::UnWeightControlPoints</vh></v>
<v t="leo1.20171224221236.155"><vh>void SSurface::CopyRowOrCol</vh></v>
<v t="leo1.20171224221236.156"><vh>void SSurface::BlendRowOrCol</vh></v>
<v t="leo1.20171224221236.157"><vh>void SSurface::SplitInHalf</vh></v>
<v t="leo1.20171224221236.158"><vh>void SSurface::AllPointsIntersectingUntrimmed</vh></v>
<v t="leo1.20171224221236.159"><vh>void SSurface::AllPointsIntersecting</vh>
<v t="leo1.20171224221236.160"><vh>double dp</vh></v>
</v>
<v t="leo1.20171224221236.161"><vh>void SShell::AllPointsIntersecting</vh></v>
<v t="leo1.20171224221236.162"><vh>bool SShell::ClassifyEdge</vh>
<v t="leo1.20171224221236.163"><vh>int er_edge_n</vh></v>
</v>
</v>
<v t="leo1.20171224221236.164"><vh>@@clean surface.cpp</vh>
<v t="leo1.20171224221236.165"><vh>bool SSurface::IsExtrusion</vh></v>
<v t="leo1.20171224221236.166"><vh>bool SSurface::IsCylinder</vh></v>
<v t="leo1.20171224221236.167"><vh>double thetas</vh></v>
<v t="leo1.20171224221236.168"><vh>bool includingTrims</vh></v>
<v t="leo1.20171224221236.169"><vh>void SSurface::GetAxisAlignedBounding</vh></v>
<v t="leo1.20171224221236.170"><vh>bool SSurface::LineEntirelyOutsideBbox</vh></v>
<v t="leo1.20171224221236.171"><vh>void SSurface::MakeTrimEdgesInto</vh></v>
<v t="leo1.20171224221236.172"><vh>void SSurface::MakeEdgesInto</vh></v>
<v t="leo1.20171224221236.173"><vh>void SSurface::MakeSectionEdgesInto</vh></v>
<v t="leo1.20171224221237.1"><vh>void SSurface::TriangulateInto</vh></v>
<v t="leo1.20171224221237.2"><vh>void SSurface::Reverse</vh></v>
<v t="leo1.20171224221237.3"><vh>void SSurface::ScaleSelfBy</vh></v>
<v t="leo1.20171224221237.4"><vh>void SSurface::Clear</vh></v>
<v t="leo1.20171224221237.5"><vh>typedef struct</vh></v>
<v t="leo1.20171224221237.6"><vh>void SShell::MakeFromExtrusionOf</vh></v>
<v t="leo1.20171224221237.7"><vh>typedef struct</vh></v>
<v t="leo1.20171224221237.8"><vh>void SShell::MakeFromRevolutionOf</vh></v>
<v t="leo1.20171224221237.9"><vh>void SShell::MakeFromCopyOf</vh></v>
<v t="leo1.20171224221237.10"><vh>void SShell::MakeFromTransformationOf</vh></v>
<v t="leo1.20171224221237.11"><vh>void SShell::MakeEdgesInto</vh></v>
<v t="leo1.20171224221237.12"><vh>void SShell::MakeSectionEdgesInto</vh></v>
<v t="leo1.20171224221237.13"><vh>void SShell::TriangulateInto</vh></v>
<v t="leo1.20171224221237.14"><vh>bool SShell::IsEmpty</vh></v>
<v t="leo1.20171224221237.15"><vh>void SShell::Clear</vh></v>
</v>
<v t="leo1.20171224221237.16"><vh>@@clean surfinter.cpp</vh>
<v t="leo1.20171224221237.17"><vh>void SSurface::AddExactIntersectionCurve</vh></v>
<v t="leo1.20171224221237.18"><vh>void SSurface::IntersectAgainst</vh>
<v t="leo1.20171224221237.19"><vh>bool isExtdt</vh></v>
</v>
<v t="leo1.20171224221237.20"><vh>bool SSurface::CoincidentWith</vh></v>
<v t="leo1.20171224221237.21"><vh>bool SSurface::CoincidentWithPlane</vh></v>
<v t="leo1.20171224221237.22"><vh>void SShell::MakeCoincidentEdgesInto</vh></v>
</v>
<v t="leo1.20171224221237.23"><vh>@@clean triangulate.cpp</vh>
<v t="leo1.20171224221237.24"><vh>void SPolygon::UvTriangulateInto</vh></v>
<v t="leo1.20171224221237.25"><vh>bool SContour::BridgeToContour</vh></v>
<v t="leo1.20171224221237.26"><vh>bool SContour::IsEar</vh>
<v t="leo1.20171224221237.27"><vh>int ap</vh></v>
</v>
<v t="leo1.20171224221237.28"><vh>void SContour::ClipEarInto</vh>
<v t="leo1.20171224221237.29"><vh>int ap</vh></v>
</v>
<v t="leo1.20171224221237.30"><vh>void SContour::UvTriangulateInto</vh></v>
<v t="leo1.20171224221237.31"><vh>void SSurface::MakeTriangulationGridInto</vh></v>
<v t="leo1.20171224221237.32"><vh>void SPolygon::UvGridTriangulateInto</vh></v>
<v t="leo1.20171224221237.33"><vh>void SPolygon::TriangulateInto</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo1.20171224221534.1"><vh>import src h</vh>
<v t="leo1.20171224221604.1" a="E"><vh>imported files</vh>
<v t="leo1.20171224221636.1"><vh>import log</vh></v>
<v t="leo1.20171224221605.1" a="E"><vh>@path ./../src</vh>
<v t="leo1.20171224221605.2"><vh>@@clean dsc.h</vh>
<v t="leo1.20171224221605.3"><vh>class Quaternion</vh></v>
<v t="leo1.20171224221605.4"><vh>class Vector</vh></v>
<v t="leo1.20171224221605.5"><vh>class Vector4</vh></v>
<v t="leo1.20171224221605.6"><vh>class Point2d</vh></v>
<v t="leo1.20171224221605.7"><vh>class List</vh>
<v t="leo1.20171224221605.8"><vh>void ReserveMore</vh></v>
<v t="leo1.20171224221605.9"><vh>void AllocForOneMore</vh></v>
<v t="leo1.20171224221605.10"><vh>void Add</vh></v>
<v t="leo1.20171224221605.11"><vh>void AddToBeginning</vh></v>
<v t="leo1.20171224221605.12"><vh>const T</vh></v>
<v t="leo1.20171224221605.13"><vh>const T</vh></v>
<v t="leo1.20171224221605.14"><vh>void ClearTags</vh></v>
<v t="leo1.20171224221605.15"><vh>void Clear</vh></v>
<v t="leo1.20171224221605.16"><vh>void RemoveTagged</vh></v>
<v t="leo1.20171224221605.17"><vh>void RemoveLast</vh></v>
<v t="leo1.20171224221605.18"><vh>void Reverse</vh></v>
</v>
<v t="leo1.20171224221605.19"><vh>class IdList</vh>
<v t="leo1.20171224221605.20"><vh>void ReserveMore</vh></v>
<v t="leo1.20171224221605.21"><vh>void Add</vh></v>
<v t="leo1.20171224221605.22"><vh>int IndexOf</vh></v>
<v t="leo1.20171224221605.23"><vh>void ClearTags</vh></v>
<v t="leo1.20171224221605.24"><vh>void Tag</vh></v>
<v t="leo1.20171224221605.25"><vh>void RemoveTagged</vh></v>
<v t="leo1.20171224221605.26"><vh>void RemoveById</vh></v>
<v t="leo1.20171224221605.27"><vh>void MoveSelfInto</vh></v>
<v t="leo1.20171224221605.28"><vh>void DeepCopyInto</vh></v>
<v t="leo1.20171224221605.29"><vh>void Clear</vh></v>
</v>
<v t="leo1.20171224221605.30"><vh>class BandedMatrix</vh></v>
<v t="leo1.20171224221605.31"><vh>class RgbaColor</vh>
<v t="leo1.20171224221605.32"><vh>bool Equals</vh></v>
<v t="leo1.20171224221605.33"><vh>static RgbaColor</vh></v>
<v t="leo1.20171224221605.34"><vh>static RgbaColor</vh></v>
<v t="leo1.20171224221605.35"><vh>static RgbaColor</vh></v>
<v t="leo1.20171224221605.36"><vh>static RgbaColor</vh></v>
</v>
<v t="leo1.20171224221605.37"><vh>bool operator</vh></v>
<v t="leo1.20171224221605.38"><vh>class BBox</vh></v>
</v>
<v t="leo1.20171224221605.39"><vh>@@clean expr.h</vh>
<v t="leo1.20171224221605.40"><vh>class Expr</vh></v>
<v t="leo1.20171224221605.41"><vh>class ExprVector</vh></v>
<v t="leo1.20171224221605.42"><vh>class ExprQuaternion</vh></v>
</v>
<v t="leo1.20171224221605.43"><vh>@@clean polygon.h</vh>
<v t="leo1.20171224221605.44"><vh>class SEdge</vh></v>
<v t="leo1.20171224221605.45"><vh>class SEdgeList</vh></v>
<v t="leo1.20171224221605.46"><vh>class SEdgeLl</vh></v>
<v t="leo1.20171224221605.47"><vh>class SKdNodeEdges</vh>
<v t="leo1.20171224221605.48"><vh>int AnyEdgeCrossings</vh></v>
</v>
<v t="leo1.20171224221605.49"><vh>class SPointList</vh></v>
<v t="leo1.20171224221605.50"><vh>class SContour</vh></v>
<v t="leo1.20171224221605.51"><vh>typedef struct</vh></v>
<v t="leo1.20171224221605.52"><vh>class SPolygon</vh></v>
<v t="leo1.20171224221605.53"><vh>class STriangle</vh>
<v t="leo1.20171224221605.54"><vh>bool Raytrace</vh></v>
<v t="leo1.20171224221605.55"><vh>static SBsp2</vh></v>
<v t="leo1.20171224221605.56"><vh>void InsertConvexHow</vh></v>
</v>
<v t="leo1.20171224221605.57"><vh>class STriangleLl</vh></v>
<v t="leo1.20171224221605.58"><vh>class SOutline</vh></v>
<v t="leo1.20171224221605.59"><vh>class SOutlineList</vh></v>
<v t="leo1.20171224221605.60"><vh>class SKdNode</vh>
<v t="leo1.20171224221605.61"><vh>class PolylineBuilder</vh></v>
</v>
</v>
<v t="leo1.20171224221605.62"><vh>@@clean resource.h</vh>
<v t="leo1.20171224221605.63"><vh>class Pixmap</vh></v>
<v t="leo1.20171224221605.64"><vh>class BitmapFont</vh>
<v t="leo1.20171224221605.65"><vh>void LocateGlyph</vh></v>
</v>
</v>
<v t="leo1.20171224221605.66"><vh>@@clean sketch.h</vh>
<v t="leo1.20171224221605.67"><vh>class hGroup</vh></v>
<v t="leo1.20171224221605.68"><vh>class hRequest</vh></v>
<v t="leo1.20171224221605.69"><vh>class hEntity</vh></v>
<v t="leo1.20171224221605.70"><vh>class hParam</vh></v>
<v t="leo1.20171224221605.71"><vh>class hStyle</vh></v>
<v t="leo1.20171224221605.72"><vh>class EntityId</vh></v>
<v t="leo1.20171224221605.73"><vh>class EntityMap</vh>
<v t="leo1.20171224221605.74"><vh>void Clear</vh></v>
</v>
<v t="leo1.20171224221605.75"><vh>class Request</vh>
<v t="leo1.20171224221606.1"><vh>void Clear</vh></v>
<v t="leo1.20171224221606.2"><vh>void Clear</vh></v>
<v t="leo1.20171224221606.3"><vh>void Clear</vh></v>
</v>
<v t="leo1.20171224221606.4"><vh>class EntReqTable</vh>
<v t="leo1.20171224221606.5"><vh>bool GetRequestInfo</vh></v>
<v t="leo1.20171224221606.6"><vh>void Clear</vh></v>
</v>
<v t="leo1.20171224221606.7"><vh>class ConstraintBase</vh>
<v t="leo1.20171224221606.8"><vh>void Clear</vh></v>
<v t="leo1.20171224221606.9"><vh>static hConstraint</vh></v>
</v>
<v t="leo1.20171224221606.10"><vh>class Equation</vh>
<v t="leo1.20171224221606.11"><vh>void Clear</vh></v>
<v t="leo1.20171224221606.12"><vh>typedef struct</vh></v>
</v>
<v t="leo1.20171224221606.13"><vh>class ClipboardRequest</vh></v>
</v>
<v t="leo1.20171224221606.14" a="E"><vh>@@clean solvespace.h</vh>
<v t="leo1.20171224221606.15"><vh>void assert_failure</vh></v>
<v t="leo1.20171224221606.16"><vh>class utf8_iterator</vh></v>
<v t="leo1.20171224221606.17"><vh>class ReadUTF8</vh></v>
<v t="leo1.20171224221606.18"><vh>class System</vh></v>
<v t="leo1.20171224221606.19"><vh>class StepFileWriter</vh></v>
<v t="leo1.20171224221606.20"><vh>class VectorFileWriter</vh></v>
<v t="leo1.20171224221606.21"><vh>class DxfFileWriter</vh></v>
<v t="leo1.20171224221606.22"><vh>class EpsFileWriter</vh>
<v t="leo1.20171224221606.23"><vh>class PdfFileWriter</vh>
<v t="leo1.20171224221606.24"><vh>class SvgFileWriter</vh>
<v t="leo1.20171224221606.25"><vh>class HpglFileWriter</vh>
<v t="leo1.20171224221606.26"><vh>class Step2dFileWriter</vh>
<v t="leo1.20171224221606.27"><vh>class GCodeFileWriter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo1.20171224221606.28"><vh>class Sketch</vh></v>
<v t="leo1.20171224221606.29"><vh>class SolveSpaceUI</vh>
<v t="leo1.20171224221606.30"><vh>typedef struct</vh>
<v t="leo1.20171224221606.31"><vh>void Clear</vh></v>
</v>
<v t="leo1.20171224221606.32"><vh>typedef struct</vh></v>
<v t="leo1.20171224221606.33"><vh>typedef struct</vh></v>
<v t="leo1.20171224221606.34"><vh>class Clipboard</vh></v>
</v>
</v>
<v t="leo1.20171224221606.35"><vh>@@clean ttf.h</vh>
<v t="leo1.20171224221606.36"><vh>class TtfFont</vh>
<v t="leo1.20171224221606.37"><vh>void PlotString</vh></v>
</v>
</v>
<v t="leo1.20171224221606.38"><vh>@@clean ui.h</vh>
<v t="leo1.20171224221606.39"><vh>class Locale</vh></v>
<v t="leo1.20171224221606.40"><vh>bool operator</vh></v>
<v t="leo1.20171224221606.41"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.42"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.43"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.44"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.45"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.46"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.47"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.48"><vh>const FileFilter</vh></v>
<v t="leo1.20171224221606.49"><vh>class TextWindow</vh>
<v t="leo1.20171224221606.50"><vh>typedef struct</vh></v>
<v t="leo1.20171224221606.51"><vh>typedef struct</vh></v>
</v>
<v t="leo1.20171224221606.52"><vh>class GraphicsWindow</vh>
<v t="leo1.20171224221606.53"><vh>typedef struct</vh></v>
<v t="leo1.20171224221606.54"><vh>class ParametricCurve</vh></v>
<v t="leo1.20171224221606.55"><vh>class Selection</vh></v>
<v t="leo1.20171224221606.56"><vh>class Hover</vh></v>
</v>
</v>
<v t="leo1.20171224221606.57"><vh>@path platform</vh>
<v t="leo1.20171224221606.58"><vh>@@clean platform.h</vh>
<v t="leo1.20171224221606.59"><vh>class Path</vh></v>
</v>
</v>
<v t="leo1.20171224221606.60"><vh>@path render</vh>
<v t="leo1.20171224221606.61"><vh>@@clean gl3shader.h</vh>
<v t="leo1.20171224221606.62"><vh>class Vector2f</vh></v>
<v t="leo1.20171224221606.63"><vh>class Vector3f</vh></v>
<v t="leo1.20171224221606.64"><vh>class Vector4f</vh></v>
<v t="leo1.20171224221606.65"><vh>class Shader</vh></v>
<v t="leo1.20171224221606.66"><vh>class MeshRenderer</vh></v>
<v t="leo1.20171224221606.67"><vh>class StippleAtlas</vh></v>
<v t="leo1.20171224221606.68"><vh>class EdgeRenderer</vh></v>
<v t="leo1.20171224221606.69"><vh>class OutlineRenderer</vh></v>
<v t="leo1.20171224221606.70"><vh>class SIndexedMesh</vh>
<v t="leo1.20171224221606.71"><vh>void AddPixmap</vh></v>
</v>
</v>
<v t="leo1.20171224221606.72"><vh>@@clean render.h</vh>
<v t="leo1.20171224221606.73"><vh>class Camera</vh></v>
<v t="leo1.20171224221606.74"><vh>class Lighting</vh></v>
<v t="leo1.20171224221606.75"><vh>class Canvas</vh>
<v t="leo1.20171224221606.76"><vh>class hStroke</vh></v>
<v t="leo1.20171224221606.77"><vh>class hFill</vh></v>
<v t="leo1.20171224221606.78"><vh>class Stroke</vh></v>
<v t="leo1.20171224221606.79"><vh>class Fill</vh></v>
<v t="leo1.20171224221606.80"><vh>const Vector</vh></v>
</v>
<v t="leo1.20171224221606.81"><vh>class BatchCanvas</vh></v>
<v t="leo1.20171224221606.82"><vh>class UiCanvas</vh></v>
<v t="leo1.20171224221606.83"><vh>class ObjectPicker</vh>
<v t="leo1.20171224221606.84"><vh>class SurfaceRenderer</vh></v>
</v>
<v t="leo1.20171224221606.85"><vh>class CairoRenderer</vh></v>
<v t="leo1.20171224221606.86"><vh>class GlOffscreen</vh></v>
</v>
</v>
<v t="leo1.20171224221606.87"><vh>@path srf</vh>
<v t="leo1.20171224221606.88"><vh>@@clean surface.h</vh>
<v t="leo1.20171224221606.89"><vh>class SBspUv</vh></v>
<v t="leo1.20171224221606.90"><vh>class hSSurface</vh></v>
<v t="leo1.20171224221606.91"><vh>class hSCurve</vh></v>
<v t="leo1.20171224221606.92"><vh>class SBezier</vh></v>
<v t="leo1.20171224221606.93"><vh>class SBezierList</vh>
<v t="leo1.20171224221606.94"><vh>bool GetPlaneContainingBeziers</vh></v>
<v t="leo1.20171224221606.95"><vh>static SBezierLoop</vh></v>
<v t="leo1.20171224221606.96"><vh>class SBezierLoopSetSet</vh></v>
</v>
<v t="leo1.20171224221606.97"><vh>class SCurve</vh>
<v t="leo1.20171224221606.98"><vh>class STrimBy</vh></v>
</v>
<v t="leo1.20171224221606.99"><vh>class SInter</vh></v>
<v t="leo1.20171224221606.100"><vh>class SSurface</vh>
<v t="leo1.20171224221606.101"><vh>void IntersectAgainst</vh></v>
<v t="leo1.20171224221606.102"><vh>bool IsCylinder</vh></v>
</v>
<v t="leo1.20171224221607.1"><vh>class SShell</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo1.20171224004519.1"></t>
<t tx="leo1.20171224004528.1"></t>
<t tx="leo1.20171224004528.2">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /*  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /*  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /*  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /*  Minibuffer  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /*  */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo1.20171224004528.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo1.20171224004715.1">git clone https://github.com/solvespace/solvespace.git solvespack

cd solvespack

git submodule update --init</t>
<t tx="leo1.20171224010119.1">@language python
import os, errno

try:
    os.makedirs("./../build/")
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

# cd into build
os.chdir("./../build/")
os.system('cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release')
g.es("cmake complete")
</t>
<t tx="leo1.20171224010128.1">@language python
import os
os.chdir("./../build")
os.system("mingw32-make")
g.es("mingw32-make done")</t>
<t tx="leo1.20171224010556.1">#[[
    list(APPEND ANGLE_DEFINITIONS
        "-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")
]]

After compiled, need libwinpthread-1.dll, d3dcompiler_43.dll and solvespace.exe to run.</t>
<t tx="leo1.20171224082621.1"></t>
<t tx="leo1.20171224221039.1">'''Recursively import all ['.cpp'] files in a directory and clean the result.'''

# Latest change: use c.recursiveImport.

c.recursiveImport(
    dir_ = r'./../src',
    kind = '@clean',
    safe_at_file = True,
    theTypes = ['.cpp']
)</t>
<t tx="leo1.20171224221219.1"></t>
<t tx="leo1.20171224221220.1"></t>
<t tx="leo1.20171224221220.10">void AllocQuad() {
    vpos = (Vector *)AllocTemporary(sizeof(Vector) * 4);
}

</t>
<t tx="leo1.20171224221220.11">void AllocClassify(size_t size) {
    // Allocate a one big piece is faster than a small ones.
    isPos = (bool *)AllocTemporary(sizeof(bool) * size * 3);
    isNeg = &amp;isPos[size];
    isOn  = &amp;isNeg[size];
}

</t>
<t tx="leo1.20171224221220.12">void AllocVertices(size_t size) {
    vpos = (Vector *)AllocTemporary(sizeof(Vector) * size * 2);
    vneg = &amp;vpos[size];
}

</t>
<t tx="leo1.20171224221220.13">void ClassifyTriangle(STriangle *tri, SBsp3 *node) {
    tr   = tri;
    bsp  = node;
    onc  = 0;
    posc = 0;
    negc = 0;

    AllocClassify(3);

    double dt[3] = { (tr-&gt;a).Dot(bsp-&gt;n), (tr-&gt;b).Dot(bsp-&gt;n), (tr-&gt;c).Dot(bsp-&gt;n) };
    double d = bsp-&gt;d;
    // Count vertices in the plane
    for(int i = 0; i &lt; 3; i++) {
        if(dt[i] &gt; d + LENGTH_EPS) {
            posc++;
            isPos[i] = true;
        } else if(dt[i] &lt; d - LENGTH_EPS) {
            negc++;
            isNeg[i] = true;
        } else {
            onc++;
            isOn[i] = true;
        }
    }
}

</t>
<t tx="leo1.20171224221220.14">bool ClassifyConvex(Vector *vertex, size_t cnt, SBsp3 *node, bool insertEdge) {
    bsp  = node;
    onc  = 0;
    posc = 0;
    negc = 0;

    AllocClassify(cnt);
    AllocOn();

    for(size_t i = 0; i &lt; cnt; i++) {
        double dt = bsp-&gt;n.Dot(vertex[i]);
        isPos[i] = isNeg[i] = isOn[i] = false;
        if(fabs(dt - bsp-&gt;d) &lt; LENGTH_EPS) {
            isOn[i] = true;
            if(onc &lt; 2) {
                on[onc] = vertex[i];
            }
            onc++;
        } else if(dt &gt; bsp-&gt;d) {
            isPos[i] = true;
            posc++;
        } else {
            isNeg[i] = true;
            negc++;
        }
    }

    if(onc != 2 &amp;&amp; onc != 1 &amp;&amp; onc != 0) return false;
    if(onc == 2) {
        if(insertEdge) {
            Vector e01 = (vertex[1]).Minus(vertex[0]);
            Vector e12 = (vertex[2]).Minus(vertex[1]);
            Vector out = e01.Cross(e12);
            SEdge se = SEdge::From(on[0], on[1]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        }
    }
    return true;
}

</t>
<t tx="leo1.20171224221220.15">bool ClassifyConvexVertices(Vector *vertex, size_t cnt, bool insertEdges) {
    Vector inter[2];
    int inters = 0;

    npos = 0;
    nneg = 0;

    // Enlarge vertices list to consider two intersections
    AllocVertices(cnt + 4);

    for(size_t i = 0; i &lt; cnt; i++) {
        size_t ip = WRAP((i + 1), cnt);

        if(isPos[i]) {
            vpos[npos++] = vertex[i];
        }
        if(isNeg[i]) {
            vneg[nneg++] = vertex[i];
        }
        if(isOn[i]) {
            vneg[nneg++] = vertex[i];
            vpos[npos++] = vertex[i];
        }
        if((isPos[i] &amp;&amp; isNeg[ip]) || (isNeg[i] &amp;&amp; isPos[ip])) {
            Vector vi = bsp-&gt;IntersectionWith(vertex[i], vertex[ip]);
            vpos[npos++] = vi;
            vneg[nneg++] = vi;

            if(inters &gt;= 2) return false; // triangulate: XXX shouldn't happen but does
            inter[inters++] = vi;
        }
    }
    ssassert(npos &lt;= cnt + 1 &amp;&amp; nneg &lt;= cnt + 1, "Impossible");

    if(insertEdges) {
        Vector e01 = (vertex[1]).Minus(vertex[0]);
        Vector e12 = (vertex[2]).Minus(vertex[1]);
        Vector out = e01.Cross(e12);
        if(inters == 2) {
            SEdge se = SEdge::From(inter[0], inter[1]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        } else if(inters == 1 &amp;&amp; onc == 1) {
            SEdge se = SEdge::From(inter[0], on[0]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        } else if(inters == 0 &amp;&amp; onc == 2) {
            // We already handled this on-plane existing edge
        } else {
            return false; //triangulate;
        }
    }
    if(nneg &lt; 3 || npos &lt; 3) return false; // triangulate; // XXX

    return true;
}

</t>
<t tx="leo1.20171224221220.16">void ProcessEdgeInsert() {
    ssassert(onc == 2, "Impossible");

    Vector a, b;
    if     (!isOn[0]) { a = tr-&gt;b; b = tr-&gt;c; }
    else if(!isOn[1]) { a = tr-&gt;c; b = tr-&gt;a; }
    else if(!isOn[2]) { a = tr-&gt;a; b = tr-&gt;b; }
    else ssassert(false, "Impossible");

    SEdge se = SEdge::From(a, b);
    bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, tr-&gt;Normal());
}

</t>
<t tx="leo1.20171224221220.17">bool SplitIntoTwoTriangles(bool insertEdge) {
    ssassert(posc == 1 &amp;&amp; negc == 1 &amp;&amp; onc == 1, "Impossible");

    bool bpos;
    Vector a, b, c;

    // Standardize so that a is on the plane
    if       (isOn[0]) { a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c; bpos = isPos[1];
    } else if(isOn[1]) { a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a; bpos = isPos[2];
    } else if(isOn[2]) { a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b; bpos = isPos[0];
    } else ssassert(false, "Impossible");

    AllocTriangles();
    Vector bPc = bsp-&gt;IntersectionWith(b, c);
    *btri = STriangle::From(tr-&gt;meta, a, b, bPc);
    *ctri = STriangle::From(tr-&gt;meta, c, a, bPc);

    if(insertEdge) {
        SEdge se = SEdge::From(a, bPc);
        bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, tr-&gt;Normal());
    }

    return bpos;
}

</t>
<t tx="leo1.20171224221220.18">bool SplitIntoTwoPieces(bool insertEdge) {
    Vector a, b, c;
    if(posc == 2 &amp;&amp; negc == 1) {
        // Standardize so that a is on one side, and b and c are on the other.
        if       (isNeg[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isNeg[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isNeg[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else if(posc == 1 &amp;&amp; negc == 2) {
        if       (isPos[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isPos[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isPos[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else ssassert(false, "Impossible");

    Vector aPb = bsp-&gt;IntersectionWith(a, b);
    Vector cPa = bsp-&gt;IntersectionWith(c, a);
    AllocTriangle();
    AllocQuad();

    *btri = STriangle::From(tr-&gt;meta, a, aPb, cPa);

    vpos[0] = aPb;
    vpos[1] = b;
    vpos[2] = c;
    vpos[3] = cPa;

    if(insertEdge) {
        SEdge se = SEdge::From(aPb, cPa);
        bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, btri-&gt;Normal());
    }

    return posc == 2 &amp;&amp; negc == 1;
}

</t>
<t tx="leo1.20171224221220.19">static SBsp3 *Triangulate(SBsp3 *bsp, const STriMeta &amp;meta, Vector *vertex,
                          size_t cnt, SMesh *instead) {
    for(size_t i = 0; i &lt; cnt - 2; i++) {
        STriangle tr = STriangle::From(meta, vertex[0], vertex[i + 1], vertex[i + 2]);
        bsp = SBsp3::InsertOrCreate(bsp, &amp;tr, instead);
    }
    return bsp;
}
</t>
<t tx="leo1.20171224221220.2">//-----------------------------------------------------------------------------
// Binary space partitioning tree, used to represent a volume in 3-space
// bounded by a triangle mesh. These are used to compute Boolean operations
// on meshes. These aren't used for anything relating to an SShell of
// ratpoly surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

SBsp2 *SBsp2::Alloc() { return (SBsp2 *)AllocTemporary(sizeof(SBsp2)); }
SBsp3 *SBsp3::Alloc() { return (SBsp3 *)AllocTemporary(sizeof(SBsp3)); }

SBsp3 *SBsp3::FromMesh(const SMesh *m) {
    SBsp3 *bsp3 = NULL;
    int i;

    SMesh mc = {};
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        mc.AddTriangle(&amp;(m-&gt;l.elem[i]));
    }

    srand(0); // Let's be deterministic, at least!
    int n = mc.l.n;
    while(n &gt; 1) {
        int k = rand() % n;
        n--;
        swap(mc.l.elem[k], mc.l.elem[n]);
    }

    for(i = 0; i &lt; mc.l.n; i++) {
        bsp3 = InsertOrCreate(bsp3, &amp;(mc.l.elem[i]), NULL);
    }

    mc.Clear();
    return bsp3;
}

Vector SBsp3::IntersectionWith(Vector a, Vector b) const {
    double da = a.Dot(n) - d;
    double db = b.Dot(n) - d;
    ssassert(da*db &lt; 0, "Expected segment to intersect BSP node");

    double dab = (db - da);
    return (a.ScaledBy(db/dab)).Plus(b.ScaledBy(-da/dab));
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.20">void SBsp3::InsertConvexHow(BspClass how, STriMeta meta, Vector *vertex, size_t n,
                            SMesh *instead) {
    switch(how) {
        case BspClass::POS:
            if(pos) {
                pos = pos-&gt;InsertConvex(meta, vertex, n, instead);
                return;
            }
            break;

        case BspClass::NEG:
            if(neg) {
                neg = neg-&gt;InsertConvex(meta, vertex, n, instead);
                return;
            }
            break;

        default: ssassert(false, "Unexpected BSP insert type");
    }

    for(size_t i = 0; i &lt; n - 2; i++) {
        STriangle tr = STriangle::From(meta,
                                       vertex[0], vertex[i+1], vertex[i+2]);
        InsertHow(how, &amp;tr, instead);
    }
}

SBsp3 *SBsp3::InsertConvex(STriMeta meta, Vector *vertex, size_t cnt, SMesh *instead) {
    BspUtil *u = BspUtil::Alloc();
    if(u-&gt;ClassifyConvex(vertex, cnt, this, !instead)) {
        if(u-&gt;posc == 0) {
            InsertConvexHow(BspClass::NEG, meta, vertex, cnt, instead);
            return this;
        }
        if(u-&gt;negc == 0) {
            InsertConvexHow(BspClass::POS, meta, vertex, cnt, instead);
            return this;
        }

        if(u-&gt;ClassifyConvexVertices(vertex, cnt, !instead)) {
            InsertConvexHow(BspClass::NEG, meta, u-&gt;vneg, u-&gt;nneg, instead);
            InsertConvexHow(BspClass::POS, meta, u-&gt;vpos, u-&gt;npos, instead);
            return this;
        }
    }

    // We don't handle the special case for this; do it as triangles
    return BspUtil::Triangulate(this, meta, vertex, cnt, instead);
}

SBsp3 *SBsp3::InsertOrCreate(SBsp3 *where, STriangle *tr, SMesh *instead) {
    if(where == NULL) {
        if(instead) {
            if(instead-&gt;flipNormal) {
                instead-&gt;atLeastOneDiscarded = true;
            } else {
                instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
            }
            return NULL;
        }

        // Brand new node; so allocate for it, and fill us in.
        SBsp3 *r = Alloc();
        r-&gt;n = (tr-&gt;Normal()).WithMagnitude(1);
        r-&gt;d = (tr-&gt;a).Dot(r-&gt;n);
        r-&gt;tri = *tr;
        return r;
    }
    where-&gt;Insert(tr, instead);
    return where;
}

</t>
<t tx="leo1.20171224221220.21">void SBsp3::Insert(STriangle *tr, SMesh *instead) {
    BspUtil *u = BspUtil::Alloc();
    u-&gt;ClassifyTriangle(tr, this);

    // All vertices in-plane
    if(u-&gt;onc == 3) {
        InsertHow(BspClass::COPLANAR, tr, instead);
        return;
    }

    // No split required
    if(u-&gt;posc == 0 || u-&gt;negc == 0) {
        if(!instead &amp;&amp; u-&gt;onc == 2) {
            u-&gt;ProcessEdgeInsert();
        }

        if(u-&gt;posc &gt; 0) {
            InsertHow(BspClass::POS, tr, instead);
        } else {
            InsertHow(BspClass::NEG, tr, instead);
        }
        return;
    }

    // The polygon must be split into two triangles, one above, one below.
    if(u-&gt;posc == 1 &amp;&amp; u-&gt;negc == 1 &amp;&amp; u-&gt;onc == 1) {
        if(u-&gt;SplitIntoTwoTriangles(!instead)) {
            InsertHow(BspClass::POS, u-&gt;btri, instead);
            InsertHow(BspClass::NEG, u-&gt;ctri, instead);
        } else {
            InsertHow(BspClass::POS, u-&gt;ctri, instead);
            InsertHow(BspClass::NEG, u-&gt;btri, instead);
        }
        return;
    }

    // The polygon must be split into two pieces: a triangle and a quad.
    if(u-&gt;SplitIntoTwoPieces(!instead)) {
        InsertConvexHow(BspClass::POS, tr-&gt;meta, u-&gt;vpos, 4, instead);
        InsertHow(BspClass::NEG, u-&gt;btri, instead);
    } else {
        InsertConvexHow(BspClass::NEG, tr-&gt;meta, u-&gt;vpos, 4, instead);
        InsertHow(BspClass::POS, u-&gt;btri, instead);
    }
}

</t>
<t tx="leo1.20171224221220.22">void SBsp3::GenerateInPaintOrder(SMesh *m) const {
    // Doesn't matter which branch we take if the normal has zero z
    // component, so don't need a separate case for that.
    if(n.z &lt; 0) {
        if(pos) pos-&gt;GenerateInPaintOrder(m);
    } else {
        if(neg) neg-&gt;GenerateInPaintOrder(m);
    }

    const SBsp3 *flip = this;
    while(flip) {
        m-&gt;AddTriangle(&amp;(flip-&gt;tri));
        flip = flip-&gt;more;
    }

    if(n.z &lt; 0) {
        if(neg) neg-&gt;GenerateInPaintOrder(m);
    } else {
        if(pos) pos-&gt;GenerateInPaintOrder(m);
    }
}

/////////////////////////////////

Vector SBsp2::IntersectionWith(Vector a, Vector b) const {
    double da = a.Dot(no) - d;
    double db = b.Dot(no) - d;
    ssassert(da*db &lt; 0, "Expected segment to intersect BSP node");

    double dab = (db - da);
    return (a.ScaledBy(db/dab)).Plus(b.ScaledBy(-da/dab));
}

SBsp2 *SBsp2::InsertOrCreateEdge(SBsp2 *where, SEdge *nedge, Vector nnp, Vector out) {
    if(where == NULL) {
        // Brand new node; so allocate for it, and fill us in.
        SBsp2 *r = Alloc();
        r-&gt;np = nnp;
        r-&gt;no = ((r-&gt;np).Cross((nedge-&gt;b).Minus(nedge-&gt;a))).WithMagnitude(1);
        if(out.Dot(r-&gt;no) &lt; 0) {
            r-&gt;no = (r-&gt;no).ScaledBy(-1);
        }
        r-&gt;d = (nedge-&gt;a).Dot(r-&gt;no);
        r-&gt;edge = *nedge;
        return r;
    }
    where-&gt;InsertEdge(nedge, nnp, out);
    return where;
}

</t>
<t tx="leo1.20171224221220.23">void SBsp2::InsertEdge(SEdge *nedge, Vector nnp, Vector out) {

    double dt[2] = { (nedge-&gt;a).Dot(no), (nedge-&gt;b).Dot(no) };

    bool isPos[2] = {}, isNeg[2] = {}, isOn[2] = {};
    for(int i = 0; i &lt; 2; i++) {
        if(fabs(dt[i] - d) &lt; LENGTH_EPS) {
            isOn[i] = true;
        } else if(dt[i] &gt; d) {
            isPos[i] = true;
        } else {
            isNeg[i] = true;
        }
    }

    if((isPos[0] &amp;&amp; isPos[1])||(isPos[0] &amp;&amp; isOn[1])||(isOn[0] &amp;&amp; isPos[1])) {
        pos = InsertOrCreateEdge(pos, nedge, nnp, out);
        return;
    }
    if((isNeg[0] &amp;&amp; isNeg[1])||(isNeg[0] &amp;&amp; isOn[1])||(isOn[0] &amp;&amp; isNeg[1])) {
        neg = InsertOrCreateEdge(neg, nedge, nnp, out);
        return;
    }
    if(isOn[0] &amp;&amp; isOn[1]) {
        SBsp2 *m = Alloc();

        m-&gt;np = nnp;
        m-&gt;no = ((m-&gt;np).Cross((nedge-&gt;b).Minus(nedge-&gt;a))).WithMagnitude(1);
        if(out.Dot(m-&gt;no) &lt; 0) {
            m-&gt;no = (m-&gt;no).ScaledBy(-1);
        }
        m-&gt;d = (nedge-&gt;a).Dot(m-&gt;no);
        m-&gt;edge = *nedge;

        m-&gt;more = more;
        more = m;
        return;
    }
    if((isPos[0] &amp;&amp; isNeg[1]) || (isNeg[0] &amp;&amp; isPos[1])) {
        Vector aPb = IntersectionWith(nedge-&gt;a, nedge-&gt;b);

        SEdge ea = SEdge::From(nedge-&gt;a, aPb);
        SEdge eb = SEdge::From(aPb, nedge-&gt;b);

        if(isPos[0]) {
            pos = InsertOrCreateEdge(pos, &amp;ea, nnp, out);
            neg = InsertOrCreateEdge(neg, &amp;eb, nnp, out);
        } else {
            neg = InsertOrCreateEdge(neg, &amp;ea, nnp, out);
            pos = InsertOrCreateEdge(pos, &amp;eb, nnp, out);
        }
        return;
    }
    ssassert(false, "Impossible");
}

</t>
<t tx="leo1.20171224221220.24">void SBsp2::InsertTriangleHow(BspClass how, STriangle *tr, SMesh *m, SBsp3 *bsp3) {
    switch(how) {
        case BspClass::POS:
            if(pos) {
                pos-&gt;InsertTriangle(tr, m, bsp3);
            } else {
                bsp3-&gt;InsertInPlane(/*pos2=*/true, tr, m);
            }
            break;

        case BspClass::NEG:
            if(neg) {
                neg-&gt;InsertTriangle(tr, m, bsp3);
            } else {
                bsp3-&gt;InsertInPlane(/*pos2=*/false, tr, m);
            }
            break;

        default: ssassert(false, "Unexpected BSP insert type");
    }
}

</t>
<t tx="leo1.20171224221220.25">void SBsp2::InsertTriangle(STriangle *tr, SMesh *m, SBsp3 *bsp3) {
    double dt[3] = { (tr-&gt;a).Dot(no), (tr-&gt;b).Dot(no), (tr-&gt;c).Dot(no) };

    bool isPos[3] = {}, isNeg[3] = {}, isOn[3] = {};
    int inc = 0, posc = 0, negc = 0;
    for(int i = 0; i &lt; 3; i++) {
        if(fabs(dt[i] - d) &lt; LENGTH_EPS) {
            isOn[i] = true;
            inc++;
        } else if(dt[i] &gt; d) {
            isPos[i] = true;
            posc++;
        } else {
            isNeg[i] = true;
            negc++;
        }
    }

    if(inc == 3) {
        // All vertices on-line; so it's a degenerate triangle, to ignore.
        return;
    }

    // No split required
    if(posc == 0 || negc == 0) {
        if(posc &gt; 0) {
            InsertTriangleHow(BspClass::POS, tr, m, bsp3);
        } else {
            InsertTriangleHow(BspClass::NEG, tr, m, bsp3);
        }
        return;
    }

    // The polygon must be split into two pieces, one above, one below.
    Vector a, b, c;

    if(posc == 1 &amp;&amp; negc == 1 &amp;&amp; inc == 1) {
        bool bpos;
        // Standardize so that a is on the plane
        if       (isOn[0]) { a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c; bpos = isPos[1];
        } else if(isOn[1]) { a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a; bpos = isPos[2];
        } else if(isOn[2]) { a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b; bpos = isPos[0];
        } else ssassert(false, "Impossible");

        Vector bPc = IntersectionWith(b, c);
        STriangle btri = STriangle::From(tr-&gt;meta, a, b, bPc);
        STriangle ctri = STriangle::From(tr-&gt;meta, c, a, bPc);

        if(bpos) {
            InsertTriangleHow(BspClass::POS, &amp;btri, m, bsp3);
            InsertTriangleHow(BspClass::NEG, &amp;ctri, m, bsp3);
        } else {
            InsertTriangleHow(BspClass::POS, &amp;ctri, m, bsp3);
            InsertTriangleHow(BspClass::NEG, &amp;btri, m, bsp3);
        }

        return;
    }

    if(posc == 2 &amp;&amp; negc == 1) {
        // Standardize so that a is on one side, and b and c are on the other.
        if       (isNeg[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isNeg[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isNeg[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");

    } else if(posc == 1 &amp;&amp; negc == 2) {
        if       (isPos[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isPos[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isPos[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else ssassert(false, "Impossible");

    Vector aPb = IntersectionWith(a, b);
    Vector cPa = IntersectionWith(c, a);

    STriangle alone = STriangle::From(tr-&gt;meta, a,   aPb, cPa);
    STriangle quad1 = STriangle::From(tr-&gt;meta, aPb, b,   c  );
    STriangle quad2 = STriangle::From(tr-&gt;meta, aPb, c,   cPa);

    if(posc == 2 &amp;&amp; negc == 1) {
        InsertTriangleHow(BspClass::POS, &amp;quad1, m, bsp3);
        InsertTriangleHow(BspClass::POS, &amp;quad2, m, bsp3);
        InsertTriangleHow(BspClass::NEG, &amp;alone, m, bsp3);
    } else {
        InsertTriangleHow(BspClass::NEG, &amp;quad1, m, bsp3);
        InsertTriangleHow(BspClass::NEG, &amp;quad2, m, bsp3);
        InsertTriangleHow(BspClass::POS, &amp;alone, m, bsp3);
    }

    return;
}
</t>
<t tx="leo1.20171224221220.26">//-----------------------------------------------------------------------------
// The clipboard that gets manipulated when the user selects Edit -&gt; Cut,
// Copy, Paste, etc.; may contain entities only, not constraints.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.27">void SolveSpaceUI::Clipboard::Clear() {
    c.Clear();
    r.Clear();
}

</t>
<t tx="leo1.20171224221220.28">bool SolveSpaceUI::Clipboard::ContainsEntity(hEntity he) {
    if(he.v == Entity::NO_ENTITY.v)
        return true;

    ClipboardRequest *cr;
    for(cr = r.First(); cr; cr = r.NextAfter(cr)) {
        if(cr-&gt;oldEnt.v == he.v)
            return true;

        for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
            if(cr-&gt;oldPointEnt[i].v == he.v)
                return true;
        }
    }
    return false;
}

hEntity SolveSpaceUI::Clipboard::NewEntityFor(hEntity he) {
    if(he.v == Entity::NO_ENTITY.v)
        return Entity::NO_ENTITY;

    ClipboardRequest *cr;
    for(cr = r.First(); cr; cr = r.NextAfter(cr)) {
        if(cr-&gt;oldEnt.v == he.v)
            return cr-&gt;newReq.entity(0);

        for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
            if(cr-&gt;oldPointEnt[i].v == he.v)
                return cr-&gt;newReq.entity(1+i);
        }
    }

    ssassert(false, "Expected to find entity in some clipboard request");
}

</t>
<t tx="leo1.20171224221220.29">void GraphicsWindow::DeleteSelection() {
    SK.request.ClearTags();
    SK.constraint.ClearTags();
    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        hRequest r = { 0 };
        if(s-&gt;entity.v &amp;&amp; s-&gt;entity.isFromRequest()) {
            r = s-&gt;entity.request();
        }
        if(r.v &amp;&amp; !r.IsFromReferences()) {
            SK.request.Tag(r, 1);
        }
        if(s-&gt;constraint.v) {
            SK.constraint.Tag(s-&gt;constraint, 1);
        }
    }

    SK.constraint.RemoveTagged();
    // Note that this regenerates and clears the selection, to avoid
    // lingering references to the just-deleted items.
    DeleteTaggedRequests();
}

</t>
<t tx="leo1.20171224221220.3">void SBsp3::InsertInPlane(bool pos2, STriangle *tr, SMesh *m) {
    Vector tc = ((tr-&gt;a).Plus(tr-&gt;b).Plus(tr-&gt;c)).ScaledBy(1.0/3);

    bool onFace = false;
    bool sameNormal = false;
    double maxNormalMag = -1;

    Vector lln, trn = tr-&gt;Normal();

    SBsp3 *ll = this;
    while(ll) {
        if((ll-&gt;tri).ContainsPoint(tc)) {
            onFace = true;
            // If the mesh contains almost-zero-area triangles, and we're
            // just on the edge of one of those, then don't trust its normal.
            lln = (ll-&gt;tri).Normal();
            if(lln.Magnitude() &gt; maxNormalMag) {
                sameNormal = trn.Dot(lln) &gt; 0;
                maxNormalMag = lln.Magnitude();
            }
        }
        ll = ll-&gt;more;
    }

    if(m-&gt;flipNormal &amp;&amp; ((!pos2 &amp;&amp; !onFace) ||
                                   (onFace &amp;&amp; !sameNormal &amp;&amp; m-&gt;keepCoplanar)))
    {
        m-&gt;AddTriangle(tr-&gt;meta, tr-&gt;c, tr-&gt;b, tr-&gt;a);
    } else if(!(m-&gt;flipNormal) &amp;&amp; ((pos2 &amp;&amp; !onFace) ||
                                   (onFace &amp;&amp; sameNormal &amp;&amp; m-&gt;keepCoplanar)))
    {
        m-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
    } else {
        m-&gt;atLeastOneDiscarded = true;
    }
}

</t>
<t tx="leo1.20171224221220.30">void GraphicsWindow::CopySelection() {
    SS.clipboard.Clear();

    Entity *wrkpl  = SK.GetEntity(ActiveWorkplane());
    Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
    Vector u = wrkpln-&gt;NormalU(),
           v = wrkpln-&gt;NormalV(),
           n = wrkpln-&gt;NormalN(),
           p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();

    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;entity.v) continue;
        // Work only on entities that have requests that will generate them.
        Entity *e = SK.GetEntity(s-&gt;entity);
        bool hasDistance;
        Request::Type req;
        int pts;
        if(!EntReqTable::GetEntityInfo(e-&gt;type, e-&gt;extraPoints,
                &amp;req, &amp;pts, NULL, &amp;hasDistance))
        {
            if(!e-&gt;h.isFromRequest()) continue;
            Request *r = SK.GetRequest(e-&gt;h.request());
            if(r-&gt;type != Request::Type::DATUM_POINT) continue;
            EntReqTable::GetEntityInfo((Entity::Type)0, e-&gt;extraPoints,
                &amp;req, &amp;pts, NULL, &amp;hasDistance);
        }
        if(req == Request::Type::WORKPLANE) continue;

        ClipboardRequest cr = {};
        cr.type         = req;
        cr.extraPoints  = e-&gt;extraPoints;
        cr.style        = e-&gt;style;
        cr.str          = e-&gt;str;
        cr.font         = e-&gt;font;
        cr.file         = e-&gt;file;
        cr.construction = e-&gt;construction;
        {for(int i = 0; i &lt; pts; i++) {
            Vector pt;
            if(req == Request::Type::DATUM_POINT) {
                pt = e-&gt;PointGetNum();
            } else {
                pt = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
            }
            pt = pt.Minus(p);
            pt = pt.DotInToCsys(u, v, n);
            cr.point[i] = pt;
        }}
        if(hasDistance) {
            cr.distance = SK.GetEntity(e-&gt;distance)-&gt;DistanceGetNum();
        }

        cr.oldEnt = e-&gt;h;
        for(int i = 0; i &lt; pts; i++) {
            cr.oldPointEnt[i] = e-&gt;point[i];
        }

        SS.clipboard.r.Add(&amp;cr);
    }

    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;constraint.v) continue;

        Constraint *c = SK.GetConstraint(s-&gt;constraint);
        if(c-&gt;type == Constraint::Type::COMMENT) {
            SS.clipboard.c.Add(c);
        }
    }

    Constraint *c;
    for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
        if(!SS.clipboard.ContainsEntity(c-&gt;ptA) ||
           !SS.clipboard.ContainsEntity(c-&gt;ptB) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityA) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityB) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityC) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityD) ||
           c-&gt;type == Constraint::Type::COMMENT) {
            continue;
        }
        SS.clipboard.c.Add(c);
    }
}

</t>
<t tx="leo1.20171224221220.31">void GraphicsWindow::PasteClipboard(Vector trans, double theta, double scale) {
    Entity *wrkpl  = SK.GetEntity(ActiveWorkplane());
    Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
    Vector u = wrkpln-&gt;NormalU(),
           v = wrkpln-&gt;NormalV(),
           n = wrkpln-&gt;NormalN(),
           p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();

    // For arcs, reflection involves swapping the endpoints, or otherwise
    // the arc gets inverted.
    @others
}

</t>
<t tx="leo1.20171224221220.32">auto mapPoint = [scale](hEntity he) {
    if(he.v == 0) return he;

    if(scale &lt; 0) {
        hRequest hr = he.request();
        Request *r = SK.GetRequest(hr);
        if(r-&gt;type == Request::Type::ARC_OF_CIRCLE) {
            if(he.v == hr.entity(2).v) {
                return hr.entity(3);
            } else if(he.v == hr.entity(3).v) {
                return hr.entity(2);
            }
        }
    }
    return he;
};

ClipboardRequest *cr;
for(cr = SS.clipboard.r.First(); cr; cr = SS.clipboard.r.NextAfter(cr)) {
    hRequest hr = AddRequest(cr-&gt;type, /*rememberForUndo=*/false);
    Request *r = SK.GetRequest(hr);
    r-&gt;extraPoints  = cr-&gt;extraPoints;
    r-&gt;style        = cr-&gt;style;
    r-&gt;str          = cr-&gt;str;
    r-&gt;font         = cr-&gt;font;
    r-&gt;file         = cr-&gt;file;
    r-&gt;construction = cr-&gt;construction;
    // Need to regen to get the right number of points, if extraPoints
    // changed.
    SS.GenerateAll(SolveSpaceUI::Generate::REGEN);
    SS.MarkGroupDirty(r-&gt;group);
    bool hasDistance;
    int i, pts;
    EntReqTable::GetRequestInfo(r-&gt;type, r-&gt;extraPoints,
        NULL, &amp;pts, NULL, &amp;hasDistance);
    for(i = 0; i &lt; pts; i++) {
        Vector pt = cr-&gt;point[i];
        // We need the reflection to occur within the workplane; it may
        // otherwise correspond to just a rotation as projected.
        if(scale &lt; 0) {
            pt.x *= -1;
        }
        // Likewise the scale, which could otherwise take us out of the
        // workplane.
        pt = pt.ScaledBy(fabs(scale));
        pt = pt.ScaleOutOfCsys(u, v, Vector::From(0, 0, 0));
        pt = pt.Plus(p);
        pt = pt.RotatedAbout(n, theta);
        pt = pt.Plus(trans);
        int j = (r-&gt;type == Request::Type::DATUM_POINT) ? i : i + 1;
        SK.GetEntity(mapPoint(hr.entity(j)))-&gt;PointForceTo(pt);
    }
    if(hasDistance) {
        SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(
                                        cr-&gt;distance*fabs(scale));
    }

    cr-&gt;newReq = hr;
    MakeSelected(hr.entity(0));
    for(i = 0; i &lt; pts; i++) {
        int j = (r-&gt;type == Request::Type::DATUM_POINT) ? i : i + 1;
        MakeSelected(hr.entity(j));
    }
}

Constraint *cc;
for(cc = SS.clipboard.c.First(); cc; cc = SS.clipboard.c.NextAfter(cc)) {
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();
    c.type = cc-&gt;type;
    c.valA = cc-&gt;valA;
    c.ptA = SS.clipboard.NewEntityFor(mapPoint(cc-&gt;ptA));
    c.ptB = SS.clipboard.NewEntityFor(mapPoint(cc-&gt;ptB));
    c.entityA = SS.clipboard.NewEntityFor(cc-&gt;entityA);
    c.entityB = SS.clipboard.NewEntityFor(cc-&gt;entityB);
    c.entityC = SS.clipboard.NewEntityFor(cc-&gt;entityC);
    c.entityD = SS.clipboard.NewEntityFor(cc-&gt;entityD);
    c.other = cc-&gt;other;
    c.other2 = cc-&gt;other2;
    c.reference = cc-&gt;reference;
    c.disp = cc-&gt;disp;
    c.comment = cc-&gt;comment;
    switch(c.type) {
        case Constraint::Type::COMMENT:
            c.disp.offset = c.disp.offset.Plus(trans);
            break;

        case Constraint::Type::PT_PT_DISTANCE:
        case Constraint::Type::PT_LINE_DISTANCE:
        case Constraint::Type::PROJ_PT_DISTANCE:
        case Constraint::Type::DIAMETER:
            c.valA *= fabs(scale);
            break;

        default:
            break;
    }

    hConstraint hc = Constraint::AddConstraint(&amp;c, /*rememberForUndo=*/false);
    if(c.type == Constraint::Type::COMMENT) {
        MakeSelected(hc);
    }
}
</t>
<t tx="leo1.20171224221220.33">void GraphicsWindow::MenuClipboard(Command id) {
    if(id != Command::DELETE &amp;&amp; !SS.GW.LockedInWorkplane()) {
        Error(_("Cut, paste, and copy work only in a workplane.\n\n"
                "Activate one with Sketch -&gt; In Workplane."));
        return;
    }

    switch(id) {
        case Command::PASTE: {
            SS.UndoRemember();
            Vector trans = SS.GW.projRight.ScaledBy(80/SS.GW.scale).Plus(
                           SS.GW.projUp   .ScaledBy(40/SS.GW.scale));
            SS.GW.ClearSelection();
            SS.GW.PasteClipboard(trans, 0, 1);
            break;
        }

        case Command::PASTE_TRANSFORM: {
            if(SS.clipboard.r.n == 0) {
                Error(_("Clipboard is empty; nothing to paste."));
                break;
            }

            Entity *wrkpl  = SK.GetEntity(SS.GW.ActiveWorkplane());
            Vector p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();
            SS.TW.shown.paste.times  = 1;
            SS.TW.shown.paste.trans  = Vector::From(0, 0, 0);
            SS.TW.shown.paste.theta  = 0;
            SS.TW.shown.paste.origin = p;
            SS.TW.shown.paste.scale  = 1;
            SS.TW.GoToScreen(TextWindow::Screen::PASTE_TRANSFORMED);
            SS.GW.ForceTextWindowShown();
            SS.ScheduleShowTW();
            break;
        }

        case Command::COPY:
            SS.GW.CopySelection();
            SS.GW.ClearSelection();
            break;

        case Command::CUT:
            SS.UndoRemember();
            SS.GW.CopySelection();
            SS.GW.DeleteSelection();
            break;

        case Command::DELETE:
            SS.UndoRemember();
            SS.GW.DeleteSelection();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo1.20171224221220.34">bool TextWindow::EditControlDoneForPaste(const char *s) {
    Expr *e;
    switch(edit.meaning) {
        case Edit::PASTE_TIMES_REPEATED: {
            e = Expr::From(s, /*popUpError=*/true);
            if(!e) break;
            int v = (int)e-&gt;Eval();
            if(v &gt; 0) {
                shown.paste.times = v;
            } else {
                Error(_("Number of copies to paste must be at least one."));
            }
            break;
        }
        case Edit::PASTE_ANGLE:
            e = Expr::From(s, /*popUpError=*/true);
            if(!e) break;
            shown.paste.theta = WRAP_SYMMETRIC((e-&gt;Eval())*PI/180, 2*PI);
            break;

        case Edit::PASTE_SCALE: {
            e = Expr::From(s, /*popUpError=*/true);
            double v = e-&gt;Eval();
            if(fabs(v) &gt; 1e-6) {
                shown.paste.scale = v;
            } else {
                Error(_("Scale cannot be zero."));
            }
            break;
        }

        default:
            return false;
    }
    return true;
}

</t>
<t tx="leo1.20171224221220.35">void TextWindow::ScreenChangePasteTransformed(int link, uint32_t v) {
    switch(link) {
        case 't':
            SS.TW.ShowEditControl(13, ssprintf("%d", SS.TW.shown.paste.times));
            SS.TW.edit.meaning = Edit::PASTE_TIMES_REPEATED;
            break;

        case 'r':
            SS.TW.ShowEditControl(13, ssprintf("%.3f", SS.TW.shown.paste.theta*180/PI));
            SS.TW.edit.meaning = Edit::PASTE_ANGLE;
            break;

        case 's':
            SS.TW.ShowEditControl(13, ssprintf("%.3f", SS.TW.shown.paste.scale));
            SS.TW.edit.meaning = Edit::PASTE_SCALE;
            break;
    }
}

</t>
<t tx="leo1.20171224221220.36">void TextWindow::ScreenPasteTransformed(int link, uint32_t v) {
    SS.GW.GroupSelection();
    switch(link) {
        case 'o':
            if(SS.GW.gs.points == 1 &amp;&amp; SS.GW.gs.n == 1) {
                Entity *e = SK.GetEntity(SS.GW.gs.point[0]);
                SS.TW.shown.paste.origin = e-&gt;PointGetNum();
            } else {
                Error(_("Select one point to define origin of rotation."));
            }
            SS.GW.ClearSelection();
            break;

        case 't':
            if(SS.GW.gs.points == 2 &amp;&amp; SS.GW.gs.n == 2) {
                Entity *pa = SK.GetEntity(SS.GW.gs.point[0]),
                       *pb = SK.GetEntity(SS.GW.gs.point[1]);
                SS.TW.shown.paste.trans =
                    (pb-&gt;PointGetNum()).Minus(pa-&gt;PointGetNum());
            } else {
                Error(_("Select two points to define translation vector."));
            }
            SS.GW.ClearSelection();
            break;

        case 'g': {
            if(fabs(SS.TW.shown.paste.theta) &lt; LENGTH_EPS &amp;&amp;
               SS.TW.shown.paste.trans.Magnitude() &lt; LENGTH_EPS &amp;&amp;
               SS.TW.shown.paste.times != 1)
            {
                Message(_("Transformation is identity. So all copies will be "
                          "exactly on top of each other."));
            }
            if(SS.TW.shown.paste.times*SS.clipboard.r.n &gt; 100) {
                Error(_("Too many items to paste; split this into smaller "
                        "pastes."));
                break;
            }
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("No workplane active."));
                break;
            }
            Entity *wrkpl  = SK.GetEntity(SS.GW.ActiveWorkplane());
            Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
            Vector wn = wrkpln-&gt;NormalN();
            SS.UndoRemember();
            SS.GW.ClearSelection();
            for(int i = 0; i &lt; SS.TW.shown.paste.times; i++) {
                Vector trans  = SS.TW.shown.paste.trans.ScaledBy(i+1),
                       origin = SS.TW.shown.paste.origin;
                double theta = SS.TW.shown.paste.theta*(i+1);
                // desired transformation is Q*(p - o) + o + t =
                // Q*p - Q*o + o + t = Q*p + (t + o - Q*o)
                Vector t = trans.Plus(
                           origin).Minus(
                           origin.RotatedAbout(wn, theta));

                SS.GW.PasteClipboard(t, theta, SS.TW.shown.paste.scale);
            }
            SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
            SS.ScheduleShowTW();
            break;
        }
    }
}

</t>
<t tx="leo1.20171224221220.37">void TextWindow::ShowPasteTransformed() {
    Printf(true, "%FtPASTE TRANSFORMED%E");
    Printf(true,  "%Ba   %Ftrepeat%E    %d time%s %Fl%Lt%f[change]%E",
        shown.paste.times, (shown.paste.times == 1) ? "" : "s",
        &amp;ScreenChangePasteTransformed);
    Printf(false, "%Bd   %Ftrotate%E    %@ degrees %Fl%Lr%f[change]%E",
        shown.paste.theta*180/PI,
        &amp;ScreenChangePasteTransformed);
    Printf(false, "%Ba   %Ftabout pt%E  (%s, %s, %s) %Fl%Lo%f[use selected]%E",
            SS.MmToString(shown.paste.origin.x).c_str(),
            SS.MmToString(shown.paste.origin.y).c_str(),
            SS.MmToString(shown.paste.origin.z).c_str(),
        &amp;ScreenPasteTransformed);
    Printf(false, "%Bd   %Fttranslate%E (%s, %s, %s) %Fl%Lt%f[use selected]%E",
            SS.MmToString(shown.paste.trans.x).c_str(),
            SS.MmToString(shown.paste.trans.y).c_str(),
            SS.MmToString(shown.paste.trans.z).c_str(),
        &amp;ScreenPasteTransformed);
    Printf(false, "%Ba   %Ftscale%E     %@ %Fl%Ls%f[change]%E",
        shown.paste.scale,
        &amp;ScreenChangePasteTransformed);

    Printf(true, " %Fl%Lg%fpaste transformed now%E", &amp;ScreenPasteTransformed);

    Printf(true, "(or %Fl%Ll%fcancel operation%E)", &amp;ScreenHome);
}

</t>
<t tx="leo1.20171224221220.38">//-----------------------------------------------------------------------------
// For the configuration screen, setup items that are not specific to the
// file being edited right now.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.39">void TextWindow::ScreenChangeLightDirection(int link, uint32_t v) {
    SS.TW.ShowEditControl(8, ssprintf("%.2f, %.2f, %.2f", CO(SS.lightDir[v])));
    SS.TW.edit.meaning = Edit::LIGHT_DIRECTION;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo1.20171224221220.4">void SBsp3::InsertHow(BspClass how, STriangle *tr, SMesh *instead) {
    switch(how) {
        case BspClass::POS:
            if(instead &amp;&amp; !pos) goto alt;
            pos = InsertOrCreate(pos, tr, instead);
            break;

        case BspClass::NEG:
            if(instead &amp;&amp; !neg) goto alt;
            neg = InsertOrCreate(neg, tr, instead);
            break;

        case BspClass::COPLANAR: {
            if(instead) goto alt;
            SBsp3 *m = Alloc();
            m-&gt;n = n;
            m-&gt;d = d;
            m-&gt;tri = *tr;
            m-&gt;more = more;
            more = m;
            break;
        }
    }
    return;

alt:
    if(how == BspClass::POS &amp;&amp; !(instead-&gt;flipNormal)) {
        instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
    } else if(how == BspClass::NEG &amp;&amp; instead-&gt;flipNormal) {
        instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;c, tr-&gt;b, tr-&gt;a);
    } else if(how == BspClass::COPLANAR) {
        if(edges) {
            edges-&gt;InsertTriangle(tr, instead, this);
        } else {
            // I suppose this actually is allowed to happen, if the coplanar
            // face is the leaf, and all of its neighbors are earlier in tree?
            InsertInPlane(/*pos2=*/false, tr, instead);
        }
    } else {
        instead-&gt;atLeastOneDiscarded = true;
    }
}

</t>
<t tx="leo1.20171224221220.40">void TextWindow::ScreenChangeLightIntensity(int link, uint32_t v) {
    SS.TW.ShowEditControl(31, ssprintf("%.2f", SS.lightIntensity[v]));
    SS.TW.edit.meaning = Edit::LIGHT_INTENSITY;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo1.20171224221220.41">void TextWindow::ScreenChangeColor(int link, uint32_t v) {
    SS.TW.ShowEditControlWithColorPicker(13, SS.modelColor[v]);

    SS.TW.edit.meaning = Edit::COLOR;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo1.20171224221220.42">void TextWindow::ScreenChangeChordTolerance(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%lg", SS.chordTol));
    SS.TW.edit.meaning = Edit::CHORD_TOLERANCE;
    SS.TW.edit.i = 0;
}

</t>
<t tx="leo1.20171224221220.43">void TextWindow::ScreenChangeMaxSegments(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%d", SS.maxSegments));
    SS.TW.edit.meaning = Edit::MAX_SEGMENTS;
    SS.TW.edit.i = 0;
}

</t>
<t tx="leo1.20171224221220.44">void TextWindow::ScreenChangeExportChordTolerance(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%lg", SS.exportChordTol));
    SS.TW.edit.meaning = Edit::CHORD_TOLERANCE;
    SS.TW.edit.i = 1;
}

</t>
<t tx="leo1.20171224221220.45">void TextWindow::ScreenChangeExportMaxSegments(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%d", SS.exportMaxSegments));
    SS.TW.edit.meaning = Edit::MAX_SEGMENTS;
    SS.TW.edit.i = 1;
}

</t>
<t tx="leo1.20171224221220.46">void TextWindow::ScreenChangeCameraTangent(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%.3f", 1000*SS.cameraTangent));
    SS.TW.edit.meaning = Edit::CAMERA_TANGENT;
}

</t>
<t tx="leo1.20171224221220.47">void TextWindow::ScreenChangeGridSpacing(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, SS.MmToString(SS.gridSpacing));
    SS.TW.edit.meaning = Edit::GRID_SPACING;
}

</t>
<t tx="leo1.20171224221220.48">void TextWindow::ScreenChangeDigitsAfterDecimal(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%d", SS.UnitDigitsAfterDecimal()));
    SS.TW.edit.meaning = Edit::DIGITS_AFTER_DECIMAL;
}

</t>
<t tx="leo1.20171224221220.49">void TextWindow::ScreenChangeExportScale(int link, uint32_t v) {
    SS.TW.ShowEditControl(5, ssprintf("%.3f", (double)SS.exportScale));
    SS.TW.edit.meaning = Edit::EXPORT_SCALE;
}

</t>
<t tx="leo1.20171224221220.5">class BspUtil {
public:
    SBsp3      *bsp;

    size_t      onc;
    size_t      posc;
    size_t      negc;
    bool       *isPos;
    bool       *isNeg;
    bool       *isOn;

    // triangle operations
    STriangle  *tr;
    STriangle  *btri; // also as alone
    STriangle  *ctri;

    // convex operations
    Vector     *on;
    size_t      npos;
    size_t      nneg;
    Vector     *vpos; // also as quad
    Vector     *vneg;

    @others
};

</t>
<t tx="leo1.20171224221220.50">void TextWindow::ScreenChangeExportOffset(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, SS.MmToString(SS.exportOffset));
    SS.TW.edit.meaning = Edit::EXPORT_OFFSET;
}

</t>
<t tx="leo1.20171224221220.51">void TextWindow::ScreenChangeFixExportColors(int link, uint32_t v) {
    SS.fixExportColors = !SS.fixExportColors;
}

</t>
<t tx="leo1.20171224221220.52">void TextWindow::ScreenChangeBackFaces(int link, uint32_t v) {
    SS.drawBackFaces = !SS.drawBackFaces;
    SS.GW.persistentDirty = true;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.53">void TextWindow::ScreenChangeShowContourAreas(int link, uint32_t v) {
    SS.showContourAreas = !SS.showContourAreas;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.54">void TextWindow::ScreenChangeCheckClosedContour(int link, uint32_t v) {
    SS.checkClosedContour = !SS.checkClosedContour;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.55">void TextWindow::ScreenChangeShadedTriangles(int link, uint32_t v) {
    SS.exportShadedTriangles = !SS.exportShadedTriangles;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.56">void TextWindow::ScreenChangePwlCurves(int link, uint32_t v) {
    SS.exportPwlCurves = !SS.exportPwlCurves;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.57">void TextWindow::ScreenChangeCanvasSizeAuto(int link, uint32_t v) {
    if(link == 't') {
        SS.exportCanvasSizeAuto = true;
    } else {
        SS.exportCanvasSizeAuto = false;
    }
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221220.58">void TextWindow::ScreenChangeCanvasSize(int link, uint32_t v) {
    double d;
    switch(v) {
        case  0: d = SS.exportMargin.left;      break;
        case  1: d = SS.exportMargin.right;     break;
        case  2: d = SS.exportMargin.bottom;    break;
        case  3: d = SS.exportMargin.top;       break;

        case 10: d = SS.exportCanvas.width;     break;
        case 11: d = SS.exportCanvas.height;    break;
        case 12: d = SS.exportCanvas.dx;        break;
        case 13: d = SS.exportCanvas.dy;        break;

        default: return;
    }
    int col = 13;
    if(v &lt; 10) col = 11;
    SS.TW.ShowEditControl(col, SS.MmToString(d));
    SS.TW.edit.meaning = Edit::CANVAS_SIZE;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo1.20171224221220.59">void TextWindow::ScreenChangeGCodeParameter(int link, uint32_t v) {
    std::string buf;
    switch(link) {
        case 'd':
            SS.TW.edit.meaning = Edit::G_CODE_DEPTH;
            buf += SS.MmToString(SS.gCode.depth);
            break;

        case 's':
            SS.TW.edit.meaning = Edit::G_CODE_PASSES;
            buf += std::to_string(SS.gCode.passes);
            break;

        case 'F':
            SS.TW.edit.meaning = Edit::G_CODE_FEED;
            buf += SS.MmToString(SS.gCode.feed);
            break;

        case 'P':
            SS.TW.edit.meaning = Edit::G_CODE_PLUNGE_FEED;
            buf += SS.MmToString(SS.gCode.plungeFeed);
            break;
    }
    SS.TW.ShowEditControl(14, buf);
}

</t>
<t tx="leo1.20171224221220.6">static BspUtil *Alloc() {
    return (BspUtil *)AllocTemporary(sizeof(BspUtil));
}

</t>
<t tx="leo1.20171224221220.60">void TextWindow::ScreenChangeAutosaveInterval(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, std::to_string(SS.autosaveInterval));
    SS.TW.edit.meaning = Edit::AUTOSAVE_INTERVAL;
}

</t>
<t tx="leo1.20171224221220.61">void TextWindow::ShowConfiguration() {
    int i;
    Printf(true, "%Ft user color (r, g, b)");

    for(i = 0; i &lt; SS.MODEL_COLORS; i++) {
        Printf(false, "%Bp   #%d:  %Bz  %Bp  (%@, %@, %@) %f%D%Ll%Fl[change]%E",
            (i &amp; 1) ? 'd' : 'a',
            i, &amp;SS.modelColor[i],
            (i &amp; 1) ? 'd' : 'a',
            SS.modelColor[i].redF(),
            SS.modelColor[i].greenF(),
            SS.modelColor[i].blueF(),
            &amp;ScreenChangeColor, i);
    }

    Printf(false, "");
    Printf(false, "%Ft light direction               intensity");
    for(i = 0; i &lt; 2; i++) {
        Printf(false, "%Bp   #%d  (%2,%2,%2)%Fl%D%f%Ll[c]%E "
                      "%2 %Fl%D%f%Ll[c]%E",
            (i &amp; 1) ? 'd' : 'a', i,
            CO(SS.lightDir[i]), i, &amp;ScreenChangeLightDirection,
            SS.lightIntensity[i], i, &amp;ScreenChangeLightIntensity);
    }

    Printf(false, "");
    Printf(false, "%Ft chord tolerance (in percents)%E");
    Printf(false, "%Ba   %@ %% %Fl%Ll%f%D[change]%E; %@ mm, %d triangles",
        SS.chordTol,
        &amp;ScreenChangeChordTolerance, 0, SS.chordTolCalculated,
        SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh.l.n);
    Printf(false, "%Ft max piecewise linear segments%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.maxSegments,
        &amp;ScreenChangeMaxSegments);

    Printf(false, "");
    Printf(false, "%Ft export chord tolerance (in mm)%E");
    Printf(false, "%Ba   %@ %Fl%Ll%f%D[change]%E",
        SS.exportChordTol,
        &amp;ScreenChangeExportChordTolerance, 0);
    Printf(false, "%Ft export max piecewise linear segments%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.exportMaxSegments,
        &amp;ScreenChangeExportMaxSegments);

    Printf(false, "");
    Printf(false, "%Ft perspective factor (0 for parallel)%E");
    Printf(false, "%Ba   %# %Fl%Ll%f%D[change]%E",
        SS.cameraTangent*1000,
        &amp;ScreenChangeCameraTangent, 0);
    Printf(false, "%Ft snap grid spacing%E");
    Printf(false, "%Ba   %s %Fl%Ll%f%D[change]%E",
        SS.MmToString(SS.gridSpacing).c_str(),
        &amp;ScreenChangeGridSpacing, 0);
    Printf(false, "%Ft digits after decimal point to show%E");
    Printf(false, "%Ba   %d %Fl%Ll%f%D[change]%E (e.g. '%s')",
        SS.UnitDigitsAfterDecimal(),
        &amp;ScreenChangeDigitsAfterDecimal, 0,
        SS.MmToString(SS.StringToMm("1.23456789")).c_str());

    Printf(false, "");
    Printf(false, "%Ft export scale factor (1:1=mm, 1:25.4=inch)");
    Printf(false, "%Ba   1:%# %Fl%Ll%f%D[change]%E",
        (double)SS.exportScale,
        &amp;ScreenChangeExportScale, 0);
    Printf(false, "%Ft cutter radius offset (0=no offset) ");
    Printf(false, "%Ba   %s %Fl%Ll%f%D[change]%E",
        SS.MmToString(SS.exportOffset).c_str(),
        &amp;ScreenChangeExportOffset, 0);

    Printf(false, "");
    Printf(false, "  %Fd%f%Ll%s  export shaded 2d triangles%E",
        &amp;ScreenChangeShadedTriangles,
        SS.exportShadedTriangles ? CHECK_TRUE : CHECK_FALSE);
    if(fabs(SS.exportOffset) &gt; LENGTH_EPS) {
        Printf(false, "  %Fd%s  curves as piecewise linear%E "
                      "(since cutter radius is not zero)", CHECK_TRUE);
    } else {
        Printf(false, "  %Fd%f%Ll%s  export curves as piecewise linear%E",
            &amp;ScreenChangePwlCurves,
            SS.exportPwlCurves ? CHECK_TRUE : CHECK_FALSE);
    }
    Printf(false, "  %Fd%f%Ll%s  fix white exported lines%E",
        &amp;ScreenChangeFixExportColors,
        SS.fixExportColors ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "%Ft export canvas size:  "
                  "%f%Fd%Lf%s fixed%E  "
                  "%f%Fd%Lt%s auto%E",
        &amp;ScreenChangeCanvasSizeAuto,
        !SS.exportCanvasSizeAuto ? RADIO_TRUE : RADIO_FALSE,
        &amp;ScreenChangeCanvasSizeAuto,
        SS.exportCanvasSizeAuto ? RADIO_TRUE : RADIO_FALSE);

    if(SS.exportCanvasSizeAuto) {
        Printf(false, "%Ft (by margins around exported geometry)");
        Printf(false, "%Ba%Ft   left:   %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.left).c_str(), &amp;ScreenChangeCanvasSize, 0);
        Printf(false, "%Bd%Ft   right:  %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.right).c_str(), &amp;ScreenChangeCanvasSize, 1);
        Printf(false, "%Ba%Ft   bottom: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.bottom).c_str(), &amp;ScreenChangeCanvasSize, 2);
        Printf(false, "%Bd%Ft   top:    %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.top).c_str(), &amp;ScreenChangeCanvasSize, 3);
    } else {
        Printf(false, "%Ft (by absolute dimensions and offsets)");
        Printf(false, "%Ba%Ft   width:    %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.width).c_str(), &amp;ScreenChangeCanvasSize, 10);
        Printf(false, "%Bd%Ft   height:   %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.height).c_str(), &amp;ScreenChangeCanvasSize, 11);
        Printf(false, "%Ba%Ft   offset x: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.dx).c_str(), &amp;ScreenChangeCanvasSize, 12);
        Printf(false, "%Bd%Ft   offset y: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.dy).c_str(), &amp;ScreenChangeCanvasSize, 13);
    }

    Printf(false, "");
    Printf(false, "%Ft exported g code parameters");
    Printf(false, "%Ba%Ft   depth:     %Fd%s %Fl%Ld%f[change]%E",
        SS.MmToString(SS.gCode.depth).c_str(), &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Bd%Ft   passes:    %Fd%d %Fl%Ls%f[change]%E",
        SS.gCode.passes, &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Ba%Ft   feed:      %Fd%s %Fl%LF%f[change]%E",
        SS.MmToString(SS.gCode.feed).c_str(), &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Bd%Ft   plunge fd: %Fd%s %Fl%LP%f[change]%E",
        SS.MmToString(SS.gCode.plungeFeed).c_str(), &amp;ScreenChangeGCodeParameter);

    Printf(false, "");
    Printf(false, "  %Fd%f%Ll%s  draw triangle back faces in red%E",
        &amp;ScreenChangeBackFaces,
        SS.drawBackFaces ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  check sketch for closed contour%E",
        &amp;ScreenChangeCheckClosedContour,
        SS.checkClosedContour ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  show areas of closed contours%E",
        &amp;ScreenChangeShowContourAreas,
        SS.showContourAreas ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "%Ft autosave interval (in minutes)%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.autosaveInterval, &amp;ScreenChangeAutosaveInterval);

    if(canvas) {
        const char *gl_vendor, *gl_renderer, *gl_version;
        canvas-&gt;GetIdent(&amp;gl_vendor, &amp;gl_renderer, &amp;gl_version);
        Printf(false, "");
        Printf(false, " %Ftgl vendor   %E%s", gl_vendor);
        Printf(false, " %Ft   renderer %E%s", gl_renderer);
        Printf(false, " %Ft   version  %E%s", gl_version);
    }
}

</t>
<t tx="leo1.20171224221220.62">bool TextWindow::EditControlDoneForConfiguration(const char *s) {
    switch(edit.meaning) {
        case Edit::LIGHT_INTENSITY:
            SS.lightIntensity[edit.i] = min(1.0, max(0.0, atof(s)));
            InvalidateGraphics();
            break;

        case Edit::LIGHT_DIRECTION: {
            double x, y, z;
            if(sscanf(s, "%lf, %lf, %lf", &amp;x, &amp;y, &amp;z)==3) {
                SS.lightDir[edit.i] = Vector::From(x, y, z);
            } else {
                Error(_("Bad format: specify coordinates as x, y, z"));
            }
            InvalidateGraphics();
            break;
        }
        case Edit::COLOR: {
            Vector rgb;
            if(sscanf(s, "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);
                SS.modelColor[edit.i] = RGBf(rgb.x, rgb.y, rgb.z);
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::CHORD_TOLERANCE: {
            if(edit.i == 0) {
                SS.chordTol = max(0.0, atof(s));
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            } else {
                SS.exportChordTol = max(0.0, atof(s));
            }
            break;
        }
        case Edit::MAX_SEGMENTS: {
            if(edit.i == 0) {
                SS.maxSegments = min(1000, max(7, atoi(s)));
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            } else {
                SS.exportMaxSegments = min(1000, max(7, atoi(s)));
            }
            break;
        }
        case Edit::CAMERA_TANGENT: {
            SS.cameraTangent = (min(2.0, max(0.0, atof(s))))/1000.0;
            if(!SS.usePerspectiveProj) {
                Message(_("The perspective factor will have no effect until you "
                          "enable View -&gt; Use Perspective Projection."));
            }
            InvalidateGraphics();
            break;
        }
        case Edit::GRID_SPACING: {
            SS.gridSpacing = (float)min(1e4, max(1e-3, SS.StringToMm(s)));
            InvalidateGraphics();
            break;
        }
        case Edit::DIGITS_AFTER_DECIMAL: {
            int v = atoi(s);
            if(v &lt; 0 || v &gt; 8) {
                Error(_("Specify between 0 and 8 digits after the decimal."));
            } else {
                SS.SetUnitDigitsAfterDecimal(v);
            }
            InvalidateGraphics();
            break;
        }
        case Edit::EXPORT_SCALE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double ev = e-&gt;Eval();
                if(fabs(ev) &lt; 0.001 || isnan(ev)) {
                    Error(_("Export scale must not be zero!"));
                } else {
                    SS.exportScale = (float)ev;
                }
            }
            break;
        }
        case Edit::EXPORT_OFFSET: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double ev = SS.ExprToMm(e);
                if(isnan(ev) || ev &lt; 0) {
                    Error(_("Cutter radius offset must not be negative!"));
                } else {
                    SS.exportOffset = (float)ev;
                }
            }
            break;
        }
        case Edit::CANVAS_SIZE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(!e) {
                break;
            }
            float d = (float)SS.ExprToMm(e);
            switch(edit.i) {
                case  0: SS.exportMargin.left   = d;    break;
                case  1: SS.exportMargin.right  = d;    break;
                case  2: SS.exportMargin.bottom = d;    break;
                case  3: SS.exportMargin.top    = d;    break;

                case 10: SS.exportCanvas.width  = d;    break;
                case 11: SS.exportCanvas.height = d;    break;
                case 12: SS.exportCanvas.dx     = d;    break;
                case 13: SS.exportCanvas.dy     = d;    break;
            }
            break;
        }
        case Edit::G_CODE_DEPTH: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.depth = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::G_CODE_PASSES: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.passes = (int)(e-&gt;Eval());
            SS.gCode.passes = max(1, min(1000, SS.gCode.passes));
            break;
        }
        case Edit::G_CODE_FEED: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.feed = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::G_CODE_PLUNGE_FEED: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.plungeFeed = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::AUTOSAVE_INTERVAL: {
            int interval;
            if(sscanf(s, "%d", &amp;interval)==1) {
                if(interval &gt;= 1) {
                    SS.autosaveInterval = interval;
                    SetAutosaveTimerFor(interval);
                } else {
                    Error(_("Bad value: autosave interval should be positive"));
                }
            } else {
                Error(_("Bad format: specify interval in integral minutes"));
            }
            break;
        }

        default: return false;
    }
    return true;
}

</t>
<t tx="leo1.20171224221220.63">//-----------------------------------------------------------------------------
// Implementation of the Constraint menu, to create new constraints in
// the sketch.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Constraint::DescriptionString() const {
    std::string s;
    switch(type) {
        case Type::POINTS_COINCIDENT:   s = C_("constr-name", "pts-coincident"); break;
        case Type::PT_PT_DISTANCE:      s = C_("constr-name", "pt-pt-distance"); break;
        case Type::PT_LINE_DISTANCE:    s = C_("constr-name", "pt-line-distance"); break;
        case Type::PT_PLANE_DISTANCE:   s = C_("constr-name", "pt-plane-distance"); break;
        case Type::PT_FACE_DISTANCE:    s = C_("constr-name", "pt-face-distance"); break;
        case Type::PROJ_PT_DISTANCE:    s = C_("constr-name", "proj-pt-pt-distance"); break;
        case Type::PT_IN_PLANE:         s = C_("constr-name", "pt-in-plane"); break;
        case Type::PT_ON_LINE:          s = C_("constr-name", "pt-on-line"); break;
        case Type::PT_ON_FACE:          s = C_("constr-name", "pt-on-face"); break;
        case Type::EQUAL_LENGTH_LINES:  s = C_("constr-name", "eq-length"); break;
        case Type::EQ_LEN_PT_LINE_D:    s = C_("constr-name", "eq-length-and-pt-ln-dist"); break;
        case Type::EQ_PT_LN_DISTANCES:  s = C_("constr-name", "eq-pt-line-distances"); break;
        case Type::LENGTH_RATIO:        s = C_("constr-name", "length-ratio"); break;
        case Type::LENGTH_DIFFERENCE:   s = C_("constr-name", "length-difference"); break;
        case Type::SYMMETRIC:           s = C_("constr-name", "symmetric"); break;
        case Type::SYMMETRIC_HORIZ:     s = C_("constr-name", "symmetric-h"); break;
        case Type::SYMMETRIC_VERT:      s = C_("constr-name", "symmetric-v"); break;
        case Type::SYMMETRIC_LINE:      s = C_("constr-name", "symmetric-line"); break;
        case Type::AT_MIDPOINT:         s = C_("constr-name", "at-midpoint"); break;
        case Type::HORIZONTAL:          s = C_("constr-name", "horizontal"); break;
        case Type::VERTICAL:            s = C_("constr-name", "vertical"); break;
        case Type::DIAMETER:            s = C_("constr-name", "diameter"); break;
        case Type::PT_ON_CIRCLE:        s = C_("constr-name", "pt-on-circle"); break;
        case Type::SAME_ORIENTATION:    s = C_("constr-name", "same-orientation"); break;
        case Type::ANGLE:               s = C_("constr-name", "angle"); break;
        case Type::PARALLEL:            s = C_("constr-name", "parallel"); break;
        case Type::ARC_LINE_TANGENT:    s = C_("constr-name", "arc-line-tangent"); break;
        case Type::CUBIC_LINE_TANGENT:  s = C_("constr-name", "cubic-line-tangent"); break;
        case Type::CURVE_CURVE_TANGENT: s = C_("constr-name", "curve-curve-tangent"); break;
        case Type::PERPENDICULAR:       s = C_("constr-name", "perpendicular"); break;
        case Type::EQUAL_RADIUS:        s = C_("constr-name", "eq-radius"); break;
        case Type::EQUAL_ANGLE:         s = C_("constr-name", "eq-angle"); break;
        case Type::EQUAL_LINE_ARC_LEN:  s = C_("constr-name", "eq-line-len-arc-len"); break;
        case Type::WHERE_DRAGGED:       s = C_("constr-name", "lock-where-dragged"); break;
        case Type::COMMENT:             s = C_("constr-name", "comment"); break;
        default:                        s = "???"; break;
    }

    return ssprintf("c%03x-%s", h.v, s.c_str());
}

#ifndef LIBRARY

//-----------------------------------------------------------------------------
// Delete all constraints with the specified type, entityA, ptA. We use this
// when auto-removing constraints that would become redundant.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.64">void Constraint::DeleteAllConstraintsFor(Constraint::Type type, hEntity entityA, hEntity ptA)
{
    SK.constraint.ClearTags();
    for(int i = 0; i &lt; SK.constraint.n; i++) {
        ConstraintBase *ct = &amp;(SK.constraint.elem[i]);
        if(ct-&gt;type != type) continue;

        if(ct-&gt;entityA.v != entityA.v) continue;
        if(ct-&gt;ptA.v != ptA.v) continue;
        ct-&gt;tag = 1;
    }
    SK.constraint.RemoveTagged();
    // And no need to do anything special, since nothing
    // ever depends on a constraint. But do clear the
    // hover, in case the just-deleted constraint was
    // hovered.
    SS.GW.hover.Clear();
}

hConstraint Constraint::AddConstraint(Constraint *c) {
    return AddConstraint(c, /*rememberForUndo=*/true);
}

hConstraint Constraint::AddConstraint(Constraint *c, bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();

    hConstraint hc = SK.constraint.AddAndAssignId(c);
    SK.GetConstraint(hc)-&gt;Generate(&amp;SK.param);

    SS.MarkGroupDirty(c-&gt;group);
    SK.GetGroup(c-&gt;group)-&gt;dofCheckOk = false;
    return c-&gt;h;
}

hConstraint Constraint::Constrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                     hEntity entityA, hEntity entityB,
</t>
<t tx="leo1.20171224221220.65">                                     bool other, bool other2)
{
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();
    c.type = type;
    c.ptA = ptA;
    c.ptB = ptB;
    c.entityA = entityA;
    c.entityB = entityB;
    c.other = other;
    c.other2 = other2;
    return AddConstraint(&amp;c, /*rememberForUndo=*/false);
}

hConstraint Constraint::Constrain(Constraint::Type type, hEntity ptA, hEntity ptB, hEntity entityA){
    return Constrain(type, ptA, ptB, entityA, Entity::NO_ENTITY, /*other=*/false, /*other2=*/false);
}

hConstraint Constraint::ConstrainCoincident(hEntity ptA, hEntity ptB) {
    return Constrain(Type::POINTS_COINCIDENT, ptA, ptB,
        Entity::NO_ENTITY, Entity::NO_ENTITY, /*other=*/false, /*other2=*/false);
}

</t>
<t tx="leo1.20171224221220.66">void Constraint::MenuConstrain(Command id) {
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::DISTANCE_DIA:
        case Command::REF_DISTANCE: {
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::PT_PT_DISTANCE;
                Entity *e = SK.GetEntity(gs.entity[0]);
                c.ptA = e-&gt;point[0];
                c.ptB = e-&gt;point[1];
            } else if(gs.vectors == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                c.type = Type::PROJ_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.vector[0];
            } else if(gs.workplanes == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PLANE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_LINE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.faces == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_FACE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else if(gs.circlesOrArcs == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::DIAMETER;
                c.entityA = gs.entity[0];
            } else {
                Error(_("Bad selection for distance / diameter constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two points (distance between points)\n"
                        "    * a line segment (length)\n"
                        "    * two points and a line segment or normal (projected distance)\n"
                        "    * a workplane and a point (minimum distance)\n"
                        "    * a line segment and a point (minimum distance)\n"
                        "    * a plane face and a point (minimum distance)\n"
                        "    * a circle or an arc (diameter)\n"));
                return;
            }
            if(c.type == Type::PT_PT_DISTANCE || c.type == Type::PROJ_PT_DISTANCE) {
                Vector n = SS.GW.projRight.Cross(SS.GW.projUp);
                Vector a = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector b = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                c.disp.offset = n.Cross(a.Minus(b));
                c.disp.offset = (c.disp.offset).WithMagnitude(50/SS.GW.scale);
            } else {
                c.disp.offset = Vector::From(0, 0, 0);
            }

            if(id == Command::REF_DISTANCE) {
                c.reference = true;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;
        }

        case Command::ON_ENTITY:
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::POINTS_COINCIDENT;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.points == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_IN_PLANE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_LINE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.circlesOrArcs == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_CIRCLE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.faces == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_FACE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else {
                Error(_("Bad selection for on point / curve / plane constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points (points coincident)\n"
                        "    * a point and a workplane (point in plane)\n"
                        "    * a point and a line segment (point on line)\n"
                        "    * a point and a circle or arc (point on curve)\n"
                        "    * a point and a plane face (point on face)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::EQUAL:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LENGTH_LINES;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 4) {
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[1];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                // The same line segment for the distances, but different
                // points.
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 3) {
                c.type = Type::EQ_LEN_PT_LINE_D;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
                c.ptA = gs.point[0];
            } else if(gs.vectors == 4 &amp;&amp; gs.n == 4) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[2];
                c.entityD = gs.vector[3];
            } else if(gs.vectors == 3 &amp;&amp; gs.n == 3) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[1];
                c.entityD = gs.vector[2];
            } else if(gs.circlesOrArcs == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_RADIUS;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.arcs == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LINE_ARC_LEN;
                if(SK.GetEntity(gs.entity[0])-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    c.entityA = gs.entity[1];
                    c.entityB = gs.entity[0];
                } else {
                    c.entityA = gs.entity[0];
                    c.entityB = gs.entity[1];
                }
            } else {
                Error(_("Bad selection for equal length / radius constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two line segments (equal length)\n"
                        "    * two line segments and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment, and a point and line segment "
                                "(point-line distance equals length)\n"
                        "    * four line segments or normals "
                                "(equal angle between A,B and C,D)\n"
                        "    * three line segments or normals "
                                "(equal angle between A,B and B,C)\n"
                        "    * two circles or arcs (equal radius)\n"
                        "    * a line segment and an arc "
                                "(line segment length equals arc length)\n"));
                return;
            }
            if(c.type == Type::EQUAL_ANGLE) {
                // Infer the nearest supplementary angle from the sketch.
                Vector a1 = SK.GetEntity(c.entityA)-&gt;VectorGetNum(),
                       b1 = SK.GetEntity(c.entityB)-&gt;VectorGetNum(),
                       a2 = SK.GetEntity(c.entityC)-&gt;VectorGetNum(),
                       b2 = SK.GetEntity(c.entityD)-&gt;VectorGetNum();
                double d1 = a1.Dot(b1), d2 = a2.Dot(b2);

                if(d1*d2 &lt; 0) {
                    c.other = true;
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::RATIO:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_RATIO;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length ratio constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::DIFFERENCE:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_DIFFERENCE;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length difference constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::AT_MIDPOINT:
            if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];

                // If a point is at-midpoint, then no reason to also constrain
                // it on-line; so auto-remove that.
                DeleteAllConstraintsFor(Type::PT_ON_LINE, c.entityA, c.ptA);
            } else if(gs.lineSegments == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                int i = SK.GetEntity(gs.entity[0])-&gt;IsWorkplane() ? 1 : 0;
                c.entityA = gs.entity[i];
                c.entityB = gs.entity[1-i];
            } else {
                Error(_("Bad selection for at midpoint constraint. This "
                        "constraint can apply to:\n\n"
                        "    * a line segment and a point "
                              "(point at midpoint)\n"
                        "    * a line segment and a workplane "
                              "(line's midpoint on plane)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::SYMMETRIC:
            if(gs.points == 2 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 3) ||
                                 (gs.n == 2)))
            {
                if(gs.entities &gt; 0)
                    c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.type = Type::SYMMETRIC;
            } else if(gs.lineSegments == 1 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 2) ||
                                 (gs.n == 1)))
            {
                Entity *line;
                if(SK.GetEntity(gs.entity[0])-&gt;IsWorkplane()) {
                    line = SK.GetEntity(gs.entity[1]);
                    c.entityA = gs.entity[0];
                } else {
                    line = SK.GetEntity(gs.entity[0]);
                }
                c.ptA = line-&gt;point[0];
                c.ptB = line-&gt;point[1];
                c.type = Type::SYMMETRIC;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 2 &amp;&amp; gs.n == 2)
            {
                Entity *l0 = SK.GetEntity(gs.entity[0]),
                       *l1 = SK.GetEntity(gs.entity[1]);

                if((l1-&gt;group.v != SS.GW.activeGroup.v) ||
                   (l1-&gt;construction &amp;&amp; !(l0-&gt;construction)))
                {
                    swap(l0, l1);
                }
                c.ptA = l1-&gt;point[0];
                c.ptB = l1-&gt;point[1];
                c.entityA = l0-&gt;h;
                c.type = Type::SYMMETRIC_LINE;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3)
            {
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.entity[0];
                c.type = Type::SYMMETRIC_LINE;
            } else {
                Error(_("Bad selection for symmetric constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two points or a line segment "
                            "(symmetric about workplane's coordinate axis)\n"
                        "    * line segment, and two points or a line segment "
                            "(symmetric about line segment)\n"
                        "    * workplane, and two points or a line segment "
                            "(symmetric about workplane)\n"));
                return;
            }
            if(c.entityA.v == Entity::NO_ENTITY.v) {
                // Horizontal / vertical symmetry, implicit symmetry plane
                // normal to the workplane
                if(c.workplane.v == Entity::FREE_IN_3D.v) {
                    Error(_("A workplane must be active when constraining "
                            "symmetric without an explicit symmetry plane."));
                    return;
                }
                Vector pa = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector pb = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                Vector dp = pa.Minus(pb);
                EntityBase *norm = SK.GetEntity(c.workplane)-&gt;Normal();;
                Vector u = norm-&gt;NormalU(), v = norm-&gt;NormalV();
                if(fabs(dp.Dot(u)) &gt; fabs(dp.Dot(v))) {
                    c.type = Type::SYMMETRIC_HORIZ;
                } else {
                    c.type = Type::SYMMETRIC_VERT;
                }
                if(gs.lineSegments == 1) {
                    // If this line segment is already constrained horiz or
                    // vert, then auto-remove that redundant constraint.
                    DeleteAllConstraintsFor(Type::HORIZONTAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                    DeleteAllConstraintsFor(Type::VERTICAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::VERTICAL:
        case Command::HORIZONTAL: {
            hEntity ha, hb;
            if(c.workplane.v == Entity::FREE_IN_3D.v) {
                Error(_("Activate a workplane (with Sketch -&gt; In Workplane) before "
                        "applying a horizontal or vertical constraint."));
                return;
            }
            if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.entityA = gs.entity[0];
                Entity *e = SK.GetEntity(c.entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else if(gs.points == 2 &amp;&amp; gs.n == 2) {
                ha = c.ptA = gs.point[0];
                hb = c.ptB = gs.point[1];
            } else {
                Error(_("Bad selection for horizontal / vertical constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points\n"
                        "    * a line segment\n"));
                return;
            }
            if(id == Command::HORIZONTAL) {
                c.type = Type::HORIZONTAL;
            } else {
                c.type = Type::VERTICAL;
            }
            AddConstraint(&amp;c);
            break;
        }

        case Command::ORIENTED_SAME: {
            if(gs.anyNormals == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::SAME_ORIENTATION;
                c.entityA = gs.anyNormal[0];
                c.entityB = gs.anyNormal[1];
            } else {
                Error(_("Bad selection for same orientation constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two normals\n"));
                return;
            }
            SS.UndoRemember();

            Entity *nfree = SK.GetEntity(c.entityA);
            Entity *nref  = SK.GetEntity(c.entityB);
            if(nref-&gt;group.v == SS.GW.activeGroup.v) {
                swap(nref, nfree);
            }
            if(nfree-&gt;group.v == SS.GW.activeGroup.v &amp;&amp;
               nref -&gt;group.v != SS.GW.activeGroup.v)
            {
                // nfree is free, and nref is locked (since it came from a
                // previous group); so let's force nfree aligned to nref,
                // and make convergence easy
                Vector ru = nref -&gt;NormalU(), rv = nref -&gt;NormalV();
                Vector fu = nfree-&gt;NormalU(), fv = nfree-&gt;NormalV();

                if(fabs(fu.Dot(ru)) &lt; fabs(fu.Dot(rv))) {
                    // There might be an odd*90 degree rotation about the
                    // normal vector; allow that, since the numerical
                    // constraint does
                    swap(ru, rv);
                }
                fu = fu.Dot(ru) &gt; 0 ? ru : ru.ScaledBy(-1);
                fv = fv.Dot(rv) &gt; 0 ? rv : rv.ScaledBy(-1);

                nfree-&gt;NormalForceTo(Quaternion::From(fu, fv));
            }
            AddConstraint(&amp;c, /*rememberForUndo=*/false);
            break;
        }

        case Command::OTHER_ANGLE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;type == Type::ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    c-&gt;ModifyToSatisfy();
                    break;
                }
                if(c-&gt;type == Type::EQUAL_ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    SS.MarkGroupDirty(c-&gt;group);
                    break;
                }
            }
            Error(_("Must select an angle constraint."));
            return;

        case Command::REFERENCE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Type::COMMENT) {
                    (c-&gt;reference) = !(c-&gt;reference);
                    SS.MarkGroupDirty(c-&gt;group, /*onlyThis=*/true);
                    break;
                }
            }
            Error(_("Must select a constraint with associated label."));
            return;

        case Command::ANGLE:
        case Command::REF_ANGLE: {
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.valA = 0;
            } else {
                Error(_("Bad selection for angle constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }

            Entity *ea = SK.GetEntity(c.entityA),
                   *eb = SK.GetEntity(c.entityB);
            if(ea-&gt;type == Entity::Type::LINE_SEGMENT &amp;&amp;
               eb-&gt;type == Entity::Type::LINE_SEGMENT)
            {
                Vector a0 = SK.GetEntity(ea-&gt;point[0])-&gt;PointGetNum(),
                       a1 = SK.GetEntity(ea-&gt;point[1])-&gt;PointGetNum(),
                       b0 = SK.GetEntity(eb-&gt;point[0])-&gt;PointGetNum(),
                       b1 = SK.GetEntity(eb-&gt;point[1])-&gt;PointGetNum();
                if(a0.Equals(b0) || a1.Equals(b1)) {
                    // okay, vectors should be drawn in same sense
                } else if(a0.Equals(b1) || a1.Equals(b0)) {
                    // vectors are in opposite sense
                    c.other = true;
                } else {
                    // no shared point; not clear which intersection to draw
                }
            }

            if(id == Command::REF_ANGLE) {
                c.reference = true;
            }

            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;
        }

        case Command::PARALLEL:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PARALLEL;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.arcs == 1 &amp;&amp; gs.n == 2) {
                Entity *line = SK.GetEntity(gs.entity[0]);
                Entity *arc  = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    swap(line, arc);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector a1 = SK.GetEntity(arc-&gt;point[1])-&gt;PointGetNum(),
                       a2 = SK.GetEntity(arc-&gt;point[2])-&gt;PointGetNum();

                if(l0.Equals(a1) || l1.Equals(a1)) {
                    c.other = false;
                } else if(l0.Equals(a2) || l1.Equals(a2)) {
                    c.other = true;
                } else {
                    Error(_("The tangent arc and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::ARC_LINE_TANGENT;
                c.entityA = arc-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.lineSegments == 1 &amp;&amp; gs.cubics == 1 &amp;&amp; gs.n == 2) {
                Entity *line  = SK.GetEntity(gs.entity[0]);
                Entity *cubic = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::CUBIC) {
                    swap(line, cubic);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector as = cubic-&gt;CubicGetStartNum(),
                       af = cubic-&gt;CubicGetFinishNum();

                if(l0.Equals(as) || l1.Equals(as)) {
                    c.other = false;
                } else if(l0.Equals(af) || l1.Equals(af)) {
                    c.other = true;
                } else {
                    Error(_("The tangent cubic and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::CUBIC_LINE_TANGENT;
                c.entityA = cubic-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.cubics + gs.arcs == 2 &amp;&amp; gs.n == 2) {
                if(!SS.GW.LockedInWorkplane()) {
                    Error(_("Curve-curve tangency must apply in workplane."));
                    return;
                }
                Entity *eA = SK.GetEntity(gs.entity[0]),
                       *eB = SK.GetEntity(gs.entity[1]);
                Vector as = eA-&gt;EndpointStart(),
                       af = eA-&gt;EndpointFinish(),
                       bs = eB-&gt;EndpointStart(),
                       bf = eB-&gt;EndpointFinish();
                if(as.Equals(bs)) {
                    c.other = false; c.other2 = false;
                } else if(as.Equals(bf)) {
                    c.other = false; c.other2 = true;
                } else if(af.Equals(bs)) {
                    c.other = true; c.other2 = false;
                } else if(af.Equals(bf)) {
                    c.other = true; c.other2 = true;
                } else {
                    Error(_("The curves must share an endpoint. Constrain them "
                            "with Constrain -&gt; On Point before constraining "
                            "tangent."));
                    return;
                }
                c.type = Type::CURVE_CURVE_TANGENT;
                c.entityA = eA-&gt;h;
                c.entityB = eB-&gt;h;
            } else {
                Error(_("Bad selection for parallel / tangent constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments (parallel)\n"
                        "    * a line segment and a normal (parallel)\n"
                        "    * two normals (parallel)\n"
                        "    * two line segments, arcs, or beziers, that share "
                              "an endpoint (tangent)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::PERPENDICULAR:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PERPENDICULAR;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else {
                Error(_("Bad selection for perpendicular constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::WHERE_DRAGGED:
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::WHERE_DRAGGED;
                c.ptA = gs.point[0];
            } else {
                Error(_("Bad selection for lock point where dragged constraint. "
                        "This constraint can apply to:\n\n"
                        "    * a point\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::COMMENT:
            SS.GW.pending.operation = GraphicsWindow::Pending::COMMAND;
            SS.GW.pending.command = Command::COMMENT;
            SS.GW.pending.description = _("click center of comment text");
            SS.ScheduleShowTW();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }

    if(SK.constraint.FindByIdNoOops(c.h)) {
        Constraint *constraint = SK.GetConstraint(c.h);
        if(SS.TestRankForGroup(c.group) == SolveResult::REDUNDANT_OKAY &amp;&amp;
                !SK.GetGroup(SS.GW.activeGroup)-&gt;allowRedundant &amp;&amp;
                @others
}

#endif /* ! LIBRARY */
</t>
<t tx="leo1.20171224221220.67">            constraint-&gt;HasLabel()) {
        constraint-&gt;reference = true;
    }
}

SS.GW.ClearSelection();
InvalidateGraphics();
</t>
<t tx="leo1.20171224221220.68">//-----------------------------------------------------------------------------
// Given a constraint, generate one or more equations in our symbolic algebra
// system to represent that constraint; also various geometric helper
// functions for that.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hConstraint ConstraintBase::NO_CONSTRAINT = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.69">bool ConstraintBase::HasLabel() const {
    switch(type) {
        case Type::PT_LINE_DISTANCE:
        case Type::PT_PLANE_DISTANCE:
        case Type::PT_FACE_DISTANCE:
        case Type::PT_PT_DISTANCE:
        case Type::PROJ_PT_DISTANCE:
        case Type::DIAMETER:
        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::ANGLE:
        case Type::COMMENT:
            return true;

        default:
            return false;
    }
}

ExprVector ConstraintBase::VectorsParallel3d(ExprVector a, ExprVector b, hParam p) {
    return a.Minus(b.ScaledBy(Expr::From(p)));
}

Expr *ConstraintBase::PointLineDistance(hEntity wrkpl, hEntity hpt, hEntity hln)
{
    EntityBase *ln = SK.GetEntity(hln);
    EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
    EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

    EntityBase *p = SK.GetEntity(hpt);

    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        ExprVector ep = p-&gt;PointGetExprs();

        ExprVector ea = a-&gt;PointGetExprs();
        ExprVector eb = b-&gt;PointGetExprs();
        ExprVector eab = ea.Minus(eb);
        Expr *m = eab.Magnitude();

        return ((eab.Cross(ea.Minus(ep))).Magnitude())-&gt;Div(m);
    } else {
        Expr *ua, *va, *ub, *vb;
        a-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ua, &amp;va);
        b-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ub, &amp;vb);

        Expr *du = ua-&gt;Minus(ub);
        Expr *dv = va-&gt;Minus(vb);

        Expr *u, *v;
        p-&gt;PointGetExprsInWorkplane(wrkpl, &amp;u, &amp;v);

        Expr *m = ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();

        Expr *proj = (dv-&gt;Times(ua-&gt;Minus(u)))-&gt;Minus(
                     (du-&gt;Times(va-&gt;Minus(v))));

        return proj-&gt;Div(m);
    }
}

Expr *ConstraintBase::PointPlaneDistance(ExprVector p, hEntity hpl) {
    ExprVector n;
    Expr *d;
    SK.GetEntity(hpl)-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
    return (p.Dot(n))-&gt;Minus(d);
}

Expr *ConstraintBase::Distance(hEntity wrkpl, hEntity hpa, hEntity hpb) {
    EntityBase *pa = SK.GetEntity(hpa);
    EntityBase *pb = SK.GetEntity(hpb);
    ssassert(pa-&gt;IsPoint() &amp;&amp; pb-&gt;IsPoint(),
             "Expected two points to measure projected distance between");

    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        // This is true distance
        ExprVector ea, eb, eab;
        ea = pa-&gt;PointGetExprs();
        eb = pb-&gt;PointGetExprs();
        eab = ea.Minus(eb);

        return eab.Magnitude();
    } else {
        // This is projected distance, in the given workplane.
        Expr *au, *av, *bu, *bv;

        pa-&gt;PointGetExprsInWorkplane(wrkpl, &amp;au, &amp;av);
        pb-&gt;PointGetExprsInWorkplane(wrkpl, &amp;bu, &amp;bv);

        Expr *du = au-&gt;Minus(bu);
        Expr *dv = av-&gt;Minus(bv);

        return ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();
    }
}

//-----------------------------------------------------------------------------
// Return the cosine of the angle between two vectors. If a workplane is
// specified, then it's the cosine of their projections into that workplane.
//-----------------------------------------------------------------------------
Expr *ConstraintBase::DirectionCosine(hEntity wrkpl,
                                      ExprVector ae, ExprVector be)
{
    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        Expr *mags = (ae.Magnitude())-&gt;Times(be.Magnitude());
        return (ae.Dot(be))-&gt;Div(mags);
    } else {
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();
        Expr *ua = u.Dot(ae);
        Expr *va = v.Dot(ae);
        Expr *ub = u.Dot(be);
        Expr *vb = v.Dot(be);
        Expr *maga = (ua-&gt;Square()-&gt;Plus(va-&gt;Square()))-&gt;Sqrt();
        Expr *magb = (ub-&gt;Square()-&gt;Plus(vb-&gt;Square()))-&gt;Sqrt();
        Expr *dot = (ua-&gt;Times(ub))-&gt;Plus(va-&gt;Times(vb));
        return dot-&gt;Div(maga-&gt;Times(magb));
    }
}

ExprVector ConstraintBase::PointInThreeSpace(hEntity workplane,
                                             Expr *u, Expr *v)
{
    EntityBase *w = SK.GetEntity(workplane);

    ExprVector ub = w-&gt;Normal()-&gt;NormalExprsU();
    ExprVector vb = w-&gt;Normal()-&gt;NormalExprsV();
    ExprVector ob = w-&gt;WorkplaneGetOffsetExprs();

    return (ub.ScaledBy(u)).Plus(vb.ScaledBy(v)).Plus(ob);
}

</t>
<t tx="leo1.20171224221220.7">void AllocOn() {
    on = (Vector *)AllocTemporary(sizeof(Vector) * 2);
}

</t>
<t tx="leo1.20171224221220.70">void ConstraintBase::ModifyToSatisfy() {
    if(type == Type::ANGLE) {
        Vector a = SK.GetEntity(entityA)-&gt;VectorGetNum();
        Vector b = SK.GetEntity(entityB)-&gt;VectorGetNum();
        if(other) a = a.ScaledBy(-1);
        if(workplane.v != EntityBase::FREE_IN_3D.v) {
            a = a.ProjectVectorInto(workplane);
            b = b.ProjectVectorInto(workplane);
        }
        double c = (a.Dot(b))/(a.Magnitude() * b.Magnitude());
        valA = acos(c)*180/PI;
    } else if(type == Type::PT_ON_LINE) {
        EntityBase *eln = SK.GetEntity(entityA);
        EntityBase *ea = SK.GetEntity(eln-&gt;point[0]);
        EntityBase *eb = SK.GetEntity(eln-&gt;point[1]);
        EntityBase *ep = SK.GetEntity(ptA);
        ExprVector exp = ep-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exa = ea-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exb = eb-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exba = exb.Minus(exa);
        SK.GetParam(valP)-&gt;val = exba.Dot(exp.Minus(exa))-&gt;Eval() / exba.Dot(exba)-&gt;Eval();
    } else {
        // We'll fix these ones up by looking at their symbolic equation;
        // that means no extra work.
        IdList&lt;Equation,hEquation&gt; l = {};
        // Generate the equations even if this is a reference dimension
        GenerateEquations(&amp;l, /*forReference=*/true);
        ssassert(l.n == 1, "Expected constraint to generate a single equation");

        // These equations are written in the form f(...) - d = 0, where
        // d is the value of the valA.
        valA += (l.elem[0].e)-&gt;Eval();

        l.Clear();
    }
}

</t>
<t tx="leo1.20171224221220.71">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const
{
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo1.20171224221220.72">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, const ExprVector &amp;v,
                           int baseIndex) const {
    AddEq(l, v.x, baseIndex);
    AddEq(l, v.y, baseIndex + 1);
    if(workplane.v == EntityBase::FREE_IN_3D.v) {
        AddEq(l, v.z, baseIndex + 2);
    }
}

</t>
<t tx="leo1.20171224221220.73">void ConstraintBase::Generate(IdList&lt;Param,hParam&gt; *l) {
    switch(type) {
        case Type::PARALLEL:
        case Type::CUBIC_LINE_TANGENT:
            // Add new parameter only when we operate in 3d space
            if(workplane.v != EntityBase::FREE_IN_3D.v) break;
            // fallthrough
        case Type::SAME_ORIENTATION:
        case Type::PT_ON_LINE: {
            Param p = {};
            valP = h.param(0);
            p.h = valP;
            l-&gt;Add(&amp;p);
            break;
        }

        default:
            break;
    }
}

</t>
<t tx="leo1.20171224221220.74">void ConstraintBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l,
                                       bool forReference) const {
    if(reference &amp;&amp; !forReference) return;

    Expr *exA = Expr::From(valA);
    switch(type) {
        case Type::PT_PT_DISTANCE:
            AddEq(l, Distance(workplane, ptA, ptB)-&gt;Minus(exA), 0);
            return;

        case Type::PROJ_PT_DISTANCE: {
            ExprVector pA = SK.GetEntity(ptA)-&gt;PointGetExprs(),
                       pB = SK.GetEntity(ptB)-&gt;PointGetExprs(),
                       dp = pB.Minus(pA);

            ExprVector pp = SK.GetEntity(entityA)-&gt;VectorGetExprs();
            pp = pp.WithMagnitude(Expr::From(1.0));

            AddEq(l, (dp.Dot(pp))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_LINE_DISTANCE:
            AddEq(l,
                PointLineDistance(workplane, ptA, entityA)-&gt;Minus(exA), 0);
            return;

        case Type::PT_PLANE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            AddEq(l, (PointPlaneDistance(pt, entityA))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_FACE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (pt.Minus(p0)).Dot(n)-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_LENGTH_LINES: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            AddEq(l, Distance(workplane, a-&gt;point[0], a-&gt;point[1])-&gt;Minus(
                     Distance(workplane, b-&gt;point[0], b-&gt;point[1])), 0);
            return;
        }

        // These work on distance squared, since the pt-line distances are
        // signed, and we want the absolute value.
        case Type::EQ_LEN_PT_LINE_D: {
            EntityBase *forLen = SK.GetEntity(entityA);
            Expr *d1 = Distance(workplane, forLen-&gt;point[0], forLen-&gt;point[1]);
            Expr *d2 = PointLineDistance(workplane, ptA, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }
        case Type::EQ_PT_LN_DISTANCES: {
            Expr *d1 = PointLineDistance(workplane, ptA, entityA);
            Expr *d2 = PointLineDistance(workplane, ptB, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }

        case Type::LENGTH_RATIO: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Div(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::LENGTH_DIFFERENCE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Minus(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::DIAMETER: {
            EntityBase *circle = SK.GetEntity(entityA);
            Expr *r = circle-&gt;CircleGetRadiusExpr();
            AddEq(l, (r-&gt;Times(Expr::From(2)))-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_RADIUS: {
            EntityBase *c1 = SK.GetEntity(entityA);
            EntityBase *c2 = SK.GetEntity(entityB);
            AddEq(l, (c1-&gt;CircleGetRadiusExpr())-&gt;Minus(
                      c2-&gt;CircleGetRadiusExpr()), 0);
            return;
        }

        case Type::EQUAL_LINE_ARC_LEN: {
            EntityBase *line = SK.GetEntity(entityA),
                       *arc  = SK.GetEntity(entityB);

            // Get the line length
            ExprVector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetExprs(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetExprs();
            Expr *ll = (l1.Minus(l0)).Magnitude();

            // And get the arc radius, and the cosine of its angle
            EntityBase *ao = SK.GetEntity(arc-&gt;point[0]),
                       *as = SK.GetEntity(arc-&gt;point[1]),
                       *af = SK.GetEntity(arc-&gt;point[2]);

            ExprVector aos = (as-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs()),
                       aof = (af-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs());
            Expr *r = aof.Magnitude();

            ExprVector n = arc-&gt;Normal()-&gt;NormalExprsN();
            ExprVector u = aos.WithMagnitude(Expr::From(1.0));
            ExprVector v = n.Cross(u);
            // so in our new csys, we start at (1, 0, 0)
            Expr *costheta = aof.Dot(u)-&gt;Div(r);
            Expr *sintheta = aof.Dot(v)-&gt;Div(r);

            double thetas, thetaf, dtheta;
            arc-&gt;ArcGetAngles(&amp;thetas, &amp;thetaf, &amp;dtheta);
            Expr *theta;
            if(dtheta &lt; 3*PI/4) {
                theta = costheta-&gt;ACos();
            } else if(dtheta &lt; 5*PI/4) {
                // As the angle crosses pi, cos theta is not invertible;
                // so use the sine to stop blowing up
                theta = Expr::From(PI)-&gt;Minus(sintheta-&gt;ASin());
            } else {
                theta = (Expr::From(2*PI))-&gt;Minus(costheta-&gt;ACos());
            }

            // And write the equation; r*theta = L
            AddEq(l, (r-&gt;Times(theta))-&gt;Minus(ll), 0);
            return;
        }

        case Type::POINTS_COINCIDENT: {
            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                AddEq(l, pa.x-&gt;Minus(pb.x), 0);
                AddEq(l, pa.y-&gt;Minus(pb.y), 1);
                AddEq(l, pa.z-&gt;Minus(pb.z), 2);
            } else {
                Expr *au, *av;
                Expr *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Minus(bv), 1);
            }
            return;
        }

        case Type::PT_IN_PLANE:
            // This one works the same, whether projected or not.
            AddEq(l, PointPlaneDistance(
                        SK.GetEntity(ptA)-&gt;PointGetExprs(), entityA), 0);
            return;

        case Type::PT_ON_FACE: {
            // a plane, n dot (p - p0) = 0
            ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (p.Minus(p0)).Dot(n), 0);
            return;
        }

        case Type::PT_ON_LINE: {
            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *b = SK.GetEntity(ln-&gt;point[1]);
            EntityBase *p = SK.GetEntity(ptA);

            ExprVector ep = p-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);

            ExprVector ptOnLine = ea.Plus(eb.Minus(ea).ScaledBy(Expr::From(valP)));
            ExprVector eq = ptOnLine.Minus(ep);

            AddEq(l, eq);
            return;
        }

        case Type::PT_ON_CIRCLE: {
            // This actually constrains the point to lie on the cylinder.
            EntityBase *circle = SK.GetEntity(entityA);
            ExprVector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetExprs();
            ExprVector pt     = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *normal = SK.GetEntity(circle-&gt;normal);
            ExprVector u = normal-&gt;NormalExprsU(),
                       v = normal-&gt;NormalExprsV();

            Expr *du = (center.Minus(pt)).Dot(u),
                 *dv = (center.Minus(pt)).Dot(v);

            Expr *r = circle-&gt;CircleGetRadiusExpr();

            AddEq(l, du-&gt;Square()-&gt;Plus(dv-&gt;Square())-&gt;Sqrt()-&gt;Minus(r), 0);
            return;
        }

        case Type::AT_MIDPOINT:
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                EntityBase *ln = SK.GetEntity(entityA);
                ExprVector a = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetExprs();
                ExprVector b = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetExprs();
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));

                if(ptA.v) {
                    ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
                    AddEq(l, (m.x)-&gt;Minus(p.x), 0);
                    AddEq(l, (m.y)-&gt;Minus(p.y), 1);
                    AddEq(l, (m.z)-&gt;Minus(p.z), 2);
                } else {
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            } else {
                EntityBase *ln = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
                EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                if(ptA.v) {
                    EntityBase *p = SK.GetEntity(ptA);
                    Expr *pu, *pv;
                    p-&gt;PointGetExprsInWorkplane(workplane, &amp;pu, &amp;pv);
                    AddEq(l, pu-&gt;Minus(mu), 0);
                    AddEq(l, pv-&gt;Minus(mv), 1);
                } else {
                    ExprVector m = PointInThreeSpace(workplane, mu, mv);
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            }
            return;

        case Type::SYMMETRIC:
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *ea = SK.GetEntity(ptA);
                EntityBase *eb = SK.GetEntity(ptB);
                ExprVector a = ea-&gt;PointGetExprs();
                ExprVector b = eb-&gt;PointGetExprs();

                // The midpoint of the line connecting the symmetric points
                // lies on the plane of the symmetry.
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // And projected into the plane of symmetry, the points are
                // coincident.
                Expr *au, *av, *bu, *bv;
                ea-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;au, &amp;av);
                eb-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 1);
                AddEq(l, av-&gt;Minus(bv), 2);
            } else {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ptA);
                EntityBase *b = SK.GetEntity(ptB);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                ExprVector m = PointInThreeSpace(workplane, mu, mv);
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // Construct a vector within the workplane that is normal
                // to the symmetry pane's normal (i.e., that lies in the
                // plane of symmetry). The line connecting the points is
                // perpendicular to that constructed vector.
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
                ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();

                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                ExprVector n;
                Expr *d;
                plane-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
                AddEq(l, (n.Cross(u.Cross(v))).Dot(pa.Minus(pb)), 1);
            }
            return;

        case Type::SYMMETRIC_HORIZ:
        case Type::SYMMETRIC_VERT: {
            ssassert(workplane.v != Entity::FREE_IN_3D.v,
                     "Unexpected horizontal/vertical symmetric constraint in 3d");

            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            if(type == Type::SYMMETRIC_HORIZ) {
                AddEq(l, av-&gt;Minus(bv), 0);
                AddEq(l, au-&gt;Plus(bu), 1);
            } else {
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Plus(bv), 1);
            }
            return;
        }

        case Type::SYMMETRIC_LINE: {
            EntityBase *pa = SK.GetEntity(ptA);
            EntityBase *pb = SK.GetEntity(ptB);

            Expr *pau, *pav, *pbu, *pbv;
            pa-&gt;PointGetExprsInWorkplane(workplane, &amp;pau, &amp;pav);
            pb-&gt;PointGetExprsInWorkplane(workplane, &amp;pbu, &amp;pbv);

            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *la = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *lb = SK.GetEntity(ln-&gt;point[1]);
            Expr *lau, *lav, *lbu, *lbv;
            la-&gt;PointGetExprsInWorkplane(workplane, &amp;lau, &amp;lav);
            lb-&gt;PointGetExprsInWorkplane(workplane, &amp;lbu, &amp;lbv);

            Expr *dpu = pbu-&gt;Minus(pau), *dpv = pbv-&gt;Minus(pav);
            Expr *dlu = lbu-&gt;Minus(lau), *dlv = lbv-&gt;Minus(lav);

            // The line through the points is perpendicular to the line
            // of symmetry.
            AddEq(l, (dlu-&gt;Times(dpu))-&gt;Plus(dlv-&gt;Times(dpv)), 0);

            // And the signed distances of the points to the line are
            // equal in magnitude and opposite in sign, so sum to zero
            Expr *dista = (dlv-&gt;Times(lau-&gt;Minus(pau)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pav))));
            Expr *distb = (dlv-&gt;Times(lau-&gt;Minus(pbu)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pbv))));
            AddEq(l, dista-&gt;Plus(distb), 1);

            return;
        }

        case Type::HORIZONTAL:
        case Type::VERTICAL: {
            ssassert(workplane.v != Entity::FREE_IN_3D.v,
                     "Unexpected horizontal/vertical constraint in 3d");

            hEntity ha, hb;
            if(entityA.v) {
                EntityBase *e = SK.GetEntity(entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else {
                ha = ptA;
                hb = ptB;
            }
            EntityBase *a = SK.GetEntity(ha);
            EntityBase *b = SK.GetEntity(hb);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            AddEq(l, (type == Type::HORIZONTAL) ? av-&gt;Minus(bv) : au-&gt;Minus(bu), 0);
            return;
        }

        case Type::SAME_ORIENTATION: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);

            ExprVector au = a-&gt;NormalExprsU(),
                       an = a-&gt;NormalExprsN();
            ExprVector bu = b-&gt;NormalExprsU(),
                       bv = b-&gt;NormalExprsV(),
                       bn = b-&gt;NormalExprsN();

            ExprVector eq = VectorsParallel3d(an, bn, valP);
            AddEq(l, eq.x, 0);
            AddEq(l, eq.y, 1);
            AddEq(l, eq.z, 2);
            Expr *d1 = au.Dot(bv);
            Expr *d2 = au.Dot(bu);
            // Allow either orientation for the coordinate system, depending
            // on how it was drawn.
            if(fabs(d1-&gt;Eval()) &lt; fabs(d2-&gt;Eval())) {
                AddEq(l, d1, 3);
            } else {
                AddEq(l, d2, 3);
            }
            return;
        }

        case Type::PERPENDICULAR:
        case Type::ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            if(other) ae = ae.ScaledBy(Expr::From(-1));
            Expr *c = DirectionCosine(workplane, ae, be);

            if(type == Type::ANGLE) {
                // The direction cosine is equal to the cosine of the
                // specified angle
                Expr *rads = exA-&gt;Times(Expr::From(PI/180)),
                     *rc   = rads-&gt;Cos();
                double arc = fabs(rc-&gt;Eval());
                // avoid false detection of inconsistent systems by gaining
                // up as the difference in dot products gets small at small
                // angles; doubles still have plenty of precision, only
                // problem is that rank test
                Expr *mult = Expr::From(arc &gt; 0.99 ? 0.01/(1.00001 - arc) : 1);
                AddEq(l, (c-&gt;Minus(rc))-&gt;Times(mult), 0);
            } else {
                // The dot product (and therefore the direction cosine)
                // is equal to zero, perpendicular.
                AddEq(l, c, 0);
            }
            return;
        }

        case Type::EQUAL_ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            EntityBase *c = SK.GetEntity(entityC);
            EntityBase *d = SK.GetEntity(entityD);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            ExprVector ce = c-&gt;VectorGetExprs();
            ExprVector de = d-&gt;VectorGetExprs();

            if(other) ae = ae.ScaledBy(Expr::From(-1));

            Expr *cab = DirectionCosine(workplane, ae, be);
            Expr *ccd = DirectionCosine(workplane, ce, de);

            AddEq(l, cab-&gt;Minus(ccd), 0);
            return;
        }

        case Type::ARC_LINE_TANGENT: {
            EntityBase *arc  = SK.GetEntity(entityA);
            EntityBase *line = SK.GetEntity(entityB);

            ExprVector ac = SK.GetEntity(arc-&gt;point[0])-&gt;PointGetExprs();
            ExprVector ap =
                SK.GetEntity(arc-&gt;point[other ? 2 : 1])-&gt;PointGetExprs();

            ExprVector ld = line-&gt;VectorGetExprs();

            // The line is perpendicular to the radius
            AddEq(l, ld.Dot(ac.Minus(ap)), 0);
            return;
        }

        case Type::CUBIC_LINE_TANGENT: {
            EntityBase *cubic = SK.GetEntity(entityA);
            EntityBase *line  = SK.GetEntity(entityB);

            ExprVector a;
            if(other) {
                a = cubic-&gt;CubicGetFinishTangentExprs();
            } else {
                a = cubic-&gt;CubicGetStartTangentExprs();
            }

            ExprVector b = line-&gt;VectorGetExprs();

            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, (a.Cross(b)).Dot(wn), 0);
            }
            return;
        }

        case Type::CURVE_CURVE_TANGENT: {
            bool parallel = true;
            int i;
            ExprVector dir[2];
            for(i = 0; i &lt; 2; i++) {
                EntityBase *e = SK.GetEntity((i == 0) ? entityA : entityB);
                bool oth = (i == 0) ? other : other2;

                if(e-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    ExprVector center, endpoint;
                    center = SK.GetEntity(e-&gt;point[0])-&gt;PointGetExprs();
                    endpoint =
                        SK.GetEntity(e-&gt;point[oth ? 2 : 1])-&gt;PointGetExprs();
                    dir[i] = endpoint.Minus(center);
                    // We're using the vector from the center of the arc to
                    // an endpoint; so that's normal to the tangent, not
                    // parallel.
                    parallel = !parallel;
                } else if(e-&gt;type == Entity::Type::CUBIC) { // BRANCH_ALWAYS_TAKEN
                    if(oth) {
                        dir[i] = e-&gt;CubicGetFinishTangentExprs();
                    } else {
                        dir[i] = e-&gt;CubicGetStartTangentExprs();
                    }
                } else {
                    ssassert(false, "Unexpected entity types for CURVE_CURVE_TANGENT");
                }
            }
            if(parallel) {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, ((dir[0]).Cross(dir[1])).Dot(wn), 0);
            } else {
                AddEq(l, (dir[0]).Dot(dir[1]), 0);
            }
            return;
        }

        case Type::PARALLEL: {
            EntityBase *ea = SK.GetEntity(entityA), *eb = SK.GetEntity(entityB);
            ExprVector a = ea-&gt;VectorGetExprsInWorkplane(workplane);
            ExprVector b = eb-&gt;VectorGetExprsInWorkplane(workplane);

            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                // We use expressions written in workplane csys, so we can assume the workplane
                // normal is (0, 0, 1). We can write the equation as:
                //   Expr *eq = a.Cross(b).Dot(ExprVector::From(0.0, 0.0, 1.0));
                // but this will just result in elimination of x and y terms after dot product.
                // We can only use the z expression:
                //   Expr *eq = a.Cross(b).z;
                // but it's more efficient to write it in the terms of pseudo-scalar product:
                Expr *eq = (a.x-&gt;Times(b.y))-&gt;Minus(a.y-&gt;Times(b.x));
                AddEq(l, eq, 0);
            }

            return;
        }

        case Type::WHERE_DRAGGED: {
            EntityBase *ep = SK.GetEntity(ptA);
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector ev = ep-&gt;PointGetExprs();
                Vector v = ep-&gt;PointGetNum();

                AddEq(l, ev.x-&gt;Minus(Expr::From(v.x)), 0);
                AddEq(l, ev.y-&gt;Minus(Expr::From(v.y)), 1);
                AddEq(l, ev.z-&gt;Minus(Expr::From(v.z)), 2);
            } else {
                Expr *u, *v;
                ep-&gt;PointGetExprsInWorkplane(workplane, &amp;u, &amp;v);
                AddEq(l, u-&gt;Minus(Expr::From(u-&gt;Eval())), 0);
                AddEq(l, v-&gt;Minus(Expr::From(v-&gt;Eval())), 1);
            }
            return;
        }

        case Type::COMMENT:
            return;
    }
    ssassert(false, "Unexpected constraint ID");
}

</t>
<t tx="leo1.20171224221220.75">//-----------------------------------------------------------------------------
// The screens when an entity is selected, that show some description of it--
// endpoints of the lines, diameter of the circle, etc.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221220.76">void TextWindow::ScreenUnselectAll(int link, uint32_t v) {
    GraphicsWindow::MenuEdit(Command::UNSELECT_ALL);
}

</t>
<t tx="leo1.20171224221220.77">void TextWindow::ScreenEditTtfText(int link, uint32_t v) {
    hRequest hr = { v };
    Request *r = SK.GetRequest(hr);

    SS.TW.ShowEditControl(10, r-&gt;str);
    SS.TW.edit.meaning = Edit::TTF_TEXT;
    SS.TW.edit.request = hr;
}

</t>
<t tx="leo1.20171224221220.78">void TextWindow::ScreenSetTtfFont(int link, uint32_t v) {
    int i = (int)v;
    if(i &lt; 0) return;
    if(i &gt;= SS.fonts.l.n) return;

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    if(gs.entities != 1 || gs.n != 1) return;

    Entity *e = SK.entity.FindByIdNoOops(gs.entity[0]);
    if(!e || e-&gt;type != Entity::Type::TTF_TEXT || !e-&gt;h.isFromRequest()) return;

    Request *r = SK.request.FindByIdNoOops(e-&gt;h.request());
    if(!r) return;

    SS.UndoRemember();
    r-&gt;font = SS.fonts.l.elem[i].FontFileBaseName();
    SS.MarkGroupDirty(r-&gt;group);
    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221220.79">void TextWindow::ScreenConstraintShowAsRadius(int link, uint32_t v) {
    hConstraint hc = { v };
    Constraint *c = SK.GetConstraint(hc);

    SS.UndoRemember();
    c-&gt;other = !c-&gt;other;

    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221220.8">void AllocTriangle() {
    btri = (STriangle *)AllocTemporary(sizeof(STriangle));
}

</t>
<t tx="leo1.20171224221220.80">void TextWindow::DescribeSelection() {
    Printf(false, "");

    auto const &amp;gs = SS.GW.gs;
    if(gs.n == 1 &amp;&amp; (gs.points == 1 || gs.entities == 1)) {
        Entity *e = SK.GetEntity(gs.points == 1 ? gs.point[0] : gs.entity[0]);
        Vector p;

#define COSTR(p) \
    SS.MmToString((p).x).c_str(), \
    SS.MmToString((p).y).c_str(), \
    SS.MmToString((p).z).c_str()
#define PT_AS_STR "(%Fi%s%E, %Fi%s%E, %Fi%s%E)"
#define PT_AS_NUM "(%Fi%3%E, %Fi%3%E, %Fi%3%E)"
        switch(e-&gt;type) {
            case Entity::Type::POINT_IN_3D:
            case Entity::Type::POINT_IN_2D:
            case Entity::Type::POINT_N_TRANS:
            case Entity::Type::POINT_N_ROT_TRANS:
            case Entity::Type::POINT_N_COPY:
            case Entity::Type::POINT_N_ROT_AA:
                p = e-&gt;PointGetNum();
                Printf(false, "%FtPOINT%E at " PT_AS_STR, COSTR(p));
                break;

            case Entity::Type::NORMAL_IN_3D:
            case Entity::Type::NORMAL_IN_2D:
            case Entity::Type::NORMAL_N_COPY:
            case Entity::Type::NORMAL_N_ROT:
            case Entity::Type::NORMAL_N_ROT_AA: {
                Quaternion q = e-&gt;NormalGetNum();
                p = q.RotationN();
                Printf(false, "%FtNORMAL / COORDINATE SYSTEM%E");
                Printf(true,  "  basis n = " PT_AS_NUM, CO(p));
                p = q.RotationU();
                Printf(false, "        u = " PT_AS_NUM, CO(p));
                p = q.RotationV();
                Printf(false, "        v = " PT_AS_NUM, CO(p));
                break;
            }
            case Entity::Type::WORKPLANE: {
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(false, "%FtWORKPLANE%E");
                Printf(true, "   origin = " PT_AS_STR, COSTR(p));
                Quaternion q = e-&gt;Normal()-&gt;NormalGetNum();
                p = q.RotationN();
                Printf(true, "   normal = " PT_AS_NUM, CO(p));
                break;
            }
            case Entity::Type::LINE_SEGMENT: {
                Vector p0 = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                p = p0;
                Printf(false, "%FtLINE SEGMENT%E");
                Printf(true,  "   thru " PT_AS_STR, COSTR(p));
                Vector p1 = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                p = p1;
                Printf(false, "        " PT_AS_STR, COSTR(p));
                Printf(true,  "   len = %Fi%s%E",
                    SS.MmToString((p1.Minus(p0).Magnitude())).c_str());
                break;
            }
            case Entity::Type::CUBIC_PERIODIC:
            case Entity::Type::CUBIC:
                int pts;
                if(e-&gt;type == Entity::Type::CUBIC_PERIODIC) {
                    Printf(false, "%FtPERIODIC C2 CUBIC SPLINE%E");
                    pts = (3 + e-&gt;extraPoints);
                } else if(e-&gt;extraPoints &gt; 0) {
                    Printf(false, "%FtINTERPOLATING C2 CUBIC SPLINE%E");
                    pts = (4 + e-&gt;extraPoints);
                } else {
                    Printf(false, "%FtCUBIC BEZIER CURVE%E");
                    pts = 4;
                }
                for(int i = 0; i &lt; pts; i++) {
                    p = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
                    Printf((i==0), "   p%d = " PT_AS_STR, i, COSTR(p));
                }
                break;

            case Entity::Type::ARC_OF_CIRCLE: {
                Printf(false, "%FtARC OF A CIRCLE%E");
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(true,  "     center = " PT_AS_STR, COSTR(p));
                p = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                Printf(true,  "  endpoints = " PT_AS_STR, COSTR(p));
                p = SK.GetEntity(e-&gt;point[2])-&gt;PointGetNum();
                Printf(false, "              " PT_AS_STR, COSTR(p));
                double r = e-&gt;CircleGetRadiusNum();
                Printf(true, "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
                Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
                double thetas, thetaf, dtheta;
                e-&gt;ArcGetAngles(&amp;thetas, &amp;thetaf, &amp;dtheta);
                Printf(false, "    arc len =  %Fi%s", SS.MmToString(dtheta*r).c_str());
                break;
            }
            case Entity::Type::CIRCLE: {
                Printf(false, "%FtCIRCLE%E");
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(true,  "     center = " PT_AS_STR, COSTR(p));
                double r = e-&gt;CircleGetRadiusNum();
                Printf(true,  "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
                Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
                break;
            }
            case Entity::Type::FACE_NORMAL_PT:
            case Entity::Type::FACE_XPROD:
            case Entity::Type::FACE_N_ROT_TRANS:
            case Entity::Type::FACE_N_ROT_AA:
            case Entity::Type::FACE_N_TRANS:
                Printf(false, "%FtPLANE FACE%E");
                p = e-&gt;FaceGetNormalNum();
                Printf(true,  "   normal = " PT_AS_NUM, CO(p));
                p = e-&gt;FaceGetPointNum();
                Printf(false, "     thru = " PT_AS_STR, COSTR(p));
                break;

            case Entity::Type::TTF_TEXT: {
                Printf(false, "%FtTRUETYPE FONT TEXT%E");
                Printf(true, "  font = '%Fi%s%E'", e-&gt;font.c_str());
                if(e-&gt;h.isFromRequest()) {
                    Printf(false, "  text = '%Fi%s%E' %Fl%Ll%f%D[change]%E",
                        e-&gt;str.c_str(), &amp;ScreenEditTtfText, e-&gt;h.request().v);
                    Printf(true, "  select new font");
                    SS.fonts.LoadAll();
                    int i;
                    for(i = 0; i &lt; SS.fonts.l.n; i++) {
                        TtfFont *tf = &amp;(SS.fonts.l.elem[i]);
                        if(e-&gt;font == tf-&gt;FontFileBaseName()) {
                            Printf(false, "%Bp    %s",
                                (i &amp; 1) ? 'd' : 'a',
                                tf-&gt;name.c_str());
                        } else {
                            Printf(false, "%Bp    %f%D%Fl%Ll%s%E%Bp",
                                (i &amp; 1) ? 'd' : 'a',
                                &amp;ScreenSetTtfFont, i,
                                tf-&gt;name.c_str(),
                                (i &amp; 1) ? 'd' : 'a');
                        }
                    }
                } else {
                    Printf(false, "  text = '%Fi%s%E'", e-&gt;str.c_str());
                }
                break;
            }
            case Entity::Type::IMAGE: {
                Printf(false, "%FtIMAGE%E");
                Platform::Path relativePath = e-&gt;file.RelativeTo(SS.saveFile.Parent());
                if(relativePath.IsEmpty()) {
                    Printf(true, "  file = '%Fi%s%E'", e-&gt;file.raw.c_str());
                } else {
                    Printf(true, "  file = '%Fi%s%E'", relativePath.raw.c_str());
                }
                break;
            }

            default:
                Printf(true, "%Ft?? ENTITY%E");
                break;
        }

        Group *g = SK.GetGroup(e-&gt;group);
        Printf(false, "");
        Printf(false, "%FtIN GROUP%E      %s", g-&gt;DescriptionString().c_str());
        if(e-&gt;workplane.v == Entity::FREE_IN_3D.v) {
            Printf(false, "%FtNOT LOCKED IN WORKPLANE%E");
        } else {
            Entity *w = SK.GetEntity(e-&gt;workplane);
            Printf(false, "%FtIN WORKPLANE%E  %s", w-&gt;DescriptionString().c_str());
        }
        if(e-&gt;style.v) {
            Style *s = Style::Get(e-&gt;style);
            Printf(false, "%FtIN STYLE%E      %s", s-&gt;DescriptionString().c_str());
        } else {
            Printf(false, "%FtIN STYLE%E      none");
        }
        if(e-&gt;construction) {
            Printf(false, "%FtCONSTRUCTION");
        }

        std::vector&lt;hConstraint&gt; lhc = {};
        for(const Constraint &amp;c : SK.constraint) {
            if(!(c.ptA.v == e-&gt;h.v ||
                 c.ptB.v == e-&gt;h.v ||
                 c.entityA.v == e-&gt;h.v ||
                 c.entityB.v == e-&gt;h.v ||
                 c.entityC.v == e-&gt;h.v ||
                 c.entityD.v == e-&gt;h.v)) continue;
            lhc.push_back(c.h);
        }

        if(!lhc.empty()) {
            Printf(true, "%FtCONSTRAINED BY:%E");

            int a = 0;
            for(hConstraint hc : lhc) {
                Constraint *c = SK.GetConstraint(hc);
                std::string s = c-&gt;DescriptionString();
                Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E %s",
                    (a &amp; 1) ? 'd' : 'a',
                    c-&gt;h.v, (&amp;TextWindow::ScreenSelectConstraint),
                    (&amp;TextWindow::ScreenHoverConstraint), s.c_str(),
                    c-&gt;reference ? "(ref)" : "");
                a++;
            }
        }
    } else if(gs.n == 2 &amp;&amp; gs.points == 2) {
        Printf(false, "%FtTWO POINTS");
        Vector p0 = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "   at " PT_AS_STR, COSTR(p0));
        Vector p1 = SK.GetEntity(gs.point[1])-&gt;PointGetNum();
        Printf(false, "      " PT_AS_STR, COSTR(p1));
        double d = (p1.Minus(p0)).Magnitude();
        Printf(true, "  d = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.points == 1 &amp;&amp; gs.circlesOrArcs == 1) {
        Entity *ec = SK.GetEntity(gs.entity[0]);
        if(ec-&gt;type == Entity::Type::CIRCLE) {
            Printf(false, "%FtPOINT AND A CIRCLE");
        } else if(ec-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
            Printf(false, "%FtPOINT AND AN ARC");
        } else ssassert(false, "Unexpected entity type");
        Vector p = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "        pt at " PT_AS_STR, COSTR(p));
        Vector c = SK.GetEntity(ec-&gt;point[0])-&gt;PointGetNum();
        Printf(true,  "     center = " PT_AS_STR, COSTR(c));
        double r = ec-&gt;CircleGetRadiusNum();
        Printf(false, "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
        Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
        double d = (p.Minus(c)).Magnitude() - r;
        Printf(true,  "   distance = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.faces == 1 &amp;&amp; gs.points == 1) {
        Printf(false, "%FtA POINT AND A PLANE FACE");
        Vector pt = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "        point = " PT_AS_STR, COSTR(pt));
        Vector n = SK.GetEntity(gs.face[0])-&gt;FaceGetNormalNum();
        Printf(true,  " plane normal = " PT_AS_NUM, CO(n));
        Vector pl = SK.GetEntity(gs.face[0])-&gt;FaceGetPointNum();
        Printf(false, "   plane thru = " PT_AS_STR, COSTR(pl));
        double dd = n.Dot(pl) - n.Dot(pt);
        Printf(true,  "     distance = %Fi%s", SS.MmToString(dd).c_str());
    } else if(gs.n == 3 &amp;&amp; gs.points == 2 &amp;&amp; gs.vectors == 1) {
        Printf(false, "%FtTWO POINTS AND A VECTOR");
        Vector p0 = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "  pointA = " PT_AS_STR, COSTR(p0));
        Vector p1 = SK.GetEntity(gs.point[1])-&gt;PointGetNum();
        Printf(false, "  pointB = " PT_AS_STR, COSTR(p1));
        Vector v  = SK.GetEntity(gs.vector[0])-&gt;VectorGetNum();
        v = v.WithMagnitude(1);
        Printf(true,  "  vector = " PT_AS_NUM, CO(v));
        double d = (p1.Minus(p0)).Dot(v);
        Printf(true,  "  proj_d = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.points == 1) {
        Entity *ln = SK.GetEntity(gs.entity[0]);
        Vector lp0 = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
               lp1 = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
        Printf(false, "%FtLINE SEGMENT AND POINT%E");
        Printf(true,  "   ln thru " PT_AS_STR, COSTR(lp0));
        Printf(false, "           " PT_AS_STR, COSTR(lp1));
        Entity *p  = SK.GetEntity(gs.point[0]);
        Vector pp = p-&gt;PointGetNum();
        Printf(true,  "     point " PT_AS_STR, COSTR(pp));
        Printf(true,  " pt-ln distance = %Fi%s%E",
            SS.MmToString(pp.DistanceToLine(lp0, lp1.Minus(lp0))).c_str());
        hEntity wrkpl = SS.GW.ActiveWorkplane();
        if(wrkpl.v != Entity::FREE_IN_3D.v &amp;&amp;
                !(p-&gt;workplane.v == wrkpl.v &amp;&amp; ln-&gt;workplane.v == wrkpl.v)) {
            Vector ppw  = pp.ProjectInto(wrkpl);
            Vector lp0w = lp0.ProjectInto(wrkpl);
            Vector lp1w = lp1.ProjectInto(wrkpl);
            Printf(false, "    or distance = %Fi%s%E (in workplane)",
                SS.MmToString(ppw.DistanceToLine(lp0w, lp1w.Minus(lp0w))).c_str());
        }
    } else if(gs.n == 2 &amp;&amp; gs.vectors == 2) {
        Printf(false, "%FtTWO VECTORS");

        Vector v0 = SK.GetEntity(gs.entity[0])-&gt;VectorGetNum(),
               v1 = SK.GetEntity(gs.entity[1])-&gt;VectorGetNum();
        v0 = v0.WithMagnitude(1);
        v1 = v1.WithMagnitude(1);

        Printf(true,  "  vectorA = " PT_AS_NUM, CO(v0));
        Printf(false, "  vectorB = " PT_AS_NUM, CO(v1));

        double theta = acos(v0.Dot(v1));
        Printf(true,  "    angle = %Fi%2%E degrees", theta*180/PI);
        while(theta &lt; PI/2) theta += PI;
        while(theta &gt; PI/2) theta -= PI;
        Printf(false, " or angle = %Fi%2%E (mod 180)", theta*180/PI);
    } else if(gs.n == 2 &amp;&amp; gs.faces == 2) {
        Printf(false, "%FtTWO PLANE FACES");

        Vector n0 = SK.GetEntity(gs.face[0])-&gt;FaceGetNormalNum();
        Printf(true,  " planeA normal = " PT_AS_NUM, CO(n0));
        Vector p0 = SK.GetEntity(gs.face[0])-&gt;FaceGetPointNum();
        Printf(false, "   planeA thru = " PT_AS_STR, COSTR(p0));

        Vector n1 = SK.GetEntity(gs.face[1])-&gt;FaceGetNormalNum();
        Printf(true,  " planeB normal = " PT_AS_NUM, CO(n1));
        Vector p1 = SK.GetEntity(gs.face[1])-&gt;FaceGetPointNum();
        Printf(false, "   planeB thru = " PT_AS_STR, COSTR(p1));

        double theta = acos(n0.Dot(n1));
        Printf(true,  "         angle = %Fi%2%E degrees", theta*180/PI);
        while(theta &lt; PI/2) theta += PI;
        while(theta &gt; PI/2) theta -= PI;
        Printf(false, "      or angle = %Fi%2%E (mod 180)", theta*180/PI);

        if(fabs(theta) &lt; 0.01) {
            double d = (p1.Minus(p0)).Dot(n0);
            Printf(true,  "      distance = %Fi%s", SS.MmToString(d).c_str());
        }
    } else if(gs.n == 0 &amp;&amp; gs.stylables &gt; 0) {
        Printf(false, "%FtSELECTED:%E comment text");
    } else if(gs.n == 0 &amp;&amp; gs.constraints == 1) {
        Constraint *c = SK.GetConstraint(gs.constraint[0]);

        if(c-&gt;type == Constraint::Type::DIAMETER) {
            Printf(false, "%FtDIAMETER CONSTRAINT");

            Printf(true, "  %Fd%f%D%Ll%s  show as radius",
                   &amp;ScreenConstraintShowAsRadius, gs.constraint[0].v,
                   c-&gt;other ? CHECK_TRUE : CHECK_FALSE);
        } else {
            Printf(false, "%FtSELECTED:%E %s",
            c-&gt;DescriptionString().c_str());
        }

        std::vector&lt;hEntity&gt; lhe = {};
        lhe.push_back(c-&gt;ptA);
        lhe.push_back(c-&gt;ptB);
        lhe.push_back(c-&gt;entityA);
        lhe.push_back(c-&gt;entityB);
        lhe.push_back(c-&gt;entityC);
        lhe.push_back(c-&gt;entityD);

        @others
}

</t>
<t tx="leo1.20171224221220.81">    auto it = std::remove_if(lhe.begin(), lhe.end(),
        [](hEntity he) {
            return he.v == Entity::NO_ENTITY.v || !he.isFromRequest();
        });
    lhe.erase(it, lhe.end());

    if(!lhe.empty()) {
        Printf(true, "%FtCONSTRAINS:%E");

        int a = 0;
        for(hEntity he : lhe) {
            Request *r = SK.GetRequest(he.request());
            std::string s = r-&gt;DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
                (a &amp; 1) ? 'd' : 'a',
                r-&gt;h.v, (&amp;TextWindow::ScreenSelectRequest),
                &amp;(TextWindow::ScreenHoverRequest), s.c_str());
            a++;
        }
    }
} else {
    int n = SS.GW.selection.n;
    Printf(false, "%FtSELECTED:%E %d item%s", n, n == 1 ? "" : "s");
}

if(shown.screen == Screen::STYLE_INFO &amp;&amp;
   shown.style.v &gt;= Style::FIRST_CUSTOM &amp;&amp; gs.stylables &gt; 0)
{
    // If we are showing a screen for a particular style, then offer the
    // option to assign our selected entities to that style.
    Style *s = Style::Get(shown.style);
    Printf(true, "%Fl%D%f%Ll(assign to style %s)%E",
        shown.style.v,
        &amp;ScreenAssignSelectionToStyle,
        s-&gt;DescriptionString().c_str());
}
// If any of the selected entities have an assigned style, then offer
// the option to remove that style.
bool styleAssigned = false;
for(int i = 0; i &lt; gs.entities; i++) {
    Entity *e = SK.GetEntity(gs.entity[i]);
    if(e-&gt;style.v != 0) {
        styleAssigned = true;
    }
}
for(int i = 0; i &lt; gs.constraints; i++) {
    Constraint *c = SK.GetConstraint(gs.constraint[i]);
    if(c-&gt;type == Constraint::Type::COMMENT &amp;&amp; c-&gt;disp.style.v != 0) {
        styleAssigned = true;
    }
}
if(styleAssigned) {
    Printf(true, "%Fl%D%f%Ll(remove assigned style)%E",
        0,
        &amp;ScreenAssignSelectionToStyle);
}

Printf(true, "%Fl%f%Ll(unselect all)%E", &amp;TextWindow::ScreenUnselectAll);
</t>
<t tx="leo1.20171224221220.82">void TextWindow::GoToScreen(Screen screen) {
    shown.screen = screen;
}

</t>
<t tx="leo1.20171224221220.9">void AllocTriangles() {
    btri = (STriangle *)AllocTemporary(sizeof(STriangle) * 2);
    ctri = &amp;btri[1];
}

</t>
<t tx="leo1.20171224221221.1">//-----------------------------------------------------------------------------
// The root function to paint our graphics window, after setting up all the
// views and such appropriately. Also contains all the stuff to manage the
// selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221221.10">bool GraphicsWindow::IsSelected(hEntity he) {
    Selection s = {};
    s.entity = he;
    return IsSelected(&amp;s);
}
</t>
<t tx="leo1.20171224221221.100">void VectorFileWriter::BezierAsNonrationalCubic(SBezier *sb, int depth) {
    Vector t0 = sb-&gt;TangentAt(0), t1 = sb-&gt;TangentAt(1);
    // The curve is correct, and the first derivatives are correct, at the
    // endpoints.
    SBezier bnr = SBezier::From(
                        sb-&gt;Start(),
                        sb-&gt;Start().Plus(t0.ScaledBy(1.0/3)),
                        sb-&gt;Finish().Minus(t1.ScaledBy(1.0/3)),
                        sb-&gt;Finish());

    double tol = SS.ExportChordTolMm();
    // Arbitrary choice, but make it a little finer than pwl tolerance since
    // it should be easier to achieve that with the smooth curves.
    tol /= 2;

    bool closeEnough = true;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        double t = i/4.0;
        Vector p0 = sb-&gt;PointAt(t),
               pn = bnr.PointAt(t);
        double d = (p0.Minus(pn)).Magnitude();
        if(d &gt; tol) {
            closeEnough = false;
        }
    }

    if(closeEnough || depth &gt; 3) {
        Bezier(&amp;bnr);
    } else {
        SBezier bef, aft;
        sb-&gt;SplitAt(0.5, &amp;bef, &amp;aft);
        BezierAsNonrationalCubic(&amp;bef, depth+1);
        BezierAsNonrationalCubic(&amp;aft, depth+1);
    }
}

//-----------------------------------------------------------------------------
// Export a triangle mesh, in the requested format.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.101">void SolveSpaceUI::ExportMeshTo(const Platform::Path &amp;filename) {
    SS.exportMode = true;
    GenerateAll(Generate::ALL);

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    g-&gt;GenerateDisplayItems();

    SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
    if(m-&gt;IsEmpty()) {
        Error(_("Active group mesh is empty; nothing to export."));
        return;
    }

    FILE *f = OpenFile(filename, "wb");
    if(!f) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return;
    }
    ShowNakedEdges(/*reportOnlyWhenNotOkay=*/true);
    if(filename.HasExtension("stl")) {
        ExportMeshAsStlTo(f, m);
    } else if(filename.HasExtension("obj")) {
        Platform::Path mtlFilename = filename.WithExtension("mtl");
        FILE *fMtl = OpenFile(mtlFilename, "wb");
        if(!fMtl) {
            Error("Couldn't write to '%s'", filename.raw.c_str());
            return;
        }

        fprintf(f, "mtllib %s\n", mtlFilename.FileName().c_str());
        ExportMeshAsObjTo(f, fMtl, m);

        fclose(fMtl);
    } else if(filename.HasExtension("js") ||
              filename.HasExtension("html")) {
        SOutlineList *e = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayOutlines);
        ExportMeshAsThreeJsTo(f, filename, m, e);
    } else {
        Error("Can't identify output file type from file extension of "
              "filename '%s'; try .stl, .obj, .js, .html.", filename.raw.c_str());
    }

    fclose(f);

    SS.justExportedInfo.showOrigin = false;
    SS.justExportedInfo.draw = true;
    InvalidateGraphics();
}

//-----------------------------------------------------------------------------
// Export the mesh as an STL file; it should always be vertex-to-vertex and
// not self-intersecting, so not much to do.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.102">void SolveSpaceUI::ExportMeshAsStlTo(FILE *f, SMesh *sm) {
    char str[80] = {};
    strcpy(str, "STL exported mesh");
    fwrite(str, 1, 80, f);

    uint32_t n = sm-&gt;l.n;
    fwrite(&amp;n, 4, 1, f);

    double s = SS.exportScale;
    int i;
    for(i = 0; i &lt; sm-&gt;l.n; i++) {
        STriangle *tr = &amp;(sm-&gt;l.elem[i]);
        Vector n = tr-&gt;Normal().WithMagnitude(1);
        float w;
        w = (float)n.x;           fwrite(&amp;w, 4, 1, f);
        w = (float)n.y;           fwrite(&amp;w, 4, 1, f);
        w = (float)n.z;           fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.z)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.z)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.z)/s); fwrite(&amp;w, 4, 1, f);
        fputc(0, f);
        fputc(0, f);
    }
}

//-----------------------------------------------------------------------------
// Export the mesh as Wavefront OBJ format. This requires us to reduce all the
// identical vertices to the same identifier, so do that first.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.103">void SolveSpaceUI::ExportMeshAsObjTo(FILE *fObj, FILE *fMtl, SMesh *sm) {
    std::map&lt;RgbaColor, std::string, RgbaColorCompare&gt; colors;
    for(const STriangle &amp;t : sm-&gt;l) {
        RgbaColor color = t.meta.color;
        if(colors.find(color) == colors.end()) {
            std::string id = ssprintf("h%02x%02x%02x",
                                      color.red,
                                      color.green,
                                      color.blue);
            colors.emplace(color, id);
        }
        for(int i = 0; i &lt; 3; i++) {
            fprintf(fObj, "v %.10f %.10f %.10f\n",
                    CO(t.vertices[i].ScaledBy(1 / SS.exportScale)));
        }
    }

    for(auto &amp;it : colors) {
        fprintf(fMtl, "newmtl %s\n",
                it.second.c_str());
        fprintf(fMtl, "Kd %.3f %.3f %.3f\n",
                it.first.redF(), it.first.greenF(), it.first.blueF());
    }

    for(const STriangle &amp;t : sm-&gt;l) {
        for(int i = 0; i &lt; 3; i++) {
            Vector n = t.normals[i].WithMagnitude(1.0);
            fprintf(fObj, "vn %.10f %.10f %.10f\n",
                    CO(n));
        }
    }

    RgbaColor currentColor = {};
    for(int i = 0; i &lt; sm-&gt;l.n; i++) {
        const STriangle &amp;t = sm-&gt;l.elem[i];
        if(!currentColor.Equals(t.meta.color)) {
            currentColor = t.meta.color;
            fprintf(fObj, "usemtl %s\n", colors[currentColor].c_str());
        }

        fprintf(fObj, "f %d//%d %d//%d %d//%d\n",
                i * 3 + 1, i * 3 + 1,
                i * 3 + 2, i * 3 + 2,
                i * 3 + 3, i * 3 + 3);
    }
}

//-----------------------------------------------------------------------------
// Export the mesh as a JavaScript script, which is compatible with Three.js.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.104">void SolveSpaceUI::ExportMeshAsThreeJsTo(FILE *f, const Platform::Path &amp;filename,
                                         SMesh *sm, SOutlineList *sol)
{
    SPointList spl = {};
    STriangle *tr;
    Vector bndl, bndh;
    const char htmlbegin[] = R"(
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
)";
    const char htmlend[] = R"(

    // A default three.js viewer with OrthographicTrackballControls is
    // generated as a comment preceding the data.

    // x bounds should be the range of x or y, whichever
    // is larger, before aspect ratio correction is applied.
    // y bounds should be the range of x or y, whichever is
    // larger. No aspect ratio correction is applied.
    // Near plane should be 1.
    // Camera's z-position should be the range of z + 1 or the larger of
    // the x or y bounds, whichever is larger.
    // Far plane should be at least twice as much as the camera's
    // z-position.
    // Edge projection bias should be about 1/500 of the far plane's distance.
    // Further corrections will be applied to the z-position and far plane in
    // the default viewer, but the defaults are fine for a model which
    // only rotates about the world origin.

    sm-&gt;GetBounding(&amp;bndh, &amp;bndl);
    double largerBoundXY = max((bndh.x - bndl.x), (bndh.y - bndl.y));
    double largerBoundZ = max(largerBoundXY, (bndh.z - bndl.z + 1));

    std::string basename = filename.FileStem();
    for(size_t i = 0; i &lt; basename.length(); i++) {
        if(!(isalnum(basename[i]) || ((unsigned)basename[i] &gt;= 0x80))) {
            basename[i] = '_';
        }
    }

    if(filename.HasExtension("html")) {
        fprintf(f, htmlbegin,
                LoadStringFromGzip("threejs/three-r76.js.gz").c_str(),
                LoadStringFromGzip("threejs/hammer-2.0.8.js.gz").c_str(),
                LoadString("threejs/SolveSpaceControls.js").c_str());
    }

    fprintf(f, "var solvespace_model_%s = {\n"
               "  bounds: {\n"
               "    x: %f, y: %f, near: %f, far: %f, z: %f, edgeBias: %f\n"
               "  },\n",
            basename.c_str(),
            largerBoundXY,
            largerBoundXY,
            1.0,
            largerBoundZ * 2,
            largerBoundZ,
            largerBoundZ / 250);

    // Output lighting information.
    fputs("  lights: {\n"
          "    d: [\n", f);

    // Directional.
    int lightCount;
    for(lightCount = 0; lightCount &lt; 2; lightCount++) {
        fprintf(f, "      {\n"
                   "        intensity: %f, direction: [%f, %f, %f]\n"
                   "      },\n",
                SS.lightIntensity[lightCount],
                CO(SS.lightDir[lightCount]));
    }

    // Global Ambience.
    fprintf(f, "    ],\n"
               "    a: %f\n", SS.ambientIntensity);

    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        spl.IncrementTagFor(tr-&gt;a);
        spl.IncrementTagFor(tr-&gt;b);
        spl.IncrementTagFor(tr-&gt;c);
    }

    // Output all the vertices.
    SPoint *sp;
    fputs("  },\n"
          "  points: [\n", f);
    for(sp = spl.l.First(); sp; sp = spl.l.NextAfter(sp)) {
        fprintf(f, "    [%f, %f, %f],\n",
                sp-&gt;p.x / SS.exportScale,
                sp-&gt;p.y / SS.exportScale,
                sp-&gt;p.z / SS.exportScale);
    }

    fputs("  ],\n"
          "  faces: [\n", f);
    // And now all the triangular faces, in terms of those vertices.
    // This time we count from zero.
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    [%d, %d, %d],\n",
                spl.IndexForPoint(tr-&gt;a),
                spl.IndexForPoint(tr-&gt;b),
                spl.IndexForPoint(tr-&gt;c));
    }

    // Output face normals.
    fputs("  ],\n"
          "  normals: [\n", f);
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    [[%f, %f, %f], [%f, %f, %f], [%f, %f, %f]],\n",
                CO(tr-&gt;an), CO(tr-&gt;bn), CO(tr-&gt;cn));
    }

    fputs("  ],\n"
          "  colors: [\n", f);
    // Output triangle colors.
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    0x%x,\n", tr-&gt;meta.color.ToARGB32());
    }

    fputs("  ],\n"
          "  edges: [\n", f);
    // Output edges. Assume user's model colors do not obscure white edges.
    for(const SOutline &amp;so : sol-&gt;l) {
        if(so.tag == 0) continue;
        fprintf(f, "    [[%f, %f, %f], [%f, %f, %f]],\n",
                so.a.x / SS.exportScale,
                so.a.y / SS.exportScale,
                so.a.z / SS.exportScale,
                so.b.x / SS.exportScale,
                so.b.y / SS.exportScale,
                so.b.z / SS.exportScale);
    }

    fputs("  ]\n};\n", f);

    if(filename.HasExtension("html")) {
        fprintf(f, htmlend,
                basename.c_str(),
                SS.GW.scale,
                CO(SS.GW.offset),
                CO(SS.GW.projUp),
                CO(SS.GW.projRight));
    }

    spl.Clear();
}

//-----------------------------------------------------------------------------
// Export a view of the model as an image; we just take a screenshot, by
// rendering the view in the usual way and then copying the pixels.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.105">void SolveSpaceUI::ExportAsPngTo(const Platform::Path &amp;filename) {
    screenshotFile = filename;
    // The rest of the work is done in the next redraw.
    InvalidateGraphics();
}
</t>
<t tx="leo1.20171224221221.11">bool GraphicsWindow::IsSelected(Selection *st) {
    Selection *s;
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;Equals(st)) {
            return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------
// Unselect an item, if it is selected. We can either unselect just that item,
// or also unselect any coincident points. The latter is useful if the user
// somehow selects two coincident points (like with select all), because it
// would otherwise be impossible to de-select the lower of the two.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.12">void GraphicsWindow::MakeUnselected(hEntity he, bool coincidentPointTrick) {
    Selection stog = {};
    stog.entity = he;
    MakeUnselected(&amp;stog, coincidentPointTrick);
}
</t>
<t tx="leo1.20171224221221.13">void GraphicsWindow::MakeUnselected(Selection *stog, bool coincidentPointTrick){
    if(stog-&gt;IsEmpty()) return;

    Selection *s;

    // If an item was selected, then we just un-select it.
    selection.ClearTags();
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;Equals(stog)) {
            s-&gt;tag = 1;
        }
    }
    // If two points are coincident, then it's impossible to hover one of
    // them. But make sure to deselect both, to avoid mysterious seeming
    // inability to deselect if the bottom one did somehow get selected.
    if(stog-&gt;entity.v &amp;&amp; coincidentPointTrick) {
        Entity *e = SK.GetEntity(stog-&gt;entity);
        if(e-&gt;IsPoint()) {
            Vector ep = e-&gt;PointGetNum();
            for(s = selection.First(); s; s = selection.NextAfter(s)) {
                if(!s-&gt;entity.v) continue;
                if(s-&gt;entity.v == stog-&gt;entity.v) continue;
                Entity *se = SK.GetEntity(s-&gt;entity);
                if(!se-&gt;IsPoint()) continue;
                if(ep.Equals(se-&gt;PointGetNum())) {
                    s-&gt;tag = 1;
                }
            }
        }
    }
    selection.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Select an item, if it isn't selected already.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.14">void GraphicsWindow::MakeSelected(hEntity he) {
    Selection stog = {};
    stog.entity = he;
    MakeSelected(&amp;stog);
}

</t>
<t tx="leo1.20171224221221.15">void GraphicsWindow::MakeSelected(hConstraint hc) {
    Selection stog = {};
    stog.constraint = hc;
    MakeSelected(&amp;stog);
}

</t>
<t tx="leo1.20171224221221.16">void GraphicsWindow::MakeSelected(Selection *stog) {
    if(stog-&gt;IsEmpty()) return;
    if(IsSelected(stog)) return;

    if(stog-&gt;entity.v != 0 &amp;&amp; SK.GetEntity(stog-&gt;entity)-&gt;IsFace()) {
        // In the interest of speed for the triangle drawing code,
        // only two faces may be selected at a time.
        int c = 0;
        Selection *s;
        selection.ClearTags();
        for(s = selection.First(); s; s = selection.NextAfter(s)) {
            hEntity he = s-&gt;entity;
            if(he.v != 0 &amp;&amp; SK.GetEntity(he)-&gt;IsFace()) {
                c++;
                if(c &gt;= 2) s-&gt;tag = 1;
            }
        }
        selection.RemoveTagged();
    }

    selection.Add(stog);
}

//-----------------------------------------------------------------------------
// Select everything that lies within the marquee view-aligned rectangle.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.17">void GraphicsWindow::SelectByMarquee() {
    Point2d marqueePoint = ProjectPoint(orig.marqueePoint);
    BBox marqueeBBox = BBox::From(Vector::From(marqueePoint.x, marqueePoint.y, -1),
                                  Vector::From(orig.mouse.x,   orig.mouse.y,    1));

    Entity *e;
    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(e-&gt;group.v != SS.GW.activeGroup.v) continue;
        if(e-&gt;IsFace() || e-&gt;IsDistance()) continue;
        if(!e-&gt;IsVisible()) continue;

        bool entityHasBBox;
        BBox entityBBox = e-&gt;GetOrGenerateScreenBBox(&amp;entityHasBBox);
        if(entityHasBBox &amp;&amp; entityBBox.Overlaps(marqueeBBox)) {
            MakeSelected(e-&gt;h);
        }
    }
}

//-----------------------------------------------------------------------------
// Sort the selection according to various critieria: the entities and
// constraints separately, counts of certain types of entities (circles,
// lines, etc.), and so on.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.18">void GraphicsWindow::GroupSelection() {
    gs = {};
    int i;
    for(i = 0; i &lt; selection.n; i++) {
        Selection *s = &amp;(selection.elem[i]);
        if(s-&gt;entity.v) {
            (gs.n)++;

            Entity *e = SK.entity.FindById(s-&gt;entity);

            if(e-&gt;IsStylable()) gs.stylables++;

            // A list of points, and a list of all entities that aren't points.
            if(e-&gt;IsPoint()) {
                gs.points++;
                gs.point.push_back(s-&gt;entity);
            } else {
                gs.entities++;
                gs.entity.push_back(s-&gt;entity);
            }

            // And an auxiliary list of normals, including normals from
            // workplanes.
            if(e-&gt;IsNormal()) {
                gs.anyNormals++;
                gs.anyNormal.push_back(s-&gt;entity);
            } else if(e-&gt;IsWorkplane()) {
                gs.anyNormals++;
                gs.anyNormal.push_back(e-&gt;Normal()-&gt;h);
            }

            // And of vectors (i.e., stuff with a direction to constrain)
            if(e-&gt;HasVector()) {
                gs.vectors++;
                gs.vector.push_back(s-&gt;entity);
            }

            // Faces (which are special, associated/drawn with triangles)
            if(e-&gt;IsFace()) {
                gs.faces++;
                gs.face.push_back(s-&gt;entity);
            }

            if(e-&gt;HasEndpoints()) {
                (gs.withEndpoints)++;
            }

            // And some aux counts too
            switch(e-&gt;type) {
                case Entity::Type::WORKPLANE:      (gs.workplanes)++; break;
                case Entity::Type::LINE_SEGMENT:   (gs.lineSegments)++; break;
                case Entity::Type::CUBIC:          (gs.cubics)++; break;
                case Entity::Type::CUBIC_PERIODIC: (gs.periodicCubics)++; break;

                case Entity::Type::ARC_OF_CIRCLE:
                    (gs.circlesOrArcs)++;
                    (gs.arcs)++;
                    break;

                case Entity::Type::CIRCLE:         (gs.circlesOrArcs)++; break;

                default: break;
            }
        }
        if(s-&gt;constraint.v) {
            gs.constraints++;
            gs.constraint.push_back(s-&gt;constraint);
            Constraint *c = SK.GetConstraint(s-&gt;constraint);
            if(c-&gt;IsStylable()) gs.stylables++;
            if(c-&gt;HasLabel()) gs.constraintLabels++;
        }
    }
}

Camera GraphicsWindow::GetCamera() const {
    Camera camera = {};
    camera.width     = (int)width;
    camera.height    = (int)height;
    camera.offset    = offset;
    camera.projUp    = projUp;
    camera.projRight = projRight;
    camera.scale     = scale;
    camera.tangent   = SS.CameraTangent();
    camera.hasPixels = true;
    return camera;
}

Lighting GraphicsWindow::GetLighting() const {
    Lighting lighting = {};
    lighting.backgroundColor   = SS.backgroundColor;
    lighting.ambientIntensity  = SS.ambientIntensity;
    lighting.lightIntensity[0] = SS.lightIntensity[0];
    lighting.lightIntensity[1] = SS.lightIntensity[1];
    lighting.lightDirection[0] = SS.lightDir[0];
    lighting.lightDirection[1] = SS.lightDir[1];
    return lighting;
}

GraphicsWindow::Selection GraphicsWindow::ChooseFromHoverToSelect() {
    Selection sel = {};
    if(hoverList.n == 0) return sel;

    Group *activeGroup = SK.GetGroup(SS.GW.activeGroup);
    int bestOrder = -1;
    int bestZIndex;
    for(const Hover &amp;hov : hoverList) {
        hGroup hg = {};
        if(hov.selection.entity.v != 0) {
            hg = SK.GetEntity(hov.selection.entity)-&gt;group;
        } else if(hov.selection.constraint.v != 0) {
            hg = SK.GetConstraint(hov.selection.constraint)-&gt;group;
        }

        Group *g = SK.GetGroup(hg);
        if(g-&gt;order &gt; activeGroup-&gt;order) continue;
        if(bestOrder != -1 &amp;&amp; (bestOrder &gt;= g-&gt;order || bestZIndex &gt; hov.zIndex)) continue;
        bestOrder  = g-&gt;order;
        bestZIndex = hov.zIndex;
        sel = hov.selection;
    }
    return sel;
}

GraphicsWindow::Selection GraphicsWindow::ChooseFromHoverToDrag() {
    Selection sel = {};
    for(const Hover &amp;hov : hoverList) {
        if(hov.selection.entity.v == 0) continue;
        if(!hov.selection.entity.isFromRequest()) continue;
        sel = hov.selection;
        break;
    }
    if(!sel.IsEmpty()) {
        return sel;
    }
    return ChooseFromHoverToSelect();
}

</t>
<t tx="leo1.20171224221221.19">void GraphicsWindow::HitTestMakeSelection(Point2d mp) {
    hoverList = {};
    Selection sel = {};

    // Did the view projection change? If so, invalidate bounding boxes.
    if(!offset.EqualsExactly(cached.offset) ||
           !projRight.EqualsExactly(cached.projRight) ||
           !projUp.EqualsExactly(cached.projUp) ||
           EXACT(scale != cached.scale)) {
        cached.offset = offset;
        cached.projRight = projRight;
        cached.projUp = projUp;
        cached.scale = scale;
        for(Entity *e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
            e-&gt;screenBBoxValid = false;
        }
    }

    ObjectPicker canvas = {};
    canvas.camera    = GetCamera();
    canvas.selRadius = 10.0;
    canvas.point     = mp;
    canvas.maxZIndex = -1;

    // Always do the entities; we might be dragging something that should
    // be auto-constrained, and we need the hover for that.
    for(Entity &amp;e : SK.entity) {
        if(!e.IsVisible()) continue;

        // If faces aren't selectable, image entities aren't either.
        if(e.type == Entity::Type::IMAGE &amp;&amp; !showFaces) continue;

        // Don't hover whatever's being dragged.
        if(IsFromPending(e.h.request())) {
            // The one exception is when we're creating a new cubic; we
            // want to be able to hover the first point, because that's
            // how we turn it into a periodic spline.
            if(!e.IsPoint()) continue;
            if(!e.h.isFromRequest()) continue;
            Request *r = SK.GetRequest(e.h.request());
            if(r-&gt;type != Request::Type::CUBIC) continue;
            if(r-&gt;extraPoints &lt; 2) continue;
            if(e.h.v != r-&gt;h.entity(1).v) continue;
        }

        if(canvas.Pick([&amp;]{ e.Draw(Entity::DrawAs::DEFAULT, &amp;canvas); })) {
            Hover hov = {};
            hov.distance = canvas.minDistance;
            hov.zIndex   = canvas.maxZIndex;
            hov.selection.entity = e.h;
            hoverList.Add(&amp;hov);
        }
    }

    // The constraints and faces happen only when nothing's in progress.
    if(pending.operation == Pending::NONE) {
        // Constraints
        for(Constraint &amp;c : SK.constraint) {
            if(canvas.Pick([&amp;]{ c.Draw(Constraint::DrawAs::DEFAULT, &amp;canvas); })) {
                Hover hov = {};
                hov.distance = canvas.minDistance;
                hov.zIndex   = canvas.maxZIndex;
                hov.selection.constraint = c.h;
                hoverList.Add(&amp;hov);
            }
        }
    }

    std::sort(hoverList.begin(), hoverList.end(),
        [](const Hover &amp;a, const Hover &amp;b) {
            if(a.zIndex == b.zIndex) return a.distance &lt; b.distance;
            return a.zIndex &gt; b.zIndex;
        });
    sel = ChooseFromHoverToSelect();

    if(pending.operation == Pending::NONE) {
        // Faces, from the triangle mesh; these are lowest priority
        if(sel.constraint.v == 0 &amp;&amp; sel.entity.v == 0 &amp;&amp; showShaded &amp;&amp; showFaces) {
            Group *g = SK.GetGroup(activeGroup);
            SMesh *m = &amp;(g-&gt;displayMesh);

            uint32_t v = m-&gt;FirstIntersectionWith(mp);
            if(v) {
                sel.entity.v = v;
            }
        }
    }

    canvas.Clear();

    if(!sel.Equals(&amp;hover)) {
        hover = sel;
        InvalidateGraphics();
    }
}

//-----------------------------------------------------------------------------
// Project a point in model space to screen space, exactly as gl would; return
// units are pixels.
//-----------------------------------------------------------------------------
Point2d GraphicsWindow::ProjectPoint(Vector p) {
    Vector p3 = ProjectPoint3(p);
    Point2d p2 = { p3.x, p3.y };
    return p2;
}
//-----------------------------------------------------------------------------
// Project a point in model space to screen space, exactly as gl would; return
// units are pixels. The z coordinate is also returned, also in pixels.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::ProjectPoint3(Vector p) {
    double w;
    Vector r = ProjectPoint4(p, &amp;w);
    return r.ScaledBy(scale/w);
}
//-----------------------------------------------------------------------------
// Project a point in model space halfway into screen space. The scale is
// not applied, and the perspective divide isn't applied; instead the w
// coordinate is returned separately.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::ProjectPoint4(Vector p, double *w) {
    p = p.Plus(offset);

    Vector r;
    r.x = p.Dot(projRight);
    r.y = p.Dot(projUp);
    r.z = p.Dot(projUp.Cross(projRight));

    *w = 1 + r.z*SS.CameraTangent()*scale;
    return r;
}

//-----------------------------------------------------------------------------
// Return a point in the plane parallel to the screen and through the offset,
// that projects onto the specified (x, y) coordinates.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::UnProjectPoint(Point2d p) {
    Vector orig = offset.ScaledBy(-1);

    // Note that we ignoring the effects of perspective. Since our returned
    // point has the same component normal to the screen as the offset, it
    // will have z = 0 after the rotation is applied, thus w = 1. So this is
    // correct.
    orig = orig.Plus(projRight.ScaledBy(p.x / scale)).Plus(
                     projUp.   ScaledBy(p.y / scale));
    return orig;
}

Vector GraphicsWindow::UnProjectPoint3(Vector p) {
    p.z = p.z / (scale - p.z * SS.CameraTangent() * scale);
    double w = 1 + p.z * SS.CameraTangent() * scale;
    p.x *= w / scale;
    p.y *= w / scale;

    Vector orig = offset.ScaledBy(-1);
    orig = orig.Plus(projRight.ScaledBy(p.x)).Plus(
                     projUp.   ScaledBy(p.y).Plus(
                     projRight.Cross(projUp). ScaledBy(p.z)));
    return orig;
}

</t>
<t tx="leo1.20171224221221.2">bool GraphicsWindow::Selection::Equals(Selection *b) {
    if(entity.v     != b-&gt;entity.v)     return false;
    if(constraint.v != b-&gt;constraint.v) return false;
    return true;
}

</t>
<t tx="leo1.20171224221221.20">void GraphicsWindow::NormalizeProjectionVectors() {
    if(projRight.Magnitude() &lt; LENGTH_EPS) {
        projRight = Vector::From(1, 0, 0);
    }

    Vector norm = projRight.Cross(projUp);
    // If projRight and projUp somehow ended up parallel, then pick an
    // arbitrary projUp normal to projRight.
    if(norm.Magnitude() &lt; LENGTH_EPS) {
        norm = projRight.Normal(0);
    }
    projUp = norm.Cross(projRight);

    projUp = projUp.WithMagnitude(1);
    projRight = projRight.WithMagnitude(1);
}

</t>
<t tx="leo1.20171224221221.21">void GraphicsWindow::DrawSnapGrid(Canvas *canvas) {
    if(!LockedInWorkplane()) return;

    hEntity he = ActiveWorkplane();
    EntityBase *wrkpl = SK.GetEntity(he),
               *norm  = wrkpl-&gt;Normal();
    Vector n = projUp.Cross(projRight);
    Vector wu, wv, wn, wp;
    wp = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();
    wu = norm-&gt;NormalU();
    wv = norm-&gt;NormalV();
    wn = norm-&gt;NormalN();

    double g = SS.gridSpacing;

    @others
}

</t>
<t tx="leo1.20171224221221.22">double umin = VERY_POSITIVE, umax = VERY_NEGATIVE,
       vmin = VERY_POSITIVE, vmax = VERY_NEGATIVE;
int a;
for(a = 0; a &lt; 4; a++) {
    // Ideally, we would just do +/- half the width and height; but
    // allow some extra slop for rounding.
    Vector horiz = projRight.ScaledBy((0.6*width)/scale  + 2*g),
           vert  = projUp.   ScaledBy((0.6*height)/scale + 2*g);
    if(a == 2 || a == 3) horiz = horiz.ScaledBy(-1);
    if(a == 1 || a == 3) vert  = vert. ScaledBy(-1);
    Vector tp = horiz.Plus(vert).Minus(offset);

    // Project the point into our grid plane, normal to the screen
    // (not to the grid plane). If the plane is on edge then this is
    // impossible so don't try to draw the grid.
    bool parallel;
    Vector tpp = Vector::AtIntersectionOfPlaneAndLine(
                                    wn, wn.Dot(wp),
                                    tp, tp.Plus(n),
                                    &amp;parallel);
    if(parallel) return;

    tpp = tpp.Minus(wp);
    double uu = tpp.Dot(wu),
i0 = (int)(umin / g);
i1 = (int)(umax / g);
j0 = (int)(vmin / g);
j1 = (int)(vmax / g);

if(i0 &gt; i1 || i1 - i0 &gt; 400) return;
if(j0 &gt; j1 || j1 - j0 &gt; 400) return;

Canvas::Stroke stroke = {};
stroke.layer  = Canvas::Layer::BACK;
stroke.color  = Style::Color(Style::DATUM).WithAlpha(75);
stroke.unit   = Canvas::Unit::PX;
stroke.width  = 1.0f;
Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

for(i = i0 + 1; i &lt; i1; i++) {
    canvas-&gt;DrawLine(wp.Plus(wu.ScaledBy(i*g)).Plus(wv.ScaledBy(j0*g)),
                     wp.Plus(wu.ScaledBy(i*g)).Plus(wv.ScaledBy(j1*g)),
                     hcs);
}
for(j = j0 + 1; j &lt; j1; j++) {
    canvas-&gt;DrawLine(wp.Plus(wu.ScaledBy(i0*g)).Plus(wv.ScaledBy(j*g)),
                     wp.Plus(wu.ScaledBy(i1*g)).Plus(wv.ScaledBy(j*g)),
                     hcs);
}
</t>
<t tx="leo1.20171224221221.23">void GraphicsWindow::DrawEntities(Canvas *canvas, bool persistent) {
    for(Entity &amp;e : SK.entity) {
        if(persistent == (e.IsNormal() || e.IsWorkplane())) continue;
        switch(SS.GW.drawOccludedAs) {
            case DrawOccludedAs::VISIBLE:
                e.Draw(Entity::DrawAs::OVERLAY, canvas);
                break;

            case DrawOccludedAs::STIPPLED:
                e.Draw(Entity::DrawAs::HIDDEN, canvas);
                /* fallthrough */
            case DrawOccludedAs::INVISIBLE:
                e.Draw(Entity::DrawAs::DEFAULT, canvas);
                break;
        }
    }
}

</t>
<t tx="leo1.20171224221221.24">void GraphicsWindow::DrawPersistent(Canvas *canvas) {
    // Draw the active group; this does stuff like the mesh and edges.
    SK.GetGroup(activeGroup)-&gt;Draw(canvas);

    // Now draw the entities that don't change with viewport.
    DrawEntities(canvas, /*persistent=*/true);

    // Draw filled paths in all groups, when those filled paths were requested
    // specially by assigning a style with a fill color, or when the filled
    // paths are just being filled by default. This should go last, to make
    // the transparency work.
    for(hGroup hg : SK.groupOrder) {
        Group *g = SK.GetGroup(hg);
        if(!(g-&gt;IsVisible())) continue;
        g-&gt;DrawFilledPaths(canvas);
    }
}

</t>
<t tx="leo1.20171224221221.25">void GraphicsWindow::Draw(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    // Nasty case when we're reloading the linked files; could be that
    // we get an error, so a dialog pops up, and a message loop starts, and
    // we have to get called to paint ourselves. If the sketch is screwed
    // up, then we could trigger an oops trying to draw.
    if(!SS.allConsistent) return;

    if(showSnapGrid) DrawSnapGrid(canvas);

    // Draw all the things that don't change when we rotate.
    if(persistentCanvas != NULL) {
        if(persistentDirty) {
            persistentDirty = false;

            persistentCanvas-&gt;Clear();
            DrawPersistent(&amp;*persistentCanvas);
            persistentCanvas-&gt;Finalize();
        }

        persistentCanvas-&gt;Draw();
    } else {
        DrawPersistent(canvas);
    }

    // Draw the entities that do change with viewport.
    DrawEntities(canvas, /*persistent=*/false);

    // Draw the polygon errors.
    if(SS.checkClosedContour) {
        SK.GetGroup(activeGroup)-&gt;DrawPolyError(canvas);
    }

    // Draw the constraints
    for(Constraint &amp;c : SK.constraint) {
        c.Draw(Constraint::DrawAs::DEFAULT, canvas);
    }

    // Draw areas
    if(SS.showContourAreas) {
        for(hGroup hg : SK.groupOrder) {
            Group *g = SK.GetGroup(hg);
            if(g-&gt;h.v != activeGroup.v) continue;
            if(!(g-&gt;IsVisible())) continue;
            g-&gt;DrawContourAreaLabels(canvas);
        }
    }

    // Draw the "pending" constraint, i.e. a constraint that would be
    // placed on a line that is almost horizontal or vertical.
    if(SS.GW.pending.operation == Pending::DRAGGING_NEW_LINE_POINT &amp;&amp;
            SS.GW.pending.hasSuggestion) {
        Constraint c = {};
        c.group = SS.GW.activeGroup;
        c.workplane = SS.GW.ActiveWorkplane();
        c.type = SS.GW.pending.suggestion;
        c.entityA = SS.GW.pending.request.entity(0);
        c.Draw(Constraint::DrawAs::DEFAULT, canvas);
    }

    Canvas::Stroke strokeAnalyze = Style::Stroke(Style::ANALYZE);
    strokeAnalyze.layer = Canvas::Layer::FRONT;
    Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(strokeAnalyze);

    // Draw the traced path, if one exists
    SEdgeList tracedEdges = {};
    SS.traced.path.MakeEdgesInto(&amp;tracedEdges);
    canvas-&gt;DrawEdges(tracedEdges, hcsAnalyze);
    tracedEdges.Clear();

    Canvas::Stroke strokeError = Style::Stroke(Style::DRAW_ERROR);
    strokeError.layer = Canvas::Layer::FRONT;
    strokeError.width = 12;
    Canvas::hStroke hcsError = canvas-&gt;GetStroke(strokeError);

    // And the naked edges, if the user did Analyze -&gt; Show Naked Edges.
    canvas-&gt;DrawEdges(SS.nakedEdges, hcsError);

    // Then redraw whatever the mouse is hovering over, highlighted.
    hover.Draw(/*isHovered=*/true, canvas);
    SK.GetGroup(activeGroup)-&gt;DrawMesh(Group::DrawMeshAs::HOVERED, canvas);

    // And finally draw the selection, same mechanism.
    for(Selection *s = selection.First(); s; s = selection.NextAfter(s)) {
        s-&gt;Draw(/*isHovered=*/false, canvas);
    }
    SK.GetGroup(activeGroup)-&gt;DrawMesh(Group::DrawMeshAs::SELECTED, canvas);

    Canvas::Stroke strokeDatum = Style::Stroke(Style::DATUM);
    strokeDatum.unit  = Canvas::Unit::PX;
    strokeDatum.layer = Canvas::Layer::FRONT;
    strokeDatum.width = 1;
    Canvas::hStroke hcsDatum = canvas-&gt;GetStroke(strokeDatum);

    // An extra line, used to indicate the origin when rotating within the
    // plane of the monitor.
    if(SS.extraLine.draw) {
        canvas-&gt;DrawLine(SS.extraLine.ptA, SS.extraLine.ptB, hcsDatum);
    }

    if(SS.centerOfMass.draw &amp;&amp; !SS.centerOfMass.dirty) {
        Vector p = SS.centerOfMass.position;
        Vector u = camera.projRight;
        Vector v = camera.projUp;

        const double size = 10.0;
        const int subdiv = 16;
        double h = Style::DefaultTextHeight() / camera.scale;
        canvas-&gt;DrawVectorText(ssprintf("%.3f, %.3f, %.3f", p.x, p.y, p.z), h,
                               p.Plus(u.ScaledBy((size + 5.0)/scale)).Minus(v.ScaledBy(h / 2.0)),
                               u, v,hcsDatum);
        u = u.WithMagnitude(size / scale);
        v = v.WithMagnitude(size / scale);

        canvas-&gt;DrawLine(p.Minus(u), p.Plus(u), hcsDatum);
        canvas-&gt;DrawLine(p.Minus(v), p.Plus(v), hcsDatum);
        Vector prev;
        for(int i = 0; i &lt;= subdiv; i++) {
            double a = (double)i / subdiv * 2.0 * PI;
            Vector point = p.Plus(u.ScaledBy(cos(a))).Plus(v.ScaledBy(sin(a)));
            if(i &gt; 0) {
                canvas-&gt;DrawLine(point, prev, hcsDatum);
            }
            prev = point;
        }
    }

    // A note to indicate the origin in the just-exported file.
    if(SS.justExportedInfo.draw) {
        Vector p, u, v;
        if(SS.justExportedInfo.showOrigin) {
            p = SS.justExportedInfo.pt,
            u = SS.justExportedInfo.u,
            v = SS.justExportedInfo.v;
        } else {
            p = camera.offset.ScaledBy(-1);
            u = camera.projRight;
            v = camera.projUp;
        }
        canvas-&gt;DrawVectorText("previewing exported geometry; press Esc to return",
                              Style::DefaultTextHeight() / camera.scale,
                              p.Plus(u.ScaledBy(10/scale)).Plus(v.ScaledBy(10/scale)), u, v,
                              hcsDatum);

        if(SS.justExportedInfo.showOrigin) {
            Vector um = p.Plus(u.WithMagnitude(-15/scale)),
                   up = p.Plus(u.WithMagnitude(30/scale)),
                   vm = p.Plus(v.WithMagnitude(-15/scale)),
                   vp = p.Plus(v.WithMagnitude(30/scale));
            canvas-&gt;DrawLine(um, up, hcsDatum);
            canvas-&gt;DrawLine(vm, vp, hcsDatum);
            canvas-&gt;DrawVectorText("(x, y) = (0, 0) for file just exported",
                                  Style::DefaultTextHeight() / camera.scale,
                                  p.Plus(u.ScaledBy(40/scale)).Plus(
                                         v.ScaledBy(-(Style::DefaultTextHeight())/scale)), u, v,
                                  hcsDatum);
        }
    }
}

</t>
<t tx="leo1.20171224221221.26">void GraphicsWindow::Paint() {
    if(!canvas) return;

    havePainted = true;

    int w, h;
    GetGraphicsWindowSize(&amp;w, &amp;h);
    width = w;
    height = h;

    Camera   camera   = GetCamera();
    Lighting lighting = GetLighting();

    if(!SS.ActiveGroupsOkay()) {
        // Draw a different background whenever we're having solve problems.
        RgbaColor bgColor = Style::Color(Style::DRAW_ERROR);
        bgColor = RgbaColor::FromFloat(0.4f*bgColor.redF(),
                                       0.4f*bgColor.greenF(),
                                       0.4f*bgColor.blueF());
        lighting.backgroundColor = bgColor;
        // And show the text window, which has info to debug it
        ForceTextWindowShown();
    }

    auto renderStartTime = std::chrono::high_resolution_clock::now();

    canvas-&gt;SetLighting(lighting);
    canvas-&gt;SetCamera(camera);
    canvas-&gt;NewFrame();
    Draw(canvas.get());
    canvas-&gt;FlushFrame();

    auto renderEndTime = std::chrono::high_resolution_clock::now();
    std::chrono::duration&lt;double, std::milli&gt; renderTime = renderEndTime - renderStartTime;

    camera.LoadIdentity();
    camera.offset.x = -(double)camera.width  / 2.0;
    camera.offset.y = -(double)camera.height / 2.0;
    canvas-&gt;SetCamera(camera);

    UiCanvas uiCanvas = {};
    uiCanvas.canvas = canvas;

    // If a marquee selection is in progress, then draw the selection
    // rectangle, as an outline and a transparent fill.
    if(pending.operation == Pending::DRAGGING_MARQUEE) {
        Point2d begin = ProjectPoint(orig.marqueePoint);
        uiCanvas.DrawRect((int)orig.mouse.x + (int)camera.width / 2,
                          (int)begin.x + (int)camera.width / 2,
                          (int)orig.mouse.y + (int)camera.height / 2,
                          (int)begin.y + (int)camera.height / 2,
                          /*fillColor=*/Style::Color(Style::HOVERED).WithAlpha(25),
                          /*outlineColor=*/Style::Color(Style::HOVERED));
    }

    // If we've had a screenshot requested, take it now, before the UI is overlaid.
    if(!SS.screenshotFile.IsEmpty()) {
        FILE *f = OpenFile(SS.screenshotFile, "wb");
        if(!f || !canvas-&gt;ReadFrame()-&gt;WritePng(f, /*flip=*/true)) {
            Error("Couldn't write to '%s'", SS.screenshotFile.raw.c_str());
        }
        if(f) fclose(f);
        SS.screenshotFile.Clear();
    }

    // And finally the toolbar.
    if(SS.showToolbar) {
        canvas-&gt;SetCamera(camera);
        ToolbarDraw(&amp;uiCanvas);
    }

    // Also display an fps counter.
    RgbaColor renderTimeColor;
    if(1000 / renderTime.count() &lt; 60) {
        // We aim for a steady 60fps; draw the counter in red when we're slower.
        renderTimeColor = { 255, 0, 0, 255 };
    } else {
        renderTimeColor = { 255, 255, 255, 255 };
    }
    uiCanvas.DrawBitmapText(ssprintf("rendered in %ld ms (%ld 1/s)",
                                     (long)renderTime.count(),
                                     (long)(1000/renderTime.count())),
                            5, 5, renderTimeColor);

    canvas-&gt;FlushFrame();
    canvas-&gt;Clear();
}
</t>
<t tx="leo1.20171224221221.27">//-----------------------------------------------------------------------------
// Given a constraint, draw a graphical and user-selectable representation
// of that constraint on-screen. We can either draw with gl, or compute the
// distance from a point (the location of the mouse pointer) to the lines
// that we would have drawn, for selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Constraint::Label() const {
    std::string result;
    if(type == Type::ANGLE) {
        if(valA == floor(valA)) {
            result = ssprintf("%.0f", valA);
        } else {
            result = ssprintf("%.2f", valA);
        }
    } else if(type == Type::LENGTH_RATIO) {
        result = ssprintf("%.3f:1", valA);
    } else if(type == Type::COMMENT) {
        result = comment;
    } else if(type == Type::DIAMETER) {
        if(!other) {
            result = "" + SS.MmToString(valA);
        } else {
            result = "R" + SS.MmToString(valA / 2);
        }
    } else {
        // valA has units of distance
        result = SS.MmToString(fabs(valA));
    }
    if(reference) {
        result += " REF";
    }
    return result;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221221.28">void Constraint::DoLine(Canvas *canvas, Canvas::hStroke hcs, Vector a, Vector b) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    a = camera.AlignToPixelGrid(a);
    b = camera.AlignToPixelGrid(b);
    canvas-&gt;DrawLine(a, b, hcs);
}

</t>
<t tx="leo1.20171224221221.29">void Constraint::DoStippledLine(Canvas *canvas, Canvas::hStroke hcs, Vector a, Vector b) {
    Canvas::Stroke strokeStippled = *canvas-&gt;strokes.FindById(hcs);
    strokeStippled.stipplePattern = StipplePattern::SHORT_DASH;
    strokeStippled.stippleScale   = 4.0;
    Canvas::hStroke hcsStippled = canvas-&gt;GetStroke(strokeStippled);
    DoLine(canvas, hcsStippled, a, b);
}

</t>
<t tx="leo1.20171224221221.3">bool GraphicsWindow::Selection::IsEmpty() {
    if(entity.v)        return false;
    if(constraint.v)    return false;
    return true;
}

</t>
<t tx="leo1.20171224221221.30">void Constraint::DoLabel(Canvas *canvas, Canvas::hStroke hcs,
                         Vector ref, Vector *labelPos, Vector gr, Vector gu) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    std::string s = Label();
    double textHeight = Style::TextHeight(GetStyle()) / camera.scale;
    @others
}

</t>
<t tx="leo1.20171224221221.31">double swidth  = VectorFont::Builtin()-&gt;GetWidth(textHeight, s),
       sheight = VectorFont::Builtin()-&gt;GetCapHeight(textHeight);

// By default, the reference is from the center; but the style could
// specify otherwise if one is present, and it could also specify a
// rotation.
if(type == Type::COMMENT &amp;&amp; disp.style.v) {
    Style *st = Style::Get(disp.style);
    // rotation first
    double rads = st-&gt;textAngle*PI/180;
    double c = cos(rads), s = sin(rads);
    Vector pr = gr, pu = gu;
    gr = pr.ScaledBy( c).Plus(pu.ScaledBy(s));
    gu = pr.ScaledBy(-s).Plus(pu.ScaledBy(c));
    // then origin
    uint32_t o = (uint32_t)st-&gt;textOrigin;
    if(o &amp; (uint32_t)Style::TextOrigin::LEFT) ref = ref.Plus(gr.WithMagnitude(swidth/2));
    if(o &amp; (uint32_t)Style::TextOrigin::RIGHT) ref = ref.Minus(gr.WithMagnitude(swidth/2));
    if(o &amp; (uint32_t)Style::TextOrigin::BOT) ref = ref.Plus(gu.WithMagnitude(sheight/2));
    if(o &amp; (uint32_t)Style::TextOrigin::TOP) ref = ref.Minus(gu.WithMagnitude(sheight/2));
}

Vector o = ref.Minus(gr.WithMagnitude(swidth/2)).Minus(
                     gu.WithMagnitude(sheight/2));
canvas-&gt;DrawVectorText(s, textHeight, o, gr.WithMagnitude(1), gu.WithMagnitude(1), hcs);
if(labelPos) *labelPos = o;
</t>
<t tx="leo1.20171224221221.32">void Constraint::DoProjectedPoint(Canvas *canvas, Canvas::hStroke hcs,
                                  Vector *r, Vector n, Vector o) {
    double d = r-&gt;DistanceToPlane(n, o);
    Vector p = r-&gt;Minus(n.ScaledBy(d));
    DoStippledLine(canvas, hcs, p, *r);
    *r = p;
}

</t>
<t tx="leo1.20171224221221.33">void Constraint::DoProjectedPoint(Canvas *canvas, Canvas::hStroke hcs, Vector *r) {
    Vector p = r-&gt;ProjectInto(workplane);
    DoStippledLine(canvas, hcs, p, *r);
    *r = p;
}

//-----------------------------------------------------------------------------
// There is a rectangular box, aligned to our display axes (projRight, projUp)
// centered at ref. This is where a dimension label will be drawn. We want to
// draw a line from A to B. If that line would intersect the label box, then
// trim the line to leave a gap for it, and return zero. If not, then extend
// the line to almost meet the box, and return either positive or negative,
// depending whether that extension was from A or from B.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.34">int Constraint::DoLineTrimmedAgainstBox(Canvas *canvas, Canvas::hStroke hcs,
                                        Vector ref, Vector a, Vector b, bool extend) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double th      = Style::TextHeight(GetStyle()) / camera.scale;
    double pixels  = 1.0 / camera.scale;
    @others
}

</t>
<t tx="leo1.20171224221221.35">    double swidth  = VectorFont::Builtin()-&gt;GetWidth(th, Label()) + 4 * pixels,
           sheight = VectorFont::Builtin()-&gt;GetCapHeight(th) + 8 * pixels;
    Vector gu = camera.projUp.WithMagnitude(1),
           gr = camera.projRight.WithMagnitude(1);
    return DoLineTrimmedAgainstBox(canvas, hcs, ref, a, b, extend, gr, gu, swidth, sheight);
}

int Constraint::DoLineTrimmedAgainstBox(Canvas *canvas, Canvas::hStroke hcs,
                                        Vector ref, Vector a, Vector b, bool extend,
                                        Vector gr, Vector gu, double swidth, double sheight) {
    struct {
        Vector n;
        double d;
    } planes[4];
    // reference pos is the center of box occupied by text; build a rectangle
    // around that, aligned to axes gr and gu, from four planes will all four
    // normals pointing inward
    planes[0].n = gu.ScaledBy(-1); planes[0].d = -(gu.Dot(ref) + sheight/2);
    planes[1].n = gu;              planes[1].d =   gu.Dot(ref) - sheight/2;
    planes[2].n = gr;              planes[2].d =   gr.Dot(ref) - swidth/2;
    planes[3].n = gr.ScaledBy(-1); planes[3].d = -(gr.Dot(ref) + swidth/2);

    double tmin = VERY_POSITIVE, tmax = VERY_NEGATIVE;
    Vector dl = b.Minus(a);

    for(int i = 0; i &lt; 4; i++) {
        bool parallel;
        Vector p = Vector::AtIntersectionOfPlaneAndLine(
                                planes[i].n, planes[i].d,
                                a, b, &amp;parallel);
        if(parallel) continue;

        int j;
        for(j = 0; j &lt; 4; j++) {
            double d = (planes[j].n).Dot(p) - planes[j].d;
            if(d &lt; -LENGTH_EPS) break;
        }
        if(j &lt; 4) continue;

        double t = (p.Minus(a)).DivPivoting(dl);
        tmin = min(t, tmin);
        tmax = max(t, tmax);
    }

    // Both in range; so there's pieces of the line on both sides of the label box.
    if(tmin &gt;= 0.0 &amp;&amp; tmin &lt;= 1.0 &amp;&amp; tmax &gt;= 0.0 &amp;&amp; tmax &lt;= 1.0) {
        DoLine(canvas, hcs, a, a.Plus(dl.ScaledBy(tmin)));
        DoLine(canvas, hcs, a.Plus(dl.ScaledBy(tmax)), b);
        return 0;
    }

    // Only one intersection in range; so the box is right on top of the endpoint
    if(tmin &gt;= 0.0 &amp;&amp; tmin &lt;= 1.0) {
        DoLine(canvas, hcs, a, a.Plus(dl.ScaledBy(tmin)));
        return 0;
    }

    // Likewise.
    if(tmax &gt;= 0.0 &amp;&amp; tmax &lt;= 1.0) {
        DoLine(canvas, hcs, a.Plus(dl.ScaledBy(tmax)), b);
        return 0;
    }

    // The line does not intersect the label; so the line should get
    // extended to just barely meet the label.
    // 0 means the label lies within the line, negative means it's outside
    // and closer to b, positive means outside and closer to a.
    if(tmax &lt; 0.0) {
        if(extend) a = a.Plus(dl.ScaledBy(tmax));
        DoLine(canvas, hcs, a, b);
        return 1;
    }

    if(tmin &gt; 1.0) {
        if(extend) b = a.Plus(dl.ScaledBy(tmin));
        DoLine(canvas, hcs, a, b);
        return -1;
    }

    // This will happen if the entire line lies within the box.
    return 0;
</t>
<t tx="leo1.20171224221221.36">void Constraint::DoArrow(Canvas *canvas, Canvas::hStroke hcs,
                         Vector p, Vector dir, Vector n, double width, double angle, double da) {
    dir = dir.WithMagnitude(width / cos(angle));
    dir = dir.RotatedAbout(n, da);
    DoLine(canvas, hcs, p, p.Plus(dir.RotatedAbout(n,  angle)));
    DoLine(canvas, hcs, p, p.Plus(dir.RotatedAbout(n, -angle)));
}

//-----------------------------------------------------------------------------
// Draw a line with arrows on both ends, and possibly a gap in the middle for
// the dimension. We will use these for most length dimensions. The length
// being dimensioned is from A to B; but those points get extended perpendicular
// to the line AB, until the line between the extensions crosses ref (the
// center of the label).
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.37">void Constraint::DoLineWithArrows(Canvas *canvas, Canvas::hStroke hcs,
                                  Vector ref, Vector a, Vector b,
                                  bool onlyOneExt)
{
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double pixels = 1.0 / camera.scale;

    Vector ab   = a.Minus(b);
    Vector ar   = a.Minus(ref);
    // Normal to a plane containing the line and the label origin.
    Vector n    = ab.Cross(ar);
    // Within that plane, and normal to the line AB; so that's our extension
    // line.
    Vector out  = ab.Cross(n).WithMagnitude(1);
    out = out.ScaledBy(-out.Dot(ar));

    Vector ae = a.Plus(out), be = b.Plus(out);

    // Extension lines extend 10 pixels beyond where the arrows get
    // drawn (which is at the same offset perpendicular from AB as the
    // label).
    DoLine(canvas, hcs, a, ae.Plus(out.WithMagnitude(10*pixels)));
    if(!onlyOneExt) {
        DoLine(canvas, hcs, b, be.Plus(out.WithMagnitude(10*pixels)));
    }

    int within = DoLineTrimmedAgainstBox(canvas, hcs, ref, ae, be);

    // Arrow heads are 13 pixels long, with an 18 degree half-angle.
    double theta = 18*PI/180;
    Vector arrow = (be.Minus(ae)).WithMagnitude(13*pixels);

    if(within != 0) {
        arrow = arrow.ScaledBy(-1);
        Vector seg = (be.Minus(ae)).WithMagnitude(18*pixels);
        if(within &lt; 0) DoLine(canvas, hcs, ae, ae.Minus(seg));
        if(within &gt; 0) DoLine(canvas, hcs, be, be.Plus(seg));
    }

    DoArrow(canvas, hcs, ae, arrow, n, 13.0 * pixels, theta, 0.0);
    DoArrow(canvas, hcs, be, arrow.Negated(), n, 13.0 * pixels, theta, 0.0);
}

</t>
<t tx="leo1.20171224221221.38">void Constraint::DoEqualLenTicks(Canvas *canvas, Canvas::hStroke hcs,
                                 Vector a, Vector b, Vector gn, Vector *refp) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    Vector m = (a.ScaledBy(1.0/3)).Plus(b.ScaledBy(2.0/3));
    if(refp) *refp = m;
    Vector ab = a.Minus(b);
    Vector n = (gn.Cross(ab)).WithMagnitude(10/camera.scale);

    DoLine(canvas, hcs, m.Minus(n), m.Plus(n));
}

</t>
<t tx="leo1.20171224221221.39">void Constraint::DoEqualRadiusTicks(Canvas *canvas, Canvas::hStroke hcs,
                                    hEntity he, Vector *refp) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Entity *circ = SK.GetEntity(he);

    Vector center = SK.GetEntity(circ-&gt;point[0])-&gt;PointGetNum();
    double r = circ-&gt;CircleGetRadiusNum();
    Quaternion q = circ-&gt;Normal()-&gt;NormalGetNum();
    Vector u = q.RotationU(), v = q.RotationV();

    double theta;
    if(circ-&gt;type == Entity::Type::CIRCLE) {
        theta = PI/2;
    } else if(circ-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
        double thetaa, thetab, dtheta;
        circ-&gt;ArcGetAngles(&amp;thetaa, &amp;thetab, &amp;dtheta);
        theta = thetaa + dtheta/2;
    } else ssassert(false, "Unexpected entity type");

    Vector d = u.ScaledBy(cos(theta)).Plus(v.ScaledBy(sin(theta)));
    d = d.ScaledBy(r);
    Vector p = center.Plus(d);
    if(refp) *refp = p;
    Vector tick = d.WithMagnitude(10/camera.scale);
    DoLine(canvas, hcs, p.Plus(tick), p.Minus(tick));
}

</t>
<t tx="leo1.20171224221221.4">bool GraphicsWindow::Selection::HasEndpoints() {
    if(!entity.v) return false;
    Entity *e = SK.GetEntity(entity);
    return e-&gt;HasEndpoints();
}

</t>
<t tx="leo1.20171224221221.40">void Constraint::DoArcForAngle(Canvas *canvas, Canvas::hStroke hcs,
                               Vector a0, Vector da, Vector b0, Vector db,
                               Vector offset, Vector *ref, bool trim)
{
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double pixels = 1.0 / camera.scale;
    Vector gr = camera.projRight.ScaledBy(1.0);
    Vector gu = camera.projUp.ScaledBy(1.0);

    if(workplane.v != Entity::FREE_IN_3D.v) {
        a0 = a0.ProjectInto(workplane);
        b0 = b0.ProjectInto(workplane);
        da = da.ProjectVectorInto(workplane);
        db = db.ProjectVectorInto(workplane);
    }

    Vector a1 = a0.Plus(da);
    Vector b1 = b0.Plus(db);

    bool skew;
    Vector pi = Vector::AtIntersectionOfLines(a0, a0.Plus(da),
                                              b0, b0.Plus(db), &amp;skew);

    if(!skew) {
        *ref = pi.Plus(offset);
        // We draw in a coordinate system centered at the intersection point.
        // One basis vector is da, and the other is normal to da and in
        // the plane that contains our lines (so normal to its normal).
        da = da.WithMagnitude(1);
        db = db.WithMagnitude(1);

        Vector norm = da.Cross(db);

        Vector dna = norm.Cross(da).WithMagnitude(1.0);
        Vector dnb = norm.Cross(db).WithMagnitude(1.0);

        // da and db magnitudes are 1.0
        double thetaf = acos(da.Dot(db));

        // Calculate median
        Vector m = da.ScaledBy(cos(thetaf/2)).Plus(
                   dna.ScaledBy(sin(thetaf/2)));
        Vector rm = (*ref).Minus(pi);

        // Test which side we have to place an arc
        if(m.Dot(rm) &lt; 0) {
            da = da.ScaledBy(-1); dna = dna.ScaledBy(-1);
            db = db.ScaledBy(-1); dnb = dnb.ScaledBy(-1);
        }

        double rda = rm.Dot(da), rdna = rm.Dot(dna);

        // Introduce minimal arc radius in pixels
        double r = max(sqrt(rda*rda + rdna*rdna), 15.0 * pixels);

        double th = Style::TextHeight(GetStyle()) / camera.scale;
        double swidth   = VectorFont::Builtin()-&gt;GetWidth(th, Label()) + 4*pixels,
        double arrowA = 18.0 * PI / 180.0;
        bool arrowVisible = apb.Minus(apa).Magnitude() &gt; 2.5 * arrowW;
        // Arrow reversing indicator
        bool arrowRev = false;

        // The minimal extension length in angular representation
        double extAngle = 18 * pixels / r;

        // Arc additional angle
        double addAngle = 0.0;
        // Arc start angle
        double startAngle = 0.0;

        // Arc extension to db.
        // We have just enlarge angle value.
        if(HasLabel() &amp;&amp; rm.Dot(dnb) &gt; 0.0) {
            // rm direction projected to plane with u = da, v = dna
            Vector rmp = da.ScaledBy(rda).Plus(dna.ScaledBy(rdna)).WithMagnitude(1.0);
            // rmp and db magnitudes are 1.0
            addAngle = std::max(acos(rmp.Dot(db)), extAngle);

            if(arrowVisible) {
                startAngle = -extAngle;
                addAngle += extAngle;
                arrowRev = true;
            }
        }

        // Arc extension to da.
        // We are enlarge angle value and rewrite basis to align along rm projection.
        if(HasLabel() &amp;&amp; rm.Dot(dna) &lt; 0.0) {
            // rm direction projected to plane with u = da, v = dna
            Vector rmp = da.ScaledBy(rda).Plus(dna.ScaledBy(rdna)).WithMagnitude(1.0);
            // rmp and da magnitudes are 1.0
            startAngle = -std::max(acos(rmp.Dot(da)), extAngle);
            addAngle = -startAngle;

            if(arrowVisible) {
                addAngle += extAngle;
                arrowRev = true;
            }
        }

        Vector prev;
        int n = 30;
        for(int i = 0; i &lt;= n; i++) {
            double theta = startAngle + (i*(thetaf + addAngle))/n;
            Vector p =  da.ScaledBy(r*cos(theta)).Plus(
                       dna.ScaledBy(r*sin(theta))).Plus(pi);
            if(i &gt; 0) {
                if(trim) {
                    DoLineTrimmedAgainstBox(canvas, hcs, *ref, prev, p,
                                            /*extend=*/false, gr, gu, swidth, sheight);
                } else {
                    DoLine(canvas, hcs, prev, p);
                }
            }
            prev = p;
        }

        DoLineExtend(canvas, hcs, a0, a1, apa, 5.0 * pixels);
        DoLineExtend(canvas, hcs, b0, b1, apb, 5.0 * pixels);

        // Draw arrows only when we have enough space.
        if(arrowVisible) {
            double angleCorr = arrowW / (2.0 * r);
            if(arrowRev) {
                dna = dna.ScaledBy(-1.0);
                angleCorr = -angleCorr;
            }
            DoArrow(canvas, hcs, apa, dna, norm, arrowW, arrowA, angleCorr);
            DoArrow(canvas, hcs, apb, dna, norm, arrowW, arrowA, thetaf + PI - angleCorr);
        }
    } else {
        // The lines are skew; no wonderful way to illustrate that.

        *ref = a0.Plus(b0);
        *ref = (*ref).ScaledBy(0.5).Plus(disp.offset);
        gu = gu.WithMagnitude(1);
        double textHeight = Style::TextHeight(GetStyle()) / camera.scale;
        Vector trans =
            (*ref).Plus(gu.ScaledBy(-1.5*VectorFont::Builtin()-&gt;GetCapHeight(textHeight)));
        canvas-&gt;DrawVectorText("angle between skew lines", textHeight,
                               trans, gr.WithMagnitude(1), gu.WithMagnitude(1),
                               hcs);
    }
}

</t>
<t tx="leo1.20171224221221.41">bool Constraint::IsVisible() const {
    if(!SS.GW.showConstraints) return false;
    Group *g = SK.GetGroup(group);
    // If the group is hidden, then the constraints are hidden and not
    // able to be selected.
    if(!(g-&gt;visible)) return false;
    // And likewise if the group is not the active group; except for comments
    // with an assigned style.
    if(g-&gt;h.v != SS.GW.activeGroup.v &amp;&amp; !(type == Type::COMMENT &amp;&amp; disp.style.v)) {
        return false;
    }
    if(disp.style.v) {
        Style *s = Style::Get(disp.style);
        if(!s-&gt;visible) return false;
    }
    return true;
}

</t>
<t tx="leo1.20171224221221.42">bool Constraint::DoLineExtend(Canvas *canvas, Canvas::hStroke hcs,
                              Vector p0, Vector p1, Vector pt, double salient) {
    Vector dir = p1.Minus(p0);
    double k = dir.Dot(pt.Minus(p0)) / dir.Dot(dir);
    Vector ptOnLine = p0.Plus(dir.ScaledBy(k));

    // Draw projection line.
    DoLine(canvas, hcs, pt, ptOnLine);

    // Calculate salient direction.
    Vector sd = dir.WithMagnitude(1.0).ScaledBy(salient);

    Vector from;
    Vector to;

    if(k &lt; 0.0) {
        from = p0;
        to = ptOnLine.Minus(sd);
    } else if(k &gt; 1.0) {
        from = p1;
        to = ptOnLine.Plus(sd);
    } else {
        return false;
    }

    // Draw extension line.
    DoLine(canvas, hcs, from, to);
    return true;
}

</t>
<t tx="leo1.20171224221221.43">void Constraint::DoLayout(DrawAs how, Canvas *canvas,
                          Vector *labelPos, std::vector&lt;Vector&gt; *refs) {
    if(!(how == DrawAs::HOVERED || how == DrawAs::SELECTED) &amp;&amp;
       !IsVisible()) return;

    // Unit vectors that describe our current view of the scene. One pixel
    // long, not one actual unit.
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Vector gr = camera.projRight.ScaledBy(1/camera.scale);
    Vector gu = camera.projUp.ScaledBy(1/camera.scale);
    Vector gn = (gr.Cross(gu)).WithMagnitude(1/camera.scale);

    double textHeight = Style::TextHeight(GetStyle()) / camera.scale;

    RgbaColor color = {};
    switch(how) {
        case DrawAs::DEFAULT:  color = Style::Color(GetStyle()); break;
        case DrawAs::HOVERED:  color = Style::Color(Style::HOVERED);    break;
        case DrawAs::SELECTED: color = Style::Color(Style::SELECTED);   break;
    }
    Canvas::Stroke stroke = Style::Stroke(GetStyle());
    stroke.layer    = Canvas::Layer::FRONT;
    stroke.color    = color;
    stroke.zIndex   = 4;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    Canvas::Fill fill = {};
    fill.layer      = Canvas::Layer::FRONT;
    fill.color      = color;
    fill.zIndex     = stroke.zIndex;
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    switch(type) {
        case Type::PT_PT_DISTANCE: {
            Vector ap = SK.GetEntity(ptA)-&gt;PointGetNum();
            Vector bp = SK.GetEntity(ptB)-&gt;PointGetNum();

            if(workplane.v != Entity::FREE_IN_3D.v) {
                DoProjectedPoint(canvas, hcs, &amp;ap);
                DoProjectedPoint(canvas, hcs, &amp;bp);
            }

            Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            DoLineWithArrows(canvas, hcs, ref, ap, bp, /*onlyOneExt=*/false);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PROJ_PT_DISTANCE: {
            Vector ap = SK.GetEntity(ptA)-&gt;PointGetNum(),
                   bp = SK.GetEntity(ptB)-&gt;PointGetNum(),
                   dp = (bp.Minus(ap)),
                   pp = SK.GetEntity(entityA)-&gt;VectorGetNum();

            Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            pp = pp.WithMagnitude(1);
            double d = dp.Dot(pp);
            Vector bpp = ap.Plus(pp.ScaledBy(d));
            DoStippledLine(canvas, hcs, ap, bpp);
            DoStippledLine(canvas, hcs, bp, bpp);

            DoLineWithArrows(canvas, hcs, ref, ap, bpp, /*onlyOneExt=*/false);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PT_FACE_DISTANCE:
        case Type::PT_PLANE_DISTANCE: {
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            Entity *enta = SK.GetEntity(entityA);
            Vector n, p;
            if(type == Type::PT_PLANE_DISTANCE) {
                n = enta-&gt;Normal()-&gt;NormalN();
                p = enta-&gt;WorkplaneGetOffset();
            } else {
                n = enta-&gt;FaceGetNormalNum();
                p = enta-&gt;FaceGetPointNum();
            }

            double d = (p.Minus(pt)).Dot(n);
            Vector closest = pt.Plus(n.WithMagnitude(d));

            Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            if(!pt.Equals(closest)) {
                DoLineWithArrows(canvas, hcs, ref, pt, closest, /*onlyOneExt=*/true);
            }

            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PT_LINE_DISTANCE: {
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            Entity *line = SK.GetEntity(entityA);
            Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
            Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
            Vector dl = lB.Minus(lA);

            if(workplane.v != Entity::FREE_IN_3D.v) {
                lA = lA.ProjectInto(workplane);
                lB = lB.ProjectInto(workplane);
                DoProjectedPoint(canvas, hcs, &amp;pt);
            }

            // Find the closest point on the line
            Vector closest = pt.ClosestPointOnLine(lA, dl);

            Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);

            if(!pt.Equals(closest)) {
                DoLineWithArrows(canvas, hcs, ref, pt, closest, /*onlyOneExt=*/true);

                // Draw projected point
                Vector a    = pt;
                Vector b    = closest;
                Vector ab   = a.Minus(b);
                Vector ar   = a.Minus(ref);
                Vector n    = ab.Cross(ar);
                Vector out  = ab.Cross(n).WithMagnitude(1);
                out = out.ScaledBy(-out.Dot(ar));
                Vector be   = b.Plus(out);
                Vector np   = lA.Minus(pt).Cross(lB.Minus(pt)).WithMagnitude(1.0);
                DoProjectedPoint(canvas, hcs, &amp;be, np, pt);

                // Extensions to line
                double pixels = 1.0 / camera.scale;
                Vector refClosest = ref.ClosestPointOnLine(lA, dl);
                double ddl = dl.Dot(dl);
                if(fabs(ddl) &gt; LENGTH_EPS * LENGTH_EPS) {
                    double t = refClosest.Minus(lA).Dot(dl) / ddl;
                    if(t &lt; 0.0) {
                        DoLine(canvas, hcs, refClosest.Minus(dl.WithMagnitude(10.0 * pixels)), lA);
                    } else if(t &gt; 1.0) {
                        DoLine(canvas, hcs, refClosest.Plus(dl.WithMagnitude(10.0 * pixels)), lB);
                    }
                }
            }

            if(workplane.v != Entity::FREE_IN_3D.v) {
                // Draw the projection marker from the closest point on the
                // projected line to the projected point on the real line.
                Vector lAB = (lA.Minus(lB));
                double t = (lA.Minus(closest)).DivPivoting(lAB);

                Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
                Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();

                Vector c2 = (lA.ScaledBy(1-t)).Plus(lB.ScaledBy(t));
                DoProjectedPoint(canvas, hcs, &amp;c2);
            }
            return;
        }

        case Type::DIAMETER: {
            Entity *circle = SK.GetEntity(entityA);
            Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(circle-&gt;normal)-&gt;NormalGetNum();
            Vector n = q.RotationN().WithMagnitude(1);
            double r = circle-&gt;CircleGetRadiusNum();

            Vector ref = center.Plus(disp.offset);
            // Force the label into the same plane as the circle.
            ref = ref.Minus(n.ScaledBy(n.Dot(ref) - n.Dot(center)));
            if(refs) refs-&gt;push_back(ref);

            Vector mark = ref.Minus(center);
            mark = mark.WithMagnitude(mark.Magnitude()-r);
            DoLineTrimmedAgainstBox(canvas, hcs, ref, ref, ref.Minus(mark));

            Vector topLeft;
            DoLabel(canvas, hcs, ref, &amp;topLeft, gr, gu);
            if(labelPos) *labelPos = topLeft;
            return;
        }

        case Type::POINTS_COINCIDENT: {
            if(how == DrawAs::DEFAULT) {
                // Let's adjust the color of this constraint to have the same
                // rough luma as the point color, so that the constraint does not
                // stand out in an ugly way.
                RgbaColor cd = Style::Color(Style::DATUM),
                          cc = Style::Color(Style::CONSTRAINT);
                // convert from 8-bit color to a vector
                Vector vd = Vector::From(cd.redF(), cd.greenF(), cd.blueF()),
                       vc = Vector::From(cc.redF(), cc.greenF(), cc.blueF());
                // and scale the constraint color to have the same magnitude as
                // the datum color, maybe a bit dimmer
                vc = vc.WithMagnitude(vd.Magnitude()*0.9);
                // and set the color to that.
                fill.color = RGBf(vc.x, vc.y, vc.z);
                hcf = canvas-&gt;GetFill(fill);
            }

            for(int a = 0; a &lt; 2; a++) {
                Vector r = camera.projRight.ScaledBy((a+1)/camera.scale);
                Vector d = camera.projUp.ScaledBy((2-a)/camera.scale);
                for(int i = 0; i &lt; 2; i++) {
                    Vector p = SK.GetEntity(i == 0 ? ptA : ptB)-&gt; PointGetNum();
                    if(refs) refs-&gt;push_back(p);
                    canvas-&gt;DrawQuad(p.Plus (r).Plus (d),
                                     p.Plus (r).Minus(d),
                                     p.Minus(r).Minus(d),
                                     p.Minus(r).Plus (d),
                                     hcf);
                }

            }
            return;
        }

        case Type::PT_ON_CIRCLE:
        case Type::PT_ON_LINE:
        case Type::PT_ON_FACE:
        case Type::PT_IN_PLANE: {
            double s = 8/camera.scale;
            Vector p = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(refs) refs-&gt;push_back(p);
            Vector r, d;
            if(type == Type::PT_ON_FACE) {
                Vector n = SK.GetEntity(entityA)-&gt;FaceGetNormalNum();
                r = n.Normal(0);
                d = n.Normal(1);
            } else if(type == Type::PT_IN_PLANE) {
                EntityBase *n = SK.GetEntity(entityA)-&gt;Normal();
                r = n-&gt;NormalU();
                d = n-&gt;NormalV();
            } else {
                r = gr;
                d = gu;
                s *= (6.0/8); // draw these a little smaller
            }
            r = r.WithMagnitude(s); d = d.WithMagnitude(s);
            DoLine(canvas, hcs, p.Plus (r).Plus (d), p.Plus (r).Minus(d));
            DoLine(canvas, hcs, p.Plus (r).Minus(d), p.Minus(r).Minus(d));
            DoLine(canvas, hcs, p.Minus(r).Minus(d), p.Minus(r).Plus (d));
            DoLine(canvas, hcs, p.Minus(r).Plus (d), p.Plus (r).Plus (d));
            return;
        }

        case Type::WHERE_DRAGGED: {
            Vector p = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(refs) refs-&gt;push_back(p);
            Vector u = p.Plus(gu.WithMagnitude(8/camera.scale)).Plus(
                              gr.WithMagnitude(8/camera.scale)),
                   uu = u.Minus(gu.WithMagnitude(5/camera.scale)),
                   ur = u.Minus(gr.WithMagnitude(5/camera.scale));
            // Draw four little crop marks, uniformly spaced (by ninety
            // degree rotations) around the point.
            int i;
            for(i = 0; i &lt; 4; i++) {
                DoLine(canvas, hcs, u, uu);
                DoLine(canvas, hcs, u, ur);
                u = u.RotatedAbout(p, gn, PI/2);
                ur = ur.RotatedAbout(p, gn, PI/2);
                uu = uu.RotatedAbout(p, gn, PI/2);
            }
            return;
        }

        case Type::SAME_ORIENTATION: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                Quaternion q = e-&gt;NormalGetNum();
                Vector n = q.RotationN().WithMagnitude(25/camera.scale);
                Vector u = q.RotationU().WithMagnitude(6/camera.scale);
                Vector p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                p = p.Plus(n.WithMagnitude(10/camera.scale));
                if(refs) refs-&gt;push_back(p);

                DoLine(canvas, hcs, p.Plus(u), p.Minus(u).Plus(n));
                DoLine(canvas, hcs, p.Minus(u), p.Plus(u).Plus(n));
            }
            return;
        }

        case Type::EQUAL_ANGLE: {
            Vector ref;
            Entity *a = SK.GetEntity(entityA);
            Entity *b = SK.GetEntity(entityB);
            Entity *c = SK.GetEntity(entityC);
            Entity *d = SK.GetEntity(entityD);

            Vector a0 = a-&gt;VectorGetStartPoint();
            Vector b0 = b-&gt;VectorGetStartPoint();
            Vector c0 = c-&gt;VectorGetStartPoint();
            Vector d0 = d-&gt;VectorGetStartPoint();
            Vector da = a-&gt;VectorGetNum();
            Vector db = b-&gt;VectorGetNum();
            Vector dc = c-&gt;VectorGetNum();
            Vector dd = d-&gt;VectorGetNum();

            if(other) {
                a0 = a0.Plus(da);
                da = da.ScaledBy(-1);
            }

            DoArcForAngle(canvas, hcs, a0, da, b0, db,
                da.WithMagnitude(40/camera.scale), &amp;ref, /*trim=*/false);
            if(refs) refs-&gt;push_back(ref);
            DoArcForAngle(canvas, hcs, c0, dc, d0, dd,
                dc.WithMagnitude(40/camera.scale), &amp;ref, /*trim=*/false);
            if(refs) refs-&gt;push_back(ref);

            return;
        }

        case Type::ANGLE: {
            Entity *a = SK.GetEntity(entityA);
            Entity *b = SK.GetEntity(entityB);

            Vector a0 = a-&gt;VectorGetStartPoint();
            Vector b0 = b-&gt;VectorGetStartPoint();
            Vector da = a-&gt;VectorGetNum();
            Vector db = b-&gt;VectorGetNum();
            if(other) {
                a0 = a0.Plus(da);
                da = da.ScaledBy(-1);
            }

            Vector ref;
            DoArcForAngle(canvas, hcs, a0, da, b0, db, disp.offset, &amp;ref, /*trim=*/true);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            if(refs) refs-&gt;push_back(ref);
            return;
        }

        case Type::PERPENDICULAR: {
            Vector u = Vector::From(0, 0, 0), v = Vector::From(0, 0, 0);
            Vector rn, ru;
            if(workplane.v == Entity::FREE_IN_3D.v) {
                rn = gn;
                ru = gu;
            } else {
                EntityBase *normal = SK.GetEntity(workplane)-&gt;Normal();
                rn = normal-&gt;NormalN();
                ru = normal-&gt;NormalV(); // ru meaning r_up, not u/v
            }

            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);

                if(i == 0) {
                    // Calculate orientation of perpendicular sign only
                    // once, so that it's the same both times it's drawn
                    u = e-&gt;VectorGetNum();
                    u = u.WithMagnitude(16/camera.scale);
                    v = (rn.Cross(u)).WithMagnitude(16/camera.scale);
                    // a bit of bias to stop it from flickering between the
                    // two possibilities
                    if(fabs(u.Dot(ru)) &lt; fabs(v.Dot(ru)) + LENGTH_EPS) {
                        swap(u, v);
                    }
                    if(u.Dot(ru) &lt; 0) u = u.ScaledBy(-1);
                }

                Vector p = e-&gt;VectorGetRefPoint();
                Vector s = p.Plus(u).Plus(v);
                DoLine(canvas, hcs, s, s.Plus(v));
                Vector m = s.Plus(v.ScaledBy(0.5));
                DoLine(canvas, hcs, m, m.Plus(u));
                if(refs) refs-&gt;push_back(m);
            }
            return;
        }

        case Type::CURVE_CURVE_TANGENT:
        case Type::CUBIC_LINE_TANGENT:
        case Type::ARC_LINE_TANGENT: {
            Vector textAt, u, v;

            if(type == Type::ARC_LINE_TANGENT) {
                Entity *arc = SK.GetEntity(entityA);
                Entity *norm = SK.GetEntity(arc-&gt;normal);
                Vector c = SK.GetEntity(arc-&gt;point[0])-&gt;PointGetNum();
                Vector p =
                    SK.GetEntity(arc-&gt;point[other ? 2 : 1])-&gt;PointGetNum();
                Vector r = p.Minus(c);
                textAt = p.Plus(r.WithMagnitude(14/camera.scale));
                u = norm-&gt;NormalU();
                v = norm-&gt;NormalV();
            } else if(type == Type::CUBIC_LINE_TANGENT) {
                Vector n;
                if(workplane.v == Entity::FREE_IN_3D.v) {
                    u = gr;
                    v = gu;
                    n = gn;
                } else {
                    EntityBase *wn = SK.GetEntity(workplane)-&gt;Normal();
                    u = wn-&gt;NormalU();
                    v = wn-&gt;NormalV();
                    n = wn-&gt;NormalN();
                }

                Entity *cubic = SK.GetEntity(entityA);
                Vector p = other ? cubic-&gt;CubicGetFinishNum() :
                                   cubic-&gt;CubicGetStartNum();
                Vector dir = SK.GetEntity(entityB)-&gt;VectorGetNum();
                Vector out = n.Cross(dir);
                textAt = p.Plus(out.WithMagnitude(14/camera.scale));
            } else {
                Vector n, dir;
                EntityBase *wn = SK.GetEntity(workplane)-&gt;Normal();
                u = wn-&gt;NormalU();
                v = wn-&gt;NormalV();
                n = wn-&gt;NormalN();
                EntityBase *eA = SK.GetEntity(entityA);
                // Big pain; we have to get a vector tangent to the curve
                // at the shared point, which could be from either a cubic
                // or an arc.
                if(other) {
                    textAt = eA-&gt;EndpointFinish();
                    if(eA-&gt;type == Entity::Type::CUBIC) {
                        dir = eA-&gt;CubicGetFinishTangentNum();
                    } else {
                        dir = SK.GetEntity(eA-&gt;point[0])-&gt;PointGetNum().Minus(
                              SK.GetEntity(eA-&gt;point[2])-&gt;PointGetNum());
                        dir = n.Cross(dir);
                    }
                } else {
                    textAt = eA-&gt;EndpointStart();
                    if(eA-&gt;type == Entity::Type::CUBIC) {
                        dir = eA-&gt;CubicGetStartTangentNum();
                    } else {
                        dir = SK.GetEntity(eA-&gt;point[0])-&gt;PointGetNum().Minus(
                              SK.GetEntity(eA-&gt;point[1])-&gt;PointGetNum());
                        dir = n.Cross(dir);
                    }
                }
                dir = n.Cross(dir);
                textAt = textAt.Plus(dir.WithMagnitude(14/camera.scale));
            }

            Vector ex = VectorFont::Builtin()-&gt;GetExtents(textHeight, "T");
            canvas-&gt;DrawVectorText("T", textHeight, textAt.Minus(ex.ScaledBy(0.5)),
                                   u.WithMagnitude(1), v.WithMagnitude(1), hcs);
            if(refs) refs-&gt;push_back(textAt);
            return;
        }

        case Type::PARALLEL: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                Vector n = e-&gt;VectorGetNum();
                n = n.WithMagnitude(25/camera.scale);
                Vector u = (gn.Cross(n)).WithMagnitude(4/camera.scale);
                Vector p = e-&gt;VectorGetRefPoint();

                DoLine(canvas, hcs, p.Plus(u), p.Plus(u).Plus(n));
                DoLine(canvas, hcs, p.Minus(u), p.Minus(u).Plus(n));
                if(refs) refs-&gt;push_back(p.Plus(n.ScaledBy(0.5)));
            }
            return;
        }

        case Type::EQUAL_RADIUS: {
            for(int i = 0; i &lt; 2; i++) {
                Vector ref;
                DoEqualRadiusTicks(canvas, hcs, i == 0 ? entityA : entityB, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            return;
        }

        case Type::EQUAL_LINE_ARC_LEN: {
            Entity *line = SK.GetEntity(entityA);
            Vector ref;
            DoEqualLenTicks(canvas, hcs,
                SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum(),
                gn, &amp;ref);
            if(refs) refs-&gt;push_back(ref);
            DoEqualRadiusTicks(canvas, hcs, entityB, &amp;ref);
            if(refs) refs-&gt;push_back(ref);
            return;
        }

        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::EQUAL_LENGTH_LINES: {
            Vector a, b = Vector::From(0, 0, 0);
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();

                if(workplane.v != Entity::FREE_IN_3D.v) {
                    DoProjectedPoint(canvas, hcs, &amp;a);
                    DoProjectedPoint(canvas, hcs, &amp;b);
                }

                Vector ref;
                DoEqualLenTicks(canvas, hcs, a, b, gn, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            if((type == Type::LENGTH_RATIO) || (type == Type::LENGTH_DIFFERENCE)) {
                Vector ref = ((a.Plus(b)).ScaledBy(0.5)).Plus(disp.offset);
                DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            }
            return;
        }

        case Type::EQ_LEN_PT_LINE_D: {
            Entity *forLen = SK.GetEntity(entityA);
            Vector a = SK.GetEntity(forLen-&gt;point[0])-&gt;PointGetNum(),
                   b = SK.GetEntity(forLen-&gt;point[1])-&gt;PointGetNum();
            if(workplane.v != Entity::FREE_IN_3D.v) {
                DoProjectedPoint(canvas, hcs, &amp;a);
                DoProjectedPoint(canvas, hcs, &amp;b);
            }
            Vector refa;
            DoEqualLenTicks(canvas, hcs, a, b, gn, &amp;refa);
            if(refs) refs-&gt;push_back(refa);

            Entity *ln = SK.GetEntity(entityB);
            Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                   lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(workplane.v != Entity::FREE_IN_3D.v) {
                DoProjectedPoint(canvas, hcs, &amp;pt);
                la = la.ProjectInto(workplane);
                lb = lb.ProjectInto(workplane);
            }

            Vector closest = pt.ClosestPointOnLine(la, lb.Minus(la));
            DoLine(canvas, hcs, pt, closest);
            Vector refb;
            DoEqualLenTicks(canvas, hcs, pt, closest, gn, &amp;refb);
            if(refs) refs-&gt;push_back(refb);
            return;
        }

        case Type::EQ_PT_LN_DISTANCES: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *ln = SK.GetEntity(i == 0 ? entityA : entityB);
                Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                       lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
                Entity *pte = SK.GetEntity(i == 0 ? ptA : ptB);
                Vector pt = pte-&gt;PointGetNum();

                if(workplane.v != Entity::FREE_IN_3D.v) {
                    DoProjectedPoint(canvas, hcs, &amp;pt);
                    la = la.ProjectInto(workplane);
                    lb = lb.ProjectInto(workplane);
                }

                Vector closest = pt.ClosestPointOnLine(la, lb.Minus(la));
                DoLine(canvas, hcs, pt, closest);

                Vector ref;
                DoEqualLenTicks(canvas, hcs, pt, closest, gn, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            return;
        }

        {
        case Type::SYMMETRIC:
            Vector n;
            n = SK.GetEntity(entityA)-&gt;Normal()-&gt;NormalN(); goto s;
        case Type::SYMMETRIC_HORIZ:
            n = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalU(); goto s;
        case Type::SYMMETRIC_VERT:
            n = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalV(); goto s;
        case Type::SYMMETRIC_LINE: {
            Entity *ln = SK.GetEntity(entityA);
            Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                   lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
            la = la.ProjectInto(workplane);
            lb = lb.ProjectInto(workplane);
            n = lb.Minus(la);
            Vector nw = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalN();
            n = n.RotatedAbout(nw, PI/2);
            goto s;
        }
s:
            Vector a = SK.GetEntity(ptA)-&gt;PointGetNum();
            Vector b = SK.GetEntity(ptB)-&gt;PointGetNum();

            for(int i = 0; i &lt; 2; i++) {
                Vector tail = (i == 0) ? a : b;
                Vector d = (i == 0) ? b : a;
                d = d.Minus(tail);
                // Project the direction in which the arrow is drawn normal
                // to the symmetry plane; for projected symmetry constraints,
                // they might not be in the same direction, even when the
                // constraint is fully solved.
                d = n.ScaledBy(d.Dot(n));
                d = d.WithMagnitude(20/camera.scale);
                Vector tip = tail.Plus(d);

                DoLine(canvas, hcs, tail, tip);
                d = d.WithMagnitude(9/camera.scale);
                DoLine(canvas, hcs, tip, tip.Minus(d.RotatedAbout(gn,  0.6)));
                DoLine(canvas, hcs, tip, tip.Minus(d.RotatedAbout(gn, -0.6)));
                if(refs) refs-&gt;push_back(tip);
            }
            return;
        }

        case Type::AT_MIDPOINT:
        case Type::HORIZONTAL:
        case Type::VERTICAL:
            if(entityA.v) {
                Vector r, u, n;
                if(workplane.v == Entity::FREE_IN_3D.v) {
                    r = gr; u = gu; n = gn;
                } else {
                    r = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalU();
                    u = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalV();
                    n = r.Cross(u);
                }
                // For "at midpoint", this branch is always taken.
                Entity *e = SK.GetEntity(entityA);
                Vector a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Vector b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                Vector m = (a.ScaledBy(0.5)).Plus(b.ScaledBy(0.5));
                Vector offset = (a.Minus(b)).Cross(n);
                offset = offset.WithMagnitude(textHeight);
                // Draw midpoint constraint on other side of line, so that
                // a line can be midpoint and horizontal at same time.
                if(type == Type::AT_MIDPOINT) offset = offset.ScaledBy(-1);

                std::string s;
                switch(type) {
                    case Type::HORIZONTAL:  s = "H"; break;
                    case Type::VERTICAL:    s = "V"; break;
                    case Type::AT_MIDPOINT: s = "M"; break;
                    default: ssassert(false, "Unexpected constraint type");
                }
                Vector o  = m.Plus(offset).Plus(u.WithMagnitude(textHeight/5)),
                       ex = VectorFont::Builtin()-&gt;GetExtents(textHeight, s);
                Vector shift = r.WithMagnitude(ex.x).Plus(
                               u.WithMagnitude(ex.y));

                canvas-&gt;DrawVectorText(s, textHeight, o.Minus(shift.ScaledBy(0.5)),
                                       r.WithMagnitude(1), u.WithMagnitude(1), hcs);
                if(refs) refs-&gt;push_back(o);
            } else {
                Vector a = SK.GetEntity(ptA)-&gt;PointGetNum();
                Vector b = SK.GetEntity(ptB)-&gt;PointGetNum();

                Entity *w = SK.GetEntity(workplane);
                Vector cu = w-&gt;Normal()-&gt;NormalU();
                Vector cv = w-&gt;Normal()-&gt;NormalV();
                Vector cn = w-&gt;Normal()-&gt;NormalN();

                int i;
                for(i = 0; i &lt; 2; i++) {
                    Vector o = (i == 0) ? a : b;
                    Vector oo = (i == 0) ? a.Minus(b) : b.Minus(a);
                    Vector d = (type == Type::HORIZONTAL) ? cu : cv;
                    if(oo.Dot(d) &lt; 0) d = d.ScaledBy(-1);

                    Vector dp = cn.Cross(d);
                    d = d.WithMagnitude(14/camera.scale);
                    Vector c = o.Minus(d);
                    DoLine(canvas, hcs, o, c);
                    d = d.WithMagnitude(3/camera.scale);
                    dp = dp.WithMagnitude(2/camera.scale);
                    canvas-&gt;DrawQuad((c.Plus(d)).Plus(dp),
                                     (c.Minus(d)).Plus(dp),
                                     (c.Minus(d)).Minus(dp),
                                     (c.Plus(d)).Minus(dp),
                                     hcf);
                    if(refs) refs-&gt;push_back(c);
                }
            }
            return;

        case Type::COMMENT: {
            Vector u, v;
            if(workplane.v == Entity::FREE_IN_3D.v) {
                u = gr;
                v = gu;
            } else {
                EntityBase *norm = SK.GetEntity(workplane)-&gt;Normal();
                u = norm-&gt;NormalU();
                v = norm-&gt;NormalV();
            }

            if(disp.style.v != 0) {
                RgbaColor color = stroke.color;
                stroke = Style::Stroke(disp.style);
                stroke.layer = Canvas::Layer::FRONT;
                if(how != DrawAs::DEFAULT) {
                    stroke.color = color;
                }
                hcs = canvas-&gt;GetStroke(stroke);
            }
            DoLabel(canvas, hcs, disp.offset, labelPos, u, v);
            if(refs) refs-&gt;push_back(disp.offset);
            return;
        }
    }
    ssassert(false, "Unexpected constraint type");
}

</t>
<t tx="leo1.20171224221221.44">void Constraint::Draw(DrawAs how, Canvas *canvas) {
    DoLayout(how, canvas, NULL, NULL);
}

Vector Constraint::GetLabelPos(const Camera &amp;camera) {
    Vector p;

    ObjectPicker canvas = {};
    canvas.camera = camera;
    DoLayout(DrawAs::DEFAULT, &amp;canvas, &amp;p, NULL);
    canvas.Clear();

    return p;
}

</t>
<t tx="leo1.20171224221221.45">void Constraint::GetReferencePoints(const Camera &amp;camera, std::vector&lt;Vector&gt; *refs) {
    ObjectPicker canvas = {};
    canvas.camera = camera;
    DoLayout(DrawAs::DEFAULT, &amp;canvas, NULL, refs);
    canvas.Clear();
}

</t>
<t tx="leo1.20171224221221.46">bool Constraint::IsStylable() const {
    if(type == Type::COMMENT) return true;
    return false;
}

hStyle Constraint::GetStyle() const {
    if(disp.style.v != 0) return disp.style;
    return { Style::CONSTRAINT };
}

</t>
<t tx="leo1.20171224221221.47">bool Constraint::HasLabel() const {
    switch(type) {
        case Type::COMMENT:
        case Type::PT_PT_DISTANCE:
        case Type::PT_PLANE_DISTANCE:
        case Type::PT_LINE_DISTANCE:
        case Type::PT_FACE_DISTANCE:
        case Type::PROJ_PT_DISTANCE:
        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::DIAMETER:
        case Type::ANGLE:
            return true;

        default:
            return false;
    }
}
</t>
<t tx="leo1.20171224221221.48">//-----------------------------------------------------------------------------
// Draw a representation of an entity on-screen, in the case of curves up
// to our chord tolerance, or return the distance from the user's mouse pointer
// to the entity for selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Entity::DescriptionString() const {
    if(h.isFromRequest()) {
        Request *r = SK.GetRequest(h.request());
        return r-&gt;DescriptionString();
    } else {
        Group *g = SK.GetGroup(h.group());
        return g-&gt;DescriptionString();
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221221.49">void Entity::GenerateEdges(SEdgeList *el) {
    SBezierList *sbl = GetOrGenerateBezierCurves();

    int i, j;
    for(i = 0; i &lt; sbl-&gt;l.n; i++) {
        SBezier *sb = &amp;(sbl-&gt;l.elem[i]);

        List&lt;Vector&gt; lv = {};
        sb-&gt;MakePwlInto(&amp;lv);
        for(j = 1; j &lt; lv.n; j++) {
            el-&gt;AddEdge(lv.elem[j-1], lv.elem[j], style.v, i);
        }
        lv.Clear();
    }
}

SBezierList *Entity::GetOrGenerateBezierCurves() {
    if(beziers.l.n == 0)
        GenerateBezierCurves(&amp;beziers);
    return &amp;beziers;
}

SEdgeList *Entity::GetOrGenerateEdges() {
    if(edges.l.n != 0) {
        if(EXACT(edgesChordTol == SS.ChordTolMm()))
            return &amp;edges;
        edges.l.Clear();
    }
    if(edges.l.n == 0)
        GenerateEdges(&amp;edges);
    edgesChordTol = SS.ChordTolMm();
    return &amp;edges;
}

BBox Entity::GetOrGenerateScreenBBox(bool *hasBBox) {
    SBezierList *sbl = GetOrGenerateBezierCurves();

    // We don't bother with bounding boxes for workplanes, etc.
    *hasBBox = (IsPoint() || IsNormal() || sbl-&gt;l.n &gt; 0);
    if(!*hasBBox) return {};

    if(screenBBoxValid)
        return screenBBox;

    if(IsPoint()) {
        Vector proj = SS.GW.ProjectPoint3(PointGetNum());
        screenBBox = BBox::From(proj, proj);
    } else if(IsNormal()) {
        Vector proj = SK.GetEntity(point[0])-&gt;PointGetNum();
        screenBBox = BBox::From(proj, proj);
    } else if(sbl-&gt;l.n &gt; 0) {
        Vector first = SS.GW.ProjectPoint3(sbl-&gt;l.elem[0].ctrl[0]);
        screenBBox = BBox::From(first, first);
        for(int i = 0; i &lt; sbl-&gt;l.n; i++) {
            SBezier *sb = &amp;sbl-&gt;l.elem[i];
            for(int i = 0; i &lt;= sb-&gt;deg; i++) {
                screenBBox.Include(SS.GW.ProjectPoint3(sb-&gt;ctrl[i]));
            }
        }
    } else ssassert(false, "Expected entity to be a point or have beziers");

    screenBBoxValid = true;
    return screenBBox;
}

</t>
<t tx="leo1.20171224221221.5">void GraphicsWindow::Selection::Clear() {
    entity.v = constraint.v = 0;
    emphasized = false;
}

</t>
<t tx="leo1.20171224221221.50">void Entity::GetReferencePoints(std::vector&lt;Vector&gt; *refs) {
    switch(type) {
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D:
            refs-&gt;push_back(PointGetNum());
            break;

        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::WORKPLANE:
        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE:
        case Type::CUBIC:
        case Type::CUBIC_PERIODIC:
        case Type::TTF_TEXT:
        case Type::IMAGE:
            refs-&gt;push_back(SK.GetEntity(point[0])-&gt;PointGetNum());
            break;

        case Type::LINE_SEGMENT: {
            Vector a = SK.GetEntity(point[0])-&gt;PointGetNum(),
                   b = SK.GetEntity(point[1])-&gt;PointGetNum();
            refs-&gt;push_back(b.Plus(a.Minus(b).ScaledBy(0.5)));
            break;
        }

        case Type::DISTANCE:
        case Type::DISTANCE_N_COPY:
        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            break;
    }
}

</t>
<t tx="leo1.20171224221221.51">int Entity::GetPositionOfPoint(const Camera &amp;camera, Point2d p) {
    int position;

    ObjectPicker canvas = {};
    canvas.camera      = camera;
    canvas.point       = p;
    canvas.minDistance = 1e12;
    Draw(DrawAs::DEFAULT, &amp;canvas);
    position = canvas.position;
    canvas.Clear();

    return position;
}

</t>
<t tx="leo1.20171224221221.52">bool Entity::IsStylable() const {
    if(IsPoint()) return false;
    if(IsWorkplane()) return false;
    if(IsNormal()) return false;
    return true;
}

</t>
<t tx="leo1.20171224221221.53">bool Entity::IsVisible() const {
    Group *g = SK.GetGroup(group);

    if(g-&gt;h.v == Group::HGROUP_REFERENCES.v &amp;&amp; IsNormal()) {
        // The reference normals are always shown
        return true;
    }
    if(!(g-&gt;IsVisible())) return false;

    if(IsPoint() &amp;&amp; !SS.GW.showPoints) return false;
    if(IsNormal() &amp;&amp; !SS.GW.showNormals) return false;

    if(!SS.GW.showWorkplanes) {
        if(IsWorkplane() &amp;&amp; !h.isFromRequest()) {
            if(g-&gt;h.v != SS.GW.activeGroup.v) {
                // The group-associated workplanes are hidden outside
                // their group.
                return false;
            }
        }
    }

    if(style.v) {
        Style *s = Style::Get(style);
        if(!s-&gt;visible) return false;
    }

    if(forceHidden) return false;

    return true;
}

</t>
<t tx="leo1.20171224221221.54">void Entity::CalculateNumerical(bool forExport) {
    if(IsPoint()) actPoint = PointGetNum();
    if(IsNormal()) actNormal = NormalGetNum();
    if(type == Type::DISTANCE || type == Type::DISTANCE_N_COPY) {
        actDistance = DistanceGetNum();
    }
    if(IsFace()) {
        actPoint  = FaceGetPointNum();
        Vector n = FaceGetNormalNum();
        actNormal = Quaternion::From(0, n.x, n.y, n.z);
    }
    if(forExport) {
        // Visibility in copied linked entities follows source file
        actVisible = IsVisible();
    } else {
        // Copied entities within a file are always visible
        actVisible = true;
    }
}

//-----------------------------------------------------------------------------
// Compute a cubic, second derivative continuous, interpolating spline. Same
// routine for periodic splines (in a loop) or open splines (with specified
// end tangents).
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.55">void Entity::ComputeInterpolatingSpline(SBezierList *sbl, bool periodic) const {
    static const int MAX_N = BandedMatrix::MAX_UNKNOWNS;
    int ep = extraPoints;

    // The number of unknowns to solve for.
    int n   = periodic ? 3 + ep : ep;
    ssassert(n &lt; MAX_N, "Too many unknowns");
    // The number of on-curve points, one more than the number of segments.
    int pts = periodic ? 4 + ep : 2 + ep;

    int i, j, a;

    // The starting and finishing control points that define our end tangents
    // (if the spline isn't periodic), and the on-curve points.
    Vector ctrl_s = Vector::From(0, 0, 0);
    Vector ctrl_f = Vector::From(0, 0, 0);
    Vector pt[MAX_N+4];
    if(periodic) {
        for(i = 0; i &lt; ep + 3; i++) {
            pt[i] = SK.GetEntity(point[i])-&gt;PointGetNum();
        }
        pt[i++] = SK.GetEntity(point[0])-&gt;PointGetNum();
    } else {
        ctrl_s = SK.GetEntity(point[1])-&gt;PointGetNum();
        ctrl_f = SK.GetEntity(point[ep+2])-&gt;PointGetNum();
        j = 0;
        pt[j++] = SK.GetEntity(point[0])-&gt;PointGetNum();
        for(i = 2; i &lt;= ep + 1; i++) {
            pt[j++] = SK.GetEntity(point[i])-&gt;PointGetNum();
        }
        pt[j++] = SK.GetEntity(point[ep+3])-&gt;PointGetNum();
    }

    // The unknowns that we will be solving for, a set for each coordinate.
    double Xx[MAX_N], Xy[MAX_N], Xz[MAX_N];
    // For a cubic Bezier section f(t) as t goes from 0 to 1,
    //    f' (0) = 3*(P1 - P0)
    //    f' (1) = 3*(P3 - P2)
    //    f''(0) = 6*(P0 - 2*P1 + P2)
    //    f''(1) = 6*(P3 - 2*P2 + P1)
    for(a = 0; a &lt; 3; a++) {
        BandedMatrix bm = {};
        bm.n = n;

        for(i = 0; i &lt; n; i++) {
            int im, it, ip;
            if(periodic) {
                im = WRAP(i - 1, n);
                it = i;
                ip = WRAP(i + 1, n);
            } else {
                im = i;
                it = i + 1;
                ip = i + 2;
            }
            // All of these are expressed in terms of a constant part, and
            // of X[i-1], X[i], and X[i+1]; so let these be the four
            // components of that vector;
            Vector4 A, B, C, D, E;
            // The on-curve interpolated point
            C = Vector4::From((pt[it]).Element(a), 0, 0, 0);
            // control point one back, C - X[i]
            B = C.Plus(Vector4::From(0, 0, -1, 0));
            // control point one forward, C + X[i]
            D = C.Plus(Vector4::From(0, 0, 1, 0));
            // control point two back
            if(i == 0 &amp;&amp; !periodic) {
                A = Vector4::From(ctrl_s.Element(a), 0, 0, 0);
            } else {
                // pt[im] + X[i-1]
                A = Vector4::From(pt[im].Element(a), 1, 0, 0);
            }
            // control point two forward
            if(i == (n - 1) &amp;&amp; !periodic) {
                E = Vector4::From(ctrl_f.Element(a), 0, 0, 0);
            } else {
                // pt[ip] - X[i+1]
                E = Vector4::From((pt[ip]).Element(a), 0, 0, -1);
            }
            // Write the second derivatives of each segment, dropping constant
            Vector4 fprev_pp = (C.Minus(B.ScaledBy(2))).Plus(A),
                    fnext_pp = (C.Minus(D.ScaledBy(2))).Plus(E),
                    eq       = fprev_pp.Minus(fnext_pp);

            bm.B[i] = -eq.w;
            if(periodic) {
                bm.A[i][WRAP(i-2, n)] = eq.x;
                bm.A[i][WRAP(i-1, n)] = eq.y;
                bm.A[i][i]            = eq.z;
            } else {
                // The wrapping would work, except when n = 1 and everything
                // wraps to zero...
                if(i &gt; 0)     bm.A[i][i - 1] = eq.x;
                              bm.A[i][i]     = eq.y;
                if(i &lt; (n-1)) bm.A[i][i + 1] = eq.z;
            }
        }
        bm.Solve();
        double *X = (a == 0) ? Xx :
                    (a == 1) ? Xy :
                               Xz;
        memcpy(X, bm.X, n*sizeof(double));
    }

    for(i = 0; i &lt; pts - 1; i++) {
        Vector p0, p1, p2, p3;
        if(periodic) {
            p0 = pt[i];
            int iw = WRAP(i - 1, n);
            p1 = p0.Plus(Vector::From(Xx[iw], Xy[iw], Xz[iw]));
        } else if(i == 0) {
            p0 = pt[0];
            p1 = ctrl_s;
        } else {
            p0 = pt[i];
            p1 = p0.Plus(Vector::From(Xx[i-1], Xy[i-1], Xz[i-1]));
        }
        if(periodic) {
            p3 = pt[i+1];
            int iw = WRAP(i, n);
            p2 = p3.Minus(Vector::From(Xx[iw], Xy[iw], Xz[iw]));
        } else if(i == (pts - 2)) {
            p3 = pt[pts-1];
            p2 = ctrl_f;
        } else {
            p3 = pt[i+1];
            p2 = p3.Minus(Vector::From(Xx[i], Xy[i], Xz[i]));
        }
        SBezier sb = SBezier::From(p0, p1, p2, p3);
        sbl-&gt;l.Add(&amp;sb);
    }
}

</t>
<t tx="leo1.20171224221221.56">void Entity::GenerateBezierCurves(SBezierList *sbl) const {
    SBezier sb;

    int i = sbl-&gt;l.n;

    switch(type) {
        case Type::LINE_SEGMENT: {
            Vector a = SK.GetEntity(point[0])-&gt;PointGetNum();
            Vector b = SK.GetEntity(point[1])-&gt;PointGetNum();
            sb = SBezier::From(a, b);
            sb.entity = h.v;
            sbl-&gt;l.Add(&amp;sb);
            break;
        }
        case Type::CUBIC:
            ComputeInterpolatingSpline(sbl, /*periodic=*/false);
            break;

        case Type::CUBIC_PERIODIC:
            ComputeInterpolatingSpline(sbl, /*periodic=*/true);
            break;

        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE: {
            Vector center = SK.GetEntity(point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(normal)-&gt;NormalGetNum();
            Vector u = q.RotationU(), v = q.RotationV();
            double r = CircleGetRadiusNum();
            double thetaa, thetab, dtheta;

            if(r &lt; LENGTH_EPS) {
                // If a circle or an arc gets dragged through zero radius,
                // then we just don't generate anything.
                break;
            }

            if(type == Type::CIRCLE) {
                thetaa = 0;
                thetab = 2*PI;
                dtheta = 2*PI;
            } else {
                ArcGetAngles(&amp;thetaa, &amp;thetab, &amp;dtheta);
            }
            int i, n;
            if(dtheta &gt; (3*PI/2 + 0.01)) {
                n = 4;
            } else if(dtheta &gt; (PI + 0.01)) {
                n = 3;
            } else if(dtheta &gt; (PI/2 + 0.01)) {
                n = 2;
            } else {
                n = 1;
            }
            dtheta /= n;

            for(i = 0; i &lt; n; i++) {
                double s, c;

                c = cos(thetaa);
                s = sin(thetaa);
                // The start point of the curve, and the tangent vector at
                // that start point.
                Vector p0 = center.Plus(u.ScaledBy( r*c)).Plus(v.ScaledBy(r*s)),
                       t0 =             u.ScaledBy(-r*s). Plus(v.ScaledBy(r*c));

                thetaa += dtheta;

                c = cos(thetaa);
                s = sin(thetaa);
                Vector p2 = center.Plus(u.ScaledBy( r*c)).Plus(v.ScaledBy(r*s)),
                       t2 =             u.ScaledBy(-r*s). Plus(v.ScaledBy(r*c));

                // The control point must lie on both tangents.
                Vector p1 = Vector::AtIntersectionOfLines(p0, p0.Plus(t0),
                                                          p2, p2.Plus(t2),
                                                          NULL);

                SBezier sb = SBezier::From(p0, p1, p2);
                sb.weight[1] = cos(dtheta/2);
                sbl-&gt;l.Add(&amp;sb);
            }
            break;
        }

        case Type::TTF_TEXT: {
            Vector topLeft = SK.GetEntity(point[0])-&gt;PointGetNum();
            Vector botLeft = SK.GetEntity(point[1])-&gt;PointGetNum();
            Vector n = Normal()-&gt;NormalN();
            Vector v = topLeft.Minus(botLeft);
            Vector u = (v.Cross(n)).WithMagnitude(v.Magnitude());

            SS.fonts.PlotString(font, str, sbl, botLeft, u, v);
            break;
        }

        default:
            // Not a problem, points and normals and such don't generate curves
            break;
    }

    // Record our style for all of the Beziers that we just created.
    for(; i &lt; sbl-&gt;l.n; i++) {
        sbl-&gt;l.elem[i].auxA = style.v;
    }
}

</t>
<t tx="leo1.20171224221221.57">void Entity::Draw(DrawAs how, Canvas *canvas) {
    if(!(how == DrawAs::HOVERED || how == DrawAs::SELECTED) &amp;&amp;
       !IsVisible()) return;

    int zIndex;
    if(IsPoint()) {
        zIndex = 5;
    } else if(how == DrawAs::HIDDEN) {
        zIndex = 2;
    } else if(group.v != SS.GW.activeGroup.v) {
        zIndex = 3;
    } else {
        zIndex = 4;
    }

    hStyle hs;
    if(IsPoint()) {
        hs.v = Style::DATUM;
    } else if(IsNormal() || type == Type::WORKPLANE) {
        hs.v = Style::NORMALS;
    } else {
        hs = Style::ForEntity(h);
    }

    Canvas::Stroke stroke = Style::Stroke(hs);
    switch(how) {
        case DrawAs::DEFAULT:
            stroke.layer = Canvas::Layer::NORMAL;
            break;

        case DrawAs::OVERLAY:
            stroke.layer = Canvas::Layer::FRONT;
            break;

        case DrawAs::HIDDEN:
            stroke.layer = Canvas::Layer::OCCLUDED;
            stroke.stipplePattern = Style::PatternType({ Style::HIDDEN_EDGE });
            stroke.stippleScale   = Style::Get({ Style::HIDDEN_EDGE })-&gt;stippleScale;
            break;

        case DrawAs::HOVERED:
            stroke.layer = Canvas::Layer::FRONT;
            stroke.color = Style::Color(Style::HOVERED);
            break;

        case DrawAs::SELECTED:
            stroke.layer = Canvas::Layer::FRONT;
            stroke.color = Style::Color(Style::SELECTED);
            break;
    }
    stroke.zIndex = zIndex;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    switch(type) {
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D: {
            if(how == DrawAs::HIDDEN) return;

            // If we're analyzing the sketch to show the degrees of freedom,
            // then we draw big colored squares over the points that are
            // free to move.
            bool free = false;
            if(type == Type::POINT_IN_3D) {
                Param *px = SK.GetParam(param[0]),
                      *py = SK.GetParam(param[1]),
                      *pz = SK.GetParam(param[2]);

                free = px-&gt;free || py-&gt;free || pz-&gt;free;
            } else if(type == Type::POINT_IN_2D) {
                Param *pu = SK.GetParam(param[0]),
                      *pv = SK.GetParam(param[1]);

                free = pu-&gt;free || pv-&gt;free;
            }

            Canvas::Stroke pointStroke = {};
            pointStroke.layer  = (free) ? Canvas::Layer::FRONT : stroke.layer;
            pointStroke.zIndex = stroke.zIndex;
            pointStroke.color  = stroke.color;
            pointStroke.width  = 7.0;
            pointStroke.unit   = Canvas::Unit::PX;
            Canvas::hStroke hcsPoint = canvas-&gt;GetStroke(pointStroke);

            if(free) {
                Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                analyzeStroke.width = 14.0;
                analyzeStroke.layer = Canvas::Layer::FRONT;
                Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);

                canvas-&gt;DrawPoint(PointGetNum(), hcsAnalyze);
            }

            canvas-&gt;DrawPoint(PointGetNum(), hcsPoint);
            return;
        }

        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D: {
            const Camera &amp;camera = canvas-&gt;GetCamera();

            if(how == DrawAs::HIDDEN) return;

            for(int i = 0; i &lt; 2; i++) {
                bool asReference = (i == 1);
                if(asReference) {
                    if(!h.request().IsFromReferences()) continue;
                } else {
                    if(!SK.GetGroup(group)-&gt;IsVisible() || !SS.GW.showNormals) continue;
                }

                stroke.layer = (asReference) ? Canvas::Layer::FRONT : Canvas::Layer::NORMAL;
                if(how != DrawAs::HOVERED &amp;&amp; how != DrawAs::SELECTED) {
                    // Always draw the x, y, and z axes in red, green, and blue;
                    // brighter for the ones at the bottom left of the screen,
                    // dimmer for the ones at the model origin.
                    hRequest hr   = h.request();
                    uint8_t  luma = (asReference) ? 255 : 100;
                    if(hr.v == Request::HREQUEST_REFERENCE_XY.v) {
                        stroke.color = RgbaColor::From(0, 0, luma);
                    } else if(hr.v == Request::HREQUEST_REFERENCE_YZ.v) {
                        stroke.color = RgbaColor::From(luma, 0, 0);
                    } else if(hr.v == Request::HREQUEST_REFERENCE_ZX.v) {
                        stroke.color = RgbaColor::From(0, luma, 0);
                    }
                }

                Quaternion q = NormalGetNum();
                Vector tail;
                if(asReference) {
                    // Draw an extra copy of the x, y, and z axes, that's
                    // always in the corner of the view and at the front.
                    // So those are always available, perhaps useful.
                    stroke.width = 2;
                    double s = camera.scale;
                    double h = 60 - camera.height / 2.0;
                    double w = 60 - camera.width  / 2.0;
                    tail = camera.projRight.ScaledBy(w/s).Plus(
                           camera.projUp.   ScaledBy(h/s)).Minus(camera.offset);
                } else {
                    tail = SK.GetEntity(point[0])-&gt;PointGetNum();
                }
                tail = camera.AlignToPixelGrid(tail);

                hcs = canvas-&gt;GetStroke(stroke);
                Vector v = (q.RotationN()).WithMagnitude(50.0 / camera.scale);
                Vector tip = tail.Plus(v);
                canvas-&gt;DrawLine(tail, tip, hcs);

                v = v.WithMagnitude(12.0 / camera.scale);
                Vector axis = q.RotationV();
                canvas-&gt;DrawLine(tip, tip.Minus(v.RotatedAbout(axis,  0.6)), hcs);
                canvas-&gt;DrawLine(tip, tip.Minus(v.RotatedAbout(axis, -0.6)), hcs);

                if(type == Type::NORMAL_IN_3D) {
                    Param *nw = SK.GetParam(param[0]),
                          *nx = SK.GetParam(param[1]),
                          *ny = SK.GetParam(param[2]),
                          *nz = SK.GetParam(param[3]);

                    if(nw-&gt;free || nx-&gt;free || ny-&gt;free || nz-&gt;free) {
                        Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                        analyzeStroke.layer = Canvas::Layer::FRONT;
                        Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);
                        canvas-&gt;DrawLine(tail, tip, hcsAnalyze);
                    }
                }
            }
            return;
        }

        case Type::DISTANCE:
        case Type::DISTANCE_N_COPY:
            // These are used only as data structures, nothing to display.
            return;

        case Type::WORKPLANE: {
            const Camera &amp;camera = canvas-&gt;GetCamera();

            Vector p = SK.GetEntity(point[0])-&gt;PointGetNum();
            p = camera.AlignToPixelGrid(p);

            Vector u = Normal()-&gt;NormalU();
            Vector v = Normal()-&gt;NormalV();

            double s = (std::min(camera.width, camera.height)) * 0.45 / camera.scale;

            Vector us = u.ScaledBy(s);
            Vector vs = v.ScaledBy(s);

            Vector pp = p.Plus (us).Plus (vs);
            Vector pm = p.Plus (us).Minus(vs);
            Vector mm = p.Minus(us).Minus(vs), mm2 = mm;
            Vector mp = p.Minus(us).Plus (vs);

            Canvas::Stroke strokeBorder = stroke;
            strokeBorder.zIndex        -= 3;
            strokeBorder.stipplePattern = StipplePattern::SHORT_DASH;
            strokeBorder.stippleScale   = 8.0;
            Canvas::hStroke hcsBorder = canvas-&gt;GetStroke(strokeBorder);

            double textHeight = Style::TextHeight(hs) / camera.scale;

            if(!h.isFromRequest()) {
                mm = mm.Plus(v.ScaledBy(textHeight * 4.7));
                mm2 = mm2.Plus(u.ScaledBy(textHeight * 4.7));
                canvas-&gt;DrawLine(mm2, mm, hcsBorder);
            }
            canvas-&gt;DrawLine(pp,  pm, hcsBorder);
            canvas-&gt;DrawLine(mm2, pm, hcsBorder);
            canvas-&gt;DrawLine(mm,  mp, hcsBorder);
            canvas-&gt;DrawLine(pp,  mp, hcsBorder);

            Vector o = mm2.Plus(u.ScaledBy(3.0 / camera.scale)).Plus(
                                v.ScaledBy(3.0 / camera.scale));
            std::string shortDesc = DescriptionString().substr(5);
            canvas-&gt;DrawVectorText(shortDesc, textHeight, o, u, v, hcs);
            return;
        }

        case Type::LINE_SEGMENT:
        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE:
        case Type::CUBIC:
        case Type::CUBIC_PERIODIC:
        case Type::TTF_TEXT: {
            // Generate the rational polynomial curves, then piecewise linearize
            // them, and display those.
            if(!canvas-&gt;DrawBeziers(*GetOrGenerateBezierCurves(),  hcs)) {
                canvas-&gt;DrawEdges(*GetOrGenerateEdges(), hcs);
            }
            if(type == Type::CIRCLE) {
                Entity *dist = SK.GetEntity(distance);
                if(dist-&gt;type == Type::DISTANCE) {
                    Param *p = SK.GetParam(dist-&gt;param[0]);
                    if(p-&gt;free) {
                        Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                        analyzeStroke.layer = Canvas::Layer::FRONT;
                        Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);
                        if(!canvas-&gt;DrawBeziers(*GetOrGenerateBezierCurves(), hcsAnalyze)) {
                            canvas-&gt;DrawEdges(*GetOrGenerateEdges(), hcsAnalyze);
                        }
                    }
                }
            }
            return;
        }
        case Type::IMAGE: {
            Canvas::Fill fill = {};
            std::shared_ptr&lt;Pixmap&gt; pixmap;
            switch(how) {
                case DrawAs::HIDDEN: return;

                case DrawAs::HOVERED: {
                    fill.color   = Style::Color(Style::HOVERED).WithAlpha(180);
                    fill.pattern = Canvas::FillPattern::CHECKERED_A;
                    fill.zIndex  = 2;
                    break;
                }

                case DrawAs::SELECTED: {
                    fill.color   = Style::Color(Style::SELECTED).WithAlpha(180);
                    fill.pattern = Canvas::FillPattern::CHECKERED_B;
                    fill.zIndex  = 1;
                    break;
                }

                default:
                    fill.color   = RgbaColor::FromFloat(1.0f, 1.0f, 1.0f);
                    pixmap       = SS.images[file];
                    break;
            }

            Canvas::hFill hf = canvas-&gt;GetFill(fill);
            Vector v[4] = {};
            for(int i = 0; i &lt; 4; i++) {
                v[i] = SK.GetEntity(point[i])-&gt;PointGetNum();
            }
            Vector iu = v[3].Minus(v[0]);
            Vector iv = v[1].Minus(v[0]);

            if(how == DrawAs::DEFAULT &amp;&amp; pixmap == NULL) {
                Canvas::Stroke stroke = Style::Stroke(Style::DRAW_ERROR);
                stroke.color = stroke.color.WithAlpha(50);
                Canvas::hStroke hs = canvas-&gt;GetStroke(stroke);
                canvas-&gt;DrawLine(v[0], v[2], hs);
                canvas-&gt;DrawLine(v[1], v[3], hs);
                for(int i = 0; i &lt; 4; i++) {
                    canvas-&gt;DrawLine(v[i], v[(i + 1) % 4], hs);
                }
            } else {
                canvas-&gt;DrawPixmap(pixmap, v[0], iu, iv,
                                   Point2d::From(0.0, 0.0), Point2d::From(1.0, 1.0), hf);
            }
        }

        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            // Do nothing; these are drawn with the triangle mesh
            return;
    }
    ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo1.20171224221221.58">//-----------------------------------------------------------------------------
// The implementation of our entities in the symbolic algebra system, methods
// to return a symbolic representation of the entity (line by its endpoints,
// circle by center and radius, etc.).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hEntity  EntityBase::FREE_IN_3D = { 0 };
const hEntity  EntityBase::NO_ENTITY = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221221.59">bool EntityBase::HasVector() const {
    switch(type) {
        case Type::LINE_SEGMENT:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:
            return false;
    }
}

ExprVector EntityBase::VectorGetExprsInWorkplane(hEntity wrkpl) const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetExprsInWorkplane(wrkpl)).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetExprsInWorkplane(wrkpl));

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA: {
            ExprVector ev = NormalExprsN();
            if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
                return ev;
            }
            // Get the offset and basis vectors for this weird exotic csys.
            EntityBase *w = SK.GetEntity(wrkpl);
            ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
            ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

            // Get our coordinates in three-space, and project them into that
            // coordinate system.
            ExprVector result;
            result.x = ev.Dot(wu);
            result.y = ev.Dot(wv);
            result.z = Expr::From(0.0);
            return result;
        }
        default: ssassert(false, "Unexpected entity type");
    }
}

ExprVector EntityBase::VectorGetExprs() const {
    return VectorGetExprsInWorkplane(EntityBase::FREE_IN_3D);
}

Vector EntityBase::VectorGetNum() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetNum()).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetNum());

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return NormalN();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetRefPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return ((SK.GetEntity(point[0])-&gt;PointGetNum()).Plus(
                     SK.GetEntity(point[1])-&gt;PointGetNum())).ScaledBy(0.5);

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetStartPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return SK.GetEntity(point[1])-&gt;PointGetNum();

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo1.20171224221221.6">void GraphicsWindow::Selection::Draw(bool isHovered, Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    std::vector&lt;Vector&gt; refs;
    if(entity.v) {
        Entity *e = SK.GetEntity(entity);
        e-&gt;Draw(isHovered ? Entity::DrawAs::HOVERED :
                            Entity::DrawAs::SELECTED,
                canvas);
        if(emphasized) {
            e-&gt;GetReferencePoints(&amp;refs);
        }
    }
    if(constraint.v) {
        Constraint *c = SK.GetConstraint(constraint);
        c-&gt;Draw(isHovered ? Constraint::DrawAs::HOVERED :
                            Constraint::DrawAs::SELECTED,
                canvas);
        if(emphasized) {
            c-&gt;GetReferencePoints(camera, &amp;refs);
        }
    }
    if(emphasized &amp;&amp; (constraint.v || entity.v)) {
        // We want to emphasize this constraint or entity, by drawing a thick
        // line from the top left corner of the screen to the reference point(s)
        // of that entity or constraint.
        Canvas::Stroke strokeEmphasis = {};
        strokeEmphasis.layer  = Canvas::Layer::FRONT;
        strokeEmphasis.color  = Style::Color(Style::HOVERED).WithAlpha(50);
        strokeEmphasis.width  = 40;
        strokeEmphasis.unit   = Canvas::Unit::PX;
        Canvas::hStroke hcsEmphasis = canvas-&gt;GetStroke(strokeEmphasis);

        Point2d topLeftScreen;
        topLeftScreen.x = -(double)camera.width / 2;
        topLeftScreen.y = (double)camera.height / 2;
        Vector topLeft = camera.UnProjectPoint(topLeftScreen);

        @others
}

</t>
<t tx="leo1.20171224221221.60">bool EntityBase::IsCircle() const {
    return (type == Type::CIRCLE) || (type == Type::ARC_OF_CIRCLE);
}

Expr *EntityBase::CircleGetRadiusExpr() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetExpr();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return Constraint::Distance(workplane, point[0], point[1]);
    } else ssassert(false, "Unexpected entity type");
}

double EntityBase::CircleGetRadiusNum() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
        Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
        return (pa.Minus(c)).Magnitude();
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo1.20171224221221.61">void EntityBase::ArcGetAngles(double *thetaa, double *thetab, double *dtheta) const {
    ssassert(type == Type::ARC_OF_CIRCLE, "Unexpected entity type");

    Quaternion q = Normal()-&gt;NormalGetNum();
    Vector u = q.RotationU(), v = q.RotationV();

    Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
    Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
    Vector pb = SK.GetEntity(point[2])-&gt;PointGetNum();

    Point2d c2  = c.Project2d(u, v);
    Point2d pa2 = (pa.Project2d(u, v)).Minus(c2);
    Point2d pb2 = (pb.Project2d(u, v)).Minus(c2);

    *thetaa = atan2(pa2.y, pa2.x);
    *thetab = atan2(pb2.y, pb2.x);
    *dtheta = *thetab - *thetaa;
    // If the endpoints are coincident, call it a full arc, not a zero arc;
    // useful concept to have when splitting
    while(*dtheta &lt; 1e-6) *dtheta += 2*PI;
    while(*dtheta &gt; (2*PI)) *dtheta -= 2*PI;
}

Vector EntityBase::CubicGetStartNum() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}
Vector EntityBase::CubicGetFinishNum() const {
    return SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum();
}
ExprVector EntityBase::CubicGetStartTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[0])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[1])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
ExprVector EntityBase::CubicGetFinishTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetStartTangentNum() const {
    Vector pon  = SK.GetEntity(point[0])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[1])-&gt;PointGetNum();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetFinishTangentNum() const {
    Vector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetNum();
    return (pon.Minus(poff));
}

</t>
<t tx="leo1.20171224221221.62">bool EntityBase::IsWorkplane() const {
    return (type == Type::WORKPLANE);
}

ExprVector EntityBase::WorkplaneGetOffsetExprs() const {
    return SK.GetEntity(point[0])-&gt;PointGetExprs();
}

Vector EntityBase::WorkplaneGetOffset() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}

</t>
<t tx="leo1.20171224221221.63">void EntityBase::WorkplaneGetPlaneExprs(ExprVector *n, Expr **dn) const {
    if(type == Type::WORKPLANE) {
        *n = Normal()-&gt;NormalExprsN();

        ExprVector p0 = SK.GetEntity(point[0])-&gt;PointGetExprs();
        // The plane is n dot (p - p0) = 0, or
        //              n dot p - n dot p0 = 0
        // so dn = n dot p0
        *dn = p0.Dot(*n);
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo1.20171224221221.64">bool EntityBase::IsDistance() const {
    return (type == Type::DISTANCE) ||
           (type == Type::DISTANCE_N_COPY);
}
double EntityBase::DistanceGetNum() const {
    if(type == Type::DISTANCE) {
        return SK.GetParam(param[0])-&gt;val;
    } else if(type == Type::DISTANCE_N_COPY) {
        return numDistance;
    } else ssassert(false, "Unexpected entity type");
}
Expr *EntityBase::DistanceGetExpr() const {
    if(type == Type::DISTANCE) {
        return Expr::From(param[0]);
    } else if(type == Type::DISTANCE_N_COPY) {
        return Expr::From(numDistance);
    } else ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo1.20171224221221.65">void EntityBase::DistanceForceTo(double v) {
    if(type == Type::DISTANCE) {
        (SK.GetParam(param[0]))-&gt;val = v;
    } else if(type == Type::DISTANCE_N_COPY) {
        // do nothing, it's locked
    } else ssassert(false, "Unexpected entity type");
}

EntityBase *EntityBase::Normal() const {
    return SK.GetEntity(normal);
}

</t>
<t tx="leo1.20171224221221.66">bool EntityBase::IsPoint() const {
    switch(type) {
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D:
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo1.20171224221221.67">bool EntityBase::IsNormal() const {
    switch(type) {
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:           return false;
    }
}

Quaternion EntityBase::NormalGetNum() const {
    Quaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetNum();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = numNormal;
            break;

        case Type::NORMAL_N_ROT:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            q = q.Times(numNormal);
            break;

        case Type::NORMAL_N_ROT_AA: {
            q = GetAxisAngleQuaternion(0);
            q = q.Times(numNormal);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo1.20171224221221.68">void EntityBase::NormalForceTo(Quaternion q) {
    switch(type) {
        case Type::NORMAL_IN_3D:
            SK.GetParam(param[0])-&gt;val = q.w;
            SK.GetParam(param[1])-&gt;val = q.vx;
            SK.GetParam(param[2])-&gt;val = q.vy;
            SK.GetParam(param[3])-&gt;val = q.vz;
            break;

        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
            // There's absolutely nothing to do; these are locked.
            break;
        case Type::NORMAL_N_ROT: {
            Quaternion qp = q.Times(numNormal.Inverse());

            SK.GetParam(param[0])-&gt;val = qp.w;
            SK.GetParam(param[1])-&gt;val = qp.vx;
            SK.GetParam(param[2])-&gt;val = qp.vy;
            SK.GetParam(param[3])-&gt;val = qp.vz;
            break;
        }

        case Type::NORMAL_N_ROT_AA:
            // Not sure if I'll bother implementing this one
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::NormalU() const {
    return NormalGetNum().RotationU();
}
Vector EntityBase::NormalV() const {
    return NormalGetNum().RotationV();
}
Vector EntityBase::NormalN() const {
    return NormalGetNum().RotationN();
}

ExprVector EntityBase::NormalExprsU() const {
    return NormalGetExprs().RotationU();
}
ExprVector EntityBase::NormalExprsV() const {
    return NormalGetExprs().RotationV();
}
ExprVector EntityBase::NormalExprsN() const {
    return NormalGetExprs().RotationN();
}

ExprQuaternion EntityBase::NormalGetExprs() const {
    ExprQuaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetExprs();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = ExprQuaternion::From(numNormal);
            break;

        case Type::NORMAL_N_ROT: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);

            q = q.Times(orig);
            break;
        }

        case Type::NORMAL_N_ROT_AA: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = GetAxisAngleQuaternionExprs(0);
            q = q.Times(orig);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo1.20171224221221.69">void EntityBase::PointForceParamTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo1.20171224221221.7">    auto it = std::unique(refs.begin(), refs.end(),
                          [](Vector a, Vector b) { return a.Equals(b); });
    refs.erase(it, refs.end());
    for(Vector p : refs) {
        canvas-&gt;DrawLine(topLeft, p, hcsEmphasis);
    }
}
</t>
<t tx="leo1.20171224221221.70">void EntityBase::PointForceTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            p = p.Minus(c-&gt;WorkplaneGetOffset());
            SK.GetParam(param[0])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalU());
            SK.GetParam(param[1])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalV());
            break;
        }

        case Type::POINT_N_TRANS: {
            if(timesApplied == 0) break;
            Vector trans = (p.Minus(numPoint)).ScaledBy(1.0/timesApplied);
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            // Force only the translation; leave the rotation unchanged. But
            // remember that we're working with respect to the rotated
            // point.
            Vector trans = p.Minus(PointGetQuaternion().Rotate(numPoint));
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_AA: {
            // Force only the angle; the axis and center of rotation stay
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Vector normal = Vector::From(param[4], param[5], param[6]);
            Vector u = normal.Normal(0), v = normal.Normal(1);
            Vector po = p.Minus(offset), numo = numPoint.Minus(offset);
            double thetap = atan2(v.Dot(po), u.Dot(po));
            double thetan = atan2(v.Dot(numo), u.Dot(numo));
            double thetaf = (thetap - thetan);
            double thetai = (SK.GetParam(param[3])-&gt;val)*timesApplied*2;
            double dtheta = thetaf - thetai;
            // Take the smallest possible change in the actual step angle,
            // in order to avoid jumps when you cross from +pi to -pi
            while(dtheta &lt; -PI) dtheta += 2*PI;
            while(dtheta &gt; PI) dtheta -= 2*PI;
            SK.GetParam(param[3])-&gt;val = (thetai + dtheta)/(timesApplied*2);
            break;
        }

        case Type::POINT_N_COPY:
            // Nothing to do; it's a static copy
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::PointGetNum() const {
    Vector p;
    switch(type) {
        case Type::POINT_IN_3D:
            p = Vector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            Vector u = c-&gt;Normal()-&gt;NormalU();
            Vector v = c-&gt;Normal()-&gt;NormalV();
            p =        u.ScaledBy(SK.GetParam(param[0])-&gt;val);
            p = p.Plus(v.ScaledBy(SK.GetParam(param[1])-&gt;val));
            p = p.Plus(c-&gt;WorkplaneGetOffset());
            break;
        }

        case Type::POINT_N_TRANS: {
            Vector trans = Vector::From(param[0], param[1], param[2]);
            p = numPoint.Plus(trans.ScaledBy(timesApplied));
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = q.Rotate(numPoint);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_ROT_AA: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = numPoint.Minus(offset);
            p = q.Rotate(p);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_COPY:
            p = numPoint;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return p;
}

ExprVector EntityBase::PointGetExprs() const {
    ExprVector r;
    switch(type) {
        case Type::POINT_IN_3D:
            r = ExprVector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            ExprVector u = c-&gt;Normal()-&gt;NormalExprsU();
            ExprVector v = c-&gt;Normal()-&gt;NormalExprsV();
            r = c-&gt;WorkplaneGetOffsetExprs();
            r = r.Plus(u.ScaledBy(Expr::From(param[0])));
            r = r.Plus(v.ScaledBy(Expr::From(param[1])));
            break;
        }
        case Type::POINT_N_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            r = orig.Plus(trans.ScaledBy(Expr::From(timesApplied)));
            break;
        }
        case Type::POINT_N_ROT_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q =
                ExprQuaternion::From(param[3], param[4], param[5], param[6]);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_ROT_AA: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
            orig = orig.Minus(trans);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_COPY:
            r = ExprVector::From(numPoint);
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return r;
}

</t>
<t tx="leo1.20171224221221.71">void EntityBase::PointGetExprsInWorkplane(hEntity wrkpl, Expr **u, Expr **v) const {
    if(type == Type::POINT_IN_2D &amp;&amp; workplane.v == wrkpl.v) {
        // They want our coordinates in the form that we've written them,
        // very nice.
        *u = Expr::From(param[0]);
        *v = Expr::From(param[1]);
    } else {
        // Get the offset and basis vectors for this weird exotic csys.
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector wp = w-&gt;WorkplaneGetOffsetExprs();
        ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

        // Get our coordinates in three-space, and project them into that
        // coordinate system.
        ExprVector ev = PointGetExprs();
        ev = ev.Minus(wp);
        *u = ev.Dot(wu);
        *v = ev.Dot(wv);
    }
}

ExprVector EntityBase::PointGetExprsInWorkplane(hEntity wrkpl) const {
    if(wrkpl.v == Entity::FREE_IN_3D.v) {
        return PointGetExprs();
    }

    ExprVector r;
    PointGetExprsInWorkplane(wrkpl, &amp;r.x, &amp;r.y);
    r.z = Expr::From(0.0);
    return r;
}

</t>
<t tx="leo1.20171224221221.72">void EntityBase::PointForceQuaternionTo(Quaternion q) {
    ssassert(type == Type::POINT_N_ROT_TRANS, "Unexpected entity type");

    SK.GetParam(param[3])-&gt;val = q.w;
    SK.GetParam(param[4])-&gt;val = q.vx;
    SK.GetParam(param[5])-&gt;val = q.vy;
    SK.GetParam(param[6])-&gt;val = q.vz;
}

Quaternion EntityBase::GetAxisAngleQuaternion(int param0) const {
    Quaternion q;
    double theta = timesApplied*SK.GetParam(param[param0+0])-&gt;val;
    double s = sin(theta), c = cos(theta);
    q.w = c;
    q.vx = s*SK.GetParam(param[param0+1])-&gt;val;
    q.vy = s*SK.GetParam(param[param0+2])-&gt;val;
    q.vz = s*SK.GetParam(param[param0+3])-&gt;val;
    return q;
}

ExprQuaternion EntityBase::GetAxisAngleQuaternionExprs(int param0) const {
    ExprQuaternion q;

    Expr *theta = Expr::From(timesApplied)-&gt;Times(
                  Expr::From(param[param0+0]));
    Expr *c = theta-&gt;Cos(), *s = theta-&gt;Sin();
    q.w = c;
    q.vx = s-&gt;Times(Expr::From(param[param0+1]));
    q.vy = s-&gt;Times(Expr::From(param[param0+2]));
    q.vz = s-&gt;Times(Expr::From(param[param0+3]));
    return q;
}

Quaternion EntityBase::PointGetQuaternion() const {
    Quaternion q;

    if(type == Type::POINT_N_ROT_AA) {
        q = GetAxisAngleQuaternion(3);
    } else if(type == Type::POINT_N_ROT_TRANS) {
        q = Quaternion::From(param[3], param[4], param[5], param[6]);
    } else ssassert(false, "Unexpected entity type");

    return q;
}

</t>
<t tx="leo1.20171224221221.73">bool EntityBase::IsFace() const {
    switch(type) {
        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            return true;
        default:
            return false;
    }
}

ExprVector EntityBase::FaceGetNormalExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        Vector v = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = ExprVector::From(v.WithMagnitude(1));
    } else if(type == Type::FACE_XPROD) {
        ExprVector vc = ExprVector::From(param[0], param[1], param[2]);
        ExprVector vn =
            ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
        r = r.WithMagnitude(Expr::From(1.0));
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation; the numerical
        // normal has magnitude one, and the rotation doesn't change that,
        // so there's no need to fix it up.
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetNormalNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_XPROD) {
        Vector vc = Vector::From(param[0], param[1], param[2]);
        Vector vn = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r.WithMagnitude(1);
}

ExprVector EntityBase::FaceGetPointExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetExprs();
    } else if(type == Type::FACE_XPROD) {
        r = ExprVector::From(numPoint);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = ExprVector::From(numPoint);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        r = ExprVector::From(numPoint);
        r = r.Plus(trans.ScaledBy(Expr::From(timesApplied)));
    } else if(type == Type::FACE_N_ROT_AA) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = ExprVector::From(numPoint);
        r = r.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetPointNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::FACE_XPROD) {
        r = numPoint;
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(numPoint);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        r = numPoint.Plus(trans.ScaledBy(timesApplied));
    } else if(type == Type::FACE_N_ROT_AA) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = numPoint.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

</t>
<t tx="leo1.20171224221221.74">bool EntityBase::HasEndpoints() const {
    return (type == Type::LINE_SEGMENT) ||
           (type == Type::CUBIC) ||
           (type == Type::ARC_OF_CIRCLE);
}
Vector EntityBase::EndpointStart() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetStartNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}
Vector EntityBase::EndpointFinish() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetFinishNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[2])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo1.20171224221221.75">void EntityBase::RectGetPointsExprs(ExprVector *eb, ExprVector *ec) const {
    ssassert(type == Type::TTF_TEXT || type == Type::IMAGE,
             "Unexpected entity type");

    EntityBase *a = SK.GetEntity(point[0]);
    EntityBase *o = SK.GetEntity(point[1]);

    // Write equations for each point in the current workplane.
    // This reduces the complexity of resulting equations.
    ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
    ExprVector eo = o-&gt;PointGetExprsInWorkplane(workplane);

    // Take perpendicular vector and scale it by aspect ratio.
    ExprVector eu = ea.Minus(eo);
    ExprVector ev = ExprVector::From(eu.y, eu.x-&gt;Negate(), eu.z).ScaledBy(Expr::From(aspectRatio));

    *eb = eo.Plus(ev);
    *ec = eo.Plus(eu).Plus(ev);
}

</t>
<t tx="leo1.20171224221221.76">void EntityBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const {
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo1.20171224221221.77">void EntityBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) const {
    switch(type) {
        case Type::NORMAL_IN_3D: {
            ExprQuaternion q = NormalGetExprs();
            AddEq(l, (q.Magnitude())-&gt;Minus(Expr::From(1)), 0);
            break;
        }

        case Type::ARC_OF_CIRCLE: {
            // If this is a copied entity, with its point already fixed
            // with respect to each other, then we don't want to generate
            // the distance constraint!
            if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;

            // If the two endpoints of the arc are constrained coincident
            // (to make a complete circle), then our distance constraint
            // would be redundant and therefore overconstrain things.
            int i;
            for(i = 0; i &lt; SK.constraint.n; i++) {
                ConstraintBase *c = &amp;(SK.constraint.elem[i]);
                if(c-&gt;group.v != group.v) continue;
                if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;

                if((c-&gt;ptA.v == point[1].v &amp;&amp; c-&gt;ptB.v == point[2].v) ||
                   (c-&gt;ptA.v == point[2].v &amp;&amp; c-&gt;ptB.v == point[1].v))
                {
                    break;
                }
            }
            if(i &lt; SK.constraint.n) break;

            Expr *ra = Constraint::Distance(workplane, point[0], point[1]);
            Expr *rb = Constraint::Distance(workplane, point[0], point[2]);
            AddEq(l, ra-&gt;Minus(rb), 0);
            break;
        }

        case Type::IMAGE:
        case Type::TTF_TEXT: {
            if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;
            EntityBase *b = SK.GetEntity(point[2]);
            EntityBase *c = SK.GetEntity(point[3]);
            ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector ec = c-&gt;PointGetExprsInWorkplane(workplane);

            ExprVector ebp, ecp;
            RectGetPointsExprs(&amp;ebp, &amp;ecp);

            ExprVector beq = eb.Minus(ebp);
            AddEq(l, beq.x, 0);
            AddEq(l, beq.y, 1);
            ExprVector ceq = ec.Minus(ecp);
            AddEq(l, ceq.x, 2);
            AddEq(l, ceq.y, 3);
            break;
        }

        default: // Most entities do not generate equations.
            break;
    }
}
</t>
<t tx="leo1.20171224221221.78">//-----------------------------------------------------------------------------
// The 2d vector output stuff that isn't specific to any particular file
// format: getting the appropriate lines and curves, performing hidden line
// removal, calculating bounding boxes, and so on. Also raster and triangle
// mesh output.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221221.79">void SolveSpaceUI::ExportSectionTo(const Platform::Path &amp;filename) {
    Vector gn = (SS.GW.projRight).Cross(SS.GW.projUp);
    gn = gn.WithMagnitude(1);

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    g-&gt;GenerateDisplayItems();
    if(g-&gt;displayMesh.IsEmpty()) {
        Error(_("No solid model present; draw one with extrudes and revolves, "
                "or use Export 2d View to export bare lines and curves."));
        return;
    }

    // The plane in which the exported section lies; need this because we'll
    // reorient from that plane into the xy plane before exporting.
    Vector origin, u, v, n;
    double d;

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    if((gs.n == 0 &amp;&amp; g-&gt;activeWorkplane.v != Entity::FREE_IN_3D.v)) {
        Entity *wrkpl = SK.GetEntity(g-&gt;activeWorkplane);
        origin = wrkpl-&gt;WorkplaneGetOffset();
        n = wrkpl-&gt;Normal()-&gt;NormalN();
        u = wrkpl-&gt;Normal()-&gt;NormalU();
        v = wrkpl-&gt;Normal()-&gt;NormalV();
    } else if(gs.n == 1 &amp;&amp; gs.faces == 1) {
        Entity *face = SK.GetEntity(gs.entity[0]);
        origin = face-&gt;FaceGetPointNum();
        n = face-&gt;FaceGetNormalNum();
        if(n.Dot(gn) &lt; 0) n = n.ScaledBy(-1);
        u = n.Normal(0);
        v = n.Normal(1);
    } else if(gs.n == 3 &amp;&amp; gs.vectors == 2 &amp;&amp; gs.points == 1) {
        Vector ut = SK.GetEntity(gs.entity[0])-&gt;VectorGetNum(),
               vt = SK.GetEntity(gs.entity[1])-&gt;VectorGetNum();
        ut = ut.WithMagnitude(1);
        vt = vt.WithMagnitude(1);

        if(fabs(SS.GW.projUp.Dot(vt)) &lt; fabs(SS.GW.projUp.Dot(ut))) {
            swap(ut, vt);
        }
        if(SS.GW.projRight.Dot(ut) &lt; 0) ut = ut.ScaledBy(-1);
        if(SS.GW.projUp.   Dot(vt) &lt; 0) vt = vt.ScaledBy(-1);

        origin = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        n = ut.Cross(vt);
        u = ut.WithMagnitude(1);
        v = (n.Cross(u)).WithMagnitude(1);
    } else {
        Error(_("Bad selection for export section. Please select:\n\n"
                "    * nothing, with an active workplane "
                          "(workplane is section plane)\n"
                "    * a face (section plane through face)\n"
                "    * a point and two line segments "
                          "(plane through point and parallel to lines)\n"));
        return;
    }
    SS.GW.ClearSelection();

    n = n.WithMagnitude(1);
    d = origin.Dot(n);

    SEdgeList el = {};
    SBezierList bl = {};

    // If there's a mesh, then grab the edges from it.
    g-&gt;runningMesh.MakeEdgesInPlaneInto(&amp;el, n, d);

    // If there's a shell, then grab the edges and possibly Beziers.
    g-&gt;runningShell.MakeSectionEdgesInto(n, d,
       &amp;el,
       (SS.exportPwlCurves || fabs(SS.exportOffset) &gt; LENGTH_EPS) ? NULL : &amp;bl);

    // All of these are solid model edges, so use the appropriate style.
    SEdge *se;
    for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
        se-&gt;auxA = Style::SOLID_EDGE;
    }
    SBezier *sb;
    for(sb = bl.l.First(); sb; sb = bl.l.NextAfter(sb)) {
        sb-&gt;auxA = Style::SOLID_EDGE;
    }

    el.CullExtraneousEdges();
    bl.CullIdenticalBeziers();

    // And write the edges.
    VectorFileWriter *out = VectorFileWriter::ForFile(filename);
    if(out) {
        // parallel projection (no perspective), and no mesh
        ExportLinesAndMesh(&amp;el, &amp;bl, NULL,
                           u, v, n, origin, 0,
                           out);
    }
    el.Clear();
    bl.Clear();
}

// This is an awful temporary hack to replace Constraint::GetEdges until we have proper
// export through Canvas.
</t>
<t tx="leo1.20171224221221.8">void GraphicsWindow::ClearSelection() {
    selection.Clear();
    SS.ScheduleShowTW();
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221221.80">class GetEdgesCanvas : public Canvas {
public:
    Camera     camera;
    SEdgeList *edges;

    @others
};

</t>
<t tx="leo1.20171224221221.81">const Camera &amp;GetCamera() const override {
    return camera;
}

</t>
<t tx="leo1.20171224221221.82">void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override {
    edges-&gt;AddEdge(a, b, Style::CONSTRAINT);
}
</t>
<t tx="leo1.20171224221221.83">void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override {
    for(const SEdge &amp;e : el.l) {
        edges-&gt;AddEdge(e.a, e.b, Style::CONSTRAINT);
    }
}
</t>
<t tx="leo1.20171224221221.84">void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    hStroke hcs) override {
    auto traceEdge = [&amp;](Vector a, Vector b) { edges-&gt;AddEdge(a, b, Style::CONSTRAINT); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo1.20171224221221.85">void DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
              hFill hcf) override {
    // Do nothing
}

</t>
<t tx="leo1.20171224221221.86">bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.87">void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.88">void DrawPoint(const Vector &amp;o, hStroke hcs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.89">void DrawPolygon(const SPolygon &amp;p, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.9">void GraphicsWindow::ClearNonexistentSelectionItems() {
    bool change = false;
    Selection *s;
    selection.ClearTags();
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;constraint.v &amp;&amp; !(SK.constraint.FindByIdNoOops(s-&gt;constraint))) {
            s-&gt;tag = 1;
            change = true;
        }
        if(s-&gt;entity.v &amp;&amp; !(SK.entity.FindByIdNoOops(s-&gt;entity))) {
            s-&gt;tag = 1;
            change = true;
        }
    }
    selection.RemoveTagged();
    if(change) InvalidateGraphics();
}

//-----------------------------------------------------------------------------
// Is this entity/constraint selected?
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221221.90">void DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack = {}) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.91">void DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.92">void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                        const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                        const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.93">void InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221221.94">void SolveSpaceUI::ExportViewOrWireframeTo(const Platform::Path &amp;filename, bool exportWireframe) {
    int i;
    SEdgeList edges = {};
    SBezierList beziers = {};

    VectorFileWriter *out = VectorFileWriter::ForFile(filename);
    if(!out) return;

    SS.exportMode = true;
    GenerateAll(Generate::ALL);

    SMesh *sm = NULL;
    if(SS.GW.showShaded || SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::VISIBLE) {
        Group *g = SK.GetGroup(SS.GW.activeGroup);
        g-&gt;GenerateDisplayItems();
        sm = &amp;(g-&gt;displayMesh);
    }
    if(sm &amp;&amp; sm-&gt;IsEmpty()) {
        sm = NULL;
    }

    for(i = 0; i &lt; SK.entity.n; i++) {
        Entity *e = &amp;(SK.entity.elem[i]);
        if(!e-&gt;IsVisible()) continue;
        if(e-&gt;construction) continue;

        if(SS.exportPwlCurves || sm || fabs(SS.exportOffset) &gt; LENGTH_EPS)
        {
            // We will be doing hidden line removal, which we can't do on
            // exact curves; so we need things broken down to pwls. Same
            // problem with cutter radius compensation.
            e-&gt;GenerateEdges(&amp;edges);
        } else {
            e-&gt;GenerateBezierCurves(&amp;beziers);
        }
    }

    if(SS.GW.showEdges || SS.GW.showOutlines) {
        Group *g = SK.GetGroup(SS.GW.activeGroup);
        g-&gt;GenerateDisplayItems();
        if(SS.GW.showEdges) {
            g-&gt;displayOutlines.ListTaggedInto(&amp;edges, Style::SOLID_EDGE);
        }
    }

    if(SS.GW.showConstraints) {
        if(!out-&gt;OutputConstraints(&amp;SK.constraint)) {
            GetEdgesCanvas canvas = {};
            canvas.camera = SS.GW.GetCamera();
            canvas.edges  = &amp;edges;

            // The output format cannot represent constraints directly,
            // so convert them to edges.
            for(Constraint &amp;c : SK.constraint) {
                c.Draw(Constraint::DrawAs::DEFAULT, &amp;canvas);
            }

            canvas.Clear();
        }
    }

    if(exportWireframe) {
        Vector u = Vector::From(1.0, 0.0, 0.0),
               v = Vector::From(0.0, 1.0, 0.0),
               n = Vector::From(0.0, 0.0, 1.0),
               origin = Vector::From(0.0, 0.0, 0.0);
        double cameraTan = 0.0,

        out-&gt;SetModelviewProjection(u, v, n, origin,
                                    SS.CameraTangent()*SS.GW.scale, SS.exportScale);

        ExportLinesAndMesh(&amp;edges, &amp;beziers, sm,
                           u, v, n, origin, SS.CameraTangent()*SS.GW.scale,
                           out);

        if(!out-&gt;HasCanvasSize()) {
            // These file formats don't have a canvas size, so they just
            // get exported in the raw coordinate system. So indicate what
            // that was on-screen.
            SS.justExportedInfo.showOrigin = true;
            SS.justExportedInfo.pt = origin;
            SS.justExportedInfo.u = u;
            SS.justExportedInfo.v = v;
        } else {
            SS.justExportedInfo.showOrigin = false;
        }

        SS.justExportedInfo.draw = true;
        InvalidateGraphics();
    }

    edges.Clear();
    beziers.Clear();
}

</t>
<t tx="leo1.20171224221221.95">void SolveSpaceUI::ExportWireframeCurves(SEdgeList *sel, SBezierList *sbl,
                           VectorFileWriter *out)
{
    SBezierLoopSetSet sblss = {};
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        SBezier sb = SBezier::From(
                                (se-&gt;a).ScaledBy(1.0 / SS.exportScale),
                                (se-&gt;b).ScaledBy(1.0 / SS.exportScale));
        sblss.AddOpenPath(&amp;sb);
    }

    sbl-&gt;ScaleSelfBy(1.0/SS.exportScale);
    SBezier *sb;
    for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
        sblss.AddOpenPath(sb);
    }

    out-&gt;OutputLinesAndMesh(&amp;sblss, NULL);
    sblss.Clear();
}

</t>
<t tx="leo1.20171224221221.96">void SolveSpaceUI::ExportLinesAndMesh(SEdgeList *sel, SBezierList *sbl, SMesh *sm,
                                      Vector u, Vector v, Vector n,
                                      Vector origin, double cameraTan,
                                      VectorFileWriter *out)
{
    double s = 1.0 / SS.exportScale;

    // Project into the export plane; so when we're done, z doesn't matter,
    // and x and y are what goes in the DXF.
    SEdge *e;
    for(e = sel-&gt;l.First(); e; e = sel-&gt;l.NextAfter(e)) {
        // project into the specified csys, and apply export scale
        (e-&gt;a) = e-&gt;a.InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
        (e-&gt;b) = e-&gt;b.InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
    }

    SBezier *b;
    if(sbl) {
        for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
            *b = b-&gt;InPerspective(u, v, n, origin, cameraTan);
            int i;
            for(i = 0; i &lt;= b-&gt;deg; i++) {
                b-&gt;ctrl[i] = (b-&gt;ctrl[i]).ScaledBy(s);
            }
        }
    }

    // If cutter radius compensation is requested, then perform it now
    if(fabs(SS.exportOffset) &gt; LENGTH_EPS) {
        // assemble those edges into a polygon, and clear the edge list
        SPolygon sp = {};
        sel-&gt;AssemblePolygon(&amp;sp, NULL);
        sel-&gt;Clear();

        SPolygon compd = {};
        sp.normal = Vector::From(0, 0, -1);
        sp.FixContourDirections();
        sp.OffsetInto(&amp;compd, SS.exportOffset*s);
        sp.Clear();

        compd.MakeEdgesInto(sel);
        compd.Clear();
    }

    // Now the triangle mesh; project, then build a BSP to perform
    // occlusion testing and generated the shaded surfaces.
    SMesh smp = {};
    if(sm) {
        Vector l0 = (SS.lightDir[0]).WithMagnitude(1),
               l1 = (SS.lightDir[1]).WithMagnitude(1);
        STriangle *tr;
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            STriangle tt = *tr;
            tt.a = (tt.a).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
            tt.b = (tt.b).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
            tt.c = (tt.c).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);

            // And calculate lighting for the triangle
            Vector n = tt.Normal().WithMagnitude(1);
            double lighting = SS.ambientIntensity +
    SMesh sms = {};

    // We need the mesh for occlusion testing, but if we don't/can't export it,
    // don't generate it.
    if(SS.GW.showShaded &amp;&amp; out-&gt;CanOutputMesh()) {
        // Use the BSP routines to generate the split triangles in paint order.
        SBsp3 *bsp = SBsp3::FromMesh(&amp;smp);
        if(bsp) bsp-&gt;GenerateInPaintOrder(&amp;sms);
        // And cull the back-facing triangles
        STriangle *tr;
        sms.l.ClearTags();
        for(tr = sms.l.First(); tr; tr = sms.l.NextAfter(tr)) {
            Vector n = tr-&gt;Normal();
            if(n.z &lt; 0) {
                tr-&gt;tag = 1;
            }
        }
        sms.l.RemoveTagged();
    }

    // And now we perform hidden line removal if requested
    SEdgeList hlrd = {};
    if(sm) {
        SKdNode *root = SKdNode::From(&amp;smp);

        // Generate the edges where a curved surface turns from front-facing
        // to back-facing.
        if(SS.GW.showEdges || SS.GW.showOutlines) {
            root-&gt;MakeCertainEdgesInto(sel, EdgeKind::TURNING,
                                       /*coplanarIsInter=*/false, NULL, NULL,
                                       GW.showOutlines ? Style::OUTLINE : Style::SOLID_EDGE);
        }

        root-&gt;ClearTags();
        int cnt = 1234;

        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            if(se-&gt;auxA == Style::CONSTRAINT) {
                // Constraints should not get hidden line removed; they're
                // always on top.
                hlrd.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA);
                continue;
            }

            SEdgeList edges = {};
            // Split the original edge against the mesh
            edges.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA);
            root-&gt;OcclusionTestLine(*se, &amp;edges, cnt);
            if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::STIPPLED) {
                for(SEdge &amp;se : edges.l) {
                    if(se.tag == 1) {
                        se.auxA = Style::HIDDEN_EDGE;
                    }
                }
            } else if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::INVISIBLE) {
                edges.l.RemoveTagged();
            }

            // the occlusion test splits unnecessarily; so fix those
            edges.MergeCollinearSegments(se-&gt;a, se-&gt;b);
            cnt++;
            // And add the results to our output
            SEdge *sen;
            for(sen = edges.l.First(); sen; sen = edges.l.NextAfter(sen)) {
                hlrd.AddEdge(sen-&gt;a, sen-&gt;b, sen-&gt;auxA);
            }
            edges.Clear();
        }

        sel = &amp;hlrd;
    }

    // Clean up: remove overlapping line segments and
    // segments with zero-length projections.
    sel-&gt;l.ClearTags();
    for(int i = 0; i &lt; sel-&gt;l.n; ++i) {
        SEdge *sei = &amp;sel-&gt;l.elem[i];
        hStyle hsi = { (uint32_t)sei-&gt;auxA };
        Style *si = Style::Get(hsi);
        if(sei-&gt;tag != 0) continue;

        // Remove segments with zero length projections.
        Vector ai = sei-&gt;a;
        ai.z = 0.0;
        Vector bi = sei-&gt;b;
        bi.z = 0.0;
        Vector di = bi.Minus(ai);
        if(fabs(di.x) &lt; LENGTH_EPS &amp;&amp; fabs(di.y) &lt; LENGTH_EPS) {
            sei-&gt;tag = 1;
            continue;
        }

        for(int j = i + 1; j &lt; sel-&gt;l.n; ++j) {
            SEdge *sej = &amp;sel-&gt;l.elem[j];
            if(sej-&gt;tag != 0) continue;

            Vector *pAj = &amp;sej-&gt;a;
            Vector *pBj = &amp;sej-&gt;b;

            // Remove segments with zero length projections.
            Vector aj = sej-&gt;a;
            aj.z = 0.0;
            Vector bj = sej-&gt;b;
            bj.z = 0.0;
            Vector dj = bj.Minus(aj);
            if(fabs(dj.x) &lt; LENGTH_EPS &amp;&amp; fabs(dj.y) &lt; LENGTH_EPS) {
                sej-&gt;tag = 1;
                continue;
            }

            // Skip non-collinear segments.
            const double eps = 1e-6;
            if(aj.DistanceToLine(ai, di) &gt; eps) continue;
            if(bj.DistanceToLine(ai, di) &gt; eps) continue;

            double ta = aj.Minus(ai).Dot(di) / di.Dot(di);
            double tb = bj.Minus(ai).Dot(di) / di.Dot(di);
            if(ta &gt; tb) {
                std::swap(pAj, pBj);
                std::swap(ta, tb);
            }

            hStyle hsj = { (uint32_t)sej-&gt;auxA };
            Style *sj = Style::Get(hsj);

            bool canRemoveI = sej-&gt;auxA == sei-&gt;auxA || si-&gt;zIndex &lt; sj-&gt;zIndex;
            bool canRemoveJ = sej-&gt;auxA == sei-&gt;auxA || sj-&gt;zIndex &lt; si-&gt;zIndex;

            if(canRemoveJ) {
                // j-segment inside i-segment
                if(ta &gt; 0.0 - eps &amp;&amp; tb &lt; 1.0 + eps) {
                    sej-&gt;tag = 1;
                    continue;
                }

                // cut segment
                bool aInside = ta &gt; 0.0 - eps &amp;&amp; ta &lt; 1.0 + eps;
                if(tb &gt; 1.0 - eps &amp;&amp; aInside) {
                    *pAj = sei-&gt;b;
                    continue;
                }

                // cut segment
                bool bInside = tb &gt; 0.0 - eps &amp;&amp; tb &lt; 1.0 + eps;
                if(ta &lt; 0.0 - eps &amp;&amp; bInside) {
                    *pBj = sei-&gt;a;
                    continue;
                }

                // split segment
                if(ta &lt; 0.0 - eps &amp;&amp; tb &gt; 1.0 + eps) {
                    sel-&gt;AddEdge(sei-&gt;b, *pBj, sej-&gt;auxA, sej-&gt;auxB);
                    *pBj = sei-&gt;a;
                    continue;
                }
            }

            if(canRemoveI) {
                // j-segment inside i-segment
                if(ta &lt; 0.0 + eps &amp;&amp; tb &gt; 1.0 - eps) {
                    sei-&gt;tag = 1;
                    break;
                }

                // cut segment
                bool aInside = ta &gt; 0.0 + eps &amp;&amp; ta &lt; 1.0 - eps;
                if(tb &gt; 1.0 - eps &amp;&amp; aInside) {
                    sei-&gt;b = *pAj;
                    i--;
                    break;
                }

                // cut segment
                bool bInside = tb &gt; 0.0 + eps &amp;&amp; tb &lt; 1.0 - eps;
                if(ta &lt; 0.0 + eps &amp;&amp; bInside) {
                    sei-&gt;a = *pBj;
                    i--;
                    break;
                }

                // split segment
                if(ta &gt; 0.0 + eps &amp;&amp; tb &lt; 1.0 - eps) {
                    sel-&gt;AddEdge(*pBj, sei-&gt;b, sei-&gt;auxA, sei-&gt;auxB);
                    sei-&gt;b = *pAj;
                    i--;
                    break;
                }
            }
        }
    }
    sel-&gt;l.RemoveTagged();

    // We kept the line segments and Beziers separate until now; but put them
    // all together, and also project everything into the xy plane, since not
    // all export targets ignore the z component of the points.
    for(e = sel-&gt;l.First(); e; e = sel-&gt;l.NextAfter(e)) {
        SBezier sb = SBezier::From(e-&gt;a, e-&gt;b);
        sb.auxA = e-&gt;auxA;
        sbl-&gt;l.Add(&amp;sb);
    }
    for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
        for(int i = 0; i &lt;= b-&gt;deg; i++) {
            b-&gt;ctrl[i].z = 0;
        }
    }

    // If possible, then we will assemble these output curves into loops. They
    // will then get exported as closed paths.
    SBezierLoopSetSet sblss = {};
    SBezierList leftovers = {};
    SSurface srf = SSurface::FromPlane(Vector::From(0, 0, 0),
                                       Vector::From(1, 0, 0),
                                       Vector::From(0, 1, 0));
    SPolygon spxyz = {};
    bool allClosed;
    SEdge notClosedAt;
    sbl-&gt;l.ClearTags();
    sblss.FindOuterFacesFrom(sbl, &amp;spxyz, &amp;srf,
                             SS.ExportChordTolMm(),
                             &amp;allClosed, &amp;notClosedAt,
                             NULL, NULL,
                             &amp;leftovers);
    for(b = leftovers.l.First(); b; b = leftovers.l.NextAfter(b)) {
        sblss.AddOpenPath(b);
    }

    // Now write the lines and triangles to the output file
    out-&gt;OutputLinesAndMesh(&amp;sblss, &amp;sms);

    leftovers.Clear();
    spxyz.Clear();
    sblss.Clear();
    smp.Clear();
    sms.Clear();
    hlrd.Clear();
}

double VectorFileWriter::MmToPts(double mm) {
    // 72 points in an inch
    return (mm/25.4)*72;
}

VectorFileWriter *VectorFileWriter::ForFile(const Platform::Path &amp;filename) {
    VectorFileWriter *ret;
    bool needOpen = true;
    if(filename.HasExtension("dxf")) {
        static DxfFileWriter DxfWriter;
        ret = &amp;DxfWriter;
        needOpen = false;
    } else if(filename.HasExtension("ps") || filename.HasExtension("eps")) {
        static EpsFileWriter EpsWriter;
        ret = &amp;EpsWriter;
    } else if(filename.HasExtension("pdf")) {
        static PdfFileWriter PdfWriter;
        ret = &amp;PdfWriter;
    } else if(filename.HasExtension("svg")) {
        static SvgFileWriter SvgWriter;
        ret = &amp;SvgWriter;
    } else if(filename.HasExtension("plt") || filename.HasExtension("hpgl")) {
        static HpglFileWriter HpglWriter;
        ret = &amp;HpglWriter;
    } else if(filename.HasExtension("step") || filename.HasExtension("stp")) {
        static Step2dFileWriter Step2dWriter;
        ret = &amp;Step2dWriter;
    } else if(filename.HasExtension("txt") || filename.HasExtension("ngc")) {
        static GCodeFileWriter GCodeWriter;
        ret = &amp;GCodeWriter;
    } else {
        Error("Can't identify output file type from file extension of "
        "filename '%s'; try "
        ".step, .stp, .dxf, .svg, .plt, .hpgl, .pdf, .txt, .ngc, "
        ".eps, or .ps.",
            filename.raw.c_str());
        return NULL;
    }
    ret-&gt;filename = filename;
    if(!needOpen) return ret;

    FILE *f = OpenFile(filename, "wb");
    if(!f) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return NULL;
    }
    ret-&gt;f = f;
    return ret;
}

</t>
<t tx="leo1.20171224221221.97">void VectorFileWriter::SetModelviewProjection(const Vector &amp;u, const Vector &amp;v, const Vector &amp;n,
                                              const Vector &amp;origin, double cameraTan,
                                              double scale) {
    this-&gt;u = u;
    this-&gt;v = v;
    this-&gt;n = n;
    this-&gt;origin = origin;
    this-&gt;cameraTan = cameraTan;
    this-&gt;scale = scale;
}

Vector VectorFileWriter::Transform(Vector &amp;pos) const {
    return pos.InPerspective(u, v, n, origin, cameraTan).ScaledBy(1.0 / scale);
}

</t>
<t tx="leo1.20171224221221.98">void VectorFileWriter::OutputLinesAndMesh(SBezierLoopSetSet *sblss, SMesh *sm) {
    STriangle *tr;
    SBezier *b;

    // First calculate the bounding box.
    ptMin = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
    ptMax = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);
    if(sm) {
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            (tr-&gt;a).MakeMaxMin(&amp;ptMax, &amp;ptMin);
            (tr-&gt;b).MakeMaxMin(&amp;ptMax, &amp;ptMin);
            (tr-&gt;c).MakeMaxMin(&amp;ptMax, &amp;ptMin);
        }
    }
    if(sblss) {
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            SBezierLoop *sbl;
            for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
                for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
                    for(int i = 0; i &lt;= b-&gt;deg; i++) {
                        (b-&gt;ctrl[i]).MakeMaxMin(&amp;ptMax, &amp;ptMin);
                    }
                }
            }
        }
    }

    // And now we compute the canvas size.
    double s = 1.0 / SS.exportScale;
    if(SS.exportCanvasSizeAuto) {
        // It's based on the calculated bounding box; we grow it along each
        // boundary by the specified amount.
        ptMin.x -= s*SS.exportMargin.left;
        ptMax.x += s*SS.exportMargin.right;
        ptMin.y -= s*SS.exportMargin.bottom;
        ptMax.y += s*SS.exportMargin.top;
    } else {
        ptMin.x = -(s*SS.exportCanvas.dx);
        ptMin.y = -(s*SS.exportCanvas.dy);
        ptMax.x = ptMin.x + (s*SS.exportCanvas.width);
        ptMax.y = ptMin.y + (s*SS.exportCanvas.height);
    }

    StartFile();
    if(sm &amp;&amp; SS.exportShadedTriangles) {
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            Triangle(tr);
        }
    }
    if(sblss) {
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            SBezierLoop *sbl;
            sbl = sbls-&gt;l.First();
            if(!sbl) continue;
            b = sbl-&gt;l.First();
            if(!b || !Style::Exportable(b-&gt;auxA)) continue;

            hStyle hs = { (uint32_t)b-&gt;auxA };
            Style *stl = Style::Get(hs);
            double lineWidth   = Style::WidthMm(b-&gt;auxA)*s;
            RgbaColor strokeRgb = Style::Color(hs, /*forExport=*/true);
            RgbaColor fillRgb   = Style::FillColor(hs, /*forExport=*/true);

            StartPath(strokeRgb, lineWidth, stl-&gt;filled, fillRgb, hs);
            for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
                for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
                    Bezier(b);
                }
            }
            FinishPath(strokeRgb, lineWidth, stl-&gt;filled, fillRgb, hs);
        }
    }
    FinishAndCloseFile();
}

</t>
<t tx="leo1.20171224221221.99">void VectorFileWriter::BezierAsPwl(SBezier *sb) {
    List&lt;Vector&gt; lv = {};
    sb-&gt;MakePwlInto(&amp;lv, SS.ExportChordTolMm());
    int i;
    for(i = 1; i &lt; lv.n; i++) {
        SBezier sb = SBezier::From(lv.elem[i-1], lv.elem[i]);
        Bezier(&amp;sb);
    }
    lv.Clear();
}

</t>
<t tx="leo1.20171224221222.1"></t>
<t tx="leo1.20171224221222.10">auto startFunc = [&amp;](PolylineBuilder::Vertex *start,
                     PolylineBuilder::Vertex *next,
                     PolylineBuilder::Edge *e) {
    hStyle hs = { e-&gt;kind };
    polyline = {};
    assignEntityDefaults(&amp;polyline, hs);

    if(!(EXACT(start-&gt;pos.z == 0.0) &amp;&amp; EXACT(next-&gt;pos.z == 0.0))) {
        polyline.flags |= 8 /* 3d polyline */;
    }
    polyline.vertlist.push_back(
        new DRW_Vertex(start-&gt;pos.x, start-&gt;pos.y, start-&gt;pos.z, 0.0));
    polyline.vertlist.push_back(
        new DRW_Vertex(next-&gt;pos.x, next-&gt;pos.y, next-&gt;pos.z, 0.0));
};

</t>
<t tx="leo1.20171224221222.100">void SolveSpaceUI::LoadUsingTable(const Platform::Path &amp;filename, char *key, char *val) {
    int i;
    for(i = 0; SAVED[i].type != 0; i++) {
        if(strcmp(SAVED[i].desc, key)==0) {
            SAVEDptr *p = (SAVEDptr *)SAVED[i].ptr;
            unsigned int u = 0;
            switch(SAVED[i].fmt) {
                case 'S': p-&gt;S() = val;                     break;
                case 'b': p-&gt;b() = (atoi(val) != 0);        break;
                case 'd': p-&gt;d() = atoi(val);               break;
                case 'f': p-&gt;f() = atof(val);               break;
                case 'x': sscanf(val, "%x", &amp;u); p-&gt;x()= u; break;

                case 'P': {
                    Platform::Path path = Platform::Path::FromPortable(val);
                    if(!path.IsEmpty()) {
                        p-&gt;P() = filename.Parent().Join(path).Expand();
                    }
                    break;
                }

                case 'c':
                    sscanf(val, "%x", &amp;u);
                    p-&gt;c() = RgbaColor::FromPackedInt(u);
                    break;

                case 'M': {
                    // Don't clear this list! When the group gets added, it
                    // makes a shallow copy, so that would result in us
                    // freeing memory that we want to keep around. Just
                    // zero it out so that new memory is allocated.
                    p-&gt;M() = {};
                    for(;;) {
                        EntityMap em;
                        char line2[1024];
                        if (fgets(line2, (int)sizeof(line2), fh) == NULL)
                            break;
                        if(sscanf(line2, "%d %x %d", &amp;(em.h.v), &amp;(em.input.v),
                                                     &amp;(em.copyNumber)) == 3)
                        {
                            p-&gt;M().Add(&amp;em);
                        } else {
                            break;
                        }
                    }
                    break;
                }

                case 'i': break;

                default: ssassert(false, "Unexpected value format");
            }
            break;
        }
    }
    if(SAVED[i].type == 0) {
        fileLoadError = true;
    }
}

</t>
<t tx="leo1.20171224221222.101">bool SolveSpaceUI::LoadFromFile(const Platform::Path &amp;filename, bool canCancel) {
    allConsistent = false;
    fileLoadError = false;

    fh = OpenFile(filename, "rb");
    if(!fh) {
        Error("Couldn't read from file '%s'", filename.raw.c_str());
        return false;
    }

    ClearExisting();

    sv = {};
    sv.g.scale = 1; // default is 1, not 0; so legacy files need this
    Style::FillDefaultStyle(&amp;sv.s);

    char line[1024];
    while(fgets(line, (int)sizeof(line), fh)) {
        char *s = strchr(line, '\n');
        if(s) *s = '\0';
        // We should never get files with \r characters in them, but mailers
        // will sometimes mangle attachments.
        s = strchr(line, '\r');
        if(s) *s = '\0';

        if(*line == '\0') continue;

        char *e = strchr(line, '=');
        if(e) {
            *e = '\0';
            char *key = line, *val = e+1;
            LoadUsingTable(filename, key, val);
        } else if(strcmp(line, "AddGroup")==0) {
            // legacy files have a spurious dependency between linked groups
            // and their parent groups, remove
            if(sv.g.type == Group::Type::LINKED)
                sv.g.opA.v = 0;

            SK.group.Add(&amp;(sv.g));
            sv.g = {};
            sv.g.scale = 1; // default is 1, not 0; so legacy files need this
        } else if(strcmp(line, "AddParam")==0) {
            // params are regenerated, but we want to preload the values
            // for initial guesses
            SK.param.Add(&amp;(sv.p));
            sv.p = {};
        } else if(strcmp(line, "AddEntity")==0) {
            // entities are regenerated
        } else if(strcmp(line, "AddRequest")==0) {
            SK.request.Add(&amp;(sv.r));
            sv.r = {};
        } else if(strcmp(line, "AddConstraint")==0) {
            SK.constraint.Add(&amp;(sv.c));
            sv.c = {};
        } else if(strcmp(line, "AddStyle")==0) {
            SK.style.Add(&amp;(sv.s));
            sv.s = {};
            Style::FillDefaultStyle(&amp;sv.s);
        } else if(strcmp(line, VERSION_STRING)==0) {
            // do nothing, version string
        } else if(StrStartsWith(line, "Triangle ")      ||
                  StrStartsWith(line, "Surface ")       ||
                  StrStartsWith(line, "SCtrl ")         ||
                  StrStartsWith(line, "TrimBy ")        ||
                  StrStartsWith(line, "Curve ")         ||
                  StrStartsWith(line, "CCtrl ")         ||
                  StrStartsWith(line, "CurvePt ")       ||
                  strcmp(line, "AddSurface")==0         ||
                  strcmp(line, "AddCurve")==0)
        {
            // ignore the mesh or shell, since we regenerate that
        } else {
            fileLoadError = true;
        }
    }

    fclose(fh);

    if(fileLoadError) {
        Error(_("Unrecognized data in file. This file may be corrupt, or "
                "from a newer version of the program."));
        // At least leave the program in a non-crashing state.
        if(SK.group.n == 0) {
            NewFile();
        }
    }
    if(!ReloadAllLinked(filename, canCancel)) {
        return false;
    }
    UpgradeLegacyData();

    return true;
}

</t>
<t tx="leo1.20171224221222.102">void SolveSpaceUI::UpgradeLegacyData() {
    for(Request &amp;r : SK.request) {
        switch(r.type) {
            // TTF text requests saved in versions prior to 3.0 only have two
            // reference points (origin and origin plus v); version 3.0 adds two
            // more points, and if we don't do anything, then they will appear
            // at workplane origin, and the solver will mess up the sketch if
            // it is not fully constrained.
            case Request::Type::TTF_TEXT: {
                IdList&lt;Entity,hEntity&gt; entity = {};
                IdList&lt;Param,hParam&gt;   param = {};
                r.Generate(&amp;entity, &amp;param);

                // If we didn't load all of the entities and params that this
                // request would generate, then add them now, so that we can
                // force them to their appropriate positions.
                for(Param &amp;p : param) {
                    if(SK.param.FindByIdNoOops(p.h) != NULL) continue;
                    SK.param.Add(&amp;p);
                }
                bool allPointsExist = true;
                for(Entity &amp;e : entity) {
                    if(SK.entity.FindByIdNoOops(e.h) != NULL) continue;
                    SK.entity.Add(&amp;e);
                    allPointsExist = false;
                }

                if(!allPointsExist) {
                    Entity *text = entity.FindById(r.h.entity(0));
                    Entity *b = entity.FindById(text-&gt;point[2]);
                    Entity *c = entity.FindById(text-&gt;point[3]);
                    ExprVector bex, cex;
                    text-&gt;RectGetPointsExprs(&amp;bex, &amp;cex);
                    b-&gt;PointForceParamTo(bex.Eval());
                    c-&gt;PointForceParamTo(cex.Eval());
                }
                entity.Clear();
                param.Clear();
                break;
            }

            default:
                break;
        }
    }

    // Constraints saved in versions prior to 3.0 never had any params;
    // version 3.0 introduced params to constraints to avoid the hairy ball problem,
    // so force them where they belong.
    IdList&lt;Param,hParam&gt; oldParam = {};
    SK.param.DeepCopyInto(&amp;oldParam);
    SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

    @others
}

</t>
<t tx="leo1.20171224221222.103">auto AllParamsExistFor = [&amp;](Constraint &amp;c) {
    IdList&lt;Param,hParam&gt; param = {};
    c.Generate(&amp;param);
    bool allParamsExist = true;
    for(Param &amp;p : param) {
        if(oldParam.FindByIdNoOops(p.h) != NULL) continue;
        allParamsExist = false;
        break;
    }
    param.Clear();
    return allParamsExist;
};

for(Constraint &amp;c : SK.constraint) {
    switch(c.type) {
        case Constraint::Type::PT_ON_LINE: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *eln = SK.GetEntity(c.entityA);
            EntityBase *ea = SK.GetEntity(eln-&gt;point[0]);
            EntityBase *eb = SK.GetEntity(eln-&gt;point[1]);
            EntityBase *ep = SK.GetEntity(c.ptA);

            ExprVector exp = ep-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exa = ea-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exb = eb-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exba = exb.Minus(exa);
            Param *p = SK.GetParam(c.h.param(0));
            p-&gt;val = exba.Dot(exp.Minus(exa))-&gt;Eval() / exba.Dot(exba)-&gt;Eval();
            break;
        }

        case Constraint::Type::CUBIC_LINE_TANGENT: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *cubic = SK.GetEntity(c.entityA);
            EntityBase *line  = SK.GetEntity(c.entityB);

            ExprVector a;
            if(c.other) {
                a = cubic-&gt;CubicGetFinishTangentExprs();
            } else {
                a = cubic-&gt;CubicGetStartTangentExprs();
            }

            ExprVector b = line-&gt;VectorGetExprs();

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        case Constraint::Type::SAME_ORIENTATION: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *an = SK.GetEntity(c.entityA);
            EntityBase *bn = SK.GetEntity(c.entityB);

            ExprVector a = an-&gt;NormalExprsN();
            ExprVector b = bn-&gt;NormalExprsN();

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        case Constraint::Type::PARALLEL: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *ea = SK.GetEntity(c.entityA),
                       *eb = SK.GetEntity(c.entityB);
            ExprVector a = ea-&gt;VectorGetExprsInWorkplane(c.workplane);
            ExprVector b = eb-&gt;VectorGetExprsInWorkplane(c.workplane);

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        default:
            break;
    }
}
oldParam.Clear();
</t>
<t tx="leo1.20171224221222.104">bool SolveSpaceUI::LoadEntitiesFromFile(const Platform::Path &amp;filename, EntityList *le,
                                        SMesh *m, SShell *sh)
{
    SSurface srf = {};
    SCurve crv = {};

    fh = OpenFile(filename, "rb");
    if(!fh) return false;

    le-&gt;Clear();
    sv = {};

    char line[1024];
    while(fgets(line, (int)sizeof(line), fh)) {
        char *s = strchr(line, '\n');
        if(s) *s = '\0';
        // We should never get files with \r characters in them, but mailers
        // will sometimes mangle attachments.
        s = strchr(line, '\r');
        if(s) *s = '\0';

        if(*line == '\0') continue;

        char *e = strchr(line, '=');
        if(e) {
            *e = '\0';
            char *key = line, *val = e+1;
            LoadUsingTable(filename, key, val);
        } else if(strcmp(line, "AddGroup")==0) {
            // Don't leak memory; these get allocated whether we want them
            // or not.
            sv.g.remap.Clear();
        } else if(strcmp(line, "AddParam")==0) {

        } else if(strcmp(line, "AddEntity")==0) {
            le-&gt;Add(&amp;(sv.e));
            sv.e = {};
        } else if(strcmp(line, "AddRequest")==0) {

        } else if(strcmp(line, "AddConstraint")==0) {

        } else if(strcmp(line, "AddStyle")==0) {

        } else if(strcmp(line, VERSION_STRING)==0) {

        } else if(StrStartsWith(line, "Triangle ")) {
            STriangle tr = {};
            unsigned int rgba = 0;
            if(sscanf(line, "Triangle %x %x  "
                             "%lf %lf %lf  %lf %lf %lf  %lf %lf %lf",
                &amp;(tr.meta.face), &amp;rgba,
                &amp;(tr.a.x), &amp;(tr.a.y), &amp;(tr.a.z),
                &amp;(tr.b.x), &amp;(tr.b.y), &amp;(tr.b.z),
                &amp;(tr.c.x), &amp;(tr.c.y), &amp;(tr.c.z)) != 11) {
                ssassert(false, "Unexpected Triangle format");
            }
            tr.meta.color = RgbaColor::FromPackedInt((uint32_t)rgba);
            m-&gt;AddTriangle(&amp;tr);
        } else if(StrStartsWith(line, "Surface ")) {
            unsigned int rgba = 0;
            if(sscanf(line, "Surface %x %x %x %d %d",
                &amp;(srf.h.v), &amp;rgba, &amp;(srf.face),
                &amp;(srf.degm), &amp;(srf.degn)) != 5) {
                ssassert(false, "Unexpected Surface format");
            }
            srf.color = RgbaColor::FromPackedInt((uint32_t)rgba);
        } else if(StrStartsWith(line, "SCtrl ")) {
            int i, j;
            Vector c;
            double w;
            if(sscanf(line, "SCtrl %d %d %lf %lf %lf Weight %lf",
                                &amp;i, &amp;j, &amp;(c.x), &amp;(c.y), &amp;(c.z), &amp;w) != 6)
            {
                ssassert(false, "Unexpected SCtrl format");
            }
            srf.ctrl[i][j] = c;
            srf.weight[i][j] = w;
        } else if(StrStartsWith(line, "TrimBy ")) {
            STrimBy stb = {};
            int backwards;
            if(sscanf(line, "TrimBy %x %d  %lf %lf %lf  %lf %lf %lf",
                &amp;(stb.curve.v), &amp;backwards,
                &amp;(stb.start.x), &amp;(stb.start.y), &amp;(stb.start.z),
                &amp;(stb.finish.x), &amp;(stb.finish.y), &amp;(stb.finish.z)) != 8)
            {
                ssassert(false, "Unexpected TrimBy format");
            }
            stb.backwards = (backwards != 0);
            srf.trim.Add(&amp;stb);
        } else if(strcmp(line, "AddSurface")==0) {
            sh-&gt;surface.Add(&amp;srf);
            srf = {};
        } else if(StrStartsWith(line, "Curve ")) {
            int isExact;
            if(sscanf(line, "Curve %x %d %d %x %x",
                &amp;(crv.h.v),
                &amp;(isExact),
                &amp;(crv.exact.deg),
                &amp;(crv.surfA.v), &amp;(crv.surfB.v)) != 5)
            {
                ssassert(false, "Unexpected Curve format");
            }
            crv.isExact = (isExact != 0);
        } else if(StrStartsWith(line, "CCtrl ")) {
            int i;
            Vector c;
            double w;
            if(sscanf(line, "CCtrl %d %lf %lf %lf Weight %lf",
                                &amp;i, &amp;(c.x), &amp;(c.y), &amp;(c.z), &amp;w) != 5)
            {
                ssassert(false, "Unexpected CCtrl format");
            }
            crv.exact.ctrl[i] = c;
            crv.exact.weight[i] = w;
        } else if(StrStartsWith(line, "CurvePt ")) {
            SCurvePt scpt;
            int vertex;
            if(sscanf(line, "CurvePt %d %lf %lf %lf",
                &amp;vertex,
                &amp;(scpt.p.x), &amp;(scpt.p.y), &amp;(scpt.p.z)) != 4)
            {
                ssassert(false, "Unexpected CurvePt format");
            }
            scpt.vertex = (vertex != 0);
            crv.pts.Add(&amp;scpt);
        } else if(strcmp(line, "AddCurve")==0) {
            sh-&gt;curve.Add(&amp;crv);
            crv = {};
        } else ssassert(false, "Unexpected operation");
    }

    fclose(fh);
    return true;
}

</t>
<t tx="leo1.20171224221222.105">bool SolveSpaceUI::ReloadAllLinked(const Platform::Path &amp;saveFile, bool canCancel) {
    std::map&lt;Platform::Path, Platform::Path, Platform::PathLess&gt; linkMap;

    allConsistent = false;

    for(Group &amp;g : SK.group) {
        if(g.type != Group::Type::LINKED) continue;

        g.impEntity.Clear();
        g.impMesh.Clear();
        g.impShell.Clear();

        // If we prompted for this specific file before, don't ask again.
        if(linkMap.count(g.linkFile)) {
            g.linkFile = linkMap[g.linkFile];
        }

try_again:
        if(LoadEntitiesFromFile(g.linkFile, &amp;g.impEntity, &amp;g.impMesh, &amp;g.impShell)) {
            // We loaded the data, good. Now import its dependencies as well.
            for(Entity &amp;e : g.impEntity) {
                if(e.type != Entity::Type::IMAGE) continue;
                if(!ReloadLinkedImage(g.linkFile, &amp;e.file, canCancel)) {
                    return false;
                }
            }
        } else if(linkMap.count(g.linkFile) == 0) {
            // The file was moved; prompt the user for its new location.
            switch(LocateImportedFileYesNoCancel(g.linkFile.RelativeTo(saveFile), canCancel)) {
            case DIALOG_YES: {
                Platform::Path newLinkFile;
                if(GetOpenFile(&amp;newLinkFile, "", SlvsFileFilter)) {
                    linkMap[g.linkFile] = newLinkFile;
                    g.linkFile = newLinkFile;
                    goto try_again;
                } else {
                    if(canCancel) return false;
                    break;
                }
            }

            case DIALOG_NO:
                linkMap[g.linkFile].Clear();
                // Geometry will be pruned by GenerateAll().
                break;

            case DIALOG_CANCEL:
                return false;
            }
        } else {
            // User was already asked to and refused to locate a missing linked file.
        }
    }

    for(Request &amp;r : SK.request) {
        if(r.type != Request::Type::IMAGE) continue;

        if(!ReloadLinkedImage(saveFile, &amp;r.file, canCancel)) {
            return false;
        }
    }

    return true;
}

</t>
<t tx="leo1.20171224221222.106">bool SolveSpaceUI::ReloadLinkedImage(const Platform::Path &amp;saveFile,
                                     Platform::Path *filename, bool canCancel) {
    std::shared_ptr&lt;Pixmap&gt; pixmap;
    bool promptOpenFile = false;
    if(filename-&gt;IsEmpty()) {
        // We're prompting the user for a new image.
        promptOpenFile = true;
    } else {
        auto image = SS.images.find(*filename);
        if(image != SS.images.end()) return true;

        pixmap = Pixmap::ReadPng(*filename);
        if(pixmap == NULL) {
            // The file was moved; prompt the user for its new location.
            switch(LocateImportedFileYesNoCancel(filename-&gt;RelativeTo(saveFile), canCancel)) {
                case DIALOG_YES:
                    promptOpenFile = true;
                    break;

                case DIALOG_NO:
                    // We don't know where the file is, record it as absent.
                    break;

                case DIALOG_CANCEL:
                    return false;
            }
        }
    }

    if(promptOpenFile) {
        if(GetOpenFile(filename, "", RasterFileFilter)) {
            pixmap = Pixmap::ReadPng(*filename);
            if(pixmap == NULL) {
                Error("The image '%s' is corrupted.", filename-&gt;raw.c_str());
            }
            // We know where the file is now, good.
        } else if(canCancel) {
            return false;
        }
    }

    // We loaded the data, good.
    SS.images[*filename] = pixmap;
    return true;
}
</t>
<t tx="leo1.20171224221222.107">//-----------------------------------------------------------------------------
// Generate our model based on its parametric description, by solving each
// sketch, generating surfaces from the resulting entities, performing any
// requested surface operations (e.g. Booleans) with our model so far, and
// then repeating this process for each subsequent group.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221222.108">void SolveSpaceUI::MarkGroupDirtyByEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    MarkGroupDirty(e-&gt;group);
}

</t>
<t tx="leo1.20171224221222.109">void SolveSpaceUI::MarkGroupDirty(hGroup hg, bool onlyThis) {
    int i;
    bool go = false;
    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        if(g-&gt;h.v == hg.v) {
            go = true;
        }
        if(go) {
            g-&gt;clean = false;
            if(onlyThis) break;
        }
    }
    unsaved = true;
    ScheduleGenerateAll();
}

</t>
<t tx="leo1.20171224221222.11">auto nextFunc = [&amp;](PolylineBuilder::Vertex *next, PolylineBuilder::Edge *e) {
    if(!EXACT(next-&gt;pos.z == 0.0)) {
        polyline.flags |= 8 /* 3d polyline */;
    }
    polyline.vertlist.push_back(
        new DRW_Vertex(next-&gt;pos.x, next-&gt;pos.y, next-&gt;pos.z, 0.0));
};

</t>
<t tx="leo1.20171224221222.110">bool SolveSpaceUI::PruneOrphans() {
    int i;
    for(i = 0; i &lt; SK.request.n; i++) {
        Request *r = &amp;(SK.request.elem[i]);
        if(GroupExists(r-&gt;group)) continue;

        (deleted.requests)++;
        SK.request.RemoveById(r-&gt;h);
        return true;
    }

    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);
        if(GroupExists(c-&gt;group)) continue;

        (deleted.constraints)++;
        (deleted.nonTrivialConstraints)++;

        SK.constraint.RemoveById(c-&gt;h);
        return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221222.111">bool SolveSpaceUI::GroupsInOrder(hGroup before, hGroup after) {
    if(before.v == 0) return true;
    if(after.v  == 0) return true;
    if(!GroupExists(before)) return false;
    if(!GroupExists(after)) return false;
    int beforep = SK.GetGroup(before)-&gt;order;
    int afterp = SK.GetGroup(after)-&gt;order;
    if(beforep &gt;= afterp) return false;
    return true;
}

</t>
<t tx="leo1.20171224221222.112">bool SolveSpaceUI::GroupExists(hGroup hg) {
    // A nonexistent group is not acceptable
    return SK.group.FindByIdNoOops(hg) ? true : false;
}
</t>
<t tx="leo1.20171224221222.113">bool SolveSpaceUI::EntityExists(hEntity he) {
    // A nonexstient entity is acceptable, though, usually just means it
    // doesn't apply.
    if(he.v == Entity::NO_ENTITY.v) return true;
    return SK.entity.FindByIdNoOops(he) ? true : false;
}

</t>
<t tx="leo1.20171224221222.114">bool SolveSpaceUI::PruneGroups(hGroup hg) {
    Group *g = SK.GetGroup(hg);
    if(GroupsInOrder(g-&gt;opA, hg) &amp;&amp;
       EntityExists(g-&gt;predef.origin) &amp;&amp;
       EntityExists(g-&gt;predef.entityB) &amp;&amp;
       EntityExists(g-&gt;predef.entityC))
    {
        return false;
    }
    (deleted.groups)++;
    SK.group.RemoveById(g-&gt;h);
    return true;
}

</t>
<t tx="leo1.20171224221222.115">bool SolveSpaceUI::PruneRequests(hGroup hg) {
    int i;
    for(i = 0; i &lt; SK.entity.n; i++) {
        Entity *e = &amp;(SK.entity.elem[i]);
        if(e-&gt;group.v != hg.v) continue;

        if(EntityExists(e-&gt;workplane)) continue;

        ssassert(e-&gt;h.isFromRequest(), "Only explicitly created entities can be pruned");

        (deleted.requests)++;
        SK.request.RemoveById(e-&gt;h.request());
        return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221222.116">bool SolveSpaceUI::PruneConstraints(hGroup hg) {
    int i;
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;group.v != hg.v) continue;

        if(EntityExists(c-&gt;workplane) &amp;&amp;
           EntityExists(c-&gt;ptA) &amp;&amp;
           EntityExists(c-&gt;ptB) &amp;&amp;
           EntityExists(c-&gt;entityA) &amp;&amp;
           EntityExists(c-&gt;entityB) &amp;&amp;
           EntityExists(c-&gt;entityC) &amp;&amp;
           EntityExists(c-&gt;entityD))
        {
            continue;
        }

        (deleted.constraints)++;
        if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp;
           c-&gt;type != Constraint::Type::HORIZONTAL &amp;&amp;
           c-&gt;type != Constraint::Type::VERTICAL)
        {
            (deleted.nonTrivialConstraints)++;
        }

        SK.constraint.RemoveById(c-&gt;h);
        return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221222.117">void SolveSpaceUI::GenerateAll(Generate type, bool andFindFree, bool genForBBox) {
    int first = 0, last = 0, i, j;

    uint64_t startMillis = GetMilliseconds(),
             endMillis;

    SK.groupOrder.Clear();
    for(int i = 0; i &lt; SK.group.n; i++)
        SK.groupOrder.Add(&amp;SK.group.elem[i].h);
    std::sort(&amp;SK.groupOrder.elem[0], &amp;SK.groupOrder.elem[SK.groupOrder.n],
        [](const hGroup &amp;ha, const hGroup &amp;hb) {
            return SK.GetGroup(ha)-&gt;order &lt; SK.GetGroup(hb)-&gt;order;
        });

    switch(type) {
        case Generate::DIRTY: {
            first = INT_MAX;
            last  = 0;

            // Start from the first dirty group, and solve until the active group,
            // since all groups after the active group are hidden.
            for(i = 0; i &lt; SK.groupOrder.n; i++) {
                Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
                if((!g-&gt;clean) || !g-&gt;IsSolvedOkay()) {
                    first = min(first, i);
                }
                if(g-&gt;h.v == SS.GW.activeGroup.v) {
                    last = i;
                }
            }
            if(first == INT_MAX || last == 0) {
                // All clean; so just regenerate the entities, and don't solve anything.
                first = -1;
                last  = -1;
            } else {
                SS.nakedEdges.Clear();
            }
            break;
        }

        case Generate::ALL:
            first = 0;
            last  = INT_MAX;
            break;

        case Generate::REGEN:
            first = -1;
            last  = -1;
            break;

        case Generate::UNTIL_ACTIVE: {
            for(i = 0; i &lt; SK.groupOrder.n; i++) {
                if(SK.groupOrder.elem[i].v == SS.GW.activeGroup.v)
                    break;
            }

            first = 0;
            last  = i;
            break;
        }
    }

    // If we're generating entities for display, first we need to find
    // the bounding box to turn relative chord tolerance to absolute.
    if(!SS.exportMode &amp;&amp; !genForBBox) {
        GenerateAll(type, andFindFree, /*genForBBox=*/true);
        BBox box = SK.CalculateEntityBBox(/*includeInvisibles=*/true);
        Vector size = box.maxp.Minus(box.minp);
        double maxSize = std::max({ size.x, size.y, size.z });
        chordTolCalculated = maxSize * chordTol / 100.0;
    }

    // Remove any requests or constraints that refer to a nonexistent
    // group; can check those immediately, since we know what the list
    // of groups should be.
    while(PruneOrphans())
        ;

    // Don't lose our numerical guesses when we regenerate.
    IdList&lt;Param,hParam&gt; prev = {};
    SK.param.MoveSelfInto(&amp;prev);
    SK.param.ReserveMore(prev.n);
    int oldEntityCount = SK.entity.n;
    SK.entity.Clear();
    SK.entity.ReserveMore(oldEntityCount);

    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);

        // The group may depend on entities or other groups, to define its
        // workplane geometry or for its operands. Those must already exist
        // in a previous group, so check them before generating.
        if(PruneGroups(g-&gt;h))
            goto pruned;

        for(j = 0; j &lt; SK.request.n; j++) {
            Request *r = &amp;(SK.request.elem[j]);
            if(r-&gt;group.v != g-&gt;h.v) continue;

            r-&gt;Generate(&amp;(SK.entity), &amp;(SK.param));
        }
        for(j = 0; j &lt; SK.constraint.n; j++) {
            Constraint *c = &amp;SK.constraint.elem[j];
            if(c-&gt;group.v != g-&gt;h.v) continue;

            c-&gt;Generate(&amp;(SK.param));
        }
        g-&gt;Generate(&amp;(SK.entity), &amp;(SK.param));

        // The requests and constraints depend on stuff in this or the
        // previous group, so check them after generating.
        if(PruneRequests(g-&gt;h) || PruneConstraints(g-&gt;h))
            goto pruned;

        // Use the previous values for params that we've seen before, as
        // initial guesses for the solver.
        for(j = 0; j &lt; SK.param.n; j++) {
            Param *newp = &amp;(SK.param.elem[j]);
            if(newp-&gt;known) continue;

            Param *prevp = prev.FindByIdNoOops(newp-&gt;h);
            if(prevp) {
                newp-&gt;val = prevp-&gt;val;
                newp-&gt;free = prevp-&gt;free;
            }
        }

        if(g-&gt;h.v == Group::HGROUP_REFERENCES.v) {
            ForceReferences();
            g-&gt;solved.how = SolveResult::OKAY;
            g-&gt;clean = true;
        } else {
            if(i &gt;= first &amp;&amp; i &lt;= last) {
                // The group falls inside the range, so really solve it,
                // and then regenerate the mesh based on the solved stuff.
                if(genForBBox) {
                    SolveGroupAndReport(g-&gt;h, andFindFree);
                    g-&gt;GenerateLoops();
                } else {
                    g-&gt;GenerateShellAndMesh();
                    g-&gt;clean = true;
                }
            } else {
                // The group falls outside the range, so just assume that
                // it's good wherever we left it. The mesh is unchanged,
                // and the parameters must be marked as known.
                for(j = 0; j &lt; SK.param.n; j++) {
                    Param *newp = &amp;(SK.param.elem[j]);

                    Param *prevp = prev.FindByIdNoOops(newp-&gt;h);
                    if(prevp) newp-&gt;known = true;
                }
            }
        }
    }

    // And update any reference dimensions with their new values
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;reference) {
            c-&gt;ModifyToSatisfy();
        }
    }

    // Make sure the point that we're tracing exists.
    if(traced.point.v &amp;&amp; !SK.entity.FindByIdNoOops(traced.point)) {
        traced.point = Entity::NO_ENTITY;
    }
    // And if we're tracing a point, add its new value to the path
    if(traced.point.v) {
        Entity *pt = SK.GetEntity(traced.point);
        traced.path.AddPoint(pt-&gt;PointGetNum());
    }

    prev.Clear();
    InvalidateGraphics();

    // Remove nonexistent selection items, for same reason we waited till
    // the end to put up a dialog box.
    GW.ClearNonexistentSelectionItems();

    if(deleted.requests &gt; 0 || deleted.constraints &gt; 0 || deleted.groups &gt; 0) {
        // All sorts of interesting things could have happened; for example,
        // the active group or active workplane could have been deleted. So
        // clear all that out.
        if(deleted.groups &gt; 0) {
            SS.TW.ClearSuper();
        }
        ScheduleShowTW();
        GW.ClearSuper();

        // People get annoyed if I complain whenever they delete any request,
        // and I otherwise will, since those always come with pt-coincident
        // constraints.
        if(deleted.requests &gt; 0 || deleted.nonTrivialConstraints &gt; 0 ||
           deleted.groups &gt; 0)
        {
            // Don't display any errors until we've regenerated fully. The
            // sketch is not necessarily in a consistent state until we've
            // pruned any orphaned etc. objects, and the message loop for the
            // messagebox could allow us to repaint and crash. But now we must
            // be fine.
            Message("Additional sketch elements were deleted, because they "
                    "depend on the element that was just deleted explicitly. "
                    "These include: \n"
                    "     %d request%s\n"
                    "     %d constraint%s\n"
                    "     %d group%s"
                    "%s",
                       deleted.requests, deleted.requests == 1 ? "" : "s",
                       deleted.constraints, deleted.constraints == 1 ? "" : "s",
                       deleted.groups, deleted.groups == 1 ? "" : "s",
                       undo.cnt &gt; 0 ? "\n\nChoose Edit -&gt; Undo to undelete all elements." : "");
        }

        deleted = {};
    }

    FreeAllTemporary();
    allConsistent = true;
    SS.GW.persistentDirty = true;
    SS.centerOfMass.dirty = true;

    endMillis = GetMilliseconds();

    if(endMillis - startMillis &gt; 30) {
        const char *typeStr = "";
        switch(type) {
            case Generate::DIRTY:           typeStr = "DIRTY";        break;
            case Generate::ALL:             typeStr = "ALL";          break;
            case Generate::REGEN:           typeStr = "REGEN";        break;
            case Generate::UNTIL_ACTIVE:    typeStr = "UNTIL_ACTIVE"; break;
        }
        if(endMillis)
        dbp("Generate::%s%s took %lld ms",
            typeStr,
            (genForBBox ? " (for bounding box)" : ""),
            GetMilliseconds() - startMillis);
    }

    return;

pruned:
    // Restore the numerical guesses
    SK.param.Clear();
    prev.MoveSelfInto(&amp;(SK.param));
    // Try again
    GenerateAll(type, andFindFree, genForBBox);
}

</t>
<t tx="leo1.20171224221222.118">void SolveSpaceUI::ForceReferences() {
    // Force the values of the parameters that define the three reference
    // coordinate systems.
    @others
}

</t>
<t tx="leo1.20171224221222.119">static const struct {
    hRequest    hr;
    Quaternion  q;
} Quat[] = {
    { Request::HREQUEST_REFERENCE_XY, { 1,    0,    0,    0,   } },
    { Request::HREQUEST_REFERENCE_YZ, { 0.5,  0.5,  0.5,  0.5, } },
    { Request::HREQUEST_REFERENCE_ZX, { 0.5, -0.5, -0.5, -0.5, } },
};
for(int i = 0; i &lt; 3; i++) {
    hRequest hr = Quat[i].hr;
    Entity *wrkpl = SK.GetEntity(hr.entity(0));
    // The origin for our coordinate system, always zero
    Entity *origin = SK.GetEntity(wrkpl-&gt;point[0]);
    origin-&gt;PointForceTo(Vector::From(0, 0, 0));
    origin-&gt;construction = true;
    SK.GetParam(origin-&gt;param[0])-&gt;known = true;
    SK.GetParam(origin-&gt;param[1])-&gt;known = true;
    SK.GetParam(origin-&gt;param[2])-&gt;known = true;
    // The quaternion that defines the rotation, from the table.
    Entity *normal = SK.GetEntity(wrkpl-&gt;normal);
    normal-&gt;NormalForceTo(Quat[i].q);
    SK.GetParam(normal-&gt;param[0])-&gt;known = true;
    SK.GetParam(normal-&gt;param[1])-&gt;known = true;
    SK.GetParam(normal-&gt;param[2])-&gt;known = true;
    SK.GetParam(normal-&gt;param[3])-&gt;known = true;
}
</t>
<t tx="leo1.20171224221222.12">auto endFunc = [&amp;]() {
    dxf-&gt;writePolyline(&amp;polyline);
};

</t>
<t tx="leo1.20171224221222.120">void SolveSpaceUI::UpdateCenterOfMass() {
    SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
    SS.centerOfMass.position = m-&gt;GetCenterOfMass();
    SS.centerOfMass.dirty = false;
}

</t>
<t tx="leo1.20171224221222.121">void SolveSpaceUI::MarkDraggedParams() {
    sys.dragged.Clear();

    for(int i = -1; i &lt; SS.GW.pending.points.n; i++) {
        hEntity hp;
        if(i == -1) {
            hp = SS.GW.pending.point;
        } else {
            hp = SS.GW.pending.points.elem[i];
        }
        if(!hp.v) continue;

        // The pending point could be one in a group that has not yet
        // been processed, in which case the lookup will fail; but
        // that's not an error.
        Entity *pt = SK.entity.FindByIdNoOops(hp);
        if(pt) {
            switch(pt-&gt;type) {
                case Entity::Type::POINT_N_TRANS:
                case Entity::Type::POINT_IN_3D:
                    sys.dragged.Add(&amp;(pt-&gt;param[0]));
                    sys.dragged.Add(&amp;(pt-&gt;param[1]));
                    sys.dragged.Add(&amp;(pt-&gt;param[2]));
                    break;

                case Entity::Type::POINT_IN_2D:
                    sys.dragged.Add(&amp;(pt-&gt;param[0]));
                    sys.dragged.Add(&amp;(pt-&gt;param[1]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
    if(SS.GW.pending.circle.v) {
        Entity *circ = SK.entity.FindByIdNoOops(SS.GW.pending.circle);
        if(circ) {
            Entity *dist = SK.GetEntity(circ-&gt;distance);
            switch(dist-&gt;type) {
                case Entity::Type::DISTANCE:
                    sys.dragged.Add(&amp;(dist-&gt;param[0]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
    if(SS.GW.pending.normal.v) {
        Entity *norm = SK.entity.FindByIdNoOops(SS.GW.pending.normal);
        if(norm) {
            switch(norm-&gt;type) {
                case Entity::Type::NORMAL_IN_3D:
                    sys.dragged.Add(&amp;(norm-&gt;param[0]));
                    sys.dragged.Add(&amp;(norm-&gt;param[1]));
                    sys.dragged.Add(&amp;(norm-&gt;param[2]));
                    sys.dragged.Add(&amp;(norm-&gt;param[3]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
}

</t>
<t tx="leo1.20171224221222.122">void SolveSpaceUI::SolveGroupAndReport(hGroup hg, bool andFindFree) {
    SolveGroup(hg, andFindFree);

    Group *g = SK.GetGroup(hg);
    @others
}

</t>
<t tx="leo1.20171224221222.123">bool isOkay = g-&gt;solved.how == SolveResult::OKAY ||
              (g-&gt;allowRedundant &amp;&amp; g-&gt;solved.how == SolveResult::REDUNDANT_OKAY);
if(!isOkay || (isOkay &amp;&amp; !g-&gt;IsSolvedOkay())) {
    TextWindow::ReportHowGroupSolved(g-&gt;h);
}
</t>
<t tx="leo1.20171224221222.124">void SolveSpaceUI::WriteEqSystemForGroup(hGroup hg) {
    int i;
    // Clear out the system to be solved.
    sys.entity.Clear();
    sys.param.Clear();
    sys.eq.Clear();
    // And generate all the params for requests in this group
    for(i = 0; i &lt; SK.request.n; i++) {
        Request *r = &amp;(SK.request.elem[i]);
        if(r-&gt;group.v != hg.v) continue;

        r-&gt;Generate(&amp;(sys.entity), &amp;(sys.param));
    }
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;SK.constraint.elem[i];
        if(c-&gt;group.v != hg.v) continue;

        c-&gt;Generate(&amp;(sys.param));
    }
    // And for the group itself
    Group *g = SK.GetGroup(hg);
    g-&gt;Generate(&amp;(sys.entity), &amp;(sys.param));
    // Set the initial guesses for all the params
    for(i = 0; i &lt; sys.param.n; i++) {
        Param *p = &amp;(sys.param.elem[i]);
        p-&gt;known = false;
        p-&gt;val = SK.GetParam(p-&gt;h)-&gt;val;
    }

    MarkDraggedParams();
}

</t>
<t tx="leo1.20171224221222.125">void SolveSpaceUI::SolveGroup(hGroup hg, bool andFindFree) {
    WriteEqSystemForGroup(hg);
    Group *g = SK.GetGroup(hg);
    g-&gt;solved.remove.Clear();
    SolveResult how = sys.Solve(g, &amp;(g-&gt;solved.dof),
                                   &amp;(g-&gt;solved.remove),
                                   /*andFindBad=*/true,
                                   /*andFindFree=*/andFindFree,
                                   /*forceDofCheck=*/!g-&gt;dofCheckOk);
    if(how == SolveResult::OKAY) {
        g-&gt;dofCheckOk = true;
    }
    g-&gt;solved.how = how;
    FreeAllTemporary();
}

SolveResult SolveSpaceUI::TestRankForGroup(hGroup hg) {
    WriteEqSystemForGroup(hg);
    Group *g = SK.GetGroup(hg);
    SolveResult result = sys.SolveRank(g, NULL, NULL, false, false,
                                       /*forceDofCheck=*/!g-&gt;dofCheckOk);
    FreeAllTemporary();
    return result;
}

</t>
<t tx="leo1.20171224221222.126">bool SolveSpaceUI::ActiveGroupsOkay() {
    for(int i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        if(!g-&gt;IsSolvedOkay())
            return false;
        if(g-&gt;h.v == SS.GW.activeGroup.v)
            break;
    }
    return true;
}

</t>
<t tx="leo1.20171224221222.127">//-----------------------------------------------------------------------------
// Top-level implementation of the program's main window, in which a graphical
// representation of the model is drawn and edited by the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

#define mView (&amp;GraphicsWindow::MenuView)
#define mEdit (&amp;GraphicsWindow::MenuEdit)
#define mClip (&amp;GraphicsWindow::MenuClipboard)
#define mReq  (&amp;GraphicsWindow::MenuRequest)
#define mCon  (&amp;Constraint::MenuConstrain)
#define mFile (&amp;SolveSpaceUI::MenuFile)
#define mGrp  (&amp;Group::MenuGroup)
#define mAna  (&amp;SolveSpaceUI::MenuAnalyze)
#define mHelp (&amp;SolveSpaceUI::MenuHelp)
#define DEL   DELETE_KEY
#define ESC   ESCAPE_KEY
#define S     SHIFT_MASK
#define C     CTRL_MASK
#define F(k)  (FUNCTION_KEY_BASE+(k))
#define TN    MenuKind::NORMAL
#define TC    MenuKind::CHECK
#define TR    MenuKind::RADIO
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221222.128">const GraphicsWindow::MenuEntry GraphicsWindow::menu[] = {
//level
//   label                              id                         accel    ty   fn
{ 0, N_("&amp;File"),                       Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;New"),                        Command::NEW,              C|'N',   TN, mFile },
{ 1, N_("&amp;Open..."),                    Command::OPEN,             C|'O',   TN, mFile },
{ 1, N_("Open &amp;Recent"),                Command::OPEN_RECENT,      0,       TN, mFile },
{ 1, N_("&amp;Save"),                       Command::SAVE,             C|'S',   TN, mFile },
{ 1, N_("Save &amp;As..."),                 Command::SAVE_AS,          0,       TN, mFile },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Export &amp;Image..."),            Command::EXPORT_PNG,       0,       TN, mFile },
{ 1, N_("Export 2d &amp;View..."),          Command::EXPORT_VIEW,      0,       TN, mFile },
{ 1, N_("Export 2d &amp;Section..."),       Command::EXPORT_SECTION,   0,       TN, mFile },
{ 1, N_("Export 3d &amp;Wireframe..."),     Command::EXPORT_WIREFRAME, 0,       TN, mFile },
{ 1, N_("Export Triangle &amp;Mesh..."),    Command::EXPORT_MESH,      0,       TN, mFile },
{ 1, N_("Export &amp;Surfaces..."),         Command::EXPORT_SURFACES,  0,       TN, mFile },
{ 1, N_("Im&amp;port..."),                  Command::IMPORT,           0,       TN, mFile },
#ifndef __APPLE__
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("E&amp;xit"),                       Command::EXIT,             C|'Q',   TN, mFile },
#endif

{ 0, N_("&amp;Edit"),                       Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Undo"),                       Command::UNDO,             C|'Z',   TN, mEdit },
{ 1, N_("&amp;Redo"),                       Command::REDO,             C|'Y',   TN, mEdit },
{ 1, N_("Re&amp;generate All"),             Command::REGEN_ALL,        ' ',     TN, mEdit },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Snap Selection to &amp;Grid"),     Command::SNAP_TO_GRID,     '.',     TN, mEdit },
{ 1, N_("Rotate Imported &amp;90"),        Command::ROTATE_90,        '9',     TN, mEdit },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Cu&amp;t"),                        Command::CUT,              C|'X',   TN, mClip },
{ 1, N_("&amp;Copy"),                       Command::COPY,             C|'C',   TN, mClip },
{ 1, N_("&amp;Paste"),                      Command::PASTE,            C|'V',   TN, mClip },
{ 1, N_("Paste &amp;Transformed..."),       Command::PASTE_TRANSFORM,  C|'T',   TN, mClip },
{ 1, N_("&amp;Delete"),                     Command::DELETE,           DEL,     TN, mClip },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Select &amp;Edge Chain"),          Command::SELECT_CHAIN,     C|'E',   TN, mEdit },
{ 1, N_("Select &amp;All"),                 Command::SELECT_ALL,       C|'A',   TN, mEdit },
{ 1, N_("&amp;Unselect All"),               Command::UNSELECT_ALL,     ESC,     TN, mEdit },

{ 0, N_("&amp;View"),                       Command::NONE,             0,       TN, NULL  },
{ 1, N_("Zoom &amp;In"),                    Command::ZOOM_IN,          '+',     TN, mView },
{ 1, N_("Zoom &amp;Out"),                   Command::ZOOM_OUT,         '-',     TN, mView },
{ 1, N_("Zoom To &amp;Fit"),                Command::ZOOM_TO_FIT,      'F',     TN, mView },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Align View to &amp;Workplane"),    Command::ONTO_WORKPLANE,   'W',     TN, mView },
{ 1, N_("Nearest &amp;Ortho View"),         Command::NEAREST_ORTHO,    F(2),    TN, mView },
{ 1, N_("Nearest &amp;Isometric View"),     Command::NEAREST_ISO,      F(3),    TN, mView },
{ 1, N_("&amp;Center View At Point"),       Command::CENTER_VIEW,      F(4),    TN, mView },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Show Snap &amp;Grid"),             Command::SHOW_GRID,        '&gt;',     TC, mView },
{ 1, N_("Use &amp;Perspective Projection"), Command::PERSPECTIVE_PROJ, '`',    TC, mView },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Show &amp;Toolbar"),               Command::SHOW_TOOLBAR,     0,       TC, mView },
{ 1, N_("Show Property Bro&amp;wser"),      Command::SHOW_TEXT_WND,    '\t',    TC, mView },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("Dimensions in &amp;Inches"),       Command::UNITS_INCHES,     0,       TR, mView },
{ 1, N_("Dimensions in &amp;Millimeters"),  Command::UNITS_MM,         0,       TR, mView },
{ 1,  NULL,                             Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Full Screen"),                Command::FULL_SCREEN,      C|F(11), TC, mView },

{ 0, N_("&amp;New Group"),                  Command::NONE,             0,       TN, NULL  },
{ 1, N_("Sketch In &amp;3d"),               Command::GROUP_3D,         S|'3',   TN, mGrp  },
{ 1, N_("Sketch In New &amp;Workplane"),    Command::GROUP_WRKPL,      S|'W',   TN, mGrp  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Step &amp;Translating"),           Command::GROUP_TRANS,      S|'T',   TN, mGrp  },
{ 1, N_("Step &amp;Rotating"),              Command::GROUP_ROT,        S|'R',   TN, mGrp  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("E&amp;xtrude"),                    Command::GROUP_EXTRUDE,    S|'X',   TN, mGrp  },
{ 1, N_("&amp;Lathe"),                      Command::GROUP_LATHE,      S|'L',   TN, mGrp  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Link / Assemble..."),          Command::GROUP_LINK,       S|'I',   TN, mGrp  },
{ 1, N_("Link Recent"),                 Command::GROUP_RECENT,     0,       TN, mGrp  },

{ 0, N_("&amp;Sketch"),                     Command::NONE,             0,       TN, NULL  },
{ 1, N_("In &amp;Workplane"),               Command::SEL_WORKPLANE,    '2',     TR, mReq  },
{ 1, N_("Anywhere In &amp;3d"),             Command::FREE_IN_3D,       '3',     TR, mReq  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Datum &amp;Point"),                Command::DATUM_POINT,      'P',     TN, mReq  },
{ 1, N_("&amp;Workplane"),                  Command::WORKPLANE,        0,       TN, mReq  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Line &amp;Segment"),               Command::LINE_SEGMENT,     'S',     TN, mReq  },
{ 1, N_("C&amp;onstruction Line Segment"),  Command::CONSTR_SEGMENT,   S|'S',   TN, mReq  },
{ 1, N_("&amp;Rectangle"),                  Command::RECTANGLE,        'R',     TN, mReq  },
{ 1, N_("&amp;Circle"),                     Command::CIRCLE,           'C',     TN, mReq  },
{ 1, N_("&amp;Arc of a Circle"),            Command::ARC,              'A',     TN, mReq  },
{ 1, N_("&amp;Bezier Cubic Spline"),        Command::CUBIC,            'B',     TN, mReq  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Text in TrueType Font"),      Command::TTF_TEXT,         'T',     TN, mReq  },
{ 1, N_("&amp;Image"),                      Command::IMAGE,            0,       TN, mReq  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("To&amp;ggle Construction"),        Command::CONSTRUCTION,     'G',     TN, mReq  },
{ 1, N_("Tangent &amp;Arc at Point"),       Command::TANGENT_ARC,      S|'A',   TN, mReq  },
{ 1, N_("Split Curves at &amp;Intersection"), Command::SPLIT_CURVES,   'I',     TN, mReq  },

{ 0, N_("&amp;Constrain"),                  Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Distance / Diameter"),        Command::DISTANCE_DIA,     'D',     TN, mCon  },
{ 1, N_("Re&amp;ference Dimension"),        Command::REF_DISTANCE,     S|'D',   TN, mCon  },
{ 1, N_("A&amp;ngle"),                      Command::ANGLE,            'N',     TN, mCon  },
{ 1, N_("Reference An&amp;gle"),            Command::REF_ANGLE,        S|'N',   TN, mCon  },
{ 1, N_("Other S&amp;upplementary Angle"),  Command::OTHER_ANGLE,      'U',     TN, mCon  },
{ 1, N_("Toggle R&amp;eference Dim"),       Command::REFERENCE,        'E',     TN, mCon  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Horizontal"),                 Command::HORIZONTAL,       'H',     TN, mCon  },
{ 1, N_("&amp;Vertical"),                   Command::VERTICAL,         'V',     TN, mCon  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;On Point / Curve / Plane"),   Command::ON_ENTITY,        'O',     TN, mCon  },
{ 1, N_("E&amp;qual Length / Radius / Angle"), Command::EQUAL,         'Q',     TN, mCon  },
{ 1, N_("Length Ra&amp;tio"),               Command::RATIO,            'Z',     TN, mCon  },
{ 1, N_("Length Diff&amp;erence"),          Command::DIFFERENCE,       'J',     TN, mCon  },
{ 1, N_("At &amp;Midpoint"),                Command::AT_MIDPOINT,      'M',     TN, mCon  },
{ 1, N_("S&amp;ymmetric"),                  Command::SYMMETRIC,        'Y',     TN, mCon  },
{ 1, N_("Para&amp;llel / Tangent"),         Command::PARALLEL,         'L',     TN, mCon  },
{ 1, N_("&amp;Perpendicular"),              Command::PERPENDICULAR,    '[',     TN, mCon  },
{ 1, N_("Same Orient&amp;ation"),           Command::ORIENTED_SAME,    'X',     TN, mCon  },
{ 1, N_("Lock Point Where &amp;Dragged"),   Command::WHERE_DRAGGED,    ']',     TN, mCon  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Comment"),                     Command::COMMENT,          ';',     TN, mCon  },

{ 0, N_("&amp;Analyze"),                    Command::NONE,             0,       TN, NULL  },
{ 1, N_("Measure &amp;Volume"),             Command::VOLUME,           C|S|'V', TN, mAna  },
{ 1, N_("Measure A&amp;rea"),               Command::AREA,             C|S|'A', TN, mAna  },
{ 1, N_("Measure &amp;Perimeter"),          Command::PERIMETER,        C|S|'P', TN, mAna  },
{ 1, N_("Show &amp;Interfering Parts"),     Command::INTERFERENCE,     C|S|'I', TN, mAna  },
{ 1, N_("Show &amp;Naked Edges"),           Command::NAKED_EDGES,      C|S|'N', TN, mAna  },
{ 1, N_("Show &amp;Center of Mass"),        Command::CENTER_OF_MASS,      C|S|'C', TN, mAna  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("Show Degrees of &amp;Freedom"),    Command::SHOW_DOF,         C|S|'F', TN, mAna  },
{ 1, NULL,                              Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Trace Point"),                Command::TRACE_PT,         C|S|'T', TN, mAna  },
{ 1, N_("&amp;Stop Tracing..."),            Command::STOP_TRACING,     C|S|'S', TN, mAna  },
{ 1, N_("Step &amp;Dimension..."),          Command::STEP_DIM,         C|S|'D', TN, mAna  },

{ 0, N_("&amp;Help"),                       Command::NONE,             0,       TN, NULL  },
{ 1, N_("&amp;Website / Manual"),           Command::WEBSITE,          0,       TN, mHelp },
{ 1, N_("&amp;Language"),                   Command::LOCALE,           0,       TN, mHelp },
#ifndef __APPLE__
{ 1, N_("&amp;About"),                      Command::ABOUT,            0,       TN, mHelp },
#endif
{ -1, 0,                                Command::NONE,             0,       TN, 0     }
};

#undef DEL
#undef ESC
#undef S
#undef C
#undef F
#undef TN
#undef TC
#undef TR

std::string SolveSpace::MakeAcceleratorLabel(int accel) {
    if(!accel) return "";

    std::string label;
    if(accel &amp; GraphicsWindow::CTRL_MASK) {
        label += "Ctrl+";
    }
    if(accel &amp; GraphicsWindow::SHIFT_MASK) {
        label += "Shift+";
    }
    accel &amp;= ~(GraphicsWindow::CTRL_MASK | GraphicsWindow::SHIFT_MASK);
    if(accel &gt;= GraphicsWindow::FUNCTION_KEY_BASE + 1 &amp;&amp;
       accel &lt;= GraphicsWindow::FUNCTION_KEY_BASE + 12) {
        label += ssprintf("F%d", accel - GraphicsWindow::FUNCTION_KEY_BASE);
    } else if(accel == '\t') {
        label += "Tab";
    } else if(accel == ' ') {
        label += "Space";
    } else if(accel == GraphicsWindow::ESCAPE_KEY) {
        label += "Esc";
    } else if(accel == GraphicsWindow::DELETE_KEY) {
        label += "Del";
    } else {
        label += (char)(accel &amp; 0xff);
    }
    return label;
}

</t>
<t tx="leo1.20171224221222.13">auto aloneFunc = [&amp;](PolylineBuilder::Edge *e) {
    hStyle hs = { e-&gt;kind };
    writeLine(e-&gt;a-&gt;pos, e-&gt;b-&gt;pos, hs);
};

builder.Generate(startFunc, nextFunc, aloneFunc, endFunc);
</t>
<t tx="leo1.20171224221222.14">void writeEntities() override {
    writePolylines();

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            if(sb-&gt;deg == 1) continue;
            writeBezier(sb);
        }
    }

    if(writer-&gt;constraint) {
        Constraint *c;
        for(c = writer-&gt;constraint-&gt;First(); c; c = writer-&gt;constraint-&gt;NextAfter(c)) {
            if(!writer-&gt;NeedToOutput(c)) continue;
            switch(c-&gt;type) {
                case Constraint::Type::PT_PT_DISTANCE: {
                    Vector ap = SK.GetEntity(c-&gt;ptA)-&gt;PointGetNum();
                    Vector bp = SK.GetEntity(c-&gt;ptB)-&gt;PointGetNum();
                    Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(c-&gt;disp.offset);
                    writeAlignedDimension(xfrm(ap),  xfrm(bp), xfrm(ref),
                                          xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::PT_LINE_DISTANCE: {
                    Vector pt = SK.GetEntity(c-&gt;ptA)-&gt;PointGetNum();
                    Entity *line = SK.GetEntity(c-&gt;entityA);
                    Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
                    Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                    Vector dl = lB.Minus(lA);

                    Vector closest = pt.ClosestPointOnLine(lA, dl);

                    if(pt.Equals(closest)) break;

                    Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(c-&gt;disp.offset);
                    Vector refClosest = ref.ClosestPointOnLine(lA, dl);

                    double ddl = dl.Dot(dl);
                    if(fabs(ddl) &gt; LENGTH_EPS * LENGTH_EPS) {
                        double t = refClosest.Minus(lA).Dot(dl) / ddl;
                        if(t &lt; 0.0) {
                            refClosest = lA;
                        } else if(t &gt; 1.0) {
                            refClosest = lB;
                        }
                    }

                    Vector xdl = xfrm(lB).Minus(xfrm(lA));
                    writeLinearDimension(xfrm(pt), xfrm(refClosest), xfrm(ref),
                                         xfrm(ref), c-&gt;Label(),
                                         atan2(xdl.y, xdl.x) / PI * 180.0 + 90.0, 0.0,
                                         c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::DIAMETER: {
                    Entity *circle = SK.GetEntity(c-&gt;entityA);
                    Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
                    Quaternion q = SK.GetEntity(circle-&gt;normal)-&gt;NormalGetNum();
                    Vector n = q.RotationN().WithMagnitude(1);
                    double r = circle-&gt;CircleGetRadiusNum();

                    Vector ref = center.Plus(c-&gt;disp.offset);
                    // Force the label into the same plane as the circle.
                    ref = ref.Minus(n.ScaledBy(n.Dot(ref) - n.Dot(center)));

                    Vector rad = ref.Minus(center).WithMagnitude(r);
                    if(/*isRadius*/c-&gt;other) {
                        writeRadialDimension(
                            xfrm(center), xfrm(center.Plus(rad)),
                            xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    } else {
                        writeDiametricDimension(
                            xfrm(center.Minus(rad)), xfrm(center.Plus(rad)),
                            xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    }
                    break;
                }

                case Constraint::Type::ANGLE: {
                    Entity *a = SK.GetEntity(c-&gt;entityA);
                    Entity *b = SK.GetEntity(c-&gt;entityB);

                    Vector a0 = a-&gt;VectorGetStartPoint();
                    Vector b0 = b-&gt;VectorGetStartPoint();
                    Vector da = a-&gt;VectorGetNum();
                    Vector db = b-&gt;VectorGetNum();
                    if(/*otherAngle*/c-&gt;other) {
                        a0 = a0.Plus(da);
                        da = da.ScaledBy(-1);
                    }

                    bool skew = false;
                    Vector ref = c-&gt;disp.offset;
                    Vector pi = Vector::AtIntersectionOfLines(a0, a0.Plus(da), b0, b0.Plus(db),
                                                              &amp;skew);
                    if(!skew) ref = pi.Plus(c-&gt;disp.offset);

                    Vector norm = da.Cross(db);
                    Vector dna = norm.Cross(da).WithMagnitude(1.0);

                    double thetaf = acos(da.DirectionCosineWith(db));

                    // Calculate median
                    Vector m = da.WithMagnitude(1.0).ScaledBy(cos(thetaf/2)).Plus(
                               dna.ScaledBy(sin(thetaf/2)));
                    Vector rm = ref.Minus(pi);

                    // Test which side we have to place an arc
                    if(m.Dot(rm) &lt; 0) {
                        da = da.ScaledBy(-1); dna = dna.ScaledBy(-1);
                        db = db.ScaledBy(-1);
                    }

                    Vector bisect = da.WithMagnitude(1.0).ScaledBy(cos(thetaf / 2.0)).Plus(
                                    dna.ScaledBy(sin(thetaf / 2.0)));

                    ref = pi.Plus(bisect.WithMagnitude(c-&gt;disp.offset.Magnitude()));

                    // Get lines agian to write exact line.
                    a0 = a-&gt;VectorGetStartPoint();
                    b0 = b-&gt;VectorGetStartPoint();
                    da = a-&gt;VectorGetNum();
                    db = b-&gt;VectorGetNum();

                    writeAngularDimension(
                        xfrm(a0), xfrm(a0.Plus(da)), xfrm(b0), xfrm(b0.Plus(db)), xfrm(ref),
                        xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::COMMENT: {
                    Style *st = SK.style.FindById(c-&gt;GetStyle());
                    writeText(xfrm(c-&gt;disp.offset), c-&gt;Label(),
                              Style::TextHeight(c-&gt;GetStyle()) / SS.GW.scale,
                              st-&gt;textAngle, st-&gt;textOrigin, c-&gt;GetStyle());
                    break;
                }

                default:
                    // Other types of constraints do not have a DXF dimension equivalent.
                    break;
            }
        }
    }
}

</t>
<t tx="leo1.20171224221222.15">int findDxfColor(const RgbaColor &amp;src) {
    int best = 0;
    double minDist = VERY_POSITIVE;
    Vector srcv = Vector::From(src.redF(), src.greenF(), src.blueF());
    for(int i = 1; i &lt; 256; i++) {
        RgbaColor dst = RGBi(DRW::dxfColors[i][0], DRW::dxfColors[i][1], DRW::dxfColors[i][2]);
        Vector dstv = Vector::From(dst.redF(), dst.greenF(), dst.blueF());
        double dist = srcv.Minus(dstv).Magnitude();
        if(dist &lt; minDist || best == 0) {
            best = i;
            minDist = dist;
        }
    }
    return best;
}

</t>
<t tx="leo1.20171224221222.16">void assignEntityDefaults(DRW_Entity *entity, hStyle hs) {
    Style *s = Style::Get(hs);
    RgbaColor color = s-&gt;Color(hs, /*forExport=*/true);
    entity-&gt;color24 = color.ToPackedIntBGRA();
    entity-&gt;color = findDxfColor(color);
    entity-&gt;layer = s-&gt;DescriptionString();
    entity-&gt;lineType = DxfFileWriter::lineTypeName(s-&gt;stippleType);
    entity-&gt;ltypeScale = Style::StippleScaleMm(s-&gt;h);
    entity-&gt;setWidthMm(Style::WidthMm(hs.v));

    if(s-&gt;stippleType == StipplePattern::FREEHAND) {
        messages.insert(_("freehand lines were replaced with continuous lines"));
    } else if(s-&gt;stippleType == StipplePattern::ZIGZAG) {
        messages.insert(_("zigzag lines were replaced with continuous lines"));
    }
}

</t>
<t tx="leo1.20171224221222.17">void assignDimensionDefaults(DRW_Dimension *dimension, hStyle hs) {
    assignEntityDefaults(dimension, hs);
    dimension-&gt;layer = "dimensions";
}

</t>
<t tx="leo1.20171224221222.18">void writeLine(const Vector &amp;p0, const Vector &amp;p1, hStyle hs) {
    DRW_Line line;
    assignEntityDefaults(&amp;line, hs);
    line.basePoint = toCoord(p0);
    line.secPoint = toCoord(p1);
    dxf-&gt;writeLine(&amp;line);
}

</t>
<t tx="leo1.20171224221222.19">void writeArc(const Vector &amp;c, double r, double sa, double ea, hStyle hs) {
    DRW_Arc arc;
    assignEntityDefaults(&amp;arc, hs);
    arc.radious = r;
    arc.basePoint = toCoord(c);
    arc.staangle = sa;
    arc.endangle = ea;
    dxf-&gt;writeArc(&amp;arc);
}

</t>
<t tx="leo1.20171224221222.20">void writeBezierAsPwl(SBezier *sb) {
    List&lt;Vector&gt; lv = {};
    sb-&gt;MakePwlInto(&amp;lv, SS.ExportChordTolMm());
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    DRW_Polyline polyline;
    assignEntityDefaults(&amp;polyline, hs);
    for(int i = 0; i &lt; lv.n; i++) {
        Vector *v = &amp;lv.elem[i];
        DRW_Vertex *vertex = new DRW_Vertex(v-&gt;x, v-&gt;y, v-&gt;z, 0.0);
        polyline.vertlist.push_back(vertex);
    }
    dxf-&gt;writePolyline(&amp;polyline);
    lv.Clear();
}

</t>
<t tx="leo1.20171224221222.21">void makeKnotsFor(DRW_Spline *spline) {
    // QCad/LibreCAD require this for some reason.
    if(spline-&gt;degree == 3) {
        spline-&gt;nknots = 8;
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
    } else if(spline-&gt;degree == 2) {
        spline-&gt;nknots = 6;
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
    } else ssassert(false, "Unexpected degree of spline");
}

</t>
<t tx="leo1.20171224221222.22">void writeSpline(SBezier *sb) {
    bool isRational = sb-&gt;IsRational();
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    DRW_Spline spline;
    assignEntityDefaults(&amp;spline, hs);
    spline.flags = (isRational) ? 0x04 : 0x08;
    spline.degree = sb-&gt;deg;
    spline.ncontrol = sb-&gt;deg + 1;
    makeKnotsFor(&amp;spline);
    for(int i = 0; i &lt;= sb-&gt;deg; i++) {
        spline.controllist.push_back(
            new DRW_Coord(sb-&gt;ctrl[i].x, sb-&gt;ctrl[i].y, sb-&gt;ctrl[i].z));
        if(isRational) spline.weightlist.push_back(sb-&gt;weight[i]);
    }
    dxf-&gt;writeSpline(&amp;spline);
}

</t>
<t tx="leo1.20171224221222.23">void writeBezier(SBezier *sb) {
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    Vector c;
    Vector n = Vector::From(0.0, 0.0, 1.0);
    double r;

    if(sb-&gt;deg == 1) {
        // Line
        writeLine(sb-&gt;ctrl[0], sb-&gt;ctrl[1], hs);
    } else if(sb-&gt;IsInPlane(n, 0) &amp;&amp; sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        // Circle perpendicular to camera
        double theta0 = atan2(sb-&gt;ctrl[0].y - c.y, sb-&gt;ctrl[0].x - c.x);
        double theta1 = atan2(sb-&gt;ctrl[2].y - c.y, sb-&gt;ctrl[2].x - c.x);
        double dtheta = WRAP_SYMMETRIC(theta1 - theta0, 2.0 * PI);
        if(dtheta &lt; 0.0) swap(theta0, theta1);

        writeArc(c, r, theta0, theta1, hs);
    } else if(sb-&gt;IsRational()) {
        // Rational bezier
        // We'd like to export rational beziers exactly, but the resulting DXF
        // files can only be read by AutoCAD; LibreCAD/QCad simply do not
        // implement the feature. So, export as piecewise linear for compatiblity.
        writeBezierAsPwl(sb);
    } else {
        // Any other curve
        writeSpline(sb);
    }
}

</t>
<t tx="leo1.20171224221222.24">void writeAlignedDimension(Vector def1, Vector def2, Vector dimp,
                           Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimAligned dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDef1Point(toCoord(def1));
    dim.setDef2Point(toCoord(def2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo1.20171224221222.25">void writeLinearDimension(Vector def1, Vector def2, Vector dimp,
                          Vector textp, const std::string &amp;text,
                          double angle, double oblique, hStyle hs, double actual) {
    DRW_DimLinear dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDef1Point(toCoord(def1));
    dim.setDef2Point(toCoord(def2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setAngle(angle);
    dim.setOblique(oblique);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo1.20171224221222.26">void writeRadialDimension(Vector center, Vector radius,
                          Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimRadial dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setCenterPoint(toCoord(center));
    dim.setDiameterPoint(toCoord(radius));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo1.20171224221222.27">void writeDiametricDimension(Vector def1, Vector def2,
                             Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimDiametric dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDiameter1Point(toCoord(def1));
    dim.setDiameter2Point(toCoord(def2));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo1.20171224221222.28">void writeAngularDimension(Vector fl1, Vector fl2, Vector sl1, Vector sl2, Vector dimp,
                           Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimAngular dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setFirstLine1(toCoord(fl1));
    dim.setFirstLine2(toCoord(fl2));
    dim.setSecondLine1(toCoord(sl1));
    dim.setSecondLine2(toCoord(sl2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual * PI / 180.0);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo1.20171224221222.29">void writeText(Vector textp, const std::string &amp;text,
               double height, double angle, Style::TextOrigin origin, hStyle hs) {
    DRW_Text txt;
    assignEntityDefaults(&amp;txt, hs);
    txt.layer = "text";
    txt.style = "unicode";
    txt.basePoint = toCoord(textp);
    txt.secPoint = txt.basePoint;
    txt.text = text;
    txt.height = height;
    txt.angle = angle;
    txt.alignH = DRW_Text::HCenter;
    if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::LEFT) {
        txt.alignH = DRW_Text::HLeft;
    } else if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::RIGHT) {
        txt.alignH = DRW_Text::HRight;
    }
    txt.alignV = DRW_Text::VMiddle;
    if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::TOP) {
        txt.alignV = DRW_Text::VTop;
    } else if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::BOT) {
        txt.alignV = DRW_Text::VBaseLine;
    }
    dxf-&gt;writeText(&amp;txt);
}
</t>
<t tx="leo1.20171224221222.3">//-----------------------------------------------------------------------------
// The file format-specific stuff for all of the 2d vector output formats.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include &lt;libdxfrw.h&gt;
#include "solvespace.h"

//-----------------------------------------------------------------------------
// Routines for DXF export
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221222.30">bool DxfFileWriter::OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *constraint) {
    this-&gt;constraint = constraint;
    return true;
}

</t>
<t tx="leo1.20171224221222.31">void DxfFileWriter::StartFile() {
    paths.clear();
}

</t>
<t tx="leo1.20171224221222.32">void DxfFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    BezierPath path = {};
    paths.push_back(path);
}
</t>
<t tx="leo1.20171224221222.33">void DxfFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo1.20171224221222.34">void DxfFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo1.20171224221222.35">void DxfFileWriter::Bezier(SBezier *sb) {
    paths.back().beziers.push_back(sb);
}

</t>
<t tx="leo1.20171224221222.36">void DxfFileWriter::FinishAndCloseFile() {
    dxfRW dxf;

    DxfWriteInterface interface = {};
    interface.writer = this;
    interface.dxf    = &amp;dxf;

    std::stringstream stream;
    dxf.write(stream, &amp;interface, DRW::AC1021, /*bin=*/false);
    paths.clear();
    constraint = NULL;

    if(!WriteFile(filename, stream.str())) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return;
    }

    if(!interface.messages.empty()) {
        std::string text = _("Some aspects of the drawing have no DXF equivalent and "
                             "were not exported:\n");
        for(const std::string &amp;message : interface.messages) {
            text += " * " + message + "\n";
        }
        Message(text.c_str());
    }
}

</t>
<t tx="leo1.20171224221222.37">bool DxfFileWriter::NeedToOutput(Constraint *c) {
    switch(c-&gt;type) {
        case Constraint::Type::PT_PT_DISTANCE:
        case Constraint::Type::PT_LINE_DISTANCE:
        case Constraint::Type::DIAMETER:
        case Constraint::Type::ANGLE:
        case Constraint::Type::COMMENT:
            return c-&gt;IsVisible();

        default: // See writeEntities().
            break;
    }
    return false;
}

</t>
<t tx="leo1.20171224221222.38">const char *DxfFileWriter::lineTypeName(StipplePattern stippleType) {
    switch(stippleType) {
        case StipplePattern::CONTINUOUS:   return "CONTINUOUS";
        case StipplePattern::SHORT_DASH:   return "DASHED";
        case StipplePattern::DASH:         return "DASHED";
        case StipplePattern::LONG_DASH:    return "DASHEDX2";
        case StipplePattern::DASH_DOT:     return "DASHDOT";
        case StipplePattern::DASH_DOT_DOT: return "DIVIDE";
        case StipplePattern::DOT:          return "DOT";

        case StipplePattern::FREEHAND:
        case StipplePattern::ZIGZAG:
            /* no corresponding DXF line type */
           break;
    }

    return "CONTINUOUS";
}

//-----------------------------------------------------------------------------
// Routines for EPS output
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221222.39">static std::string MakeStipplePattern(StipplePattern pattern, double scale, char delimiter,
                                      bool inkscapeWorkaround = false) {
    scale /= 2.0;

    // Inkscape ignores all elements that are exactly zero instead of drawing
    // them as dots.
    double zero = inkscapeWorkaround ? 1e-6 : 0;

    std::string result;
    switch(pattern) {
        case StipplePattern::CONTINUOUS:
            return "";

        case StipplePattern::SHORT_DASH:
            result = ssprintf("%.3f_%.3f", scale, scale * 2.0);
            break;
        case StipplePattern::DASH:
            result = ssprintf("%.3f_%.3f", scale, scale);
            break;
        case StipplePattern::DASH_DOT:
            result = ssprintf("%.3f_%.3f_%.6f_%.3f",
                              scale, scale * 0.5, zero, scale * 0.5);
            break;
        case StipplePattern::DASH_DOT_DOT:
            result = ssprintf("%.3f_%.3f_%.6f_%.3f_%.6f_%.3f",
                              scale, scale * 0.5, zero,
                              scale * 0.5, scale * 0.5, zero);
            break;
        case StipplePattern::DOT:
            result = ssprintf("%.6f_%.3f", zero, scale * 0.5);
            break;
        case StipplePattern::LONG_DASH:
            result = ssprintf("%.3f_%.3f", scale * 2.0, scale * 0.5);
            break;

        case StipplePattern::FREEHAND:
        case StipplePattern::ZIGZAG:
            ssassert(false, "Freehand and zigzag export not implemented");
    }
    std::replace(result.begin(), result.end(), '_', delimiter);
    return result;
}

</t>
<t tx="leo1.20171224221222.4">class DxfWriteInterface : public DRW_Interface {
public:
    DxfFileWriter *writer;
    dxfRW         *dxf;

    std::set&lt;std::string&gt; messages;

    @others
};

</t>
<t tx="leo1.20171224221222.40">void EpsFileWriter::StartFile() {
    fprintf(f,
"%%!PS-Adobe-2.0\r\n"
"%%%%Creator: SolveSpace\r\n"
"%%%%Title: title\r\n"
"%%%%Pages: 0\r\n"
"%%%%PageOrder: Ascend\r\n"
"%%%%BoundingBox: 0 0 %d %d\r\n"
"%%%%HiResBoundingBox: 0 0 %.3f %.3f\r\n"
"%%%%EndComments\r\n"
"\r\n"
"gsave\r\n"
"\r\n",
            (int)ceil(MmToPts(ptMax.x - ptMin.x)),
            (int)ceil(MmToPts(ptMax.y - ptMin.y)),
            MmToPts(ptMax.x - ptMin.x),
            MmToPts(ptMax.y - ptMin.y));
}

</t>
<t tx="leo1.20171224221222.41">void EpsFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    fprintf(f, "newpath\r\n");
    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo1.20171224221222.42">void EpsFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    StipplePattern pattern = Style::PatternType(hs);
    double stippleScale = MmToPts(Style::StippleScaleMm(hs));

    fprintf(f, "    %.3f setlinewidth\r\n"
               "    %.3f %.3f %.3f setrgbcolor\r\n"
               "    1 setlinejoin\r\n"  // rounded
               "    1 setlinecap\r\n"   // rounded
               "    [%s] 0 setdash\r\n"
               "    gsave stroke grestore\r\n",
        MmToPts(lineWidth),
        strokeRgb.redF(), strokeRgb.greenF(), strokeRgb.blueF(),
        MakeStipplePattern(pattern, stippleScale, ' ').c_str());
    if(filled) {
        fprintf(f, "    %.3f %.3f %.3f setrgbcolor\r\n"
                   "    gsave fill grestore\r\n",
            fillRgb.redF(), fillRgb.greenF(), fillRgb.blueF());
    }
}

</t>
<t tx="leo1.20171224221222.43">void EpsFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    if(!prevPt.Equals(st)) {
        fprintf(f, "    %.3f %.3f moveto\r\n",
            MmToPts(st.x - ptMin.x), MmToPts(st.y - ptMin.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo1.20171224221222.44">void EpsFileWriter::Triangle(STriangle *tr) {
    fprintf(f,
"%.3f %.3f %.3f setrgbcolor\r\n"
"newpath\r\n"
"    %.3f %.3f moveto\r\n"
"    %.3f %.3f lineto\r\n"
"    %.3f %.3f lineto\r\n"
"    closepath\r\n"
"gsave fill grestore\r\n",
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            MmToPts(tr-&gt;a.x - ptMin.x), MmToPts(tr-&gt;a.y - ptMin.y),
            MmToPts(tr-&gt;b.x - ptMin.x), MmToPts(tr-&gt;b.y - ptMin.y),
            MmToPts(tr-&gt;c.x - ptMin.x), MmToPts(tr-&gt;c.y - ptMin.y));

    // same issue with cracks, stroke it to avoid them
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;
    fprintf(f,
"1 setlinejoin\r\n"
"1 setlinecap\r\n"
"%.3f setlinewidth\r\n"
"gsave stroke grestore\r\n",
            MmToPts(sw));
}

</t>
<t tx="leo1.20171224221222.45">void EpsFileWriter::Bezier(SBezier *sb) {
    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f,     "    %.3f %.3f lineto\r\n",
                MmToPts(sb-&gt;ctrl[1].x - ptMin.x),
                MmToPts(sb-&gt;ctrl[1].y - ptMin.y));
    } else if(sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        Vector p0 = sb-&gt;ctrl[0], p1 = sb-&gt;ctrl[2];
        double theta0 = atan2(p0.y - c.y, p0.x - c.x),
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
        fprintf(f,
"    %.3f %.3f %.3f %.3f %.3f %.3f curveto\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[2].x - ptMin.x), MmToPts(sb-&gt;ctrl[2].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[3].x - ptMin.x), MmToPts(sb-&gt;ctrl[3].y - ptMin.y));
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

</t>
<t tx="leo1.20171224221222.46">void EpsFileWriter::FinishAndCloseFile() {
    fprintf(f,
"\r\n"
"grestore\r\n"
"\r\n");
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for PDF output, some extra complexity because we have to generate
// a correct xref table.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221222.47">void PdfFileWriter::StartFile() {
    if((ptMax.x - ptMin.x) &gt; 200*25.4 ||
       (ptMax.y - ptMin.y) &gt; 200*25.4)
    {
        Message(_("PDF page size exceeds 200 by 200 inches; many viewers may "
                  "reject this file."));
    }

    fprintf(f,
"%%PDF-1.1\r\n"
"%%%c%c%c%c\r\n",
        0xe2, 0xe3, 0xcf, 0xd3);

    xref[1] = (uint32_t)ftell(f);
    fprintf(f,
"1 0 obj\r\n"
"  &lt;&lt; /Type /Catalog\r\n"
"     /Outlines 2 0 R\r\n"
"     /Pages 3 0 R\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[2] = (uint32_t)ftell(f);
    fprintf(f,
"2 0 obj\r\n"
"  &lt;&lt; /Type /Outlines\r\n"
"     /Count 0\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[3] = (uint32_t)ftell(f);
    fprintf(f,
"3 0 obj\r\n"
"  &lt;&lt; /Type /Pages\r\n"
"     /Kids [4 0 R]\r\n"
"     /Count 1\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[4] = (uint32_t)ftell(f);
    fprintf(f,
"4 0 obj\r\n"
"  &lt;&lt; /Type /Page\r\n"
"     /Parent 3 0 R\r\n"
"     /MediaBox [0 0 %.3f %.3f]\r\n"
"     /Contents 5 0 R\r\n"
"     /Resources &lt;&lt; /ProcSet 7 0 R\r\n"
"                   /Font &lt;&lt; /F1 8 0 R &gt;&gt;\r\n"
"                &gt;&gt;\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n",
            MmToPts(ptMax.x - ptMin.x),
            MmToPts(ptMax.y - ptMin.y));

    xref[5] = (uint32_t)ftell(f);
    fprintf(f,
"5 0 obj\r\n"
"  &lt;&lt; /Length 6 0 R &gt;&gt;\r\n"
"stream\r\n");
    bodyStart = (uint32_t)ftell(f);
}

</t>
<t tx="leo1.20171224221222.48">void PdfFileWriter::FinishAndCloseFile() {
    uint32_t bodyEnd = (uint32_t)ftell(f);

    fprintf(f,
"endstream\r\n"
"endobj\r\n");

    xref[6] = (uint32_t)ftell(f);
    fprintf(f,
"6 0 obj\r\n"
"  %d\r\n"
"endobj\r\n",
        bodyEnd - bodyStart);

    xref[7] = (uint32_t)ftell(f);
    fprintf(f,
"7 0 obj\r\n"
"  [/PDF /Text]\r\n"
"endobj\r\n");

    xref[8] = (uint32_t)ftell(f);
    fprintf(f,
"8 0 obj\r\n"
"  &lt;&lt; /Type /Font\r\n"
"     /Subtype /Type1\r\n"
"     /Name /F1\r\n"
"     /BaseFont /Helvetica\r\n"
"     /Encoding /WinAnsiEncoding\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[9] = (uint32_t)ftell(f);
    fprintf(f,
"9 0 obj\r\n"
"  &lt;&lt; /Creator (SolveSpace)\r\n"
"  &gt;&gt;\r\n");

    uint32_t xrefStart = (uint32_t)ftell(f);
    fprintf(f,
"xref\r\n"
"0 10\r\n"
"0000000000 65535 f\r\n");

    int i;
    for(i = 1; i &lt;= 9; i++) {
        fprintf(f, "%010d %05d n\r\n", xref[i], 0);
    }

    fprintf(f,
"\r\n"
"trailer\r\n"
"  &lt;&lt; /Size 10\r\n"
"     /Root 1 0 R\r\n"
"     /Info 9 0 R\r\n"
"  &gt;&gt;\r\n"
"startxref\r\n"
"%d\r\n"
"%%%%EOF\r\n",
        xrefStart);

    fclose(f);

}

</t>
<t tx="leo1.20171224221222.49">void PdfFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    StipplePattern pattern = Style::PatternType(hs);
    double stippleScale = MmToPts(Style::StippleScaleMm(hs));

    fprintf(f, "1 J 1 j " // round endcaps and joins
               "%.3f w [%s] 0 d "
               "%.3f %.3f %.3f RG\r\n",
        MmToPts(lineWidth),
        MakeStipplePattern(pattern, stippleScale, ' ').c_str(),
        strokeRgb.redF(), strokeRgb.greenF(), strokeRgb.blueF());
    if(filled) {
        fprintf(f, "%.3f %.3f %.3f rg\r\n",
            fillRgb.redF(), fillRgb.greenF(), fillRgb.blueF());
    }

    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo1.20171224221222.5">static DRW_Coord toCoord(const Vector &amp;v) {
    return DRW_Coord(v.x, v.y, v.z);
}

Vector xfrm(Vector v) {
    return writer-&gt;Transform(v);
}

</t>
<t tx="leo1.20171224221222.50">void PdfFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    if(filled) {
        fprintf(f, "b\r\n");
    } else {
        fprintf(f, "S\r\n");
    }
}

</t>
<t tx="leo1.20171224221222.51">void PdfFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    if(!prevPt.Equals(st)) {
        fprintf(f, "%.3f %.3f m\r\n",
            MmToPts(st.x - ptMin.x), MmToPts(st.y - ptMin.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo1.20171224221222.52">void PdfFileWriter::Triangle(STriangle *tr) {
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;

    fprintf(f,
"1 J 1 j\r\n"
"%.3f %.3f %.3f RG\r\n"
"%.3f %.3f %.3f rg\r\n"
"%.3f w\r\n"
"%.3f %.3f m\r\n"
"%.3f %.3f l\r\n"
"%.3f %.3f l\r\n"
"b\r\n",
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            MmToPts(sw),
            MmToPts(tr-&gt;a.x - ptMin.x), MmToPts(tr-&gt;a.y - ptMin.y),
            MmToPts(tr-&gt;b.x - ptMin.x), MmToPts(tr-&gt;b.y - ptMin.y),
            MmToPts(tr-&gt;c.x - ptMin.x), MmToPts(tr-&gt;c.y - ptMin.y));
}

</t>
<t tx="leo1.20171224221222.53">void PdfFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f,
"%.3f %.3f l\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y));
    } else if(sb-&gt;deg == 3 &amp;&amp; !sb-&gt;IsRational()) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
        fprintf(f,
"%.3f %.3f %.3f %.3f %.3f %.3f c\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[2].x - ptMin.x), MmToPts(sb-&gt;ctrl[2].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[3].x - ptMin.x), MmToPts(sb-&gt;ctrl[3].y - ptMin.y));
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

//-----------------------------------------------------------------------------
// Routines for SVG output
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221222.54">void SvgFileWriter::StartFile() {
    fprintf(f,
"&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\" "
    "\"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\"&gt;\r\n"
"&lt;svg xmlns=\"http://www.w3.org/2000/svg\"  "
    "xmlns:xlink=\"http://www.w3.org/1999/xlink\" "
    "width='%.3fmm' height='%.3fmm' "
    "viewBox=\"0 0 %.3f %.3f\"&gt;\r\n"
"\r\n"
"&lt;title&gt;Exported SVG&lt;/title&gt;\r\n"
"\r\n",
        (ptMax.x - ptMin.x), (ptMax.y - ptMin.y),
        (ptMax.x - ptMin.x), (ptMax.y - ptMin.y));

    fprintf(f, "&lt;style&gt;&lt;![CDATA[\r\n");
    fprintf(f, "polygon {\r\n");
    fprintf(f, "shape-rendering:crispEdges;\r\n");
    // crispEdges turns of anti-aliasing, which tends to cause hairline
    // cracks between triangles; but there still is some cracking, so
    // specify a stroke width too, hope for around a pixel
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;
    fprintf(f, "stroke-width:%f;\r\n", sw);
    fprintf(f, "}\r\n");
    for(int i = 0; i &lt; SK.style.n; i++) {
        Style *s = &amp;SK.style.elem[i];
        RgbaColor strokeRgb = Style::Color(s-&gt;h, /*forExport=*/true);
        StipplePattern pattern = Style::PatternType(s-&gt;h);
        double stippleScale = Style::StippleScaleMm(s-&gt;h);

        fprintf(f, ".s%x {\r\n", s-&gt;h.v);
        fprintf(f, "stroke:#%02x%02x%02x;\r\n", strokeRgb.red, strokeRgb.green, strokeRgb.blue);
        // don't know why we have to take a half of the width
        fprintf(f, "stroke-width:%f;\r\n", Style::WidthMm(s-&gt;h.v) / 2.0);
        fprintf(f, "stroke-linecap:round;\r\n");
        fprintf(f, "stroke-linejoin:round;\r\n");
        std::string patternStr = MakeStipplePattern(pattern, stippleScale, ',',
                                                    /*inkscapeWorkaround=*/true);
        if(!patternStr.empty()) {
            fprintf(f, "stroke-dasharray:%s;\r\n", patternStr.c_str());
        }
        fprintf(f, "fill:none;\r\n");
        fprintf(f, "}\r\n");
    }
    fprintf(f, "]]&gt;&lt;/style&gt;\r\n");
}

</t>
<t tx="leo1.20171224221222.55">void SvgFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    fprintf(f, "&lt;path d='");
    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo1.20171224221222.56">void SvgFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    std::string fill;
    if(filled) {
        fill = ssprintf("fill='#%02x%02x%02x'",
            fillRgb.red, fillRgb.green, fillRgb.blue);
    }
    std::string cls = ssprintf("s%x", hs.v);
    fprintf(f, "' class='%s' %s/&gt;\r\n", cls.c_str(), fill.c_str());
}

</t>
<t tx="leo1.20171224221222.57">void SvgFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    // SVG uses a coordinate system with the origin at top left, +y down
    if(!prevPt.Equals(st)) {
        fprintf(f, "M%.3f %.3f ", (st.x - ptMin.x), (ptMax.y - st.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo1.20171224221222.58">void SvgFileWriter::Triangle(STriangle *tr) {
    fprintf(f,
"&lt;polygon points='%.3f,%.3f %.3f,%.3f %.3f,%.3f' "
    "stroke='#%02x%02x%02x' "
    "fill='#%02x%02x%02x'/&gt;\r\n",
            (tr-&gt;a.x - ptMin.x), (ptMax.y - tr-&gt;a.y),
            (tr-&gt;b.x - ptMin.x), (ptMax.y - tr-&gt;b.y),
            (tr-&gt;c.x - ptMin.x), (ptMax.y - tr-&gt;c.y),
            tr-&gt;meta.color.red, tr-&gt;meta.color.green, tr-&gt;meta.color.blue,
            tr-&gt;meta.color.red, tr-&gt;meta.color.green, tr-&gt;meta.color.blue);
}

</t>
<t tx="leo1.20171224221222.59">void SvgFileWriter::Bezier(SBezier *sb) {
    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f, "L%.3f,%.3f ",
            (sb-&gt;ctrl[1].x - ptMin.x), (ptMax.y - sb-&gt;ctrl[1].y));
    } else if(sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        Vector p0 = sb-&gt;ctrl[0], p1 = sb-&gt;ctrl[2];
        double theta0 = atan2(p0.y - c.y, p0.x - c.x),
                        (dtheta &lt; 0) ? 1 : 0,
                        p1.x - ptMin.x, ptMax.y - p1.y);
    } else if(!sb-&gt;IsRational()) {
        if(sb-&gt;deg == 2) {
            MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[2]);
            fprintf(f, "Q%.3f,%.3f %.3f,%.3f ",
                sb-&gt;ctrl[1].x - ptMin.x, ptMax.y - sb-&gt;ctrl[1].y,
                sb-&gt;ctrl[2].x - ptMin.x, ptMax.y - sb-&gt;ctrl[2].y);
        } else if(sb-&gt;deg == 3) {
            MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
            fprintf(f, "C%.3f,%.3f %.3f,%.3f %.3f,%.3f ",
                sb-&gt;ctrl[1].x - ptMin.x, ptMax.y - sb-&gt;ctrl[1].y,
                sb-&gt;ctrl[2].x - ptMin.x, ptMax.y - sb-&gt;ctrl[2].y,
                sb-&gt;ctrl[3].x - ptMin.x, ptMax.y - sb-&gt;ctrl[3].y);
        }
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

</t>
<t tx="leo1.20171224221222.6">void writeTextstyles() override {
    DRW_Textstyle ts;
    ts.name = "unicode";
    ts.font = "unicode";
    dxf-&gt;writeTextstyle(&amp;ts);
}

</t>
<t tx="leo1.20171224221222.60">void SvgFileWriter::FinishAndCloseFile() {
    fprintf(f, "\r\n&lt;/svg&gt;\r\n");
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for HPGL output
//-----------------------------------------------------------------------------
double HpglFileWriter::MmToHpglUnits(double mm) {
    return mm*40;
}

</t>
<t tx="leo1.20171224221222.61">void HpglFileWriter::StartFile() {
    fprintf(f, "IN;\r\n");
    fprintf(f, "SP1;\r\n");
}

</t>
<t tx="leo1.20171224221222.62">void HpglFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo1.20171224221222.63">void HpglFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo1.20171224221222.64">void HpglFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo1.20171224221222.65">void HpglFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        fprintf(f, "PU%d,%d;\r\n",
            (int)MmToHpglUnits(sb-&gt;ctrl[0].x),
            (int)MmToHpglUnits(sb-&gt;ctrl[0].y));
        fprintf(f, "PD%d,%d;\r\n",
            (int)MmToHpglUnits(sb-&gt;ctrl[1].x),
            (int)MmToHpglUnits(sb-&gt;ctrl[1].y));
    } else {
        BezierAsPwl(sb);
    }
}

</t>
<t tx="leo1.20171224221222.66">void HpglFileWriter::FinishAndCloseFile() {
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for G Code output. Slightly complicated by our ability to generate
// multiple passes, and to specify the feeds and depth; those parameters get
// set in the configuration screen.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221222.67">void GCodeFileWriter::StartFile() {
    sel = {};
}
</t>
<t tx="leo1.20171224221222.68">void GCodeFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                                bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo1.20171224221222.69">void GCodeFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                 bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo1.20171224221222.7">void writeLayers() override {
    DRW_Layer layer;

    layer.name = "dimensions";
    dxf-&gt;writeLayer(&amp;layer);
    layer.name = "text";
    dxf-&gt;writeLayer(&amp;layer);

    std::set&lt;uint32_t&gt; usedStyles;

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            usedStyles.insert((uint32_t)sb-&gt;auxA);
        }
    }

    for(uint32_t v : usedStyles) {
        Style *s = Style::Get(hStyle{v});
        layer.name = s-&gt;DescriptionString();
        dxf-&gt;writeLayer(&amp;layer);
    }
}

</t>
<t tx="leo1.20171224221222.70">void GCodeFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo1.20171224221222.71">void GCodeFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        sel.AddEdge(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
    } else {
        BezierAsPwl(sb);
    }
}

</t>
<t tx="leo1.20171224221222.72">void GCodeFileWriter::FinishAndCloseFile() {
    SPolygon sp = {};
    sel.AssemblePolygon(&amp;sp, NULL);

    int i;
    for(i = 0; i &lt; SS.gCode.passes; i++) {
        double depth = (SS.gCode.depth / SS.gCode.passes)*(i+1);

        SContour *sc;
        for(sc = sp.l.First(); sc; sc = sp.l.NextAfter(sc)) {
            if(sc-&gt;l.n &lt; 2) continue;

            SPoint *pt = sc-&gt;l.First();
            fprintf(f, "G00 X%s Y%s\r\n",
                    SS.MmToString(pt-&gt;p.x).c_str(), SS.MmToString(pt-&gt;p.y).c_str());
            fprintf(f, "G01 Z%s F%s\r\n",
                    SS.MmToString(depth).c_str(), SS.MmToString(SS.gCode.plungeFeed).c_str());

            pt = sc-&gt;l.NextAfter(pt);
            for(; pt; pt = sc-&gt;l.NextAfter(pt)) {
                fprintf(f, "G01 X%s Y%s F%s\r\n",
                        SS.MmToString(pt-&gt;p.x).c_str(), SS.MmToString(pt-&gt;p.y).c_str(),
                        SS.MmToString(SS.gCode.feed).c_str());
            }
            // Move up to a clearance plane 5mm above the work.
            fprintf(f, "G00 Z%s\r\n",
                    SS.MmToString(SS.gCode.depth &lt; 0 ? +5 : -5).c_str());
        }
    }

    sp.Clear();
    sel.Clear();
    fclose(f);
}


//-----------------------------------------------------------------------------
// Routine for STEP output; just a wrapper around the general STEP stuff that
// can also be used for surfaces or 3d curves.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221222.73">void Step2dFileWriter::StartFile() {
    sfw = {};
    sfw.f = f;
    sfw.WriteHeader();
}

</t>
<t tx="leo1.20171224221222.74">void Step2dFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo1.20171224221222.75">void Step2dFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                                 bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo1.20171224221222.76">void Step2dFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                  bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo1.20171224221222.77">void Step2dFileWriter::Bezier(SBezier *sb) {
    int c = sfw.ExportCurve(sb);
    sfw.curves.Add(&amp;c);
}

</t>
<t tx="leo1.20171224221222.78">void Step2dFileWriter::FinishAndCloseFile() {
    sfw.WriteWireframe();
    sfw.WriteFooter();
    fclose(f);
}

</t>
<t tx="leo1.20171224221222.79">//-----------------------------------------------------------------------------
// The symbolic algebra system used to write our constraint equations;
// routines to build expressions in software or from a user-provided string,
// and to compute the partial derivatives that we'll use when write our
// Jacobian matrix.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

ExprVector ExprVector::From(Expr *x, Expr *y, Expr *z) {
    ExprVector r = { x, y, z};
    return r;
}

ExprVector ExprVector::From(Vector vn) {
    ExprVector ve;
    ve.x = Expr::From(vn.x);
    ve.y = Expr::From(vn.y);
    ve.z = Expr::From(vn.z);
    return ve;
}

ExprVector ExprVector::From(hParam x, hParam y, hParam z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::From(double x, double y, double z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::Minus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Minus(b.x);
    r.y = y-&gt;Minus(b.y);
    r.z = z-&gt;Minus(b.z);
    return r;
}

ExprVector ExprVector::Plus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Plus(b.x);
    r.y = y-&gt;Plus(b.y);
    r.z = z-&gt;Plus(b.z);
    return r;
}

Expr *ExprVector::Dot(ExprVector b) const {
    Expr *r;
    r =         x-&gt;Times(b.x);
    r = r-&gt;Plus(y-&gt;Times(b.y));
    r = r-&gt;Plus(z-&gt;Times(b.z));
    return r;
}

ExprVector ExprVector::Cross(ExprVector b) const {
    ExprVector r;
    r.x = (y-&gt;Times(b.z))-&gt;Minus(z-&gt;Times(b.y));
    r.y = (z-&gt;Times(b.x))-&gt;Minus(x-&gt;Times(b.z));
    r.z = (x-&gt;Times(b.y))-&gt;Minus(y-&gt;Times(b.x));
    return r;
}

ExprVector ExprVector::ScaledBy(Expr *s) const {
    ExprVector r;
    r.x = x-&gt;Times(s);
    r.y = y-&gt;Times(s);
    r.z = z-&gt;Times(s);
    return r;
}

ExprVector ExprVector::WithMagnitude(Expr *s) const {
    Expr *m = Magnitude();
    return ScaledBy(s-&gt;Div(m));
}

Expr *ExprVector::Magnitude() const {
    Expr *r;
    r =         x-&gt;Square();
    r = r-&gt;Plus(y-&gt;Square());
    r = r-&gt;Plus(z-&gt;Square());
    return r-&gt;Sqrt();
}

Vector ExprVector::Eval() const {
    Vector r;
    r.x = x-&gt;Eval();
    r.y = y-&gt;Eval();
    r.z = z-&gt;Eval();
    return r;
}

ExprQuaternion ExprQuaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    ExprQuaternion q;
    q.w  = Expr::From(w);
    q.vx = Expr::From(vx);
    q.vy = Expr::From(vy);
    q.vz = Expr::From(vz);
    return q;
}

ExprQuaternion ExprQuaternion::From(Expr *w, Expr *vx, Expr *vy, Expr *vz)
{
    ExprQuaternion q;
    q.w = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

ExprQuaternion ExprQuaternion::From(Quaternion qn) {
    ExprQuaternion qe;
    qe.w = Expr::From(qn.w);
    qe.vx = Expr::From(qn.vx);
    qe.vy = Expr::From(qn.vy);
    qe.vz = Expr::From(qn.vz);
    return qe;
}

ExprVector ExprQuaternion::RotationU() const {
    ExprVector u;
    Expr *two = Expr::From(2);

    u.x = w-&gt;Square();
    u.x = (u.x)-&gt;Plus(vx-&gt;Square());
    u.x = (u.x)-&gt;Minus(vy-&gt;Square());
    u.x = (u.x)-&gt;Minus(vz-&gt;Square());

    u.y = two-&gt;Times(w-&gt;Times(vz));
    u.y = (u.y)-&gt;Plus(two-&gt;Times(vx-&gt;Times(vy)));

    u.z = two-&gt;Times(vx-&gt;Times(vz));
    u.z = (u.z)-&gt;Minus(two-&gt;Times(w-&gt;Times(vy)));

    return u;
}

ExprVector ExprQuaternion::RotationV() const {
    ExprVector v;
    Expr *two = Expr::From(2);

    v.x = two-&gt;Times(vx-&gt;Times(vy));
    v.x = (v.x)-&gt;Minus(two-&gt;Times(w-&gt;Times(vz)));

    v.y = w-&gt;Square();
    v.y = (v.y)-&gt;Minus(vx-&gt;Square());
    v.y = (v.y)-&gt;Plus(vy-&gt;Square());
    v.y = (v.y)-&gt;Minus(vz-&gt;Square());

    v.z = two-&gt;Times(w-&gt;Times(vx));
    v.z = (v.z)-&gt;Plus(two-&gt;Times(vy-&gt;Times(vz)));

    return v;
}

ExprVector ExprQuaternion::RotationN() const {
    ExprVector n;
    Expr *two = Expr::From(2);

    n.x =              two-&gt;Times( w-&gt;Times(vy));
    n.x = (n.x)-&gt;Plus (two-&gt;Times(vx-&gt;Times(vz)));

    n.y =              two-&gt;Times(vy-&gt;Times(vz));
    n.y = (n.y)-&gt;Minus(two-&gt;Times( w-&gt;Times(vx)));

    n.z =               w-&gt;Square();
    n.z = (n.z)-&gt;Minus(vx-&gt;Square());
    n.z = (n.z)-&gt;Minus(vy-&gt;Square());
    n.z = (n.z)-&gt;Plus (vz-&gt;Square());

    return n;
}

ExprVector ExprQuaternion::Rotate(ExprVector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

ExprQuaternion ExprQuaternion::Times(ExprQuaternion b) const {
    Expr *sa = w, *sb = b.w;
    ExprVector va = { vx, vy, vz };
    ExprVector vb = { b.vx, b.vy, b.vz };

    ExprQuaternion r;
    r.w = (sa-&gt;Times(sb))-&gt;Minus(va.Dot(vb));
    ExprVector vr = vb.ScaledBy(sa).Plus(
                    va.ScaledBy(sb).Plus(
                    va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Expr *ExprQuaternion::Magnitude() const {
    return ((w -&gt;Square())-&gt;Plus(
            (vx-&gt;Square())-&gt;Plus(
            (vy-&gt;Square())-&gt;Plus(
            (vz-&gt;Square())))))-&gt;Sqrt();
}


Expr *Expr::From(hParam p) {
    Expr *r = AllocExpr();
    r-&gt;op = Op::PARAM;
    r-&gt;parh = p;
    return r;
}

Expr *Expr::From(double v) {
    // Statically allocate common constants.
    // Note: this is only valid because AllocExpr() uses AllocTemporary(),
    // and Expr* is never explicitly freed.

    if(v == 0.0) {
        static Expr zero(0.0);
        return &amp;zero;
    }

    if(v == 1.0) {
        static Expr one(1.0);
        return &amp;one;
    }

    if(v == -1.0) {
        static Expr mone(-1.0);
        return &amp;mone;
    }

    if(v == 0.5) {
        static Expr half(0.5);
        return &amp;half;
    }

    if(v == -0.5) {
        static Expr mhalf(-0.5);
        return &amp;mhalf;
    }

    Expr *r = AllocExpr();
    r-&gt;op = Op::CONSTANT;
    r-&gt;v = v;
    return r;
}

Expr *Expr::AnyOp(Op newOp, Expr *b) {
    Expr *r = AllocExpr();
    r-&gt;op = newOp;
    r-&gt;a = this;
    r-&gt;b = b;
    return r;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221222.8">void writeLTypes() override {
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        StipplePattern st = (StipplePattern)i;
        DRW_LType type;
        // LibreCAD requires the line type to have one of these exact names,
        // or otherwise it overwrites it with its own (continuous) style.
        type.name = DxfFileWriter::lineTypeName(st);
        double sw = 1.0;
        switch(st) {
            case StipplePattern::CONTINUOUS:
                break;

            case StipplePattern::SHORT_DASH:
                type.path.push_back(sw);
                type.path.push_back(-sw * 2.0);
                break;

            case StipplePattern::DASH:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                break;

            case StipplePattern::LONG_DASH:
                type.path.push_back(sw * 2.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::DASH_DOT:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::DOT:
                type.path.push_back(sw);
                type.path.push_back(0.0);
                break;

            case StipplePattern::DASH_DOT_DOT:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::FREEHAND:
            case StipplePattern::ZIGZAG:
                // Not implemented; exported as continuous.
                break;
        }
        dxf-&gt;writeLineType(&amp;type);
    }
}

</t>
<t tx="leo1.20171224221222.80">int Expr::Children() const {
    switch(op) {
        case Op::PARAM:
        case Op::PARAM_PTR:
        case Op::CONSTANT:
        case Op::VARIABLE:
            return 0;

        case Op::PLUS:
        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
            return 2;

        case Op::NEGATE:
        case Op::SQRT:
        case Op::SQUARE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            return 1;
    }
    ssassert(false, "Unexpected operation");
}

</t>
<t tx="leo1.20171224221222.81">int Expr::Nodes() const {
    switch(Children()) {
        case 0: return 1;
        case 1: return 1 + a-&gt;Nodes();
        case 2: return 1 + a-&gt;Nodes() + b-&gt;Nodes();
        default: ssassert(false, "Unexpected children count");
    }
}

Expr *Expr::DeepCopy() const {
    Expr *n = AllocExpr();
    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopy();
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopy();
    return n;
}

Expr *Expr::DeepCopyWithParamsAsPointers(IdList&lt;Param,hParam&gt; *firstTry,
    IdList&lt;Param,hParam&gt; *thenTry) const
{
    Expr *n = AllocExpr();
    if(op == Op::PARAM) {
        // A param that is referenced by its hParam gets rewritten to go
        // straight in to the parameter table with a pointer, or simply
        // into a constant if it's already known.
        Param *p = firstTry-&gt;FindByIdNoOops(parh);
        if(!p) p = thenTry-&gt;FindById(parh);
        if(p-&gt;known) {
            n-&gt;op = Op::CONSTANT;
            n-&gt;v = p-&gt;val;
        } else {
            n-&gt;op = Op::PARAM_PTR;
            n-&gt;parp = p;
        }
        return n;
    }

    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    return n;
}

double Expr::Eval() const {
    switch(op) {
        case Op::PARAM:         return SK.GetParam(parh)-&gt;val;
        case Op::PARAM_PTR:     return parp-&gt;val;

        case Op::CONSTANT:      return v;
        case Op::VARIABLE:      ssassert(false, "Not supported yet");

        case Op::PLUS:          return a-&gt;Eval() + b-&gt;Eval();
        case Op::MINUS:         return a-&gt;Eval() - b-&gt;Eval();
        case Op::TIMES:         return a-&gt;Eval() * b-&gt;Eval();
        case Op::DIV:           return a-&gt;Eval() / b-&gt;Eval();

        case Op::NEGATE:        return -(a-&gt;Eval());
        case Op::SQRT:          return sqrt(a-&gt;Eval());
        case Op::SQUARE:        { double r = a-&gt;Eval(); return r*r; }
        case Op::SIN:           return sin(a-&gt;Eval());
        case Op::COS:           return cos(a-&gt;Eval());
        case Op::ACOS:          return acos(a-&gt;Eval());
        case Op::ASIN:          return asin(a-&gt;Eval());
    }
    ssassert(false, "Unexpected operation");
}

Expr *Expr::PartialWrt(hParam p) const {
    Expr *da, *db;

    switch(op) {
        case Op::PARAM_PTR: return From(p.v == parp-&gt;h.v ? 1 : 0);
        case Op::PARAM:     return From(p.v == parh.v ? 1 : 0);

        case Op::CONSTANT:  return From(0.0);
        case Op::VARIABLE:  ssassert(false, "Not supported yet");

        case Op::PLUS:      return (a-&gt;PartialWrt(p))-&gt;Plus(b-&gt;PartialWrt(p));
        case Op::MINUS:     return (a-&gt;PartialWrt(p))-&gt;Minus(b-&gt;PartialWrt(p));

        case Op::TIMES:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return (a-&gt;Times(db))-&gt;Plus(b-&gt;Times(da));

        case Op::DIV:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return ((da-&gt;Times(b))-&gt;Minus(a-&gt;Times(db)))-&gt;Div(b-&gt;Square());

        case Op::SQRT:
            return (From(0.5)-&gt;Div(a-&gt;Sqrt()))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::SQUARE:
            return (From(2.0)-&gt;Times(a))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::NEGATE:    return (a-&gt;PartialWrt(p))-&gt;Negate();
        case Op::SIN:       return (a-&gt;Cos())-&gt;Times(a-&gt;PartialWrt(p));
        case Op::COS:       return ((a-&gt;Sin())-&gt;Times(a-&gt;PartialWrt(p)))-&gt;Negate();

        case Op::ASIN:
            return (From(1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
        case Op::ACOS:
            return (From(-1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
    }
    ssassert(false, "Unexpected operation");
}

uint64_t Expr::ParamsUsed() const {
    uint64_t r = 0;
    if(op == Op::PARAM)     r |= ((uint64_t)1 &lt;&lt; (parh.v % 61));
    if(op == Op::PARAM_PTR) r |= ((uint64_t)1 &lt;&lt; (parp-&gt;h.v % 61));

    int c = Children();
    if(c &gt;= 1)          r |= a-&gt;ParamsUsed();
    if(c &gt;= 2)          r |= b-&gt;ParamsUsed();
    return r;
}

</t>
<t tx="leo1.20171224221222.82">bool Expr::DependsOn(hParam p) const {
    if(op == Op::PARAM)     return (parh.v    == p.v);
    if(op == Op::PARAM_PTR) return (parp-&gt;h.v == p.v);

    int c = Children();
    if(c == 1)          return a-&gt;DependsOn(p);
    if(c == 2)          return a-&gt;DependsOn(p) || b-&gt;DependsOn(p);
    return false;
}

</t>
<t tx="leo1.20171224221222.83">bool Expr::Tol(double a, double b) {
    return fabs(a - b) &lt; 0.001;
}
Expr *Expr::FoldConstants() {
    Expr *n = AllocExpr();
    *n = *this;

    int c = Children();
    if(c &gt;= 1) n-&gt;a = a-&gt;FoldConstants();
    if(c &gt;= 2) n-&gt;b = b-&gt;FoldConstants();

    switch(op) {
        case Op::PARAM_PTR:
        case Op::PARAM:
        case Op::CONSTANT:
        case Op::VARIABLE:
            break;

        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
        case Op::PLUS:
            // If both ops are known, then we can evaluate immediately
            if(n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
                break;
            }
            // x + 0 = 0 + x = x
            if(op == Op::PLUS &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::PLUS &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                *n = *(n-&gt;b); break;
            }
            // 1*x = x*1 = x
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 1)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 1)) {
                *n = *(n-&gt;b); break;
            }
            // 0*x = x*0 = 0
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }

            break;

        case Op::SQRT:
        case Op::SQUARE:
        case Op::NEGATE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            if(n-&gt;a-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
            }
            break;
    }
    return n;
}

</t>
<t tx="leo1.20171224221222.84">void Expr::Substitute(hParam oldh, hParam newh) {
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    if(op == Op::PARAM &amp;&amp; parh.v == oldh.v) {
        parh = newh;
    }
    int c = Children();
    if(c &gt;= 1) a-&gt;Substitute(oldh, newh);
    if(c &gt;= 2) b-&gt;Substitute(oldh, newh);
}

//-----------------------------------------------------------------------------
// If the expression references only one parameter that appears in pl, then
// return that parameter. If no param is referenced, then return NO_PARAMS.
// If multiple params are referenced, then return MULTIPLE_PARAMS.
//-----------------------------------------------------------------------------
const hParam Expr::NO_PARAMS       = { 0 };
const hParam Expr::MULTIPLE_PARAMS = { 1 };
hParam Expr::ReferencedParams(ParamList *pl) const {
    if(op == Op::PARAM) {
        if(pl-&gt;FindByIdNoOops(parh)) {
            return parh;
        } else {
            return NO_PARAMS;
        }
    }
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    int c = Children();
    if(c == 0) {
        return NO_PARAMS;
    } else if(c == 1) {
        return a-&gt;ReferencedParams(pl);
    } else if(c == 2) {
        hParam pa, pb;
        pa = a-&gt;ReferencedParams(pl);
        pb = b-&gt;ReferencedParams(pl);
        if(pa.v == NO_PARAMS.v) {
            return pb;
        } else if(pb.v == NO_PARAMS.v) {
            return pa;
        } else if(pa.v == pb.v) {
            return pa; // either, doesn't matter
        } else {
            return MULTIPLE_PARAMS;
        }
    } else ssassert(false, "Unexpected children count");
}


//-----------------------------------------------------------------------------
// Routines to pretty-print an expression. Mostly for debugging.
//-----------------------------------------------------------------------------

std::string Expr::Print() const {
    char c;
    switch(op) {
        case Op::PARAM:     return ssprintf("param(%08x)", parh.v);
        case Op::PARAM_PTR: return ssprintf("param(p%08x)", parp-&gt;h.v);

        case Op::CONSTANT:  return ssprintf("%.3f", v);
        case Op::VARIABLE:  return "(var)";

        case Op::PLUS:      c = '+'; goto p;
        case Op::MINUS:     c = '-'; goto p;
        case Op::TIMES:     c = '*'; goto p;
        case Op::DIV:       c = '/'; goto p;
p:
            return "(" + a-&gt;Print() + " " + c + " " + b-&gt;Print() + ")";
            break;

        case Op::NEGATE:    return "(- " + a-&gt;Print() + ")";
        case Op::SQRT:      return "(sqrt " + a-&gt;Print() + ")";
        case Op::SQUARE:    return "(square " + a-&gt;Print() + ")";
        case Op::SIN:       return "(sin " + a-&gt;Print() + ")";
        case Op::COS:       return "(cos " + a-&gt;Print() + ")";
        case Op::ASIN:      return "(asin " + a-&gt;Print() + ")";
        case Op::ACOS:      return "(acos " + a-&gt;Print() + ")";
    }
    ssassert(false, "Unexpected operation");
}


//-----------------------------------------------------------------------------
// A parser; convert a string to an expression. Infix notation, with the
// usual shift/reduce approach. I had great hopes for user-entered eq
// constraints, but those don't seem very useful, so right now this is just
// to provide calculator type functionality wherever numbers are entered.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221222.85">class ExprParser {
public:
    enum class TokenType {
        ERROR = 0,

        PAREN_LEFT,
        PAREN_RIGHT,
        BINARY_OP,
        UNARY_OP,
        OPERAND,

        END,
    };

    @others
};

ExprParser::Token ExprParser::Token::From(TokenType type, Expr *expr) {
    Token t;
    t.type = type;
    t.expr = expr;
    return t;
}

ExprParser::Token ExprParser::Token::From(TokenType type, Expr::Op op) {
    Token t;
    t.type = type;
    t.expr = Expr::AllocExpr();
    t.expr-&gt;op = op;
    return t;
}

</t>
<t tx="leo1.20171224221222.86">class Token {
public:
    TokenType  type;
    Expr      *expr;

    static Token From(TokenType type = TokenType::ERROR, Expr *expr = NULL);
    static Token From(TokenType type, Expr::Op op);
    bool IsError() const { return type == TokenType::ERROR; }
};

const char        *input;
unsigned           inputPos;
std::vector&lt;Token&gt; stack;

char ReadChar();
char PeekChar();

std::string ReadWord();
void SkipSpace();

Token PopOperator(std::string *error);
Token PopOperand(std::string *error);

int Precedence(Token token);
Token LexNumber(std::string *error);
Token Lex(std::string *error);
bool Reduce(std::string *error);
bool Parse(std::string *error, size_t reduceUntil = 0);

static Expr *Parse(const char *input, std::string *error);
</t>
<t tx="leo1.20171224221222.87">char ExprParser::ReadChar() {
    return input[inputPos++];
}

</t>
<t tx="leo1.20171224221222.88">char ExprParser::PeekChar() {
    return input[inputPos];
}

std::string ExprParser::ReadWord() {
    std::string s;

    while(char c = PeekChar()) {
        if(!isalnum(c)) break;
        s.push_back(ReadChar());
    }

    return s;
}

</t>
<t tx="leo1.20171224221222.89">void ExprParser::SkipSpace() {
    while(char c = PeekChar()) {
        if(!isspace(c)) break;
        ReadChar();
    }
}

ExprParser::Token ExprParser::LexNumber(std::string *error) {
    std::string s;

    while(char c = PeekChar()) {
        if(!((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == 'e' || c == 'E' || c == '.' || c == '_')) break;
        if(c == '_') {
            ReadChar();
            continue;
        }
        s.push_back(ReadChar());
    }

    char *endptr;
    double d = strtod(s.c_str(), &amp;endptr);

    Token t = Token::From();
    if(endptr == s.c_str() + s.size()) {
        t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
        t.expr-&gt;v = d;
    } else {
        *error = "'" + s + "' is not a valid number";
    }
    return t;
}

ExprParser::Token ExprParser::Lex(std::string *error) {
    SkipSpace();

    Token t = Token::From();
    char c = PeekChar();
    if(isupper(c)) {
        std::string n = ReadWord();
        t = Token::From(TokenType::OPERAND, Expr::Op::VARIABLE);
    } else if(isalpha(c)) {
        std::string s = ReadWord();
        if(s == "sqrt") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQRT);
        } else if(s == "square") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQUARE);
        } else if(s == "sin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SIN);
        } else if(s == "cos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::COS);
        } else if(s == "asin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ASIN);
        } else if(s == "acos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ACOS);
        } else if(s == "pi") {
            t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
            t.expr-&gt;v = PI;
        } else {
            *error = "'" + s + "' is not a valid variable, function or constant";
        }
    } else if(isdigit(c) || c == '.') {
        return LexNumber(error);
    } else if(ispunct(c)) {
        ReadChar();
        if(c == '+') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::PLUS);
        } else if(c == '-') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::MINUS);
        } else if(c == '*') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::TIMES);
        } else if(c == '/') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::DIV);
        } else if(c == '(') {
            t = Token::From(TokenType::PAREN_LEFT);
        } else if(c == ')') {
            t = Token::From(TokenType::PAREN_RIGHT);
        } else {
            *error = "'" + std::string(1, c) + "' is not a valid operator";
        }
    } else if(c == '\0') {
        t = Token::From(TokenType::END);
    } else {
        *error = "Unexpected character '" + std::string(1, c) + "'";
    }

    return t;
}

ExprParser::Token ExprParser::PopOperand(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || stack.back().type != TokenType::OPERAND) {
        *error = "Expected an operand";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

ExprParser::Token ExprParser::PopOperator(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || (stack.back().type != TokenType::UNARY_OP &amp;&amp;
                         stack.back().type != TokenType::BINARY_OP)) {
        *error = "Expected an operator";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

</t>
<t tx="leo1.20171224221222.9">void writePolylines() {
    PolylineBuilder builder;

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            if(sb-&gt;deg != 1) continue;
            builder.AddEdge(sb-&gt;ctrl[0], sb-&gt;ctrl[1], (uint32_t)sb-&gt;auxA);
        }
    }

    DRW_Polyline polyline;

    @others
}

</t>
<t tx="leo1.20171224221222.90">int ExprParser::Precedence(Token t) {
    ssassert(t.type == TokenType::BINARY_OP ||
             t.type == TokenType::UNARY_OP ||
             t.type == TokenType::OPERAND,
             "Unexpected token type");

    if(t.type == TokenType::UNARY_OP) {
        return 30;
    } else if(t.expr-&gt;op == Expr::Op::TIMES ||
              t.expr-&gt;op == Expr::Op::DIV) {
        return 20;
    } else if(t.expr-&gt;op == Expr::Op::PLUS ||
              t.expr-&gt;op == Expr::Op::MINUS) {
        return 10;
    } else if(t.type == TokenType::OPERAND) {
        return 0;
    } else ssassert(false, "Unexpected operator");
}

</t>
<t tx="leo1.20171224221222.91">bool ExprParser::Reduce(std::string *error) {
    Token a = PopOperand(error);
    if(a.IsError()) return false;

    Token op = PopOperator(error);
    if(op.IsError()) return false;

    Token r = Token::From(TokenType::OPERAND);
    switch(op.type) {
        case TokenType::BINARY_OP: {
            Token b = PopOperand(error);
            if(b.IsError()) return false;
            r.expr = b.expr-&gt;AnyOp(op.expr-&gt;op, a.expr);
            break;
        }

        case TokenType::UNARY_OP: {
            Expr *e = a.expr;
            switch(op.expr-&gt;op) {
                case Expr::Op::NEGATE: e = e-&gt;Negate(); break;
                case Expr::Op::SQRT:   e = e-&gt;Sqrt(); break;
                case Expr::Op::SQUARE: e = e-&gt;Times(e); break;
                case Expr::Op::SIN:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Sin(); break;
                case Expr::Op::COS:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Cos(); break;
                case Expr::Op::ASIN:   e = e-&gt;ASin()-&gt;Times(Expr::From(180/PI)); break;
                case Expr::Op::ACOS:   e = e-&gt;ACos()-&gt;Times(Expr::From(180/PI)); break;
                default: ssassert(false, "Unexpected unary operator");
            }
            r.expr = e;
            break;
        }

        default: ssassert(false, "Unexpected operator");
    }
    stack.push_back(r);

    return true;
}

</t>
<t tx="leo1.20171224221222.92">bool ExprParser::Parse(std::string *error, size_t reduceUntil) {
    while(true) {
        Token t = Lex(error);
        switch(t.type) {
            case TokenType::ERROR:
                return false;

            case TokenType::END:
            case TokenType::PAREN_RIGHT:
                while(stack.size() &gt; 1 + reduceUntil) {
                    if(!Reduce(error)) return false;
                }

                if(t.type == TokenType::PAREN_RIGHT) {
                    stack.push_back(t);
                }
                return true;

            case TokenType::PAREN_LEFT: {
                // sub-expression
                if(!Parse(error, /*reduceUntil=*/stack.size())) return false;

                if(stack.empty() || stack.back().type != TokenType::PAREN_RIGHT) {
                    *error = "Expected ')'";
                    return false;
                }
                stack.pop_back();
                break;
            }

            case TokenType::BINARY_OP:
                if((stack.size() &gt; reduceUntil &amp;&amp; stack.back().type != TokenType::OPERAND) ||
                   stack.size() == reduceUntil) {
                    if(t.expr-&gt;op == Expr::Op::MINUS) {
                        t.type = TokenType::UNARY_OP;
                        t.expr-&gt;op = Expr::Op::NEGATE;
                        stack.push_back(t);
                        break;
                    }
                }

                while(stack.size() &gt; 1 + reduceUntil &amp;&amp;
                      Precedence(t) &lt;= Precedence(stack[stack.size() - 2])) {
                    if(!Reduce(error)) return false;
                }

                stack.push_back(t);
                break;

            case TokenType::UNARY_OP:
            case TokenType::OPERAND:
                stack.push_back(t);
                break;
        }
    }

    return true;
}

Expr *ExprParser::Parse(const char *input, std::string *error) {
    ExprParser parser;
    parser.input    = input;
    parser.inputPos = 0;
    if(!parser.Parse(error)) return NULL;

    Token r = parser.PopOperand(error);
    if(r.IsError()) return NULL;
    return r.expr;
}

Expr *Expr::Parse(const char *input, std::string *error) {
    return ExprParser::Parse(input, error);
}

Expr *Expr::From(const char *input, bool popUpError) {
    std::string error;
    Expr *e = ExprParser::Parse(input, &amp;error);
    if(!e) {
        dbp("Parse/lex error: %s", error.c_str());
        if(popUpError) {
            Error("Not a valid number or expression: '%s'.\n%s.", input, error.c_str());
        }
    }
    return e;
}
</t>
<t tx="leo1.20171224221222.93">//-----------------------------------------------------------------------------
// Routines to write and read our .slvs file format.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

#define VERSION_STRING "\261\262\263" "SolveSpaceREVa"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221222.94">static int StrStartsWith(const char *str, const char *start) {
    return memcmp(str, start, strlen(start)) == 0;
}

//-----------------------------------------------------------------------------
// Clear and free all the dynamic memory associated with our currently-loaded
// sketch. This does not leave the program in an acceptable state (with the
// references created, and so on), so anyone calling this must fix that later.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221222.95">void SolveSpaceUI::ClearExisting() {
    UndoClearStack(&amp;redo);
    UndoClearStack(&amp;undo);

    for(int i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        g-&gt;Clear();
    }

    SK.constraint.Clear();
    SK.request.Clear();
    SK.group.Clear();
    SK.groupOrder.Clear();
    SK.style.Clear();

    SK.entity.Clear();
    SK.param.Clear();
    images.clear();
}

hGroup SolveSpaceUI::CreateDefaultDrawingGroup() {
    Group g = {};

    // And an empty group, for the first stuff the user draws.
    g.visible = true;
    g.name = C_("group-name", "sketch-in-plane");
    g.type = Group::Type::DRAWING_WORKPLANE;
    g.subtype = Group::Subtype::WORKPLANE_BY_POINT_ORTHO;
    g.order = 1;
    g.predef.q = Quaternion::From(1, 0, 0, 0);
    hRequest hr = Request::HREQUEST_REFERENCE_XY;
    g.predef.origin = hr.entity(1);
    SK.group.AddAndAssignId(&amp;g);
    SK.GetGroup(g.h)-&gt;activeWorkplane = g.h.entity(0);
    return g.h;
}

</t>
<t tx="leo1.20171224221222.96">void SolveSpaceUI::NewFile() {
    ClearExisting();

    // Our initial group, that contains the references.
    Group g = {};
    g.visible = true;
    g.name = C_("group-name", "#references");
    g.type = Group::Type::DRAWING_3D;
    g.order = 0;
    g.h = Group::HGROUP_REFERENCES;
    SK.group.Add(&amp;g);

    // Let's create three two-d coordinate systems, for the coordinate
    // planes; these are our references, present in every sketch.
    Request r = {};
    r.type = Request::Type::WORKPLANE;
    r.group = Group::HGROUP_REFERENCES;
    r.workplane = Entity::FREE_IN_3D;

    r.h = Request::HREQUEST_REFERENCE_XY;
    SK.request.Add(&amp;r);

    r.h = Request::HREQUEST_REFERENCE_YZ;
    SK.request.Add(&amp;r);

    r.h = Request::HREQUEST_REFERENCE_ZX;
    SK.request.Add(&amp;r);

    CreateDefaultDrawingGroup();
}

</t>
<t tx="leo1.20171224221222.97">const SolveSpaceUI::SaveTable SolveSpaceUI::SAVED[] = {
    { 'g',  "Group.h.v",                'x',    &amp;(SS.sv.g.h.v)                },
    { 'g',  "Group.type",               'd',    &amp;(SS.sv.g.type)               },
    { 'g',  "Group.order",              'd',    &amp;(SS.sv.g.order)              },
    { 'g',  "Group.name",               'S',    &amp;(SS.sv.g.name)               },
    { 'g',  "Group.activeWorkplane.v",  'x',    &amp;(SS.sv.g.activeWorkplane.v)  },
    { 'g',  "Group.opA.v",              'x',    &amp;(SS.sv.g.opA.v)              },
    { 'g',  "Group.opB.v",              'x',    &amp;(SS.sv.g.opB.v)              },
    { 'g',  "Group.valA",               'f',    &amp;(SS.sv.g.valA)               },
    { 'g',  "Group.valB",               'f',    &amp;(SS.sv.g.valB)               },
    { 'g',  "Group.valC",               'f',    &amp;(SS.sv.g.valB)               },
    { 'g',  "Group.color",              'c',    &amp;(SS.sv.g.color)              },
    { 'g',  "Group.subtype",            'd',    &amp;(SS.sv.g.subtype)            },
    { 'g',  "Group.skipFirst",          'b',    &amp;(SS.sv.g.skipFirst)          },
    { 'g',  "Group.meshCombine",        'd',    &amp;(SS.sv.g.meshCombine)        },
    { 'g',  "Group.forceToMesh",        'd',    &amp;(SS.sv.g.forceToMesh)        },
    { 'g',  "Group.predef.q.w",         'f',    &amp;(SS.sv.g.predef.q.w)         },
    { 'g',  "Group.predef.q.vx",        'f',    &amp;(SS.sv.g.predef.q.vx)        },
    { 'g',  "Group.predef.q.vy",        'f',    &amp;(SS.sv.g.predef.q.vy)        },
    { 'g',  "Group.predef.q.vz",        'f',    &amp;(SS.sv.g.predef.q.vz)        },
    { 'g',  "Group.predef.origin.v",    'x',    &amp;(SS.sv.g.predef.origin.v)    },
    { 'g',  "Group.predef.entityB.v",   'x',    &amp;(SS.sv.g.predef.entityB.v)   },
    { 'g',  "Group.predef.entityC.v",   'x',    &amp;(SS.sv.g.predef.entityC.v)   },
    { 'g',  "Group.predef.swapUV",      'b',    &amp;(SS.sv.g.predef.swapUV)      },
    { 'g',  "Group.predef.negateU",     'b',    &amp;(SS.sv.g.predef.negateU)     },
    { 'g',  "Group.predef.negateV",     'b',    &amp;(SS.sv.g.predef.negateV)     },
    { 'g',  "Group.visible",            'b',    &amp;(SS.sv.g.visible)            },
    { 'g',  "Group.suppress",           'b',    &amp;(SS.sv.g.suppress)           },
    { 'g',  "Group.relaxConstraints",   'b',    &amp;(SS.sv.g.relaxConstraints)   },
    { 'g',  "Group.allowRedundant",     'b',    &amp;(SS.sv.g.allowRedundant)     },
    { 'g',  "Group.allDimsReference",   'b',    &amp;(SS.sv.g.allDimsReference)   },
    { 'g',  "Group.scale",              'f',    &amp;(SS.sv.g.scale)              },
    { 'g',  "Group.remap",              'M',    &amp;(SS.sv.g.remap)              },
    { 'g',  "Group.impFile",            'i',    NULL                          },
    { 'g',  "Group.impFileRel",         'P',    &amp;(SS.sv.g.linkFile)           },

    { 'p',  "Param.h.v.",               'x',    &amp;(SS.sv.p.h.v)                },
    { 'p',  "Param.val",                'f',    &amp;(SS.sv.p.val)                },

    { 'r',  "Request.h.v",              'x',    &amp;(SS.sv.r.h.v)                },
    { 'r',  "Request.type",             'd',    &amp;(SS.sv.r.type)               },
    { 'r',  "Request.extraPoints",      'd',    &amp;(SS.sv.r.extraPoints)        },
    { 'r',  "Request.workplane.v",      'x',    &amp;(SS.sv.r.workplane.v)        },
    { 'r',  "Request.group.v",          'x',    &amp;(SS.sv.r.group.v)            },
    { 'r',  "Request.construction",     'b',    &amp;(SS.sv.r.construction)       },
    { 'r',  "Request.style",            'x',    &amp;(SS.sv.r.style)              },
    { 'r',  "Request.str",              'S',    &amp;(SS.sv.r.str)                },
    { 'r',  "Request.font",             'S',    &amp;(SS.sv.r.font)               },
    { 'r',  "Request.file",             'P',    &amp;(SS.sv.r.file)               },
    { 'r',  "Request.aspectRatio",      'f',    &amp;(SS.sv.r.aspectRatio)        },

    { 'e',  "Entity.h.v",               'x',    &amp;(SS.sv.e.h.v)                },
    { 'e',  "Entity.type",              'd',    &amp;(SS.sv.e.type)               },
    { 'e',  "Entity.construction",      'b',    &amp;(SS.sv.e.construction)       },
    { 'e',  "Entity.style",             'x',    &amp;(SS.sv.e.style)              },
    { 'e',  "Entity.str",               'S',    &amp;(SS.sv.e.str)                },
    { 'e',  "Entity.font",              'S',    &amp;(SS.sv.e.font)               },
    { 'e',  "Entity.file",              'P',    &amp;(SS.sv.e.file)               },
    { 'e',  "Entity.point[0].v",        'x',    &amp;(SS.sv.e.point[0].v)         },
    { 'e',  "Entity.point[1].v",        'x',    &amp;(SS.sv.e.point[1].v)         },
    { 'e',  "Entity.point[2].v",        'x',    &amp;(SS.sv.e.point[2].v)         },
    { 'e',  "Entity.point[3].v",        'x',    &amp;(SS.sv.e.point[3].v)         },
    { 'e',  "Entity.point[4].v",        'x',    &amp;(SS.sv.e.point[4].v)         },
    { 'e',  "Entity.point[5].v",        'x',    &amp;(SS.sv.e.point[5].v)         },
    { 'e',  "Entity.point[6].v",        'x',    &amp;(SS.sv.e.point[6].v)         },
    { 'e',  "Entity.point[7].v",        'x',    &amp;(SS.sv.e.point[7].v)         },
    { 'e',  "Entity.point[8].v",        'x',    &amp;(SS.sv.e.point[8].v)         },
    { 'e',  "Entity.point[9].v",        'x',    &amp;(SS.sv.e.point[9].v)         },
    { 'e',  "Entity.point[10].v",       'x',    &amp;(SS.sv.e.point[10].v)        },
    { 'e',  "Entity.point[11].v",       'x',    &amp;(SS.sv.e.point[11].v)        },
    { 'e',  "Entity.extraPoints",       'd',    &amp;(SS.sv.e.extraPoints)        },
    { 'e',  "Entity.normal.v",          'x',    &amp;(SS.sv.e.normal.v)           },
    { 'e',  "Entity.distance.v",        'x',    &amp;(SS.sv.e.distance.v)         },
    { 'e',  "Entity.workplane.v",       'x',    &amp;(SS.sv.e.workplane.v)        },
    { 'e',  "Entity.actPoint.x",        'f',    &amp;(SS.sv.e.actPoint.x)         },
    { 'e',  "Entity.actPoint.y",        'f',    &amp;(SS.sv.e.actPoint.y)         },
    { 'e',  "Entity.actPoint.z",        'f',    &amp;(SS.sv.e.actPoint.z)         },
    { 'e',  "Entity.actNormal.w",       'f',    &amp;(SS.sv.e.actNormal.w)        },
    { 'e',  "Entity.actNormal.vx",      'f',    &amp;(SS.sv.e.actNormal.vx)       },
    { 'e',  "Entity.actNormal.vy",      'f',    &amp;(SS.sv.e.actNormal.vy)       },
    { 'e',  "Entity.actNormal.vz",      'f',    &amp;(SS.sv.e.actNormal.vz)       },
    { 'e',  "Entity.actDistance",       'f',    &amp;(SS.sv.e.actDistance)        },
    { 'e',  "Entity.actVisible",        'b',    &amp;(SS.sv.e.actVisible),        },


    { 'c',  "Constraint.h.v",           'x',    &amp;(SS.sv.c.h.v)                },
    { 'c',  "Constraint.type",          'd',    &amp;(SS.sv.c.type)               },
    { 'c',  "Constraint.group.v",       'x',    &amp;(SS.sv.c.group.v)            },
    { 'c',  "Constraint.workplane.v",   'x',    &amp;(SS.sv.c.workplane.v)        },
    { 'c',  "Constraint.valA",          'f',    &amp;(SS.sv.c.valA)               },
    { 'c',  "Constraint.valP.v",        'x',    &amp;(SS.sv.c.valP.v)             },
    { 'c',  "Constraint.ptA.v",         'x',    &amp;(SS.sv.c.ptA.v)              },
    { 'c',  "Constraint.ptB.v",         'x',    &amp;(SS.sv.c.ptB.v)              },
    { 'c',  "Constraint.entityA.v",     'x',    &amp;(SS.sv.c.entityA.v)          },
    { 'c',  "Constraint.entityB.v",     'x',    &amp;(SS.sv.c.entityB.v)          },
    { 'c',  "Constraint.entityC.v",     'x',    &amp;(SS.sv.c.entityC.v)          },
    { 'c',  "Constraint.entityD.v",     'x',    &amp;(SS.sv.c.entityD.v)          },
    { 'c',  "Constraint.other",         'b',    &amp;(SS.sv.c.other)              },
    { 'c',  "Constraint.other2",        'b',    &amp;(SS.sv.c.other2)             },
    { 'c',  "Constraint.reference",     'b',    &amp;(SS.sv.c.reference)          },
    { 'c',  "Constraint.comment",       'S',    &amp;(SS.sv.c.comment)            },
    { 'c',  "Constraint.disp.offset.x", 'f',    &amp;(SS.sv.c.disp.offset.x)      },
    { 'c',  "Constraint.disp.offset.y", 'f',    &amp;(SS.sv.c.disp.offset.y)      },
    { 'c',  "Constraint.disp.offset.z", 'f',    &amp;(SS.sv.c.disp.offset.z)      },
    { 'c',  "Constraint.disp.style",    'x',    &amp;(SS.sv.c.disp.style)         },

    { 's',  "Style.h.v",                'x',    &amp;(SS.sv.s.h.v)                },
    { 's',  "Style.name",               'S',    &amp;(SS.sv.s.name)               },
    { 's',  "Style.width",              'f',    &amp;(SS.sv.s.width)              },
    { 's',  "Style.widthAs",            'd',    &amp;(SS.sv.s.widthAs)            },
    { 's',  "Style.textHeight",         'f',    &amp;(SS.sv.s.textHeight)         },
    { 's',  "Style.textHeightAs",       'd',    &amp;(SS.sv.s.textHeightAs)       },
    { 's',  "Style.textAngle",          'f',    &amp;(SS.sv.s.textAngle)          },
    { 's',  "Style.textOrigin",         'x',    &amp;(SS.sv.s.textOrigin)         },
    { 's',  "Style.color",              'c',    &amp;(SS.sv.s.color)              },
    { 's',  "Style.fillColor",          'c',    &amp;(SS.sv.s.fillColor)          },
    { 's',  "Style.filled",             'b',    &amp;(SS.sv.s.filled)             },
    { 's',  "Style.visible",            'b',    &amp;(SS.sv.s.visible)            },
    { 's',  "Style.exportable",         'b',    &amp;(SS.sv.s.exportable)         },
    { 's',  "Style.stippleType",        'd',    &amp;(SS.sv.s.stippleType)        },
    { 's',  "Style.stippleScale",       'f',    &amp;(SS.sv.s.stippleScale)       },

    { 0, NULL, 0, NULL }
};

struct SAVEDptr {
    IdList&lt;EntityMap,EntityId&gt; &amp;M() { return *((IdList&lt;EntityMap,EntityId&gt; *)this); }
    std::string                &amp;S() { return *((std::string *)this); }
    Platform::Path             &amp;P() { return *((Platform::Path *)this); }
    bool      &amp;b() { return *((bool *)this); }
    RgbaColor &amp;c() { return *((RgbaColor *)this); }
    int       &amp;d() { return *((int *)this); }
    double    &amp;f() { return *((double *)this); }
    uint32_t  &amp;x() { return *((uint32_t *)this); }
};

</t>
<t tx="leo1.20171224221222.98">void SolveSpaceUI::SaveUsingTable(const Platform::Path &amp;filename, int type) {
    int i;
    for(i = 0; SAVED[i].type != 0; i++) {
        if(SAVED[i].type != type) continue;

        int fmt = SAVED[i].fmt;
        SAVEDptr *p = (SAVEDptr *)SAVED[i].ptr;
        // Any items that aren't specified are assumed to be zero
        if(fmt == 'S' &amp;&amp; p-&gt;S().empty())          continue;
        if(fmt == 'P' &amp;&amp; p-&gt;P().IsEmpty())        continue;
        if(fmt == 'd' &amp;&amp; p-&gt;d() == 0)             continue;
        if(fmt == 'f' &amp;&amp; EXACT(p-&gt;f() == 0.0))    continue;
        if(fmt == 'x' &amp;&amp; p-&gt;x() == 0)             continue;
        if(fmt == 'i')                            continue;

        fprintf(fh, "%s=", SAVED[i].desc);
        switch(fmt) {
            case 'S': fprintf(fh, "%s",    p-&gt;S().c_str());       break;
            case 'b': fprintf(fh, "%d",    p-&gt;b() ? 1 : 0);       break;
            case 'c': fprintf(fh, "%08x",  p-&gt;c().ToPackedInt()); break;
            case 'd': fprintf(fh, "%d",    p-&gt;d());               break;
            case 'f': fprintf(fh, "%.20f", p-&gt;f());               break;
            case 'x': fprintf(fh, "%08x",  p-&gt;x());               break;

            case 'P': {
                if(!p-&gt;P().IsEmpty()) {
                    Platform::Path relativePath = p-&gt;P().RelativeTo(filename.Parent());
                    ssassert(!relativePath.IsEmpty(), "Cannot relativize path");
                    fprintf(fh, "%s", relativePath.ToPortable().c_str());
                }
                break;
            }

            case 'M': {
                int j;
                fprintf(fh, "{\n");
                for(j = 0; j &lt; p-&gt;M().n; j++) {
                    EntityMap *em = &amp;(p-&gt;M().elem[j]);
                    fprintf(fh, "    %d %08x %d\n",
                            em-&gt;h.v, em-&gt;input.v, em-&gt;copyNumber);
                }
                fprintf(fh, "}");
                break;
            }

            case 'i': break;

            default: ssassert(false, "Unexpected value format");
        }
        fprintf(fh, "\n");
    }
}

</t>
<t tx="leo1.20171224221222.99">bool SolveSpaceUI::SaveToFile(const Platform::Path &amp;filename) {
    // Make sure all the entities are regenerated up to date, since they will be exported.
    SS.ScheduleShowTW();
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);

    for(Group &amp;g : SK.group) {
        if(g.type != Group::Type::LINKED) continue;

        if(g.linkFile.RelativeTo(filename).IsEmpty()) {
            Error("This sketch links the sketch '%s'; it can only be saved "
                  "on the same volume.", g.linkFile.raw.c_str());
            return false;
        }
    }

    fh = OpenFile(filename, "wb");
    if(!fh) {
        Error("Couldn't write to file '%s'", filename.raw.c_str());
        return false;
    }

    fprintf(fh, "%s\n\n\n", VERSION_STRING);

    int i, j;
    for(i = 0; i &lt; SK.group.n; i++) {
        sv.g = SK.group.elem[i];
        SaveUsingTable(filename, 'g');
        fprintf(fh, "AddGroup\n\n");
    }

    for(i = 0; i &lt; SK.param.n; i++) {
        sv.p = SK.param.elem[i];
        SaveUsingTable(filename, 'p');
        fprintf(fh, "AddParam\n\n");
    }

    for(i = 0; i &lt; SK.request.n; i++) {
        sv.r = SK.request.elem[i];
        SaveUsingTable(filename, 'r');
        fprintf(fh, "AddRequest\n\n");
    }

    for(i = 0; i &lt; SK.entity.n; i++) {
        (SK.entity.elem[i]).CalculateNumerical(/*forExport=*/true);
        sv.e = SK.entity.elem[i];
        SaveUsingTable(filename, 'e');
        fprintf(fh, "AddEntity\n\n");
    }

    for(i = 0; i &lt; SK.constraint.n; i++) {
        sv.c = SK.constraint.elem[i];
        SaveUsingTable(filename, 'c');
        fprintf(fh, "AddConstraint\n\n");
    }

    for(i = 0; i &lt; SK.style.n; i++) {
        sv.s = SK.style.elem[i];
        if(sv.s.h.v &gt;= Style::FIRST_CUSTOM) {
            SaveUsingTable(filename, 's');
            fprintf(fh, "AddStyle\n\n");
        }
    }

    // A group will have either a mesh or a shell, but not both; but the code
    // to print either of those just does nothing if the mesh/shell is empty.

    Group *g = SK.GetGroup(SK.groupOrder.elem[SK.groupOrder.n - 1]);
    SMesh *m = &amp;g-&gt;runningMesh;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangle *tr = &amp;(m-&gt;l.elem[i]);
        fprintf(fh, "Triangle %08x %08x "
                "%.20f %.20f %.20f  %.20f %.20f %.20f  %.20f %.20f %.20f\n",
            tr-&gt;meta.face, tr-&gt;meta.color.ToPackedInt(),
            CO(tr-&gt;a), CO(tr-&gt;b), CO(tr-&gt;c));
    }

    SShell *s = &amp;g-&gt;runningShell;
    SSurface *srf;
    for(srf = s-&gt;surface.First(); srf; srf = s-&gt;surface.NextAfter(srf)) {
        fprintf(fh, "Surface %08x %08x %08x %d %d\n",
            srf-&gt;h.v, srf-&gt;color.ToPackedInt(), srf-&gt;face, srf-&gt;degm, srf-&gt;degn);
        for(i = 0; i &lt;= srf-&gt;degm; i++) {
            for(j = 0; j &lt;= srf-&gt;degn; j++) {
                fprintf(fh, "SCtrl %d %d %.20f %.20f %.20f Weight %20.20f\n",
                    i, j, CO(srf-&gt;ctrl[i][j]), srf-&gt;weight[i][j]);
            }
        }

        STrimBy *stb;
        for(stb = srf-&gt;trim.First(); stb; stb = srf-&gt;trim.NextAfter(stb)) {
            fprintf(fh, "TrimBy %08x %d %.20f %.20f %.20f  %.20f %.20f %.20f\n",
                stb-&gt;curve.v, stb-&gt;backwards ? 1 : 0,
                CO(stb-&gt;start), CO(stb-&gt;finish));
        }

        fprintf(fh, "AddSurface\n");
    }
    SCurve *sc;
    for(sc = s-&gt;curve.First(); sc; sc = s-&gt;curve.NextAfter(sc)) {
        fprintf(fh, "Curve %08x %d %d %08x %08x\n",
            sc-&gt;h.v,
            sc-&gt;isExact ? 1 : 0, sc-&gt;exact.deg,
            sc-&gt;surfA.v, sc-&gt;surfB.v);

        if(sc-&gt;isExact) {
            for(i = 0; i &lt;= sc-&gt;exact.deg; i++) {
                fprintf(fh, "CCtrl %d %.20f %.20f %.20f Weight %.20f\n",
                    i, CO(sc-&gt;exact.ctrl[i]), sc-&gt;exact.weight[i]);
            }
        }
        SCurvePt *scpt;
        for(scpt = sc-&gt;pts.First(); scpt; scpt = sc-&gt;pts.NextAfter(scpt)) {
            fprintf(fh, "CurvePt %d %.20f %.20f %.20f\n",
                scpt-&gt;vertex ? 1 : 0, CO(scpt-&gt;p));
        }

        fprintf(fh, "AddCurve\n");
    }

    fclose(fh);

    return true;
}

</t>
<t tx="leo1.20171224221223.1">void GraphicsWindow::Init() {
    canvas = CreateRenderer();
    if(canvas) {
        persistentCanvas = canvas-&gt;CreateBatch();
        persistentDirty = true;
    }

    scale = 5;
    offset    = Vector::From(0, 0, 0);
    projRight = Vector::From(1, 0, 0);
    projUp    = Vector::From(0, 1, 0);

    // Make sure those are valid; could get a mouse move without a mouse
    // down if someone depresses the button, then drags into our window.
    orig.projRight = projRight;
    orig.projUp = projUp;

    // And with the last group active
    activeGroup = SK.groupOrder.elem[SK.groupOrder.n - 1];
    SK.GetGroup(activeGroup)-&gt;Activate();

    showWorkplanes = false;
    showNormals = true;
    showPoints = true;
    showConstraints = true;
    showShaded = true;
    showEdges = true;
    showMesh = false;
    showOutlines = false;
    drawOccludedAs = DrawOccludedAs::INVISIBLE;

    showTextWindow = true;
    ShowTextWindow(showTextWindow);

    showSnapGrid = false;
    context.active = false;

    // Do this last, so that all the menus get updated correctly.
    ClearSuper();
}

</t>
<t tx="leo1.20171224221223.10">                        double d = min(
                            (quatt.Minus(quat0)).Magnitude(),
                            (quatt.Plus(quat0)).Magnitude());
                        if(d &lt; dmin) {
                            dmin = d;
                            quatf = quatt;
                        }
                    }
                }
            }
        }

        SS.GW.AnimateOnto(quatf, SS.GW.offset);
        break;
    }

    case Command::CENTER_VIEW:
        SS.GW.GroupSelection();
        if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
            Quaternion quat0;
            // Offset is the selected point, quaternion is same as before
            Vector pt = SK.GetEntity(SS.GW.gs.point[0])-&gt;PointGetNum();
            quat0 = Quaternion::From(SS.GW.projRight, SS.GW.projUp);
            SS.GW.AnimateOnto(quat0, pt.ScaledBy(-1));
            SS.GW.ClearSelection();
        } else {
            Error(_("Select a point; this point will become the center "
                    "of the view on screen."));
        }
        break;

    case Command::SHOW_TOOLBAR:
        SS.showToolbar = !SS.showToolbar;
        SS.GW.EnsureValidActives();
        InvalidateGraphics();
        break;

    case Command::SHOW_TEXT_WND:
        SS.GW.showTextWindow = !SS.GW.showTextWindow;
        SS.GW.EnsureValidActives();
        break;

    case Command::UNITS_INCHES:
        SS.viewUnits = Unit::INCHES;
        SS.ScheduleShowTW();
        SS.GW.EnsureValidActives();
        break;

    case Command::UNITS_MM:
        SS.viewUnits = Unit::MM;
        SS.ScheduleShowTW();
        SS.GW.EnsureValidActives();
        break;

    case Command::FULL_SCREEN:
        ToggleFullScreen();
        SS.GW.EnsureValidActives();
        break;

    default: ssassert(false, "Unexpected menu ID");
}
InvalidateGraphics();
</t>
<t tx="leo1.20171224221223.11">void GraphicsWindow::EnsureValidActives() {
    bool change = false;
    // The active group must exist, and not be the references.
    Group *g = SK.group.FindByIdNoOops(activeGroup);
    if((!g) || (g-&gt;h.v == Group::HGROUP_REFERENCES.v)) {
        int i;
        for(i = 0; i &lt; SK.groupOrder.n; i++) {
            if(SK.groupOrder.elem[i].v != Group::HGROUP_REFERENCES.v) {
                break;
            }
        }
        if(i &gt;= SK.groupOrder.n) {
            // This can happen if the user deletes all the groups in the
            // sketch. It's difficult to prevent that, because the last
            // group might have been deleted automatically, because it failed
            // a dependency. There needs to be something, so create a plane
            // drawing group and activate that. They should never be able
            // to delete the references, though.
            activeGroup = SS.CreateDefaultDrawingGroup();
            // We've created the default group, but not the workplane entity;
            // do it now so that drawing mode isn't switched to "Free in 3d".
            SS.GenerateAll(SolveSpaceUI::Generate::ALL);
        } else {
            activeGroup = SK.groupOrder.elem[i];
        }
        SK.GetGroup(activeGroup)-&gt;Activate();
        change = true;
    }

    // The active coordinate system must also exist.
    if(LockedInWorkplane()) {
        Entity *e = SK.entity.FindByIdNoOops(ActiveWorkplane());
        if(e) {
            hGroup hgw = e-&gt;group;
            if(hgw.v != activeGroup.v &amp;&amp; SS.GroupsInOrder(activeGroup, hgw)) {
                // The active workplane is in a group that comes after the
                // active group; so any request or constraint will fail.
                SetWorkplaneFreeIn3d();
                change = true;
            }
        } else {
            SetWorkplaneFreeIn3d();
            change = true;
        }
    }

    // And update the checked state for various menus
    bool locked = LockedInWorkplane();
    RadioMenuByCmd(Command::FREE_IN_3D, !locked);
    RadioMenuByCmd(Command::SEL_WORKPLANE, locked);

    SS.UndoEnableMenus();

    switch(SS.viewUnits) {
        case Unit::MM:
        case Unit::INCHES:
            break;
        default:
            SS.viewUnits = Unit::MM;
            break;
    }
    RadioMenuByCmd(Command::UNITS_MM, SS.viewUnits == Unit::MM);
    RadioMenuByCmd(Command::UNITS_INCHES, SS.viewUnits == Unit::INCHES);

    ShowTextWindow(SS.GW.showTextWindow);
    CheckMenuByCmd(Command::SHOW_TEXT_WND, /*checked=*/SS.GW.showTextWindow);

    CheckMenuByCmd(Command::SHOW_TOOLBAR, /*checked=*/SS.showToolbar);
    CheckMenuByCmd(Command::PERSPECTIVE_PROJ, /*checked=*/SS.usePerspectiveProj);
    CheckMenuByCmd(Command::SHOW_GRID,/*checked=*/SS.GW.showSnapGrid);
    CheckMenuByCmd(Command::FULL_SCREEN, /*checked=*/FullScreenIsActive());

    if(change) SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221223.12">void GraphicsWindow::SetWorkplaneFreeIn3d() {
    SK.GetGroup(activeGroup)-&gt;activeWorkplane = Entity::FREE_IN_3D;
}
hEntity GraphicsWindow::ActiveWorkplane() {
    Group *g = SK.group.FindByIdNoOops(activeGroup);
    if(g) {
        return g-&gt;activeWorkplane;
    } else {
        return Entity::FREE_IN_3D;
    }
}
</t>
<t tx="leo1.20171224221223.13">bool GraphicsWindow::LockedInWorkplane() {
    return (SS.GW.ActiveWorkplane().v != Entity::FREE_IN_3D.v);
}

</t>
<t tx="leo1.20171224221223.14">void GraphicsWindow::ForceTextWindowShown() {
    if(!showTextWindow) {
        showTextWindow = true;
        CheckMenuByCmd(Command::SHOW_TEXT_WND, /*checked=*/true);
        ShowTextWindow(true);
    }
}

</t>
<t tx="leo1.20171224221223.15">void GraphicsWindow::DeleteTaggedRequests() {
    // Rewrite any point-coincident constraints that were affected by this
    // deletion.
    Request *r;
    for(r = SK.request.First(); r; r = SK.request.NextAfter(r)) {
        if(!r-&gt;tag) continue;
        FixConstraintsForRequestBeingDeleted(r-&gt;h);
    }
    // and then delete the tagged requests.
    SK.request.RemoveTagged();

    // An edit might be in progress for the just-deleted item. So
    // now it's not.
    HideGraphicsEditControl();
    SS.TW.HideEditControl();
    // And clear out the selection, which could contain that item.
    ClearSuper();
    // And regenerate to get rid of what it generates, plus anything
    // that references it (since the regen code checks for that).
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);
    EnsureValidActives();
    SS.ScheduleShowTW();
}

Vector GraphicsWindow::SnapToGrid(Vector p) {
    if(!LockedInWorkplane()) return p;

    EntityBase *wrkpl = SK.GetEntity(ActiveWorkplane()),
               *norm  = wrkpl-&gt;Normal();
    Vector wo = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum(),
           wu = norm-&gt;NormalU(),
           wv = norm-&gt;NormalV(),
           wn = norm-&gt;NormalN();

    Vector pp = (p.Minus(wo)).DotInToCsys(wu, wv, wn);
    pp.x = floor((pp.x / SS.gridSpacing) + 0.5)*SS.gridSpacing;
    pp.y = floor((pp.y / SS.gridSpacing) + 0.5)*SS.gridSpacing;
    pp.z = 0;

    return pp.ScaleOutOfCsys(wu, wv, wn).Plus(wo);
}

</t>
<t tx="leo1.20171224221223.16">void GraphicsWindow::MenuEdit(Command id) {
    switch(id) {
        case Command::UNSELECT_ALL:
            SS.GW.GroupSelection();
            // If there's nothing selected to de-select, and no operation
            // to cancel, then perhaps they want to return to the home
            // screen in the text window.
            if(SS.GW.gs.n               == 0 &amp;&amp;
               SS.GW.gs.constraints     == 0 &amp;&amp;
               SS.GW.pending.operation  == Pending::NONE)
            {
                if(!(TextEditControlIsVisible() ||
                     GraphicsEditControlIsVisible()))
                {
                    if(SS.TW.shown.screen == TextWindow::Screen::STYLE_INFO) {
                        SS.TW.GoToScreen(TextWindow::Screen::LIST_OF_STYLES);
                    } else {
                        SS.TW.ClearSuper();
                    }
                }
            }
            SS.GW.ClearSuper();
            SS.TW.HideEditControl();
            SS.nakedEdges.Clear();
            SS.justExportedInfo.draw = false;
            SS.centerOfMass.draw = false;
            // This clears the marks drawn to indicate which points are
            // still free to drag.
            Param *p;
            for(p = SK.param.First(); p; p = SK.param.NextAfter(p)) {
                p-&gt;free = false;
            }
            if(SS.exportMode) {
                SS.exportMode = false;
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            }
            SS.GW.persistentDirty = true;
            break;

        case Command::SELECT_ALL: {
            Entity *e;
            for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                if(e-&gt;group.v != SS.GW.activeGroup.v) continue;
                if(e-&gt;IsFace() || e-&gt;IsDistance()) continue;
                if(!e-&gt;IsVisible()) continue;

                SS.GW.MakeSelected(e-&gt;h);
            }
            InvalidateGraphics();
            SS.ScheduleShowTW();
            break;
        }

        case Command::SELECT_CHAIN: {
            Entity *e;
            int newlySelected = 0;
            bool didSomething;
            do {
                didSomething = false;
                for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                    if(e-&gt;group.v != SS.GW.activeGroup.v) continue;
                    if(!e-&gt;HasEndpoints()) continue;
                    if(!e-&gt;IsVisible()) continue;

                    Vector st = e-&gt;EndpointStart(),
                           fi = e-&gt;EndpointFinish();

                    bool onChain = false, alreadySelected = false;
                    List&lt;Selection&gt; *ls = &amp;(SS.GW.selection);
                    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
                        if(!s-&gt;entity.v) continue;
                        if(s-&gt;entity.v == e-&gt;h.v) {
                            alreadySelected = true;
                            continue;
                        }
                        Entity *se = SK.GetEntity(s-&gt;entity);
                        if(!se-&gt;HasEndpoints()) continue;

                        Vector sst = se-&gt;EndpointStart(),
                               sfi = se-&gt;EndpointFinish();

                        if(sst.Equals(st) || sst.Equals(fi) ||
                           sfi.Equals(st) || sfi.Equals(fi))
                        {
                            onChain = true;
                        }
                    }
                    if(onChain &amp;&amp; !alreadySelected) {
                        SS.GW.MakeSelected(e-&gt;h);
                        newlySelected++;
                        didSomething = true;
                    }
                }
            } while(didSomething);
            if(newlySelected == 0) {
                Error(_("No additional entities share endpoints with the selected entities."));
            }
            InvalidateGraphics();
            SS.ScheduleShowTW();
            break;
        }

        case Command::ROTATE_90: {
            SS.GW.GroupSelection();
            Entity *e = NULL;
            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
                e = SK.GetEntity(SS.GW.gs.point[0]);
            } else if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.entities == 1) {
                e = SK.GetEntity(SS.GW.gs.entity[0]);
            }
            SS.GW.ClearSelection();

            hGroup hg = e ? e-&gt;group : SS.GW.activeGroup;
            Group *g = SK.GetGroup(hg);
            if(g-&gt;type != Group::Type::LINKED) {
                Error(_("To use this command, select a point or other "
                        "entity from an linked part, or make a link "
                        "group the active group."));
                break;
            }


            SS.UndoRemember();
            // Rotate by ninety degrees about the coordinate axis closest
            // to the screen normal.
            Vector norm = SS.GW.projRight.Cross(SS.GW.projUp);
            norm = norm.ClosestOrtho();
            norm = norm.WithMagnitude(1);
            Quaternion qaa = Quaternion::From(norm, PI/2);

            g-&gt;TransformImportedBy(Vector::From(0, 0, 0), qaa);

            // and regenerate as necessary.
            SS.MarkGroupDirty(hg);
            break;
        }

        case Command::SNAP_TO_GRID: {
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("No workplane is active. Activate a workplane "
                        "(with Sketch -&gt; In Workplane) to define the plane "
                        "for the snap grid."));
                break;
            }
            SS.GW.GroupSelection();
            if(SS.GW.gs.points == 0 &amp;&amp; SS.GW.gs.constraintLabels == 0) {
                Error(_("Can't snap these items to grid; select points, "
                        "text comments, or constraints with a label. "
                        "To snap a line, select its endpoints."));
                break;
            }
            SS.UndoRemember();

            List&lt;Selection&gt; *ls = &amp;(SS.GW.selection);
            for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
                if(s-&gt;entity.v) {
                    hEntity hp = s-&gt;entity;
                    Entity *ep = SK.GetEntity(hp);
                    if(!ep-&gt;IsPoint()) continue;

                    Vector p = ep-&gt;PointGetNum();
                    ep-&gt;PointForceTo(SS.GW.SnapToGrid(p));
                    SS.GW.pending.points.Add(&amp;hp);
                    SS.MarkGroupDirty(ep-&gt;group);
                } else if(s-&gt;constraint.v) {
                    Constraint *c = SK.GetConstraint(s-&gt;constraint);
                    std::vector&lt;Vector&gt; refs;
                    c-&gt;GetReferencePoints(SS.GW.GetCamera(), &amp;refs);
                    c-&gt;disp.offset = c-&gt;disp.offset.Plus(SS.GW.SnapToGrid(refs[0]).Minus(refs[0]));
                }
            }
            // Regenerate, with these points marked as dragged so that they
            // get placed as close as possible to our snap grid.
            SS.GW.ClearPending();

            SS.GW.ClearSelection();
            InvalidateGraphics();
            break;
        }

        case Command::UNDO:
            SS.UndoUndo();
            break;

        case Command::REDO:
            SS.UndoRedo();
            break;

        case Command::REGEN_ALL:
            SS.images.clear();
            SS.ReloadAllLinked(SS.saveFile);
            SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
            SS.ScheduleShowTW();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo1.20171224221223.17">void GraphicsWindow::MenuRequest(Command id) {
    const char *s;
    switch(id) {
        case Command::SEL_WORKPLANE: {
            SS.GW.GroupSelection();
            Group *g = SK.GetGroup(SS.GW.activeGroup);

            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.workplanes == 1) {
                // A user-selected workplane
                g-&gt;activeWorkplane = SS.GW.gs.entity[0];
            } else if(g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
                // The group's default workplane
                g-&gt;activeWorkplane = g-&gt;h.entity(0);
                Message(_("No workplane selected. Activating default workplane "
                          "for this group."));
            }

            if(!SS.GW.LockedInWorkplane()) {
                Error(_("No workplane is selected, and the active group does "
                        "not have a default workplane. Try selecting a "
                        "workplane, or activating a sketch-in-new-workplane "
                        "group."));
                break;
            }
            // Align the view with the selected workplane
            SS.GW.AnimateOntoWorkplane();
            SS.GW.ClearSuper();
            SS.ScheduleShowTW();
            break;
        }
        case Command::FREE_IN_3D:
            SS.GW.SetWorkplaneFreeIn3d();
            SS.GW.EnsureValidActives();
            SS.ScheduleShowTW();
            InvalidateGraphics();
            break;

        case Command::TANGENT_ARC:
            SS.GW.GroupSelection();
            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
                SS.GW.MakeTangentArc();
            } else if(SS.GW.gs.n != 0) {
                Error(_("Bad selection for tangent arc at point. Select a "
                        "single point, or select nothing to set up arc "
                        "parameters."));
            } else {
                SS.TW.GoToScreen(TextWindow::Screen::TANGENT_ARC);
                SS.GW.ForceTextWindowShown();
                SS.ScheduleShowTW();
                InvalidateGraphics(); // repaint toolbar
            }
            break;

        case Command::ARC: s = _("click point on arc (draws anti-clockwise)"); goto c;
        case Command::DATUM_POINT: s = _("click to place datum point"); goto c;
        case Command::LINE_SEGMENT: s = _("click first point of line segment"); goto c;
        case Command::CONSTR_SEGMENT:
            s = _("click first point of construction line segment"); goto c;
        case Command::CUBIC: s = _("click first point of cubic segment"); goto c;
        case Command::CIRCLE: s = _("click center of circle"); goto c;
        case Command::WORKPLANE: s = _("click origin of workplane"); goto c;
        case Command::RECTANGLE: s = _("click one corner of rectangle"); goto c;
        case Command::TTF_TEXT: s = _("click top left of text"); goto c;
        case Command::IMAGE:
            if(!SS.ReloadLinkedImage(SS.saveFile, &amp;SS.GW.pending.filename,
                                     /*canCancel=*/true)) {
                return;
            }
            s = _("click top left of image"); goto c;
c:
            SS.GW.pending.operation = GraphicsWindow::Pending::COMMAND;
            SS.GW.pending.command = id;
            SS.GW.pending.description = s;
            SS.ScheduleShowTW();
            InvalidateGraphics(); // repaint toolbar
            break;

        case Command::CONSTRUCTION: {
            SS.UndoRemember();
            SS.GW.GroupSelection();
            if(SS.GW.gs.entities == 0) {
                Error(_("No entities are selected. Select entities before "
                        "trying to toggle their construction state."));
            }
            int i;
            for(i = 0; i &lt; SS.GW.gs.entities; i++) {
                hEntity he = SS.GW.gs.entity[i];
                if(!he.isFromRequest()) continue;
                Request *r = SK.GetRequest(he.request());
                r-&gt;construction = !(r-&gt;construction);
                SS.MarkGroupDirty(r-&gt;group);
            }
            SS.GW.ClearSelection();
            break;
        }

        case Command::SPLIT_CURVES:
            SS.GW.SplitLinesOrCurves();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo1.20171224221223.18">void GraphicsWindow::ClearSuper() {
    HideGraphicsEditControl();
    ClearPending();
    ClearSelection();
    hover.Clear();
    EnsureValidActives();
}

</t>
<t tx="leo1.20171224221223.19">void GraphicsWindow::ToggleBool(bool *v) {
    *v = !*v;

    // The faces are shown as special stippling on the shaded triangle mesh,
    // so not meaningful to show them and hide the shaded.
    if(!showShaded) showFaces = false;

    // If the mesh or edges were previously hidden, they haven't been generated,
    // and if we are going to show them, we need to generate them first.
    Group *g = SK.GetGroup(SS.GW.activeGroup);
    if(*v &amp;&amp; (g-&gt;displayOutlines.l.n == 0 &amp;&amp; (v == &amp;showEdges || v == &amp;showOutlines))) {
        SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
    }

    SS.GW.persistentDirty = true;
    InvalidateGraphics();
    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221223.2">void GraphicsWindow::AnimateOntoWorkplane() {
    if(!LockedInWorkplane()) return;

    Entity *w = SK.GetEntity(ActiveWorkplane());
    Quaternion quatf = w-&gt;Normal()-&gt;NormalGetNum();
    Vector offsetf = (SK.GetEntity(w-&gt;point[0])-&gt;PointGetNum()).ScaledBy(-1);

    AnimateOnto(quatf, offsetf);
}

</t>
<t tx="leo1.20171224221223.20">bool GraphicsWindow::SuggestLineConstraint(hRequest request, Constraint::Type *type) {
    if(LockedInWorkplane()) {
        Entity *ptA = SK.GetEntity(request.entity(1)),
               *ptB = SK.GetEntity(request.entity(2));

        Expr *au, *av, *bu, *bv;

        ptA-&gt;PointGetExprsInWorkplane(ActiveWorkplane(), &amp;au, &amp;av);
        ptB-&gt;PointGetExprsInWorkplane(ActiveWorkplane(), &amp;bu, &amp;bv);

        double du = au-&gt;Minus(bu)-&gt;Eval();
        double dv = av-&gt;Minus(bv)-&gt;Eval();

        const double TOLERANCE_RATIO = 0.02;
        if(fabs(dv) &gt; LENGTH_EPS &amp;&amp; fabs(du / dv) &lt; TOLERANCE_RATIO) {
            *type = Constraint::Type::VERTICAL;
            return true;
        } else if(fabs(du) &gt; LENGTH_EPS &amp;&amp; fabs(dv / du) &lt; TOLERANCE_RATIO) {
            *type = Constraint::Type::HORIZONTAL;
            return true;
        }
    }
    return false;
}
</t>
<t tx="leo1.20171224221223.21">//-----------------------------------------------------------------------------
// Implementation of the Group class, which represents a set of entities and
// constraints that are solved together, in some cases followed by another
// operation, like to extrude surfaces from the entities or to step and
// repeat them parametrically.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hParam   Param::NO_PARAM = { 0 };
#define NO_PARAM (Param::NO_PARAM)

const hGroup Group::HGROUP_REFERENCES = { 1 };

//-----------------------------------------------------------------------------
// The group structure includes pointers to other dynamically-allocated
// memory. This clears and frees them all.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221223.22">void Group::Clear() {
    polyLoops.Clear();
    bezierLoops.Clear();
    bezierOpens.Clear();
    thisMesh.Clear();
    runningMesh.Clear();
    thisShell.Clear();
    runningShell.Clear();
    displayMesh.Clear();
    displayOutlines.Clear();
    impMesh.Clear();
    impShell.Clear();
    impEntity.Clear();
    // remap is the only one that doesn't get recreated when we regen
    remap.Clear();
}

</t>
<t tx="leo1.20171224221223.23">void Group::AddParam(IdList&lt;Param,hParam&gt; *param, hParam hp, double v) {
    Param pa = {};
    pa.h = hp;
    pa.val = v;

    param-&gt;Add(&amp;pa);
}

</t>
<t tx="leo1.20171224221223.24">bool Group::IsVisible() {
    if(!visible) return false;
    Group *active = SK.GetGroup(SS.GW.activeGroup);
    if(order &gt; active-&gt;order) return false;
    return true;
}

</t>
<t tx="leo1.20171224221223.25">int Group::GetNumConstraints(void) {
    int num = 0;
    for(int i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;SK.constraint.elem[i];
        if(c-&gt;group.v != h.v) continue;
        num++;
    }
    return num;
}

Vector Group::ExtrusionGetVector() {
    return Vector::From(h.param(0), h.param(1), h.param(2));
}

</t>
<t tx="leo1.20171224221223.26">void Group::ExtrusionForceVectorTo(const Vector &amp;v) {
    SK.GetParam(h.param(0))-&gt;val = v.x;
    SK.GetParam(h.param(1))-&gt;val = v.y;
    SK.GetParam(h.param(2))-&gt;val = v.z;
}

</t>
<t tx="leo1.20171224221223.27">void Group::MenuGroup(Command id) {
    Group g = {};
    g.visible = true;
    g.color = RGBi(100, 100, 100);
    g.scale = 1;

    if((uint32_t)id &gt;= (uint32_t)Command::RECENT_LINK &amp;&amp;
       (uint32_t)id &lt; ((uint32_t)Command::RECENT_LINK + MAX_RECENT)) {
        g.linkFile = RecentFile[(uint32_t)id-(uint32_t)Command::RECENT_LINK];
        id = Command::GROUP_LINK;
    }

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::GROUP_3D:
            g.type = Type::DRAWING_3D;
            g.name = C_("group-name", "sketch-in-3d");
            break;

        case Command::GROUP_WRKPL:
            g.type = Type::DRAWING_WORKPLANE;
            g.name = C_("group-name", "sketch-in-plane");
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                g.subtype = Subtype::WORKPLANE_BY_POINT_ORTHO;

                Vector u = SS.GW.projRight, v = SS.GW.projUp;
                u = u.ClosestOrtho();
                v = v.Minus(u.ScaledBy(v.Dot(u)));
                v = v.ClosestOrtho();

                g.predef.q = Quaternion::From(u, v);
                g.predef.origin = gs.point[0];
            } else if(gs.points == 1 &amp;&amp; gs.lineSegments == 2 &amp;&amp; gs.n == 3) {
                g.subtype = Subtype::WORKPLANE_BY_LINE_SEGMENTS;

                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.entity[0];
                g.predef.entityC = gs.entity[1];

                Vector ut = SK.GetEntity(g.predef.entityB)-&gt;VectorGetNum();
                Vector vt = SK.GetEntity(g.predef.entityC)-&gt;VectorGetNum();
                ut = ut.WithMagnitude(1);
                vt = vt.WithMagnitude(1);

                if(fabs(SS.GW.projUp.Dot(vt)) &lt; fabs(SS.GW.projUp.Dot(ut))) {
                    swap(ut, vt);
                    g.predef.swapUV = true;
                }
                if(SS.GW.projRight.Dot(ut) &lt; 0) g.predef.negateU = true;
                if(SS.GW.projUp.   Dot(vt) &lt; 0) g.predef.negateV = true;
            } else if(gs.workplanes == 1 &amp;&amp; gs.n == 1) {
                if(gs.entity[0].isFromRequest()) {
                    Entity *wrkpl = SK.GetEntity(gs.entity[0]);
                    Entity *normal = SK.GetEntity(wrkpl-&gt;normal);
                    g.subtype = Subtype::WORKPLANE_BY_POINT_ORTHO;
                    g.predef.origin = wrkpl-&gt;point[0];
                    g.predef.q = normal-&gt;NormalGetNum();
                } else {
                    Group *wrkplg = SK.GetGroup(gs.entity[0].group());
                    g.subtype = wrkplg-&gt;subtype;
                    g.predef.origin = wrkplg-&gt;predef.origin;
                    if(wrkplg-&gt;subtype == Subtype::WORKPLANE_BY_LINE_SEGMENTS) {
                        g.predef.entityB = wrkplg-&gt;predef.entityB;
                        g.predef.entityC = wrkplg-&gt;predef.entityC;
                        g.predef.swapUV = wrkplg-&gt;predef.swapUV;
                        g.predef.negateU = wrkplg-&gt;predef.negateU;
                        g.predef.negateV = wrkplg-&gt;predef.negateV;
                    } else if(wrkplg-&gt;subtype == Subtype::WORKPLANE_BY_POINT_ORTHO) {
                        g.predef.q = wrkplg-&gt;predef.q;
                    } else ssassert(false, "Unexpected workplane subtype");
                }
            } else {
                Error(_("Bad selection for new sketch in workplane. This "
                        "group can be created with:\n\n"
                        "    * a point (through the point, orthogonal to coordinate axes)\n"
                        "    * a point and two line segments (through the point, "
                               "parallel to the lines)\n"
                        "    * a workplane (copy of the workplane)\n"));
                return;
            }
            break;

        case Command::GROUP_EXTRUDE:
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("Activate a workplane (Sketch -&gt; In Workplane) before "
                        "extruding. The sketch will be extruded normal to the "
                        "workplane."));
                return;
            }
            g.type = Type::EXTRUDE;
            g.opA = SS.GW.activeGroup;
            g.predef.entityB = SS.GW.ActiveWorkplane();
            g.subtype = Subtype::ONE_SIDED;
            g.name = C_("group-name", "extrude");
            break;

        case Command::GROUP_LATHE:
            if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                g.predef.origin = SK.GetEntity(gs.entity[0])-&gt;point[0];
                g.predef.entityB = gs.entity[0];
                // since a line segment is a vector
            } else {
                Error(_("Bad selection for new lathe group. This group can "
                        "be created with:\n\n"
                        "    * a point and a line segment or normal "
                                 "(revolved about an axis parallel to line / "
                                 "normal, through point)\n"
                        "    * a line segment (revolved about line segment)\n"));
                return;
            }
            g.type = Type::LATHE;
            g.opA = SS.GW.activeGroup;
            g.name = C_("group-name", "lathe");
            break;

        case Command::GROUP_ROT: {
            if(gs.points == 1 &amp;&amp; gs.n == 1 &amp;&amp; SS.GW.LockedInWorkplane()) {
                g.predef.origin = gs.point[0];
                Entity *w = SK.GetEntity(SS.GW.ActiveWorkplane());
                g.predef.entityB = w-&gt;Normal()-&gt;h;
                g.activeWorkplane = w-&gt;h;
            } else if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else {
                Error(_("Bad selection for new rotation. This group can "
                        "be created with:\n\n"
                        "    * a point, while locked in workplane (rotate "
                              "in plane, about that point)\n"
                        "    * a point and a line or a normal (rotate about "
                              "an axis through the point, and parallel to "
                              "line / normal)\n"));
                return;
            }
            g.type = Type::ROTATE;
            g.opA = SS.GW.activeGroup;
            g.valA = 3;
            g.subtype = Subtype::ONE_SIDED;
            g.name = C_("group-name", "rotate");
            break;
        }

        case Command::GROUP_TRANS:
            g.type = Type::TRANSLATE;
            g.opA = SS.GW.activeGroup;
            g.valA = 3;
            g.subtype = Subtype::ONE_SIDED;
            g.predef.entityB = SS.GW.ActiveWorkplane();
            g.activeWorkplane = SS.GW.ActiveWorkplane();
            g.name = C_("group-name", "translate");
            break;

        case Command::GROUP_LINK: {
            g.type = Type::LINKED;
            g.meshCombine = CombineAs::ASSEMBLE;
            if(g.linkFile.IsEmpty()) {
                if(!GetOpenFile(&amp;g.linkFile, "", SlvsFileFilter)) return;
            }

            // Assign the default name of the group based on the name of
            // the linked file.
            g.name = g.linkFile.FileStem();
            for(size_t i = 0; i &lt; g.name.length(); i++) {
                if(!(isalnum(g.name[i]) || (unsigned)g.name[i] &gt;= 0x80)) {
                    // convert punctuation to dashes
                    g.name[i] = '-';
                }
            }
            break;
        }

        default: ssassert(false, "Unexpected menu ID");
    }

    // Copy color from the previous mesh-contributing group.
    if(g.IsMeshGroup() &amp;&amp; SK.groupOrder.n &gt; 0) {
        Group *running = SK.GetRunningMeshGroupFor(SS.GW.activeGroup);
        if(running != NULL) {
            g.color = running-&gt;color;
        }
    }

    SS.GW.ClearSelection();
    SS.UndoRemember();

    bool afterActive = false;
    for(int i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *gi = SK.GetGroup(SK.groupOrder.elem[i]);
        if(afterActive)
            gi-&gt;order += 1;
        if(gi-&gt;h.v == SS.GW.activeGroup.v) {
            g.order = gi-&gt;order + 1;
            afterActive = true;
        }
    }

    SK.group.AddAndAssignId(&amp;g);
    Group *gg = SK.GetGroup(g.h);

    if(gg-&gt;type == Type::LINKED) {
        SS.ReloadAllLinked(SS.saveFile);
    }
    gg-&gt;clean = false;
    SS.GW.activeGroup = gg-&gt;h;
    SS.GenerateAll();
    if(gg-&gt;type == Type::DRAWING_WORKPLANE) {
        // Can't set the active workplane for this one until after we've
        // regenerated, because the workplane doesn't exist until then.
        gg-&gt;activeWorkplane = gg-&gt;h.entity(0);
    }
    gg-&gt;Activate();
    SS.GW.AnimateOntoWorkplane();
    TextWindow::ScreenSelectGroup(0, gg-&gt;h.v);
    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221223.28">void Group::TransformImportedBy(Vector t, Quaternion q) {
    ssassert(type == Type::LINKED, "Expected a linked group");

    hParam tx, ty, tz, qw, qx, qy, qz;
    tx = h.param(0);
    ty = h.param(1);
    tz = h.param(2);
    qw = h.param(3);
    qx = h.param(4);
    qy = h.param(5);
    qz = h.param(6);

    Quaternion qg = Quaternion::From(qw, qx, qy, qz);
    qg = q.Times(qg);

    Vector tg = Vector::From(tx, ty, tz);
    tg = tg.Plus(t);

    SK.GetParam(tx)-&gt;val = tg.x;
    SK.GetParam(ty)-&gt;val = tg.y;
    SK.GetParam(tz)-&gt;val = tg.z;

    SK.GetParam(qw)-&gt;val = qg.w;
    SK.GetParam(qx)-&gt;val = qg.vx;
    SK.GetParam(qy)-&gt;val = qg.vy;
    SK.GetParam(qz)-&gt;val = qg.vz;
}

</t>
<t tx="leo1.20171224221223.29">bool Group::IsForcedToMeshBySource() const {
    const Group *srcg = this;
    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        // A step and repeat gets merged against the group's prevous group,
        // not our own previous group.
        srcg = SK.GetGroup(opA);
        if(srcg-&gt;forceToMesh) return true;
    }
    Group *g = srcg-&gt;RunningMeshGroup();
    if(g == NULL) return false;
    return g-&gt;forceToMesh || g-&gt;IsForcedToMeshBySource();
}

</t>
<t tx="leo1.20171224221223.3">void GraphicsWindow::AnimateOnto(Quaternion quatf, Vector offsetf) {
    // Get our initial orientation and translation.
    Quaternion quat0 = Quaternion::From(projRight, projUp);
    Vector offset0 = offset;

    // Make sure we take the shorter of the two possible paths.
    double mp = (quatf.Minus(quat0)).Magnitude();
    double mm = (quatf.Plus(quat0)).Magnitude();
    if(mp &gt; mm) {
        quatf = quatf.ScaledBy(-1);
        mp = mm;
    }
    double mo = (offset0.Minus(offsetf)).Magnitude()*scale;

    // Animate transition, unless it's a tiny move.
    @others
}

</t>
<t tx="leo1.20171224221223.30">bool Group::IsForcedToMesh() const {
    return forceToMesh || IsForcedToMeshBySource();
}

std::string Group::DescriptionString() {
    if(name.empty()) {
        return ssprintf("g%03x-%s", h.v, _("(unnamed)"));
    } else {
        return ssprintf("g%03x-%s", h.v, name.c_str());
    }
}

</t>
<t tx="leo1.20171224221223.31">void Group::Activate() {
    if(type == Type::EXTRUDE || type == Type::LINKED || type == Type::LATHE ||
       type == Type::TRANSLATE || type == Type::ROTATE) {
        SS.GW.showFaces = true;
    } else {
        SS.GW.showFaces = false;
    }
    SS.MarkGroupDirty(h); // for good measure; shouldn't be needed
    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221223.32">void Group::Generate(IdList&lt;Entity,hEntity&gt; *entity,
                     IdList&lt;Param,hParam&gt; *param)
{
    Vector gn = (SS.GW.projRight).Cross(SS.GW.projUp);
    Vector gp = SS.GW.projRight.Plus(SS.GW.projUp);
    Vector gc = (SS.GW.offset).ScaledBy(-1);
    gn = gn.WithMagnitude(200/SS.GW.scale);
    gp = gp.WithMagnitude(200/SS.GW.scale);
    int a, i;
    switch(type) {
        case Type::DRAWING_3D:
            return;

        case Type::DRAWING_WORKPLANE: {
            Quaternion q;
            if(subtype == Subtype::WORKPLANE_BY_LINE_SEGMENTS) {
                Vector u = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
                Vector v = SK.GetEntity(predef.entityC)-&gt;VectorGetNum();
                u = u.WithMagnitude(1);
                Vector n = u.Cross(v);
                v = (n.Cross(u)).WithMagnitude(1);

                if(predef.swapUV) swap(u, v);
                if(predef.negateU) u = u.ScaledBy(-1);
                if(predef.negateV) v = v.ScaledBy(-1);
                q = Quaternion::From(u, v);
            } else if(subtype == Subtype::WORKPLANE_BY_POINT_ORTHO) {
                // Already given, numerically.
                q = predef.q;
            } else ssassert(false, "Unexpected workplane subtype");

            Entity normal = {};
            normal.type = Entity::Type::NORMAL_N_COPY;
            normal.numNormal = q;
            normal.point[0] = h.entity(2);
            normal.group = h;
            normal.h = h.entity(1);
            entity-&gt;Add(&amp;normal);

            Entity point = {};
            point.type = Entity::Type::POINT_N_COPY;
            point.numPoint = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            point.construction = true;
            point.group = h;
            point.h = h.entity(2);
            entity-&gt;Add(&amp;point);

            Entity wp = {};
            wp.type = Entity::Type::WORKPLANE;
            wp.normal = normal.h;
            wp.point[0] = point.h;
            wp.group = h;
            wp.h = h.entity(0);
            entity-&gt;Add(&amp;wp);
            return;
        }

        case Type::EXTRUDE: {
            AddParam(param, h.param(0), gn.x);
            AddParam(param, h.param(1), gn.y);
            AddParam(param, h.param(2), gn.z);
            int ai, af;
            if(subtype == Subtype::ONE_SIDED) {
                ai = 0; af = 2;
            } else if(subtype == Subtype::TWO_SIDED) {
                ai = -1; af = 1;
            } else ssassert(false, "Unexpected extrusion subtype");

            // Get some arbitrary point in the sketch, that will be used
            // as a reference when defining top and bottom faces.
            hEntity pt = { 0 };
            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;elem[i]);
                if(e-&gt;group.v != opA.v) continue;

                if(e-&gt;IsPoint()) pt = e-&gt;h;

                e-&gt;CalculateNumerical(/*forExport=*/false);
                hEntity he = e-&gt;h; e = NULL;
                // As soon as I call CopyEntity, e may become invalid! That
                // adds entities, which may cause a realloc.
                CopyEntity(entity, SK.GetEntity(he), ai, REMAP_BOTTOM,
                    h.param(0), h.param(1), h.param(2),
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::N_TRANS);
                CopyEntity(entity, SK.GetEntity(he), af, REMAP_TOP,
                    h.param(0), h.param(1), h.param(2),
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::N_TRANS);
                MakeExtrusionLines(entity, he);
            }
            // Remapped versions of that arbitrary point will be used to
            // provide points on the plane faces.
            MakeExtrusionTopBottomFaces(entity, pt);
            return;
        }

        case Type::LATHE: {
            Vector axis_pos = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            Vector axis_dir = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();

            // Remapped entity index.
            int ai = 1;

            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;elem[i]);
                if(e-&gt;group.v != opA.v) continue;

                e-&gt;CalculateNumerical(/*forExport=*/false);
                hEntity he = e-&gt;h;

                // As soon as I call CopyEntity, e may become invalid! That
                // adds entities, which may cause a realloc.
                CopyEntity(entity, SK.GetEntity(predef.origin), 0, ai,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                CopyEntity(entity, SK.GetEntity(he), 0, REMAP_LATHE_START,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                CopyEntity(entity, SK.GetEntity(he), 0, REMAP_LATHE_END,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                MakeLatheCircles(entity, param, he, axis_pos, axis_dir, ai);
                ai++;
            }
            return;
        }

        case Type::TRANSLATE: {
            // inherit meshCombine from source group
            Group *srcg = SK.GetGroup(opA);
            meshCombine = srcg-&gt;meshCombine;
            // The translation vector
            AddParam(param, h.param(0), gp.x);
            AddParam(param, h.param(1), gp.y);
            AddParam(param, h.param(2), gp.z);

            int n = (int)valA, a0 = 0;
            if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
                a0++; n++;
            }

            for(a = a0; a &lt; n; a++) {
                for(i = 0; i &lt; entity-&gt;n; i++) {
                    Entity *e = &amp;(entity-&gt;elem[i]);
                    if(e-&gt;group.v != opA.v) continue;

                    e-&gt;CalculateNumerical(/*forExport=*/false);
                    CopyEntity(entity, e,
                        a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1)),
                        (a == (n - 1)) ? REMAP_LAST : a,
                        h.param(0), h.param(1), h.param(2),
                        NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                        CopyAs::N_TRANS);
                }
            }
            return;
        }
        case Type::ROTATE: {
            // inherit meshCombine from source group
            Group *srcg = SK.GetGroup(opA);
            meshCombine = srcg-&gt;meshCombine;
            // The center of rotation
            AddParam(param, h.param(0), gc.x);
            AddParam(param, h.param(1), gc.y);
            AddParam(param, h.param(2), gc.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 30*PI/180);
            AddParam(param, h.param(4), gn.x);
            AddParam(param, h.param(5), gn.y);
            AddParam(param, h.param(6), gn.z);

            int n = (int)valA, a0 = 0;
            if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
                a0++; n++;
            }

            for(a = a0; a &lt; n; a++) {
                for(i = 0; i &lt; entity-&gt;n; i++) {
                    Entity *e = &amp;(entity-&gt;elem[i]);
                    if(e-&gt;group.v != opA.v) continue;

                    e-&gt;CalculateNumerical(/*forExport=*/false);
                    CopyEntity(entity, e,
                        a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1)),
                        (a == (n - 1)) ? REMAP_LAST : a,
                        h.param(0), h.param(1), h.param(2),
                        h.param(3), h.param(4), h.param(5), h.param(6),
                        CopyAs::N_ROT_AA);
                }
            }
            return;
        }
        case Type::LINKED:
            // The translation vector
            AddParam(param, h.param(0), gp.x);
            AddParam(param, h.param(1), gp.y);
            AddParam(param, h.param(2), gp.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 1);
            AddParam(param, h.param(4), 0);
            AddParam(param, h.param(5), 0);
            AddParam(param, h.param(6), 0);

            for(i = 0; i &lt; impEntity.n; i++) {
                Entity *ie = &amp;(impEntity.elem[i]);
                CopyEntity(entity, ie, 0, 0,
                    h.param(0), h.param(1), h.param(2),
                    h.param(3), h.param(4), h.param(5), h.param(6),
                    CopyAs::N_ROT_TRANS);
            }
            return;
    }
    ssassert(false, "Unexpected group type");
}

</t>
<t tx="leo1.20171224221223.33">bool Group::IsSolvedOkay() {
    return this-&gt;solved.how == SolveResult::OKAY ||
           (this-&gt;allowRedundant &amp;&amp; this-&gt;solved.how == SolveResult::REDUNDANT_OKAY);
}

</t>
<t tx="leo1.20171224221223.34">void Group::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) {
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo1.20171224221223.35">void Group::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) {
    if(type == Type::LINKED) {
        // Normalize the quaternion
        ExprQuaternion q = {
            Expr::From(h.param(3)),
            Expr::From(h.param(4)),
            Expr::From(h.param(5)),
            Expr::From(h.param(6)) };
        AddEq(l, (q.Magnitude())-&gt;Minus(Expr::From(1)), 0);
    } else if(type == Type::ROTATE) {
        // The axis and center of rotation are specified numerically
#define EC(x) (Expr::From(x))
#define EP(x) (Expr::From(h.param(x)))
        ExprVector orig = SK.GetEntity(predef.origin)-&gt;PointGetExprs();
        AddEq(l, (orig.x)-&gt;Minus(EP(0)), 0);
        AddEq(l, (orig.y)-&gt;Minus(EP(1)), 1);
        AddEq(l, (orig.z)-&gt;Minus(EP(2)), 2);
        // param 3 is the angle, which is free
        Vector axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis = axis.WithMagnitude(1);
        AddEq(l, (EC(axis.x))-&gt;Minus(EP(4)), 3);
        AddEq(l, (EC(axis.y))-&gt;Minus(EP(5)), 4);
        AddEq(l, (EC(axis.z))-&gt;Minus(EP(6)), 5);
#undef EC
#undef EP
    } else if(type == Type::EXTRUDE) {
        if(predef.entityB.v != Entity::FREE_IN_3D.v) {
            // The extrusion path is locked along a line, normal to the
            // specified workplane.
            Entity *w = SK.GetEntity(predef.entityB);
            ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
            ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();
            ExprVector extruden = {
                Expr::From(h.param(0)),
                Expr::From(h.param(1)),
                Expr::From(h.param(2)) };

            AddEq(l, u.Dot(extruden), 0);
            AddEq(l, v.Dot(extruden), 1);
        }
    } else if(type == Type::TRANSLATE) {
        if(predef.entityB.v != Entity::FREE_IN_3D.v) {
            Entity *w = SK.GetEntity(predef.entityB);
            ExprVector n = w-&gt;Normal()-&gt;NormalExprsN();
            ExprVector trans;
            trans = ExprVector::From(h.param(0), h.param(1), h.param(2));

            // The translation vector is parallel to the workplane
            AddEq(l, trans.Dot(n), 0);
        }
    }
}

hEntity Group::Remap(hEntity in, int copyNumber) {
    // A hash table is used to accelerate the search
    int hash = ((unsigned)(in.v*61 + copyNumber)) % REMAP_PRIME;
    int i = remapCache[hash];
    if(i &gt;= 0 &amp;&amp; i &lt; remap.n) {
        EntityMap *em = &amp;(remap.elem[i]);
        if(em-&gt;input.v == in.v &amp;&amp; em-&gt;copyNumber == copyNumber) {
            return h.entity(em-&gt;h.v);
        }
    }
    // but if we don't find it in the hash table, then linear search
    for(i = 0; i &lt; remap.n; i++) {
        EntityMap *em = &amp;(remap.elem[i]);
        if(em-&gt;input.v == in.v &amp;&amp; em-&gt;copyNumber == copyNumber) {
            // We already have a mapping for this entity.
            remapCache[hash] = i;
            return h.entity(em-&gt;h.v);
        }
    }
    // And if we still don't find it, then create a new entry.
    EntityMap em;
    em.input = in;
    em.copyNumber = copyNumber;
    remap.AddAndAssignId(&amp;em);
    return h.entity(em.h.v);
}

</t>
<t tx="leo1.20171224221223.36">void Group::MakeExtrusionLines(IdList&lt;Entity,hEntity&gt; *el, hEntity in) {
    Entity *ep = SK.GetEntity(in);

    Entity en = {};
    if(ep-&gt;IsPoint()) {
        // A point gets extruded to form a line segment
        en.point[0] = Remap(ep-&gt;h, REMAP_TOP);
        en.point[1] = Remap(ep-&gt;h, REMAP_BOTTOM);
        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_PT_TO_LINE);
        en.type = Entity::Type::LINE_SEGMENT;
        el-&gt;Add(&amp;en);
    } else if(ep-&gt;type == Entity::Type::LINE_SEGMENT) {
        // A line gets extruded to form a plane face; an endpoint of the
        // original line is a point in the plane, and the line is in the plane.
        Vector a = SK.GetEntity(ep-&gt;point[0])-&gt;PointGetNum();
        Vector b = SK.GetEntity(ep-&gt;point[1])-&gt;PointGetNum();
        Vector ab = b.Minus(a);

        en.param[0] = h.param(0);
        en.param[1] = h.param(1);
        en.param[2] = h.param(2);
        en.numPoint = a;
        en.numNormal = Quaternion::From(0, ab.x, ab.y, ab.z);

        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_LINE_TO_FACE);
        en.type = Entity::Type::FACE_XPROD;
        el-&gt;Add(&amp;en);
    }
}

</t>
<t tx="leo1.20171224221223.37">void Group::MakeLatheCircles(IdList&lt;Entity,hEntity&gt; *el, IdList&lt;Param,hParam&gt; *param, hEntity in, Vector pt, Vector axis, int ai) {
    Entity *ep = SK.GetEntity(in);

    Entity en = {};
    if(ep-&gt;IsPoint()) {
        // A point gets revolved to form an arc.
        en.point[0] = Remap(predef.origin, ai);
        en.point[1] = Remap(ep-&gt;h, REMAP_LATHE_START);
        en.point[2] = Remap(ep-&gt;h, REMAP_LATHE_END);

        // Get arc center and point on arc.
        Entity *pc = SK.GetEntity(en.point[0]);
        Entity *pp = SK.GetEntity(en.point[1]);

        // Project arc point to the revolution axis and use it for arc center.
        double k = pp-&gt;numPoint.Minus(pt).Dot(axis) / axis.Dot(axis);
        pc-&gt;numPoint = pt.Plus(axis.ScaledBy(k));

        // Create arc entity.
        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_PT_TO_ARC);
        en.type = Entity::Type::ARC_OF_CIRCLE;

        // Generate a normal.
        Entity n = {};
        n.workplane = en.workplane;
        n.h = Remap(ep-&gt;h, REMAP_PT_TO_NORMAL);
        n.group = en.group;
        n.style = en.style;
        n.type = Entity::Type::NORMAL_N_COPY;

        // Create basis for the normal.
        Vector nu = pp-&gt;numPoint.Minus(pc-&gt;numPoint).WithMagnitude(1.0);
        Vector nv = nu.Cross(axis).WithMagnitude(1.0);
        n.numNormal = Quaternion::From(nv, nu);

        // The point determines where the normal gets displayed on-screen;
        // it's entirely cosmetic.
        n.point[0] = en.point[0];
        el-&gt;Add(&amp;n);
        en.normal = n.h;
        el-&gt;Add(&amp;en);
    } else if(ep-&gt;type == Entity::Type::LINE_SEGMENT) {
        // An axis-perpendicular line gets revolved to form a face.
        Vector a = SK.GetEntity(ep-&gt;point[0])-&gt;PointGetNum();
        Vector b = SK.GetEntity(ep-&gt;point[1])-&gt;PointGetNum();
        Vector u = b.Minus(a).WithMagnitude(1.0);

        // Check for perpendicularity: calculate cosine of the angle
        // between axis and line direction and check that
        // cos(angle) == 0 &lt;-&gt; angle == +-90 deg.
        if(fabs(u.Dot(axis) / axis.Magnitude()) &lt; ANGLE_COS_EPS) {
            en.param[0] = h.param(0);
            en.param[1] = h.param(1);
            en.param[2] = h.param(2);
            Vector v = axis.Cross(u).WithMagnitude(1.0);
            Vector n = u.Cross(v);
            en.numNormal = Quaternion::From(0, n.x, n.y, n.z);

            en.group = h;
            en.construction = ep-&gt;construction;
            en.style = ep-&gt;style;
            en.h = Remap(ep-&gt;h, REMAP_LINE_TO_FACE);
            en.type = Entity::Type::FACE_NORMAL_PT;
            en.point[0] = ep-&gt;point[0];
            el-&gt;Add(&amp;en);
        }
    }
}

</t>
<t tx="leo1.20171224221223.38">void Group::MakeExtrusionTopBottomFaces(IdList&lt;Entity,hEntity&gt; *el, hEntity pt)
{
    if(pt.v == 0) return;
    Group *src = SK.GetGroup(opA);
    Vector n = src-&gt;polyLoops.normal;

    // When there is no loop normal (e.g. if the loop is broken), use normal of workplane
    // as fallback, to avoid breaking constraints depending on the faces.
    if(n.Equals(Vector::From(0.0, 0.0, 0.0)) &amp;&amp; src-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        n = SK.GetEntity(src-&gt;h.entity(0))-&gt;Normal()-&gt;NormalN();
    }

    Entity en = {};
    en.type = Entity::Type::FACE_NORMAL_PT;
    en.group = h;

    en.numNormal = Quaternion::From(0, n.x, n.y, n.z);
    en.point[0] = Remap(pt, REMAP_TOP);
    en.h = Remap(Entity::NO_ENTITY, REMAP_TOP);
    el-&gt;Add(&amp;en);

    en.point[0] = Remap(pt, REMAP_BOTTOM);
    en.h = Remap(Entity::NO_ENTITY, REMAP_BOTTOM);
    el-&gt;Add(&amp;en);
}

</t>
<t tx="leo1.20171224221223.39">void Group::CopyEntity(IdList&lt;Entity,hEntity&gt; *el,
                       Entity *ep, int timesApplied, int remap,
                       hParam dx, hParam dy, hParam dz,
                       hParam qw, hParam qvx, hParam qvy, hParam qvz,
                       CopyAs as)
{
    Entity en = {};
    en.type = ep-&gt;type;
    en.extraPoints = ep-&gt;extraPoints;
    en.h = Remap(ep-&gt;h, remap);
    en.timesApplied = timesApplied;
    en.group = h;
    en.construction = ep-&gt;construction;
    en.style = ep-&gt;style;
    en.str = ep-&gt;str;
    en.font = ep-&gt;font;
    en.file = ep-&gt;file;

    switch(ep-&gt;type) {
        case Entity::Type::WORKPLANE:
            // Don't copy these.
            return;

        case Entity::Type::POINT_N_COPY:
        case Entity::Type::POINT_N_TRANS:
        case Entity::Type::POINT_N_ROT_TRANS:
        case Entity::Type::POINT_N_ROT_AA:
        case Entity::Type::POINT_IN_3D:
        case Entity::Type::POINT_IN_2D:
            if(as == CopyAs::N_TRANS) {
                en.type = Entity::Type::POINT_N_TRANS;
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
            } else if(as == CopyAs::NUMERIC) {
                en.type = Entity::Type::POINT_N_COPY;
            } else {
                if(as == CopyAs::N_ROT_AA) {
                    en.type = Entity::Type::POINT_N_ROT_AA;
                } else {
                    en.type = Entity::Type::POINT_N_ROT_TRANS;
                }
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
                en.param[3] = qw;
                en.param[4] = qvx;
                en.param[5] = qvy;
                en.param[6] = qvz;
            }
            en.numPoint = (ep-&gt;actPoint).ScaledBy(scale);
            break;

        case Entity::Type::NORMAL_N_COPY:
        case Entity::Type::NORMAL_N_ROT:
        case Entity::Type::NORMAL_N_ROT_AA:
        case Entity::Type::NORMAL_IN_3D:
        case Entity::Type::NORMAL_IN_2D:
            if(as == CopyAs::N_TRANS || as == CopyAs::NUMERIC) {
                en.type = Entity::Type::NORMAL_N_COPY;
            } else {
                if(as == CopyAs::N_ROT_AA) {
                    en.type = Entity::Type::NORMAL_N_ROT_AA;
                } else {
                    en.type = Entity::Type::NORMAL_N_ROT;
                }
                en.param[0] = qw;
                en.param[1] = qvx;
                en.param[2] = qvy;
                en.param[3] = qvz;
            }
            en.numNormal = ep-&gt;actNormal;
            if(scale &lt; 0) en.numNormal = en.numNormal.Mirror();

            en.point[0] = Remap(ep-&gt;point[0], remap);
            break;

        case Entity::Type::DISTANCE_N_COPY:
        case Entity::Type::DISTANCE:
            en.type = Entity::Type::DISTANCE_N_COPY;
            en.numDistance = ep-&gt;actDistance*fabs(scale);
            break;

        case Entity::Type::FACE_NORMAL_PT:
        case Entity::Type::FACE_XPROD:
        case Entity::Type::FACE_N_ROT_TRANS:
        case Entity::Type::FACE_N_TRANS:
        case Entity::Type::FACE_N_ROT_AA:
            if(as == CopyAs::N_TRANS) {
                en.type = Entity::Type::FACE_N_TRANS;
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
            } else if (as == CopyAs::NUMERIC) {
                en.type = Entity::Type::FACE_NORMAL_PT;
            } else {
                if(as == CopyAs::N_ROT_AA) {
                    en.type = Entity::Type::FACE_N_ROT_AA;
                } else {
                    en.type = Entity::Type::FACE_N_ROT_TRANS;
                }
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
                en.param[3] = qw;
                en.param[4] = qvx;
                en.param[5] = qvy;
                en.param[6] = qvz;
            }
            en.numPoint  = (ep-&gt;actPoint).ScaledBy(scale);
            en.numNormal = (ep-&gt;actNormal).ScaledBy(scale);
            break;

        default: {
            int i, points;
            bool hasNormal, hasDistance;
            EntReqTable::GetEntityInfo(ep-&gt;type, ep-&gt;extraPoints,
                NULL, &amp;points, &amp;hasNormal, &amp;hasDistance);
            for(i = 0; i &lt; points; i++) {
                en.point[i] = Remap(ep-&gt;point[i], remap);
            }
            if(hasNormal)   en.normal   = Remap(ep-&gt;normal, remap);
            if(hasDistance) en.distance = Remap(ep-&gt;distance, remap);
            break;
        }
    }

    // If the entity came from an linked file where it was invisible then
    // ep-&gt;actiVisble will be false, and we should hide it. Or if the entity
    // came from a copy (e.g. step and repeat) of a force-hidden linked
    // entity, then we also want to hide it.
    en.forceHidden = (!ep-&gt;actVisible) || ep-&gt;forceHidden;

    el-&gt;Add(&amp;en);
}

</t>
<t tx="leo1.20171224221223.4">int32_t dt = (mp &lt; 0.01 &amp;&amp; mo &lt; 10) ? (-20) :
                 (int32_t)(100 + 1000*mp + 0.4*mo);
// Don't ever animate for longer than 2000 ms; we can get absurdly
// long translations (as measured in pixels) if the user zooms out, moves,
// and then zooms in again.
if(dt &gt; 2000) dt = 2000;
int64_t tn, t0 = GetMilliseconds();
double s = 0;
Quaternion dq = quatf.Times(quat0.Inverse());
do {
    offset = (offset0.ScaledBy(1 - s)).Plus(offsetf.ScaledBy(s));
    Quaternion quat = (dq.ToThe(s)).Times(quat0);
    quat = quat.WithMagnitude(1);

    projRight = quat.RotationU();
    projUp    = quat.RotationV();
    PaintGraphics();

    tn = GetMilliseconds();
    s = (tn - t0)/((double)dt);
} while((tn - t0) &lt; dt);

projRight = quatf.RotationU();
projUp = quatf.RotationV();
offset = offsetf;
InvalidateGraphics();
// If the view screen is open, then we need to refresh it.
SS.ScheduleShowTW();
</t>
<t tx="leo1.20171224221223.40">//-----------------------------------------------------------------------------
// Routines to generate our watertight brep shells from the operations
// and entities specified by the user in each group; templated to work either
// on an SShell of ratpoly surfaces or on an SMesh of triangles.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221223.5">void GraphicsWindow::HandlePointForZoomToFit(Vector p, Point2d *pmax, Point2d *pmin,
                                             double *wmin, bool usePerspective)
{
    double w;
    Vector pp = ProjectPoint4(p, &amp;w);
    // If usePerspective is true, then we calculate a perspective projection of the point.
    // If not, then we do a parallel projection regardless of the current
    // scale factor.
    if(usePerspective) {
        pp = pp.ScaledBy(1.0/w);
    }

    pmax-&gt;x = max(pmax-&gt;x, pp.x);
    pmax-&gt;y = max(pmax-&gt;y, pp.y);
    pmin-&gt;x = min(pmin-&gt;x, pp.x);
    pmin-&gt;y = min(pmin-&gt;y, pp.y);
    *wmin = min(*wmin, w);
}
</t>
<t tx="leo1.20171224221223.6">void GraphicsWindow::LoopOverPoints(const std::vector&lt;Entity *&gt; &amp;entities,
                                    const std::vector&lt;Constraint *&gt; &amp;constraints,
                                    const std::vector&lt;hEntity&gt; &amp;faces,
                                    Point2d *pmax, Point2d *pmin, double *wmin,
                                    bool usePerspective, bool includeMesh) {

    for(Entity *e : entities) {
        if(e-&gt;IsPoint()) {
            HandlePointForZoomToFit(e-&gt;PointGetNum(), pmax, pmin, wmin, usePerspective);
        } else if(e-&gt;type == Entity::Type::CIRCLE) {
            // Lots of entities can extend outside the bbox of their points,
            // but circles are particularly bad. We want to get things halfway
            // reasonable without the mesh, because a zoom to fit is used to
            // set the zoom level to set the chord tol.
            double r = e-&gt;CircleGetRadiusNum();
            Vector c = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(e-&gt;normal)-&gt;NormalGetNum();
            for(int j = 0; j &lt; 4; j++) {
                Vector p = (j == 0) ? (c.Plus(q.RotationU().ScaledBy( r))) :
                           (j == 1) ? (c.Plus(q.RotationU().ScaledBy(-r))) :
                           (j == 2) ? (c.Plus(q.RotationV().ScaledBy( r))) :
                                      (c.Plus(q.RotationV().ScaledBy(-r)));
                HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective);
            }
        } else {
            // We have to iterate children points, because we can select entites without points
            for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
                if(e-&gt;point[i].v == 0) break;
                Vector p = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
                HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective);
            }
        }
    }

    for(Constraint *c : constraints) {
        std::vector&lt;Vector&gt; refs;
        c-&gt;GetReferencePoints(GetCamera(), &amp;refs);
        for(Vector p : refs) {
            HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective);
        }
    }

    if(!includeMesh &amp;&amp; faces.empty()) return;

    Group *g = SK.GetGroup(activeGroup);
    g-&gt;GenerateDisplayItems();
    for(int i = 0; i &lt; g-&gt;displayMesh.l.n; i++) {
        STriangle *tr = &amp;(g-&gt;displayMesh.l.elem[i]);
        if(!includeMesh) {
            bool found = false;
            for(const hEntity &amp;face : faces) {
                if(face.v != tr-&gt;meta.face) continue;
                found = true;
                break;
            }
            if(!found) continue;
        }
        HandlePointForZoomToFit(tr-&gt;a, pmax, pmin, wmin, usePerspective);
        HandlePointForZoomToFit(tr-&gt;b, pmax, pmin, wmin, usePerspective);
        HandlePointForZoomToFit(tr-&gt;c, pmax, pmin, wmin, usePerspective);
    }
    if(!includeMesh) return;
    for(int i = 0; i &lt; g-&gt;polyLoops.l.n; i++) {
        SContour *sc = &amp;(g-&gt;polyLoops.l.elem[i]);
        for(int j = 0; j &lt; sc-&gt;l.n; j++) {
            HandlePointForZoomToFit(sc-&gt;l.elem[j].p, pmax, pmin, wmin, usePerspective);
        }
    }
}
</t>
<t tx="leo1.20171224221223.7">void GraphicsWindow::ZoomToFit(bool includingInvisibles, bool useSelection) {
    std::vector&lt;Entity *&gt; entities;
    std::vector&lt;Constraint *&gt; constraints;
    std::vector&lt;hEntity&gt; faces;

    if(useSelection) {
        for(int i = 0; i &lt; selection.n; i++) {
            Selection *s = &amp;selection.elem[i];
            if(s-&gt;entity.v != 0) {
                Entity *e = SK.entity.FindById(s-&gt;entity);
                if(e-&gt;IsFace()) {
                    faces.push_back(e-&gt;h);
                    continue;
                }
                entities.push_back(e);
            }
            if(s-&gt;constraint.v != 0) {
                Constraint *c = SK.constraint.FindById(s-&gt;constraint);
                constraints.push_back(c);
            }
        }
    }

    bool selectionUsed = !entities.empty() || !constraints.empty() || !faces.empty();

    if(!selectionUsed) {
        for(Entity &amp;e : SK.entity) {
            // we don't want to handle separate points, because we will iterate them inside entities.
            if(e.IsPoint()) continue;
            if(!includingInvisibles &amp;&amp; !e.IsVisible()) continue;
            entities.push_back(&amp;e);
        }

        for(Constraint &amp;c : SK.constraint) {
            if(!c.IsVisible()) continue;
            constraints.push_back(&amp;c);
        }
    }

    // On the first run, ignore perspective.
    Point2d pmax = { -1e12, -1e12 }, pmin = { 1e12, 1e12 };
    double wmin = 1;
    LoopOverPoints(entities, constraints, faces, &amp;pmax, &amp;pmin, &amp;wmin,
                   /*usePerspective=*/false, /*includeMesh=*/!selectionUsed);

    double xm = (pmax.x + pmin.x)/2, ym = (pmax.y + pmin.y)/2;
    double dx = pmax.x - pmin.x, dy = pmax.y - pmin.y;

    offset = offset.Plus(projRight.ScaledBy(-xm)).Plus(
                         projUp.   ScaledBy(-ym));

    // And based on this, we calculate the scale and offset
    if(EXACT(dx == 0 &amp;&amp; dy == 0)) {
        scale = 5;
    } else {
        double scalex = 1e12, scaley = 1e12;
        if(EXACT(dx != 0)) scalex = 0.9*width /dx;
        if(EXACT(dy != 0)) scaley = 0.9*height/dy;
        scale = min(scalex, scaley);

        scale = min(300.0, scale);
        scale = max(0.003, scale);
    }

    // Then do another run, considering the perspective.
    pmax.x = -1e12; pmax.y = -1e12;
    pmin.x =  1e12; pmin.y =  1e12;
    wmin = 1;
    LoopOverPoints(entities, constraints, faces, &amp;pmax, &amp;pmin, &amp;wmin,
                   /*usePerspective=*/true, /*includeMesh=*/!selectionUsed);

    // Adjust the scale so that no points are behind the camera
    if(wmin &lt; 0.1) {
        double k = SS.CameraTangent();
        // w = 1+k*scale*z
        double zmin = (wmin - 1)/(k*scale);
        // 0.1 = 1 + k*scale*zmin
        // (0.1 - 1)/(k*zmin) = scale
        scale = min(scale, (0.1 - 1)/(k*zmin));
    }
}

</t>
<t tx="leo1.20171224221223.8">void GraphicsWindow::MenuView(Command id) {
    switch(id) {
        case Command::ZOOM_IN:
            SS.GW.scale *= 1.2;
            SS.ScheduleShowTW();
            break;

        case Command::ZOOM_OUT:
            SS.GW.scale /= 1.2;
            SS.ScheduleShowTW();
            break;

        case Command::ZOOM_TO_FIT:
            SS.GW.ZoomToFit(/*includingInvisibles=*/false, /*useSelection=*/true);
            SS.ScheduleShowTW();
            break;

        case Command::SHOW_GRID:
            SS.GW.showSnapGrid = !SS.GW.showSnapGrid;
            if(SS.GW.showSnapGrid &amp;&amp; !SS.GW.LockedInWorkplane()) {
                Message(_("No workplane is active, so the grid will not appear."));
            }
            SS.GW.EnsureValidActives();
            InvalidateGraphics();
            break;

        case Command::PERSPECTIVE_PROJ:
            SS.usePerspectiveProj = !SS.usePerspectiveProj;
            if(SS.cameraTangent &lt; 1e-6) {
                Error(_("The perspective factor is set to zero, so the view will "
                        "always be a parallel projection.\n\n"
                        "For a perspective projection, modify the perspective "
                        "factor in the configuration screen. A value around 0.3 "
                        "is typical."));
            }
            SS.GW.EnsureValidActives();
            InvalidateGraphics();
            break;

        case Command::ONTO_WORKPLANE:
            if(SS.GW.LockedInWorkplane()) {
                SS.GW.AnimateOntoWorkplane();
                SS.ScheduleShowTW();
                break;
            }  // if not in 2d mode fall through and use ORTHO logic
        case Command::NEAREST_ORTHO:
        case Command::NEAREST_ISO: {
            @others
}

</t>
<t tx="leo1.20171224221223.9">static const Vector ortho[3] = {
    Vector::From(1, 0, 0),
    Vector::From(0, 1, 0),
    Vector::From(0, 0, 1)
};
double sqrt2 = sqrt(2.0), sqrt6 = sqrt(6.0);
Quaternion quat0 = Quaternion::From(SS.GW.projRight, SS.GW.projUp);
Quaternion quatf = quat0;
double dmin = 1e10;

// There are 24 possible views; 3*2*2*2
int i, j, negi, negj;
for(i = 0; i &lt; 3; i++) {
    for(j = 0; j &lt; 3; j++) {
        if(i == j) continue;
        for(negi = 0; negi &lt; 2; negi++) {
            for(negj = 0; negj &lt; 2; negj++) {
                Vector ou = ortho[i], ov = ortho[j];
                if(negi) ou = ou.ScaledBy(-1);
                if(negj) ov = ov.ScaledBy(-1);
                Vector on = ou.Cross(ov);

                Vector u, v;
                if(id == Command::NEAREST_ORTHO || id == Command::ONTO_WORKPLANE) {
                    u = ou;
                    v = ov;
                } else {
                    u =
                        ou.ScaledBy(1/sqrt2).Plus(
                        on.ScaledBy(-1/sqrt2));
                    v =
                        ou.ScaledBy(-1/sqrt6).Plus(
                        ov.ScaledBy(2/sqrt6).Plus(
                        on.ScaledBy(-1/sqrt6)));
                }

                Quaternion quatt = Quaternion::From(u, v);
</t>
<t tx="leo1.20171224221224.1">void Group::AssembleLoops(bool *allClosed,
                          bool *allCoplanar,
                          bool *allNonZeroLen)
{
    SBezierList sbl = {};

    int i;
    for(i = 0; i &lt; SK.entity.n; i++) {
        Entity *e = &amp;(SK.entity.elem[i]);
        if(e-&gt;group.v != h.v) continue;
        if(e-&gt;construction) continue;
        if(e-&gt;forceHidden) continue;

        e-&gt;GenerateBezierCurves(&amp;sbl);
    }

    SBezier *sb;
    *allNonZeroLen = true;
    for(sb = sbl.l.First(); sb; sb = sbl.l.NextAfter(sb)) {
        for(i = 1; i &lt;= sb-&gt;deg; i++) {
            if(!(sb-&gt;ctrl[i]).Equals(sb-&gt;ctrl[0])) {
                break;
            }
        }
        if(i &gt; sb-&gt;deg) {
            // This is a zero-length edge.
            *allNonZeroLen = false;
            polyError.errorPointAt = sb-&gt;ctrl[0];
            goto done;
        }
    }

    // Try to assemble all these Beziers into loops. The closed loops go into
    // bezierLoops, with the outer loops grouped with their holes. The
    // leftovers, if any, go in bezierOpens.
    bezierLoops.FindOuterFacesFrom(&amp;sbl, &amp;polyLoops, NULL,
                                   SS.ChordTolMm(),
                                   allClosed, &amp;(polyError.notClosedAt),
                                   allCoplanar, &amp;(polyError.errorPointAt),
                                   &amp;bezierOpens);
    done:
    sbl.Clear();
}

</t>
<t tx="leo1.20171224221224.10">void Group::DrawMesh(DrawMeshAs how, Canvas *canvas) {
    if(!(SS.GW.showShaded ||
         SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::VISIBLE)) return;

    switch(how) {
        case DrawMeshAs::DEFAULT: {
            // Force the shade color to something dim to not distract from
            // the sketch.
            Canvas::Fill fillFront = {};
            if(!SS.GW.showShaded) {
                fillFront.layer = Canvas::Layer::DEPTH_ONLY;
            }
            if(type == Type::DRAWING_3D || type == Type::DRAWING_WORKPLANE) {
                fillFront.color = Style::Color(Style::DIM_SOLID);
            }
            Canvas::hFill hcfFront = canvas-&gt;GetFill(fillFront);

            // The back faces are drawn in red; should never seem them, since we
            // draw closed shells, so that's a debugging aid.
            Canvas::hFill hcfBack = {};
            if(SS.drawBackFaces &amp;&amp; !displayMesh.isTransparent) {
                Canvas::Fill fillBack = {};
                fillBack.layer = fillFront.layer;
                fillBack.color = RgbaColor::FromFloat(1.0f, 0.1f, 0.1f);
                hcfBack = canvas-&gt;GetFill(fillBack);
            } else {
                hcfBack = hcfFront;
            }

            // Draw the shaded solid into the depth buffer for hidden line removal,
            // and if we're actually going to display it, to the color buffer too.
            canvas-&gt;DrawMesh(displayMesh, hcfFront, hcfBack);

            // Draw mesh edges, for debugging.
            if(SS.GW.showMesh) {
                Canvas::Stroke strokeTriangle = {};
                strokeTriangle.zIndex = 1;
                strokeTriangle.color  = RgbaColor::FromFloat(0.0f, 1.0f, 0.0f);
                strokeTriangle.width  = 1;
                strokeTriangle.unit   = Canvas::Unit::PX;
                Canvas::hStroke hcsTriangle = canvas-&gt;GetStroke(strokeTriangle);
                SEdgeList edges = {};
                for(const STriangle &amp;t : displayMesh.l) {
                    edges.AddEdge(t.a, t.b);
                    edges.AddEdge(t.b, t.c);
                    edges.AddEdge(t.c, t.a);
                }
                canvas-&gt;DrawEdges(edges, hcsTriangle);
                edges.Clear();
            }
            break;
        }

        case DrawMeshAs::HOVERED: {
            Canvas::Fill fill = {};
            fill.color   = Style::Color(Style::HOVERED);
            fill.pattern = Canvas::FillPattern::CHECKERED_A;
            fill.zIndex  = 2;
            Canvas::hFill hcf = canvas-&gt;GetFill(fill);

            std::vector&lt;uint32_t&gt; faces;
            hEntity he = SS.GW.hover.entity;
            if(he.v != 0 &amp;&amp; SK.GetEntity(he)-&gt;IsFace()) {
                faces.push_back(he.v);
            }
            canvas-&gt;DrawFaces(displayMesh, faces, hcf);
            break;
        }

        case DrawMeshAs::SELECTED: {
            Canvas::Fill fill = {};
            fill.color   = Style::Color(Style::SELECTED);
            fill.pattern = Canvas::FillPattern::CHECKERED_B;
            fill.zIndex  = 1;
            Canvas::hFill hcf = canvas-&gt;GetFill(fill);

            std::vector&lt;uint32_t&gt; faces;
            SS.GW.GroupSelection();
            auto const &amp;gs = SS.GW.gs;
            if(gs.faces &gt; 0) faces.push_back(gs.face[0].v);
            if(gs.faces &gt; 1) faces.push_back(gs.face[1].v);
            canvas-&gt;DrawFaces(displayMesh, faces, hcf);
            break;
        }
    }
}

</t>
<t tx="leo1.20171224221224.100">void SKdNode::AddTriangle(STriangle *tr) {
    if(gt &amp;&amp; lt) {
        @others
}

</t>
<t tx="leo1.20171224221224.101">    double ta = (tr-&gt;a).Element(which),
           tb = (tr-&gt;b).Element(which),
           tc = (tr-&gt;c).Element(which);
    if(ta &lt; c + KDTREE_EPS ||
       tb &lt; c + KDTREE_EPS ||
       tc &lt; c + KDTREE_EPS)
    {
        lt-&gt;AddTriangle(tr);
    }
    if(ta &gt; c - KDTREE_EPS ||
       tb &gt; c - KDTREE_EPS ||
       tc &gt; c - KDTREE_EPS)
    {
        gt-&gt;AddTriangle(tr);
    }
} else {
    STriangleLl *tn = STriangleLl::Alloc();
    tn-&gt;tri = tr;
    tn-&gt;next = tris;
    tris = tn;
}
</t>
<t tx="leo1.20171224221224.102">void SKdNode::MakeMeshInto(SMesh *m) const {
    if(gt) gt-&gt;MakeMeshInto(m);
    if(lt) lt-&gt;MakeMeshInto(m);

    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        if(ll-&gt;tri-&gt;tag) continue;

        m-&gt;AddTriangle(ll-&gt;tri);
        ll-&gt;tri-&gt;tag = 1;
    }
}

</t>
<t tx="leo1.20171224221224.103">void SKdNode::ListTrianglesInto(std::vector&lt;STriangle *&gt; *tl) const {
    if(gt) gt-&gt;ListTrianglesInto(tl);
    if(lt) lt-&gt;ListTrianglesInto(tl);

    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        if(ll-&gt;tri-&gt;tag) continue;

        tl-&gt;push_back(ll-&gt;tri);
        ll-&gt;tri-&gt;tag = 1;
    }
}

//-----------------------------------------------------------------------------
// If any triangles in the mesh have an edge that goes through v (but not
// a vertex at v), then split those triangles so that they now have a vertex
// there. The existing triangle is modified, and the new triangle appears
// in extras.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.104">void SKdNode::SnapToVertex(Vector v, SMesh *extras) {
    if(gt &amp;&amp; lt) {
        double vc = v.Element(which);
        if(vc &lt; c + KDTREE_EPS) {
            lt-&gt;SnapToVertex(v, extras);
        }
        if(vc &gt; c - KDTREE_EPS) {
            gt-&gt;SnapToVertex(v, extras);
        }
        // Nothing bad happens if the triangle to be split appears in both
        // branches; the first call will split the triangle, so that the
        // second call will do nothing, because the modified triangle will
        // already contain v
    } else {
        STriangleLl *ll;
        for(ll = tris; ll; ll = ll-&gt;next) {
            STriangle *tr = ll-&gt;tri;

            // Do a cheap bbox test first
            int k;
            bool mightHit = true;

            for(k = 0; k &lt; 3; k++) {
                if((tr-&gt;a).Element(k) &lt; v.Element(k) - KDTREE_EPS &amp;&amp;
                   (tr-&gt;b).Element(k) &lt; v.Element(k) - KDTREE_EPS &amp;&amp;
                   (tr-&gt;c).Element(k) &lt; v.Element(k) - KDTREE_EPS)
                {
                    mightHit = false;
                    break;
                }
                if((tr-&gt;a).Element(k) &gt; v.Element(k) + KDTREE_EPS &amp;&amp;
                   (tr-&gt;b).Element(k) &gt; v.Element(k) + KDTREE_EPS &amp;&amp;
                   (tr-&gt;c).Element(k) &gt; v.Element(k) + KDTREE_EPS)
                {
                    mightHit = false;
                    break;
                }
            }
            if(!mightHit) continue;

            if(tr-&gt;a.Equals(v)) { tr-&gt;a = v; continue; }
            if(tr-&gt;b.Equals(v)) { tr-&gt;b = v; continue; }
            if(tr-&gt;c.Equals(v)) { tr-&gt;c = v; continue; }

            if(v.OnLineSegment(tr-&gt;a, tr-&gt;b)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;a, v, tr-&gt;c);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;a = v;
                continue;
            }
            if(v.OnLineSegment(tr-&gt;b, tr-&gt;c)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;b, v, tr-&gt;a);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;b = v;
                continue;
            }
            if(v.OnLineSegment(tr-&gt;c, tr-&gt;a)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;c, v, tr-&gt;b);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;c = v;
                continue;
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Snap to each vertex of each triangle of the given mesh. If the given mesh
// is identical to the mesh used to make this kd tree, then the result should
// be a vertex-to-vertex mesh.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.105">void SKdNode::SnapToMesh(SMesh *m) {
    int i, j, k;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangle *tr = &amp;(m-&gt;l.elem[i]);
        for(j = 0; j &lt; 3; j++) {
            Vector v = tr-&gt;vertices[j];

            SMesh extra = {};
            SnapToVertex(v, &amp;extra);

            for(k = 0; k &lt; extra.l.n; k++) {
                STriangle *tra = (STriangle *)AllocTemporary(sizeof(*tra));
                *tra = extra.l.elem[k];
                AddTriangle(tra);
            }
            extra.Clear();
        }
    }
}

//-----------------------------------------------------------------------------
// For all the edges in sel, split them against the given triangle, and test
// them for occlusion. sel is both our input and our output. tag indicates
// whether an edge is occluded.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.106">void SKdNode::SplitLinesAgainstTriangle(SEdgeList *sel, STriangle *tr) const {
    SEdgeList seln = {};

    Vector tn = tr-&gt;Normal().WithMagnitude(1);
    double td = tn.Dot(tr-&gt;a);

    // Consider front-facing triangles only.
    if(tn.z &gt; LENGTH_EPS) {
        // If the edge crosses our triangle's plane, then split into above
        // and below parts. Note that we must preserve auxA, which contains
        // the style associated with this line, as well as the tag, which
        // contains the occlusion status.
        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            @others
}

//-----------------------------------------------------------------------------
// Given an edge orig, occlusion test it against our mesh. We output an edge
// list in sel, where only invisible portions of the edge are tagged.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.107">    double da = (se-&gt;a).Dot(tn) - td,
           db = (se-&gt;b).Dot(tn) - td;
    if((da &lt; -LENGTH_EPS &amp;&amp; db &gt; LENGTH_EPS) ||
       (db &lt; -LENGTH_EPS &amp;&amp; da &gt; LENGTH_EPS))
    {
        Vector m = Vector::AtIntersectionOfPlaneAndLine(
                                tn, td,
                                se-&gt;a, se-&gt;b, NULL);
        seln.AddEdge(m, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
        se-&gt;b = m;
    }
}
for(se = seln.l.First(); se; se = seln.l.NextAfter(se)) {
    sel-&gt;AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
}
seln.Clear();

for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
    Vector pt = ((se-&gt;a).Plus(se-&gt;b)).ScaledBy(0.5);
    if(pt.Dot(tn) - td &gt; -LENGTH_EPS) {
        // Edge is in front of or on our plane (remember, tn.z &gt; 0)
        // so it is exempt from further splitting
        se-&gt;auxB = 1;
    } else {
        // Edge is behind our plane, needs further splitting
        se-&gt;auxB = 0;
    }
}

// Considering only the (x, y) coordinates, split the edge against our
// triangle.
Point2d a = (tr-&gt;a).ProjectXy(),
        b = (tr-&gt;b).ProjectXy(),
        c = (tr-&gt;c).ProjectXy();

Point2d n[3] = { (b.Minus(a)).Normal().WithMagnitude(1),
                 (c.Minus(b)).Normal().WithMagnitude(1),
                 (a.Minus(c)).Normal().WithMagnitude(1)  };

</t>
<t tx="leo1.20171224221224.108">double d[3] = { n[0].Dot(b),
                n[1].Dot(c),
                n[2].Dot(a)  };

// Split all of the edges where they intersect the triangle edges
int i;
for(i = 0; i &lt; 3; i++) {
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        if(se-&gt;auxB) continue;

        Point2d ap = (se-&gt;a).ProjectXy(),
                bp = (se-&gt;b).ProjectXy();
</t>
<t tx="leo1.20171224221224.109">            double da = n[i].Dot(ap) - d[i],
                   db = n[i].Dot(bp) - d[i];
            if((da &lt; -LENGTH_EPS &amp;&amp; db &gt; LENGTH_EPS) ||
               (db &lt; -LENGTH_EPS &amp;&amp; da &gt; LENGTH_EPS))
            {
                double dab = (db - da);
                Vector spl = ((se-&gt;a).ScaledBy( db/dab)).Plus(
                              (se-&gt;b).ScaledBy(-da/dab));
                seln.AddEdge(spl, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
                se-&gt;b = spl;
            }
        }
        for(se = seln.l.First(); se; se = seln.l.NextAfter(se)) {
            // The split pieces are all behind the triangle, since only
            // edges behind the triangle got split. So their auxB is 0.
            sel-&gt;AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
        }
        seln.Clear();
    }

    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        bool occluded;
        if(se-&gt;auxB) {
            // Lies above or on the triangle plane, so triangle doesn't
            // occlude it.
            occluded = false;
        } else {
            // Test the segment to see if it lies outside the triangle
            // (i.e., outside wrt at least one edge), and keep it only
            // then.
            Point2d pt = ((se-&gt;a).Plus(se-&gt;b).ScaledBy(0.5)).ProjectXy();
            occluded = true;
            for(i = 0; i &lt; 3; i++) {
                // If the test point lies on the boundary of our triangle,
                // then we still discard the edge.
                if(n[i].Dot(pt) - d[i] &gt; LENGTH_EPS) occluded = false;
            }
        }

        if(occluded) {
            se-&gt;tag = 1;
        }
    }
}
</t>
<t tx="leo1.20171224221224.11">void Group::Draw(Canvas *canvas) {
    // Everything here gets drawn whether or not the group is hidden; we
    // can control this stuff independently, with show/hide solids, edges,
    // mesh, etc.

    GenerateDisplayItems();
    DrawMesh(DrawMeshAs::DEFAULT, canvas);

    if(SS.GW.showEdges) {
        Canvas::Stroke strokeEdge = Style::Stroke(Style::SOLID_EDGE);
        strokeEdge.zIndex = 1;
        Canvas::hStroke hcsEdge = canvas-&gt;GetStroke(strokeEdge);

        canvas-&gt;DrawOutlines(displayOutlines, hcsEdge,
                             SS.GW.showOutlines
                             ? Canvas::DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR
                             : Canvas::DrawOutlinesAs::EMPHASIZED_AND_CONTOUR);

        if(SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::INVISIBLE) {
            Canvas::Stroke strokeHidden = Style::Stroke(Style::HIDDEN_EDGE);
            if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::VISIBLE) {
                strokeHidden.stipplePattern = StipplePattern::CONTINUOUS;
            }
            strokeHidden.layer  = Canvas::Layer::OCCLUDED;
            Canvas::hStroke hcsHidden = canvas-&gt;GetStroke(strokeHidden);

            canvas-&gt;DrawOutlines(displayOutlines, hcsHidden,
                                 Canvas::DrawOutlinesAs::EMPHASIZED_AND_CONTOUR);
        }
    }

    if(SS.GW.showOutlines) {
        Canvas::Stroke strokeOutline = Style::Stroke(Style::OUTLINE);
        strokeOutline.zIndex = 1;
        Canvas::hStroke hcsOutline = canvas-&gt;GetStroke(strokeOutline);

        canvas-&gt;DrawOutlines(displayOutlines, hcsOutline,
                             Canvas::DrawOutlinesAs::CONTOUR_ONLY);
    }
}

</t>
<t tx="leo1.20171224221224.110">void SKdNode::OcclusionTestLine(SEdge orig, SEdgeList *sel, int cnt) const {
    if(gt &amp;&amp; lt) {
        @others
}

//-----------------------------------------------------------------------------
// Search the mesh for a triangle with an edge from b to a (i.e., the mate
// for the edge from a to b), and increment info-&gt;count each time that we
// find one. If a triangle is found, then report whether it is front- or
// back-facing using info-&gt;frontFacing. And regardless of whether a mate is
// found, report whether the edge intersects the mesh with info-&gt;intersectsMesh;
// if coplanarIsInter then we count the edge as intersecting if it's coplanar
// with a triangle in the mesh, otherwise not.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.111">    double ac = (orig.a).Element(which),
           bc = (orig.b).Element(which);
    // We can ignore triangles that are separated in x or y, but triangles
    // that are separated in z may still contribute
    if(ac &lt; c + KDTREE_EPS ||
       bc &lt; c + KDTREE_EPS ||
       which == 2)
    {
        lt-&gt;OcclusionTestLine(orig, sel, cnt);
    }
    if(ac &gt; c - KDTREE_EPS ||
       bc &gt; c - KDTREE_EPS ||
       which == 2)
    {
        gt-&gt;OcclusionTestLine(orig, sel, cnt);
    }
} else {
    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        STriangle *tr = ll-&gt;tri;

        if(tr-&gt;tag == cnt) continue;

        SplitLinesAgainstTriangle(sel, tr);
        tr-&gt;tag = cnt;
    }
}
</t>
<t tx="leo1.20171224221224.112">void SKdNode::FindEdgeOn(Vector a, Vector b, int cnt, bool coplanarIsInter,
                         EdgeOnInfo *info) const
{
    if(gt &amp;&amp; lt) {
        @others
}

</t>
<t tx="leo1.20171224221224.113">    double ac = a.Element(which),
           bc = b.Element(which);
    if(ac &lt; c + KDTREE_EPS ||
       bc &lt; c + KDTREE_EPS)
    {
        lt-&gt;FindEdgeOn(a, b, cnt, coplanarIsInter, info);
    }
    if(ac &gt; c - KDTREE_EPS ||
       bc &gt; c - KDTREE_EPS)
    {
        gt-&gt;FindEdgeOn(a, b, cnt, coplanarIsInter, info);
    }
    return;
}

// We are a leaf node; so we iterate over all the triangles in our
// linked list.
STriangleLl *ll;
for(ll = tris; ll; ll = ll-&gt;next) {
    STriangle *tr = ll-&gt;tri;

    if(tr-&gt;tag == cnt) continue;

    // Test if this triangle matches up with the given edge
    if((a.Equals(tr-&gt;b) &amp;&amp; b.Equals(tr-&gt;a)) ||
       (a.Equals(tr-&gt;c) &amp;&amp; b.Equals(tr-&gt;b)) ||
       (a.Equals(tr-&gt;a) &amp;&amp; b.Equals(tr-&gt;c)))
    {
        info-&gt;count++;
        // Record whether this triangle is front- or back-facing.
        if(tr-&gt;Normal().z &gt; LENGTH_EPS) {
            info-&gt;frontFacing = true;
        } else {
            info-&gt;frontFacing = false;
        }
        // Record the triangle
        info-&gt;tr = tr;
        // And record which vertexes a and b correspond to
        info-&gt;ai = a.Equals(tr-&gt;a) ? 0 : (a.Equals(tr-&gt;b) ? 1 : 2);
        info-&gt;bi = b.Equals(tr-&gt;a) ? 0 : (b.Equals(tr-&gt;b) ? 1 : 2);
    } else if(((a.Equals(tr-&gt;a) &amp;&amp; b.Equals(tr-&gt;b)) ||
               (a.Equals(tr-&gt;b) &amp;&amp; b.Equals(tr-&gt;c)) ||
               (a.Equals(tr-&gt;c) &amp;&amp; b.Equals(tr-&gt;a))))
    {
        // It's an edge of this triangle, okay.
    } else {
        // Check for self-intersection
        Vector n = (tr-&gt;Normal()).WithMagnitude(1);
        double d = (tr-&gt;a).Dot(n);
        double pa = a.Dot(n) - d, pb = b.Dot(n) - d;
        // It's an intersection if neither point lies in-plane,
        // and the edge crosses the plane (should handle in-plane
        // intersections separately but don't yet).
        if((pa &lt; -LENGTH_EPS || pa &gt; LENGTH_EPS) &amp;&amp;
           (pb &lt; -LENGTH_EPS || pb &gt; LENGTH_EPS) &amp;&amp;
           (pa*pb &lt; 0))
        {
            // The edge crosses the plane of the triangle; now see if
            // it crosses inside the triangle.
            if(tr-&gt;ContainsPointProjd(b.Minus(a), a)) {
                if(coplanarIsInter) {
                    info-&gt;intersectsMesh = true;
                } else {
                    Vector p = Vector::AtIntersectionOfPlaneAndLine(
                                            n, d, a, b, NULL);
                    Vector ta = tr-&gt;a,
                           tb = tr-&gt;b,
                           tc = tr-&gt;c;
                    if((p.DistanceToLine(ta, tb.Minus(ta)) &lt; LENGTH_EPS) ||
                       (p.DistanceToLine(tb, tc.Minus(tb)) &lt; LENGTH_EPS) ||
                       (p.DistanceToLine(tc, ta.Minus(tc)) &lt; LENGTH_EPS))
                    {
                        // Intersection lies on edge. This happens when
                        // our edge is from a triangle coplanar with
                        // another triangle in the mesh. We don't test
                        // the edge against triangles whose plane contains
                        // that edge, but we do end up testing against
                        // the coplanar triangle's neighbours, which we
                        // will intersect on their edges.
                    } else {
                        info-&gt;intersectsMesh = true;
                    }
                }
            }
        }
    }

    // Ensure that we don't count this triangle twice if it appears
    // in two buckets of the kd tree.
    tr-&gt;tag = cnt;
}
</t>
<t tx="leo1.20171224221224.114">static bool CheckAndAddTrianglePair(std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; *pairs,
                                    STriangle *a, STriangle *b)
{
    if(pairs-&gt;find(std::make_pair(a, b)) != pairs-&gt;end() ||
       pairs-&gt;find(std::make_pair(b, a)) != pairs-&gt;end())
        return true;

    pairs-&gt;emplace(a, b);
    return false;
}

//-----------------------------------------------------------------------------
// Pick certain classes of edges out from our mesh. These might be:
//    * naked edges (i.e., edges with no anti-parallel neighbor) and self-
//      intersecting edges (i.e., edges that cross another triangle)
//    * turning edges (i.e., edges where a front-facing triangle joins
//      a back-facing triangle)
//    * emphasized edges (i.e., edges where a triangle from one face joins
//      a triangle from a different face)
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.115">void SKdNode::MakeCertainEdgesInto(SEdgeList *sel, EdgeKind how, bool coplanarIsInter,
                                   bool *inter, bool *leaky, int auxA) const
{
    if(inter) *inter = false;
    if(leaky) *leaky = false;

    std::vector&lt;STriangle *&gt; tris;
    ClearTags();
    ListTrianglesInto(&amp;tris);

    std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; edgeTris;
    int cnt = 1234;
    for(STriangle *tr : tris) {
        for(int j = 0; j &lt; 3; j++) {
            Vector a = tr-&gt;vertices[j];
            Vector b = tr-&gt;vertices[(j + 1) % 3];

            SKdNode::EdgeOnInfo info = {};
            FindEdgeOn(a, b, cnt, coplanarIsInter, &amp;info);

            switch(how) {
                case EdgeKind::NAKED_OR_SELF_INTER:
                    if(info.count != 1) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(leaky) *leaky = true;
                    }
                    if(info.intersectsMesh) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(inter) *inter = true;
                    }
                    break;

                case EdgeKind::SELF_INTER:
                    if(info.intersectsMesh) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(inter) *inter = true;
                    }
                    break;

                case EdgeKind::TURNING:
                    if((tr-&gt;Normal().z &lt; LENGTH_EPS) &amp;&amp;
                       (info.count == 1) &amp;&amp;
                       info.frontFacing)
                    {
                        if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                            break;
                        // This triangle is back-facing (or on edge), and
                        // this edge has exactly one mate, and that mate is
                        // front-facing. So this is a turning edge.
                        sel-&gt;AddEdge(a, b, auxA);
                    }
                    break;

                case EdgeKind::EMPHASIZED:
                    if(info.count == 1 &amp;&amp; tr-&gt;meta.face != info.tr-&gt;meta.face) {
                        if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                            break;
                        // The two triangles that join at this edge come from
                        // different faces; either really different faces,
                        // or one is from a face and the other is zero (i.e.,
                        // not from a face).
                        sel-&gt;AddEdge(a, b, auxA);
                    }
                    break;

                case EdgeKind::SHARP:
                    if(info.count == 1) {
                        Vector na0 = tr-&gt;normals[j].WithMagnitude(1.0);
                        Vector nb0 = tr-&gt;normals[(j + 1) % 3].WithMagnitude(1.0);
                        Vector na1 = info.tr-&gt;normals[info.ai].WithMagnitude(1.0);
                        Vector nb1 = info.tr-&gt;normals[info.bi].WithMagnitude(1.0);
                        if(!((na0.Equals(na1) &amp;&amp; nb0.Equals(nb1)) ||
                             (na0.Equals(nb1) &amp;&amp; nb0.Equals(na1)))) {
                            if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                                break;
                            // The two triangles that join at this edge meet at a sharp
                            // angle. This implies they come from different faces.
                            sel-&gt;AddEdge(a, b, auxA);
                        }
                    }
                    break;
            }

            cnt++;
        }
    }
}

</t>
<t tx="leo1.20171224221224.116">void SKdNode::MakeOutlinesInto(SOutlineList *sol, EdgeKind edgeKind) const
{
    std::vector&lt;STriangle *&gt; tris;
    ClearTags();
    ListTrianglesInto(&amp;tris);

    std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; edgeTris;
    int cnt = 1234;
    for(STriangle *tr : tris) {
        for(int j = 0; j &lt; 3; j++) {
            Vector a = tr-&gt;vertices[j];
            Vector b = tr-&gt;vertices[(j + 1) % 3];

            SKdNode::EdgeOnInfo info = {};
            FindEdgeOn(a, b, cnt, /*coplanarIsInter=*/false, &amp;info);
            cnt++;
            if(info.count != 1) continue;
            if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                continue;

            int tag = 0;
            switch(edgeKind) {
                case EdgeKind::EMPHASIZED:
                    if(tr-&gt;meta.face != info.tr-&gt;meta.face) {
                        tag = 1;
                    }
                    break;

                case EdgeKind::SHARP: {
                        Vector na0 = tr-&gt;normals[j].WithMagnitude(1.0);
                        Vector nb0 = tr-&gt;normals[(j + 1) % 3].WithMagnitude(1.0);
                        Vector na1 = info.tr-&gt;normals[info.ai].WithMagnitude(1.0);
                        Vector nb1 = info.tr-&gt;normals[info.bi].WithMagnitude(1.0);
                        if(!((na0.Equals(na1) &amp;&amp; nb0.Equals(nb1)) ||
                             (na0.Equals(nb1) &amp;&amp; nb0.Equals(na1)))) {
                            tag = 1;
                        }
                    }
                    break;

                default:
                    ssassert(false, "Unexpected edge kind");
            }

            Vector nl = tr-&gt;Normal().WithMagnitude(1.0);
            Vector nr = info.tr-&gt;Normal().WithMagnitude(1.0);

            // We don't add edges with the same left and right
            // normals because they can't produce outlines.
            if(tag == 0 &amp;&amp; nl.Equals(nr)) continue;
            sol-&gt;AddEdge(a, b, nl, nr, tag);
        }
    }
}

</t>
<t tx="leo1.20171224221224.117">bool SOutline::IsVisible(Vector projDir) const {
    double ldot = nl.Dot(projDir);
    double rdot = nr.Dot(projDir);
    return (ldot &gt; -LENGTH_EPS) == (rdot &lt; LENGTH_EPS) ||
           (rdot &gt; -LENGTH_EPS) == (ldot &lt; LENGTH_EPS);
}

</t>
<t tx="leo1.20171224221224.118">void SOutlineList::Clear() {
    l.Clear();
}

</t>
<t tx="leo1.20171224221224.119">void SOutlineList::AddEdge(Vector a, Vector b, Vector nl, Vector nr, int tag) {
    SOutline so = {};
    so.a   = a;
    so.b   = b;
    so.nl  = nl;
    so.nr  = nr;
    so.tag = tag;
    l.Add(&amp;so);
}

</t>
<t tx="leo1.20171224221224.12">void Group::DrawPolyError(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    Canvas::Stroke strokeUnclosed = Style::Stroke(Style::DRAW_ERROR);
    strokeUnclosed.color = strokeUnclosed.color.WithAlpha(50);
    Canvas::hStroke hcsUnclosed = canvas-&gt;GetStroke(strokeUnclosed);

    Canvas::Stroke strokeError = Style::Stroke(Style::DRAW_ERROR);
    strokeError.layer = Canvas::Layer::FRONT;
    strokeError.width = 1.0f;
    Canvas::hStroke hcsError = canvas-&gt;GetStroke(strokeError);

    double textHeight = Style::DefaultTextHeight() / camera.scale;

    // And finally show the polygons too, and any errors if it's not possible
    // to assemble the lines into closed polygons.
    if(polyError.how == PolyError::NOT_CLOSED) {
        // Report this error only in sketch-in-workplane groups; otherwise
        // it's just a nuisance.
        if(type == Type::DRAWING_WORKPLANE) {
            canvas-&gt;DrawVectorText(_("not closed contour, or not all same style!"),
                                   textHeight,
                                   polyError.notClosedAt.b, camera.projRight, camera.projUp,
                                   hcsError);
            canvas-&gt;DrawLine(polyError.notClosedAt.a, polyError.notClosedAt.b, hcsUnclosed);
        }
    } else if(polyError.how == PolyError::NOT_COPLANAR ||
              polyError.how == PolyError::SELF_INTERSECTING ||
              polyError.how == PolyError::ZERO_LEN_EDGE) {
        // These errors occur at points, not lines
        if(type == Type::DRAWING_WORKPLANE) {
            const char *msg;
            if(polyError.how == PolyError::NOT_COPLANAR) {
                msg = _("points not all coplanar!");
            } else if(polyError.how == PolyError::SELF_INTERSECTING) {
                msg = _("contour is self-intersecting!");
            } else {
                msg = _("zero-length edge!");
            }
            canvas-&gt;DrawVectorText(msg, textHeight,
                                   polyError.errorPointAt, camera.projRight, camera.projUp,
                                   hcsError);
        }
    } else {
        // The contours will get filled in DrawFilledPaths.
    }
}

</t>
<t tx="leo1.20171224221224.120">void SOutlineList::ListTaggedInto(SEdgeList *el, int auxA, int auxB) {
    for(const SOutline &amp;so : l) {
        if(so.tag == 0) continue;
        el-&gt;AddEdge(so.a, so.b, auxA, auxB);
    }
}

</t>
<t tx="leo1.20171224221224.121">void SOutlineList::MakeFromCopyOf(SOutlineList *sol) {
    for(SOutline *so = sol-&gt;l.First(); so; so = sol-&gt;l.NextAfter(so)) {
        l.Add(so);
    }
}

</t>
<t tx="leo1.20171224221224.122">void SMesh::PrecomputeTransparency() {
    std::sort(l.begin(), l.end(),
              [&amp;](const STriangle &amp;sta, const STriangle &amp;stb) {
        RgbaColor colora = sta.meta.color,
                  colorb = stb.meta.color;
        @others
</t>
<t tx="leo1.20171224221224.123">        bool opaquea = colora.IsEmpty() || colora.alpha == 255,
             opaqueb = colorb.IsEmpty() || colorb.alpha == 255;

        if(!opaquea || !opaqueb) isTransparent = true;
        return (opaquea != opaqueb &amp;&amp; opaquea == true);
    });
}

void SMesh::RemoveDegenerateTriangles() {
    for(auto &amp;tr : l) {
        bool isDegenerate = tr.a.OnLineSegment(tr.b, tr.c) ||
</t>
<t tx="leo1.20171224221224.124">//-----------------------------------------------------------------------------
// User-initiated (not parametric) operations to modify our sketch, by
// changing the requests, like to round a corner or split curves where they
// intersect.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

//-----------------------------------------------------------------------------
// Replace constraints on oldpt with the same constraints on newpt.
// Useful when splitting, tangent arcing, or removing bezier points.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221224.13">void Group::DrawFilledPaths(Canvas *canvas) {
    for(const SBezierLoopSet &amp;sbls : bezierLoops.l) {
        if(sbls.l.n == 0 || sbls.l.elem[0].l.n == 0) continue;

        // In an assembled loop, all the styles should be the same; so doesn't
        // matter which one we grab.
        SBezier *sb = &amp;(sbls.l.elem[0].l.elem[0]);
        Style *s = Style::Get({ (uint32_t)sb-&gt;auxA });

        Canvas::Fill fill = {};
        fill.zIndex = 1;
        if(s-&gt;filled) {
            // This is a filled loop, where the user specified a fill color.
            fill.color = s-&gt;fillColor;
        } else if(h.v == SS.GW.activeGroup.v &amp;&amp; SS.checkClosedContour &amp;&amp;
                    polyError.how == PolyError::GOOD) {
            // If this is the active group, and we are supposed to check
            // for closed contours, and we do indeed have a closed and
            // non-intersecting contour, then fill it dimly.
            fill.color = Style::Color(Style::CONTOUR_FILL).WithAlpha(127);
        } else continue;
        Canvas::hFill hcf = canvas-&gt;GetFill(fill);

        SPolygon sp = {};
        sbls.MakePwlInto(&amp;sp);
        canvas-&gt;DrawPolygon(sp, hcf);
        sp.Clear();
    }
}

</t>
<t tx="leo1.20171224221224.14">void Group::DrawContourAreaLabels(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Vector gr = camera.projRight.ScaledBy(1 / camera.scale);
    Vector gu = camera.projUp.ScaledBy(1 / camera.scale);

    for(SBezierLoopSet &amp;sbls : bezierLoops.l) {
        if(sbls.l.n == 0 || sbls.l.elem[0].l.n == 0) continue;

        Vector min = sbls.l.elem[0].l.elem[0].ctrl[0];
        Vector max = min;
        Vector zero = Vector::From(0.0, 0.0, 0.0);
        sbls.GetBoundingProjd(Vector::From(1.0, 0.0, 0.0), zero, &amp;min.x, &amp;max.x);
        sbls.GetBoundingProjd(Vector::From(0.0, 1.0, 0.0), zero, &amp;min.y, &amp;max.y);
        sbls.GetBoundingProjd(Vector::From(0.0, 0.0, 1.0), zero, &amp;min.z, &amp;max.z);

        Vector mid = min.Plus(max).ScaledBy(0.5);

        hStyle hs = { Style::CONSTRAINT };
        Canvas::Stroke stroke = Style::Stroke(hs);
        stroke.layer = Canvas::Layer::FRONT;

        double scale = SS.MmPerUnit();
        std::string label = ssprintf("%.3f %s",
                                     fabs(sbls.SignedArea() / (scale * scale)),
                                     SS.UnitName());

        double fontHeight = Style::TextHeight(hs);
        double textWidth  = VectorFont::Builtin()-&gt;GetWidth(fontHeight, label),
</t>
<t tx="leo1.20171224221224.15">#include "solvespace.h"
#include "libdxfrw.h"
#include "libdwgr.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221224.16">static std::string ToUpper(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

</t>
<t tx="leo1.20171224221224.17">class DxfImport : public DRW_Interface {
public:
    Vector blockX;
    Vector blockY;
    Vector blockZ;
    Vector blockT;

    @others
};

</t>
<t tx="leo1.20171224221224.18">void invertXTransform() {
    blockX.x = -blockX.x;
    blockY.x = -blockY.x;
    blockT.x = -blockT.x;
}

</t>
<t tx="leo1.20171224221224.19">void multBlockTransform(double x, double y, double sx, double sy, double angle) {
    Vector oldX = blockX;
    Vector oldY = blockY;
    Vector oldT = blockT;

    Vector newX = Vector::From(sx, 0.0, 0.0).RotatedAbout(Vector::From(0.0, 0.0, 1.0), angle);
    Vector newY = Vector::From(0.0, sy, 0.0).RotatedAbout(Vector::From(0.0, 0.0, 1.0), angle);
    Vector newT = Vector::From(x, y, 0.0);

    blockX = oldX.ScaledBy(newX.x).Plus(
             oldY.ScaledBy(newX.y));

    blockY = oldX.ScaledBy(newY.x).Plus(
             oldY.ScaledBy(newY.y));

    blockT = oldX.ScaledBy(newT.x).Plus(
             oldY.ScaledBy(newT.y)).Plus(oldT);
}

</t>
<t tx="leo1.20171224221224.2">void Group::GenerateLoops() {
    polyLoops.Clear();
    bezierLoops.Clear();
    bezierOpens.Clear();

    if(type == Type::DRAWING_3D || type == Type::DRAWING_WORKPLANE ||
       type == Type::ROTATE || type == Type::TRANSLATE || type == Type::LINKED)
    {
        bool allClosed = false, allCoplanar = false, allNonZeroLen = false;
        AssembleLoops(&amp;allClosed, &amp;allCoplanar, &amp;allNonZeroLen);
        if(!allNonZeroLen) {
            polyError.how = PolyError::ZERO_LEN_EDGE;
        } else if(!allCoplanar) {
            polyError.how = PolyError::NOT_COPLANAR;
        } else if(!allClosed) {
            polyError.how = PolyError::NOT_CLOSED;
        } else {
            polyError.how = PolyError::GOOD;
            // The self-intersecting check is kind of slow, so don't run it
            // unless requested.
            if(SS.checkClosedContour) {
                if(polyLoops.SelfIntersecting(&amp;(polyError.errorPointAt))) {
                    polyError.how = PolyError::SELF_INTERSECTING;
                }
            }
        }
    }
}

</t>
<t tx="leo1.20171224221224.20">void clearBlockTransform() {
    blockX = Vector::From(1.0, 0.0, 0.0);
    blockY = Vector::From(0.0, 1.0, 0.0);
    blockZ = Vector::From(0.0, 0.0, 1.0);
    blockT = Vector::From(0.0, 0.0, 0.0);
}

Vector blockTransform(Vector v) {
    Vector r = blockT;
    r = r.Plus(blockX.ScaledBy(v.x));
    r = r.Plus(blockY.ScaledBy(v.y));
    r = r.Plus(blockZ.ScaledBy(v.z));
    return r;
}

</t>
<t tx="leo1.20171224221224.21">void blockTransformArc(Vector *c, Vector *p0, Vector *p1) {
    bool oldSign = p0-&gt;Minus(*c).Cross(p1-&gt;Minus(*c)).z &gt; 0.0;

    *c = blockTransform(*c);
    *p0 = blockTransform(*p0);
    *p1 = blockTransform(*p1);

    bool newSign = p0-&gt;Minus(*c).Cross(p1-&gt;Minus(*c)).z &gt; 0.0;
    if(oldSign != newSign) std::swap(*p0, *p1);
}

Vector toVector(const DRW_Coord &amp;c, bool transform = true) {
    Vector result = Vector::From(c.x, c.y, c.z);
    if(transform) return blockTransform(result);
    return result;
}

Vector toVector(const DRW_Vertex2D &amp;c) {
    Vector result = Vector::From(c.x, c.y, 0.0);
    return blockTransform(result);
}

Vector toVector(const DRW_Vertex &amp;c) {
    Vector result = Vector::From(c.basePoint.x, c.basePoint.y, c.basePoint.z);
    return blockTransform(result);
}

</t>
<t tx="leo1.20171224221224.22">double angleTo(Vector v0, Vector v1) {
    Vector d = v1.Minus(v0);
    double a = atan2(d.y, d.x);
    return M_PI + remainder(a - M_PI, 2 * M_PI);
}

Vector polar(double radius, double angle) {
    return Vector::From(radius * cos(angle), radius * sin(angle), 0.0);
}

hRequest createBulge(Vector p0, Vector p1, double bulge) {
    bool reversed = bulge &lt; 0.0;
    double alpha = atan(bulge) * 4.0;

    Vector middle = p1.Plus(p0).ScaledBy(0.5);
    double dist = p1.Minus(p0).Magnitude() / 2.0;
    double angle = angleTo(p0, p1);

    // alpha can't be 0.0 at this point
    double radius = fabs(dist / sin(alpha / 2.0));
    double wu = fabs(radius * radius - dist * dist);
    double h = sqrt(wu);

    if(bulge &gt; 0.0) {
        angle += M_PI_2;
    } else {
        angle -= M_PI_2;
    }

    if (fabs(alpha) &gt; M_PI) {
        h *= -1.0;
    }

    Vector center = polar(h, angle);
    center = center.Plus(middle);

    if(reversed) std::swap(p0, p1);
    blockTransformArc(&amp;center, &amp;p0, &amp;p1);

    hRequest hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(center);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(p0);
    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(p1);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));
    processPoint(hr.entity(3));
    return hr;
}

struct Block {
    std::vector&lt;std::unique_ptr&lt;DRW_Entity&gt;&gt; entities;
    DRW_Block data;
};

bool asConstruction = false;
unsigned unknownEntities = 0;
std::map&lt;std::string, hStyle&gt; styles;
std::map&lt;std::string, Block&gt; blocks;
std::map&lt;std::string, DRW_Layer&gt; layers;
Block *readBlock = NULL;
const DRW_Insert *insertInsert = NULL;

template&lt;class T&gt;
</t>
<t tx="leo1.20171224221224.23">bool addPendingBlockEntity(const T &amp;e) {
    if(readBlock == NULL) return false;
    readBlock-&gt;entities.emplace_back(new T(e));
    return true;
}

</t>
<t tx="leo1.20171224221224.24">void addEntity(DRW_Entity *e) {
    switch(e-&gt;eType) {
        case DRW::POINT:
            addPoint(*static_cast&lt;DRW_Point *&gt;(e));
            break;
        case DRW::LINE:
            addLine(*static_cast&lt;DRW_Line *&gt;(e));
            break;
        case DRW::ARC:
            addArc(*static_cast&lt;DRW_Arc *&gt;(e));
            break;
        case DRW::CIRCLE:
            addCircle(*static_cast&lt;DRW_Circle *&gt;(e));
            break;
        case DRW::POLYLINE:
            addPolyline(*static_cast&lt;DRW_Polyline *&gt;(e));
            break;
        case DRW::LWPOLYLINE:
            addLWPolyline(*static_cast&lt;DRW_LWPolyline *&gt;(e));
            break;
        case DRW::SPLINE:
            addSpline(static_cast&lt;DRW_Spline *&gt;(e));
            break;
        case DRW::INSERT:
            addInsert(*static_cast&lt;DRW_Insert *&gt;(e));
            break;
        case DRW::TEXT:
            addText(*static_cast&lt;DRW_Text *&gt;(e));
            break;
        case DRW::MTEXT:
            addMText(*static_cast&lt;DRW_MText *&gt;(e));
            break;
        case DRW::DIMALIGNED:
            addDimAlign(static_cast&lt;DRW_DimAligned *&gt;(e));
            break;
        case DRW::DIMLINEAR:
            addDimLinear(static_cast&lt;DRW_DimLinear *&gt;(e));
            break;
        case DRW::DIMRADIAL:
            addDimRadial(static_cast&lt;DRW_DimRadial *&gt;(e));
            break;
        case DRW::DIMDIAMETRIC:
            addDimDiametric(static_cast&lt;DRW_DimDiametric *&gt;(e));
            break;
        case DRW::DIMANGULAR:
            addDimAngular(static_cast&lt;DRW_DimAngular *&gt;(e));
            break;
        default:
            unknownEntities++;
    }
}

Style::TextOrigin dxfAlignToOrigin(DRW_Text::HAlign alignH, DRW_Text::VAlign alignV) {
    uint32_t origin = 0;
    switch(alignH) {
        case DRW_Text::HLeft:
            origin |= (uint32_t)Style::TextOrigin::LEFT;
            break;

        case DRW_Text::HMiddle:
        case DRW_Text::HCenter:
            break;

        case DRW_Text::HRight:
            origin |= (uint32_t)Style::TextOrigin::RIGHT;
            break;

        case DRW_Text::HAligned:
        case DRW_Text::HFit:
        default:
            origin |= (uint32_t)Style::TextOrigin::LEFT;
            break;
    }

    switch(alignV) {
        case DRW_Text::VBaseLine:
        case DRW_Text::VBottom:
            origin |= (uint32_t)Style::TextOrigin::BOT;
            break;

        case DRW_Text::VMiddle:
            break;

        case DRW_Text::VTop:
            origin |= (uint32_t)Style::TextOrigin::TOP;
            break;

        default:
            origin |= (uint32_t)Style::TextOrigin::BOT;
            break;
    }

    return (Style::TextOrigin)origin;
}

DRW_Layer *getSourceLayer(const DRW_Entity *e) {
    DRW_Layer *layer = NULL;
    if(insertInsert != NULL) {
        std::string l = insertInsert-&gt;layer;
        auto bi = layers.find(l);
        if(bi != layers.end()) layer = &amp;bi-&gt;second;
    } else {
        std::string l = e-&gt;layer;
        auto bi = layers.find(l);
        if(bi != layers.end()) layer = &amp;bi-&gt;second;
    }
    return layer;
}

</t>
<t tx="leo1.20171224221224.25">int getColor(const DRW_Entity *e) {
    int col = e-&gt;color;
    if(col == DRW::ColorByBlock) {
        if(insertInsert != NULL) {
            col = insertInsert-&gt;color;
        } else {
            col = 7;
        }
    }
    if(col == DRW::ColorByLayer) {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            col = layer-&gt;color;
        } else {
            col = 7;
        }
    }
    return col;
}

DRW_LW_Conv::lineWidth getLineWidth(const DRW_Entity *e) {
    DRW_LW_Conv::lineWidth result = e-&gt;lWeight;
    if(result == DRW_LW_Conv::widthByBlock) {
        if(insertInsert != NULL) {
            result = insertInsert-&gt;lWeight;
        } else {
            result = DRW_LW_Conv::widthDefault;
        }
    }
    if(result == DRW_LW_Conv::widthByLayer) {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            result = layer-&gt;lWeight;
        } else {
            result = DRW_LW_Conv::widthDefault;
        }
    }
    return result;
}

std::string getLineType(const DRW_Entity *e) {
    std::string  result = e-&gt;lineType;
    if(result == "BYBLOCK") {
        if(insertInsert != NULL) {
            result = ToUpper(insertInsert-&gt;lineType);
        } else {
            result = "CONTINUOUS";
        }
    }
    if(result == "BYLAYER") {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            result = ToUpper(layer-&gt;lineType);
        } else {
            result = "CONTINUOUS";
        }
    }
    return result;
}

hStyle invisibleStyle() {
    std::string id = "@dxf-invisible";

    auto si = styles.find(id);
    if(si != styles.end()) {
        return si-&gt;second;
    }

    hStyle hs = { Style::CreateCustomStyle(/*rememberForUndo=*/false) };
    Style *s = Style::Get(hs);
    s-&gt;name = id;
    s-&gt;visible = false;

    styles.emplace(id, hs);
    return hs;
}

hStyle styleFor(const DRW_Entity *e) {
    // Color.
    // TODO: which color to choose: index or RGB one?
    int col = getColor(e);
    RgbaColor c = RgbaColor::From(DRW::dxfColors[col][0],
                                  DRW::dxfColors[col][1],
                                  DRW::dxfColors[col][2]);

    // Line width.
    DRW_LW_Conv::lineWidth lw = getLineWidth(e);
    double width = DRW_LW_Conv::lineWidth2dxfInt(e-&gt;lWeight) / 100.0;
    if(width &lt; 0.0) width = 1.0;

    // Line stipple.
    // TODO: Probably, we can load default autocad patterns and match it with ours.
    std::string lineType = getLineType(e);
    StipplePattern stipple = StipplePattern::CONTINUOUS;
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        StipplePattern st = (StipplePattern)i;
        if(lineType == DxfFileWriter::lineTypeName(st)) {
            stipple = st;
            break;
        }
    }

    // Text properties.
    DRW_Text::HAlign alignH = DRW_Text::HLeft;
    DRW_Text::VAlign alignV = DRW_Text::VBaseLine;
    double textAngle = 0.0;
    double textHeight = Style::DefaultTextHeight();

    if(e-&gt;eType == DRW::TEXT || e-&gt;eType == DRW::MTEXT) {
        const DRW_Text *text = static_cast&lt;const DRW_Text *&gt;(e);
        alignH = text-&gt;alignH;
        alignV = text-&gt;alignV;
        textHeight = text-&gt;height;
        textAngle = text-&gt;angle;
        // I have no idea why, but works
        if(alignH == DRW_Text::HMiddle) {
            alignV = DRW_Text::VMiddle;
        }
    }

    // Unique identifier based on style properties.
    std::string id = "@dxf";
    if(lw != DRW_LW_Conv::widthDefault)
        id += ssprintf("-w%.4g", width);
    if(lineType != "CONTINUOUS")
        id += ssprintf("-%s", lineType.c_str());
    if(c.red != 0 || c.green != 0 || c.blue != 0)
        id += ssprintf("-#%02x%02x%02x", c.red, c.green, c.blue);
    if(textHeight != Style::DefaultTextHeight())
        id += ssprintf("-h%.4g", textHeight);
    if(textAngle != 0.0)
        id += ssprintf("-a%.5g", textAngle);
    if(alignH != DRW_Text::HLeft)
        id += ssprintf("-oh%d", alignH);
    if(alignV != DRW_Text::VBaseLine)
        id += ssprintf("-ov%d", alignV);

    auto si = styles.find(id);
    if(si != styles.end()) {
        return si-&gt;second;
    }

    hStyle hs = { Style::CreateCustomStyle(/*rememberForUndo=*/false) };
    Style *s = Style::Get(hs);
    if(lw != DRW_LW_Conv::widthDefault) {
        s-&gt;widthAs = Style::UnitsAs::MM;
        s-&gt;width = width;
        s-&gt;stippleScale = 1.0 + width * 2.0;
    }
    s-&gt;name = id;
    s-&gt;stippleType = stipple;
    if(c.red != 0 || c.green != 0 || c.blue != 0) s-&gt;color = c;
    s-&gt;textHeightAs = Style::UnitsAs::MM;
    s-&gt;textHeight = textHeight;
    s-&gt;textAngle = textAngle;
    s-&gt;textOrigin = dxfAlignToOrigin(alignH, alignV);

    styles.emplace(id, hs);
    return hs;
}

</t>
<t tx="leo1.20171224221224.26">void configureRequest(hRequest hr, hStyle hs) {
    Request *r = SK.GetRequest(hr);
    r-&gt;construction = asConstruction;
    r-&gt;style = hs;
}

struct VectorHash {
    size_t operator()(const Vector &amp;v) const {
        static const size_t size = std::numeric_limits&lt;size_t&gt;::max() / 2 - 1;
        static const double eps = (4.0 * LENGTH_EPS);

        double x = fabs(v.x) / eps;
        double y = fabs(v.y) / eps;

        size_t xs = size_t(fmod(x, double(size)));
        size_t ys = size_t(fmod(y, double(size)));

        return ys * size + xs;
    }
};

struct VectorPred {
</t>
<t tx="leo1.20171224221224.27">    bool operator()(Vector a, Vector b) const {
        return a.Equals(b, LENGTH_EPS);
    }
};

std::unordered_map&lt;Vector, hEntity, VectorHash, VectorPred&gt; points;

</t>
<t tx="leo1.20171224221224.28">void processPoint(hEntity he, bool constrain = true) {
    Entity *e = SK.GetEntity(he);
    Vector pos = e-&gt;PointGetNum();
    hEntity p = findPoint(pos);
    if(p.v == he.v) return;
    if(p.v != Entity::NO_ENTITY.v) {
        if(constrain) {
            Constraint::ConstrainCoincident(he, p);
        }
        // We don't add point because we already
        // have point in this position
        return;
    }
    points.emplace(pos, he);
}

hEntity findPoint(const Vector &amp;p) {
    auto it = points.find(p);
    if(it == points.end()) return Entity::NO_ENTITY;
    return it-&gt;second;
}

hEntity createOrGetPoint(const Vector &amp;p) {
    hEntity he = findPoint(p);
    if(he.v != Entity::NO_ENTITY.v) return he;

    hRequest hr = SS.GW.AddRequest(Request::Type::DATUM_POINT, /*rememberForUndo=*/false);
    he = hr.entity(0);
    SK.GetEntity(he)-&gt;PointForceTo(p);
    points.emplace(p, he);
    return he;
}

hEntity createLine(Vector p0, Vector p1, hStyle style, bool constrainHV = false) {
    if(p0.Equals(p1)) return Entity::NO_ENTITY;
    hRequest hr = SS.GW.AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(p0);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(p1);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));

    if(constrainHV &amp;&amp; SS.GW.LockedInWorkplane()) {
        bool hasConstraint = false;
        Constraint::Type cType;
        if(fabs(p0.x - p1.x) &lt; LENGTH_EPS) {
            hasConstraint = true;
            cType = Constraint::Type::VERTICAL;
        } else if(fabs(p0.y - p1.y) &lt; LENGTH_EPS) {
            hasConstraint = true;
            cType = Constraint::Type::HORIZONTAL;
        }
        if(hasConstraint) {
            Constraint::Constrain(
                cType,
                Entity::NO_ENTITY,
                Entity::NO_ENTITY,
                hr.entity(0)
            );
        }
    }

    configureRequest(hr, style);
    return hr.entity(0);
}

hEntity createCircle(const Vector &amp;c, double r, hStyle style) {
    hRequest hr = SS.GW.AddRequest(Request::Type::CIRCLE, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(c);
    processPoint(hr.entity(1));
    SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(r);

    configureRequest(hr, style);
    return hr.entity(0);
}

</t>
<t tx="leo1.20171224221224.29">void addLayer(const DRW_Layer &amp;data) override {
    layers.emplace(data.name, data);
}

</t>
<t tx="leo1.20171224221224.3">void SShell::RemapFaces(Group *g, int remap) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)){
        hEntity face = { ss-&gt;face };
        if(face.v == Entity::NO_ENTITY.v) continue;

        face = g-&gt;Remap(face, remap);
        ss-&gt;face = face.v;
    }
}

</t>
<t tx="leo1.20171224221224.30">void addBlock(const DRW_Block &amp;data) override {
    readBlock = &amp;blocks[data.name];
    readBlock-&gt;data = data;
}

</t>
<t tx="leo1.20171224221224.31">void endBlock() override {
    readBlock = NULL;
}

</t>
<t tx="leo1.20171224221224.32">void addPoint(const DRW_Point &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Point&gt;(data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::DATUM_POINT, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(0))-&gt;PointForceTo(toVector(data.basePoint));
    processPoint(hr.entity(0));
}

</t>
<t tx="leo1.20171224221224.33">void addLine(const DRW_Line &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Line&gt;(data)) return;

    createLine(toVector(data.basePoint), toVector(data.secPoint), styleFor(&amp;data),
               /*constrainHV=*/true);
}

</t>
<t tx="leo1.20171224221224.34">void addArc(const DRW_Arc &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Arc&gt;(data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    double r = data.radious;
    double sa = data.staangle;
    double ea = data.endangle;
    Vector c = Vector::From(data.basePoint.x, data.basePoint.y, data.basePoint.z);
    Vector rvs = Vector::From(r * cos(sa), r * sin(sa), data.basePoint.z).Plus(c);
    Vector rve = Vector::From(r * cos(ea), r * sin(ea), data.basePoint.z).Plus(c);

    if(data.extPoint.z == -1.0) {
        c.x = -c.x;
        rvs.x = - rvs.x;
        rve.x = - rve.x;
        std::swap(rvs, rve);
    }

    blockTransformArc(&amp;c, &amp;rvs, &amp;rve);

    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(c);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(rvs);
    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(rve);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));
    processPoint(hr.entity(3));
    configureRequest(hr, styleFor(&amp;data));
}

</t>
<t tx="leo1.20171224221224.35">void addCircle(const DRW_Circle &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Circle&gt;(data)) return;

    createCircle(toVector(data.basePoint), data.radious, styleFor(&amp;data));
}

</t>
<t tx="leo1.20171224221224.36">void addLWPolyline(const DRW_LWPolyline &amp;data)  override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_LWPolyline&gt;(data)) return;

    size_t vNum = data.vertlist.size();

    // Check for closed polyline.
    if((data.flags &amp; 1) != 1) vNum--;

    // Correct coordinate system for the case where z=-1, as described in
    // http://paulbourke.net/dataformats/dxf/dxf10.html.
    bool needSwapX = data.extPoint.z == -1.0;

    for(size_t i = 0; i &lt; vNum; i++) {
        DRW_Vertex2D c0 = *data.vertlist[i];
        DRW_Vertex2D c1 = *data.vertlist[(i + 1) % data.vertlist.size()];

        if(needSwapX) {
            c0.x = -c0.x;
            c1.x = -c1.x;
            c0.bulge = -c0.bulge;
        }

        Vector p0 = Vector::From(c0.x, c0.y, 0.0);
        Vector p1 = Vector::From(c1.x, c1.y, 0.0);
        hStyle hs = styleFor(&amp;data);

        if(EXACT(data.vertlist[i]-&gt;bulge == 0.0)) {
            createLine(blockTransform(p0), blockTransform(p1), hs, /*constrainHV=*/true);
        } else {
            hRequest hr = createBulge(p0, p1, c0.bulge);
            configureRequest(hr, hs);
        }
    }
}

</t>
<t tx="leo1.20171224221224.37">void addPolyline(const DRW_Polyline &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Polyline&gt;(data)) return;

    size_t vNum = data.vertlist.size();

    // Check for closed polyline.
    if((data.flags &amp; 1) != 1) vNum--;

    // Correct coordinate system for the case where z=-1, as described in
    // http://paulbourke.net/dataformats/dxf/dxf10.html.
    bool needSwapX = (data.extPoint.z == -1.0);

    for(size_t i = 0; i &lt; vNum; i++) {
        DRW_Coord c0 = data.vertlist[i]-&gt;basePoint;
        DRW_Coord c1 = data.vertlist[(i + 1) % data.vertlist.size()]-&gt;basePoint;

        double bulge = data.vertlist[i]-&gt;bulge;
        if(needSwapX) {
            c0.x = -c0.x;
            c1.x = -c1.x;
            bulge = -bulge;
        }

        Vector p0 = Vector::From(c0.x, c0.y, c0.z);
        Vector p1 = Vector::From(c1.x, c1.y, c1.z);
        hStyle hs = styleFor(&amp;data);

        if(EXACT(bulge == 0.0)) {
            createLine(blockTransform(p0), blockTransform(p1), hs, /*constrainHV=*/true);
        } else {
            hRequest hr = createBulge(p0, p1, bulge);
            configureRequest(hr, hs);
        }
    }
}

</t>
<t tx="leo1.20171224221224.38">void addSpline(const DRW_Spline *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(data-&gt;degree != 3) return;
    if(addPendingBlockEntity&lt;DRW_Spline&gt;(*data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
    for(int i = 0; i &lt; 4; i++) {
        SK.GetEntity(hr.entity(i + 1))-&gt;PointForceTo(toVector(*data-&gt;controllist[i]));
        processPoint(hr.entity(i + 1));
    }
    configureRequest(hr, styleFor(data));
}

</t>
<t tx="leo1.20171224221224.39">void addInsert(const DRW_Insert &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Insert&gt;(data)) return;

    auto bi = blocks.find(data.name);
    ssassert(bi != blocks.end(), "Inserted block does not exist");
    Block *block = &amp;bi-&gt;second;

    // Push transform.
    Vector x = blockX;
    Vector y = blockY;
    Vector t = blockT;

    const DRW_Insert *oldInsert = insertInsert;
    insertInsert = &amp;data;

    if(data.extPoint.z == -1.0) invertXTransform();
    multBlockTransform(data.basePoint.x, data.basePoint.y, data.xscale, data.yscale,
                       data.angle);
    for(auto &amp;e : block-&gt;entities) {
        addEntity(&amp;*e);
    }

    insertInsert = oldInsert;

    // Pop transform.
    blockX = x;
    blockY = y;
    blockT = t;
}

</t>
<t tx="leo1.20171224221224.4">void SMesh::RemapFaces(Group *g, int remap) {
    STriangle *tr;
    for(tr = l.First(); tr; tr = l.NextAfter(tr)) {
        hEntity face = { tr-&gt;meta.face };
        if(face.v == Entity::NO_ENTITY.v) continue;

        face = g-&gt;Remap(face, remap);
        tr-&gt;meta.face = face.v;
    }
}

template&lt;class T&gt;
</t>
<t tx="leo1.20171224221224.40">void addMText(const DRW_MText &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_MText&gt;(data)) return;

    DRW_MText text = data;
    text.secPoint = text.basePoint;
    addText(text);
}

</t>
<t tx="leo1.20171224221224.41">void addText(const DRW_Text &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Text&gt;(data)) return;

    Constraint c = {};
    c.group         = SS.GW.activeGroup;
    c.workplane     = SS.GW.ActiveWorkplane();
    c.type          = Constraint::Type::COMMENT;
    if(data.alignH == DRW_Text::HLeft &amp;&amp; data.alignV == DRW_Text::VBaseLine) {
        c.disp.offset   = toVector(data.basePoint);
    } else {
        c.disp.offset   = toVector(data.secPoint);
    }
    c.comment       = data.text;
    c.disp.style    = styleFor(&amp;data);
    Constraint::AddConstraint(&amp;c, /*rememberForUndo=*/false);
}

</t>
<t tx="leo1.20171224221224.42">void addDimAlign(const DRW_DimAligned *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAligned&gt;(*data)) return;

    Vector p0 = toVector(data-&gt;getDef1Point());
    Vector p1 = toVector(data-&gt;getDef2Point());
    Vector p2 = toVector(data-&gt;getTextPoint());
    hConstraint hc = Constraint::Constrain(
        Constraint::Type::PT_PT_DISTANCE,
        createOrGetPoint(p0),
        createOrGetPoint(p1),
        Entity::NO_ENTITY
    );

    Constraint *c = SK.GetConstraint(hc);
    if(data-&gt;hasActualMeasurement()) {
        c-&gt;valA = data-&gt;getActualMeasurement();
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = p2.Minus(p0.Plus(p1).ScaledBy(0.5));
}

</t>
<t tx="leo1.20171224221224.43">void addDimLinear(const DRW_DimLinear *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimLinear&gt;(*data)) return;

    Vector p0 = toVector(data-&gt;getDef1Point(), /*transform=*/false);
    Vector p1 = toVector(data-&gt;getDef2Point(), /*transform=*/false);
    Vector p2 = toVector(data-&gt;getTextPoint(), /*transform=*/false);

    double angle = data-&gt;getAngle() * PI / 180.0;
    Vector dir = Vector::From(cos(angle), sin(angle), 0.0);
    Vector p3 = p1.Minus(p1.ClosestPointOnLine(p2, dir)).Plus(p1);
    if(p1.Minus(p3).Magnitude() &lt; LENGTH_EPS) {
        p3 = p0.Minus(p0.ClosestPointOnLine(p2, dir)).Plus(p1);
    }

    Vector p4 = p0.ClosestPointOnLine(p1, p3.Minus(p1)).Plus(p0).ScaledBy(0.5);

    p0 = blockTransform(p0);
    p1 = blockTransform(p1);
    p2 = blockTransform(p2);
    p3 = blockTransform(p3);
    p4 = blockTransform(p4);

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::PT_LINE_DISTANCE,
        createOrGetPoint(p0),
        Entity::NO_ENTITY,
        createLine(p1, p3, invisibleStyle())
    );

    Constraint *c = SK.GetConstraint(hc);
    if(data-&gt;hasActualMeasurement()) {
        c-&gt;valA = data-&gt;getActualMeasurement();
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = p2.Minus(p4);
}

</t>
<t tx="leo1.20171224221224.44">void addDimAngular(const DRW_DimAngular *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAngular&gt;(*data)) return;

    Vector l0p0 = toVector(data-&gt;getFirstLine1());
    Vector l0p1 = toVector(data-&gt;getFirstLine2());
    Vector l1p0 = toVector(data-&gt;getSecondLine1());
    Vector l1p1 = toVector(data-&gt;getSecondLine2());

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::ANGLE,
        Entity::NO_ENTITY,
        Entity::NO_ENTITY,
        createLine(l0p0, l0p1, invisibleStyle()),
        createLine(l1p1, l1p0, invisibleStyle()),
        /*other=*/false,
        /*other2=*/false
    );

    Constraint *c = SK.GetConstraint(hc);
    c-&gt;ModifyToSatisfy();
    if(data-&gt;hasActualMeasurement()) {
        double actual = data-&gt;getActualMeasurement() / PI * 180.0;
        if(fabs(180.0 - actual - c-&gt;valA) &lt; fabs(actual - c-&gt;valA)) {
            c-&gt;other = true;
        }
        c-&gt;valA = actual;
    }

    bool skew = false;
    Vector pi = Vector::AtIntersectionOfLines(l0p0, l0p1, l1p0, l1p1, &amp;skew);
    if(!skew) {
        c-&gt;disp.offset = toVector(data-&gt;getTextPoint()).Minus(pi);
    }
}

hConstraint createDiametric(Vector cp, double r, Vector tp, double actual,
</t>
<t tx="leo1.20171224221224.45">                            bool asRadius = false) {
    hEntity he = createCircle(cp, r, invisibleStyle());

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::DIAMETER,
        Entity::NO_ENTITY,
        Entity::NO_ENTITY,
        he
    );

    Constraint *c = SK.GetConstraint(hc);
    if(actual &gt; 0.0) {
        c-&gt;valA = asRadius ? actual * 2.0 : actual;
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = tp.Minus(cp);
    if(asRadius) c-&gt;other = true;
    return hc;
}

</t>
<t tx="leo1.20171224221224.46">void addDimRadial(const DRW_DimRadial *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimRadial&gt;(*data)) return;

    Vector cp = toVector(data-&gt;getCenterPoint());
    Vector dp = toVector(data-&gt;getDiameterPoint());
    Vector tp = toVector(data-&gt;getTextPoint());
    double actual = -1.0;
    if(data-&gt;hasActualMeasurement()) {
        actual = data-&gt;getActualMeasurement();
    }

    createDiametric(cp, cp.Minus(dp).Magnitude(), tp, actual, /*asRadius=*/true);
}

</t>
<t tx="leo1.20171224221224.47">void addDimDiametric(const DRW_DimDiametric *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimRadial&gt;(*data)) return;

    Vector dp1 = toVector(data-&gt;getDiameter1Point());
    Vector dp2 = toVector(data-&gt;getDiameter2Point());

    Vector cp = dp1.Plus(dp2).ScaledBy(0.5);
    Vector tp = toVector(data-&gt;getTextPoint());
    double actual = -1.0;
    if(data-&gt;hasActualMeasurement()) {
        actual = data-&gt;getActualMeasurement();
    }

    createDiametric(cp, cp.Minus(dp1).Magnitude(), tp, actual, /*asRadius=*/false);
}

</t>
<t tx="leo1.20171224221224.48">void addDimAngular3P(const DRW_DimAngular3p *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAngular3p&gt;(*data)) return;

    DRW_DimAngular dim = *static_cast&lt;const DRW_Dimension *&gt;(data);
    dim.setFirstLine1(data-&gt;getVertexPoint());
    dim.setFirstLine2(data-&gt;getFirstLine());
    dim.setSecondLine1(data-&gt;getVertexPoint());
    dim.setSecondLine2(data-&gt;getSecondLine());
    addDimAngular(&amp;dim);
}
</t>
<t tx="leo1.20171224221224.49">class DxfCheck3D : public DRW_Interface {
public:
    bool is3d;

    @others
};

</t>
<t tx="leo1.20171224221224.5">void Group::GenerateForStepAndRepeat(T *steps, T *outs, Group::CombineAs forWhat) {
    T workA, workB;
    workA = {};
    workB = {};
    T *soFar = &amp;workA, *scratch = &amp;workB;

    int n = (int)valA, a0 = 0;
    if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
        a0++; n++;
    }
    int a;
    for(a = a0; a &lt; n; a++) {
        int ap = a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1));
        int remap = (a == (n - 1)) ? REMAP_LAST : a;

        T transd = {};
        if(type == Type::TRANSLATE) {
            Vector trans = Vector::From(h.param(0), h.param(1), h.param(2));
            trans = trans.ScaledBy(ap);
            transd.MakeFromTransformationOf(steps,
                trans, Quaternion::IDENTITY, 1.0);
        } else {
            Vector trans = Vector::From(h.param(0), h.param(1), h.param(2));
            double theta = ap * SK.GetParam(h.param(3))-&gt;val;
            double c = cos(theta), s = sin(theta);
            Vector axis = Vector::From(h.param(4), h.param(5), h.param(6));
            Quaternion q = Quaternion::From(c, s*axis.x, s*axis.y, s*axis.z);
            // Rotation is centered at t; so A(x - t) + t = Ax + (t - At)
            transd.MakeFromTransformationOf(steps,
                trans.Minus(q.Rotate(trans)), q, 1.0);
        }

        // We need to rewrite any plane face entities to the transformed ones.
        transd.RemapFaces(this, remap);

        // And tack this transformed copy on to the return.
        if(soFar-&gt;IsEmpty()) {
            scratch-&gt;MakeFromCopyOf(&amp;transd);
        } else if (forWhat == CombineAs::ASSEMBLE) {
            scratch-&gt;MakeFromAssemblyOf(soFar, &amp;transd);
        } else {
            scratch-&gt;MakeFromUnionOf(soFar, &amp;transd);
        }

        swap(scratch, soFar);
        scratch-&gt;Clear();
        transd.Clear();
    }

    outs-&gt;Clear();
    *outs = *soFar;
}

template&lt;class T&gt;
</t>
<t tx="leo1.20171224221224.50">void addEntity(DRW_Entity *e) {
    switch(e-&gt;eType) {
        case DRW::POINT:
            addPoint(*static_cast&lt;DRW_Point *&gt;(e));
            break;
        case DRW::LINE:
            addLine(*static_cast&lt;DRW_Line *&gt;(e));
            break;
        case DRW::ARC:
            addArc(*static_cast&lt;DRW_Arc *&gt;(e));
            break;
        case DRW::CIRCLE:
            addCircle(*static_cast&lt;DRW_Circle *&gt;(e));
            break;
        case DRW::POLYLINE:
            addPolyline(*static_cast&lt;DRW_Polyline *&gt;(e));
            break;
        case DRW::LWPOLYLINE:
            addLWPolyline(*static_cast&lt;DRW_LWPolyline *&gt;(e));
            break;
        case DRW::SPLINE:
            addSpline(static_cast&lt;DRW_Spline *&gt;(e));
            break;
        case DRW::INSERT:
            addInsert(*static_cast&lt;DRW_Insert *&gt;(e));
            break;
        case DRW::TEXT:
            addText(*static_cast&lt;DRW_Text *&gt;(e));
            break;
        case DRW::MTEXT:
            addMText(*static_cast&lt;DRW_MText *&gt;(e));
            break;
        case DRW::DIMALIGNED:
            addDimAlign(static_cast&lt;DRW_DimAligned *&gt;(e));
            break;
        case DRW::DIMLINEAR:
            addDimLinear(static_cast&lt;DRW_DimLinear *&gt;(e));
            break;
        case DRW::DIMRADIAL:
            addDimRadial(static_cast&lt;DRW_DimRadial *&gt;(e));
            break;
        case DRW::DIMDIAMETRIC:
            addDimDiametric(static_cast&lt;DRW_DimDiametric *&gt;(e));
            break;
        case DRW::DIMANGULAR:
            addDimAngular(static_cast&lt;DRW_DimAngular *&gt;(e));
            break;
        default:
            break;
    }
}

</t>
<t tx="leo1.20171224221224.51">void addPoint(const DRW_Point &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo1.20171224221224.52">void addLine(const DRW_Line &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
    checkCoord(data.secPoint);
}

</t>
<t tx="leo1.20171224221224.53">void addArc(const DRW_Arc &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo1.20171224221224.54">void addCircle(const DRW_Circle &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo1.20171224221224.55">void addPolyline(const DRW_Polyline &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    for(size_t i = 0; i &lt; data.vertlist.size(); i++) {
        checkCoord(data.vertlist[i]-&gt;basePoint);
    }
}

</t>
<t tx="leo1.20171224221224.56">void addSpline(const DRW_Spline *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(data-&gt;degree != 3) return;
    for(int i = 0; i &lt; 4; i++) {
        checkCoord(*data-&gt;controllist[i]);
    }
}

</t>
<t tx="leo1.20171224221224.57">void addInsert(const DRW_Insert &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo1.20171224221224.58">void addMText(const DRW_MText &amp;data) override {
    if(data.space != DRW::ModelSpace) return;

    DRW_MText text = data;
    text.secPoint = text.basePoint;
    addText(text);
}

</t>
<t tx="leo1.20171224221224.59">void addText(const DRW_Text &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
    checkCoord(data.secPoint);
}

</t>
<t tx="leo1.20171224221224.6">void Group::GenerateForBoolean(T *prevs, T *thiss, T *outs, Group::CombineAs how) {
    // If this group contributes no new mesh, then our running mesh is the
    // same as last time, no combining required. Likewise if we have a mesh
    // but it's suppressed.
    if(thiss-&gt;IsEmpty() || suppress) {
        outs-&gt;MakeFromCopyOf(prevs);
        return;
    }

    // So our group's shell appears in thisShell. Combine this with the
    // previous group's shell, using the requested operation.
    if(how == CombineAs::UNION) {
        outs-&gt;MakeFromUnionOf(prevs, thiss);
    } else if(how == CombineAs::DIFFERENCE) {
        outs-&gt;MakeFromDifferenceOf(prevs, thiss);
    } else {
        outs-&gt;MakeFromAssemblyOf(prevs, thiss);
    }
}

</t>
<t tx="leo1.20171224221224.60">void addDimAlign(const DRW_DimAligned *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDef1Point());
    checkCoord(data-&gt;getDef2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo1.20171224221224.61">void addDimLinear(const DRW_DimLinear *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDef1Point());
    checkCoord(data-&gt;getDef2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo1.20171224221224.62">void addDimAngular(const DRW_DimAngular *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getFirstLine1());
    checkCoord(data-&gt;getFirstLine2());
    checkCoord(data-&gt;getSecondLine1());
    checkCoord(data-&gt;getSecondLine2());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo1.20171224221224.63">void addDimRadial(const DRW_DimRadial *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getCenterPoint());
    checkCoord(data-&gt;getDiameterPoint());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo1.20171224221224.64">void addDimDiametric(const DRW_DimDiametric *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDiameter1Point());
    checkCoord(data-&gt;getDiameter2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo1.20171224221224.65">void addDimAngular3P(const DRW_DimAngular3p *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    DRW_DimAngular dim = *static_cast&lt;const DRW_Dimension *&gt;(data);

    dim.setFirstLine1(data-&gt;getVertexPoint());
    dim.setFirstLine2(data-&gt;getFirstLine());
    dim.setSecondLine1(data-&gt;getVertexPoint());
    dim.setSecondLine2(data-&gt;getSecondLine());
    addDimAngular(&amp;dim);
}

</t>
<t tx="leo1.20171224221224.66">void checkCoord(const DRW_Coord &amp;coord) {
    if(fabs(coord.z) &gt; LENGTH_EPS) {
        is3d = true;
    }
}
</t>
<t tx="leo1.20171224221224.67">static void ImportDwgDxf(const Platform::Path &amp;filename,
                         std::function&lt;bool(const std::string &amp;data, DRW_Interface *intf)&gt; read) {
    std::string fileType = ToUpper(filename.Extension());

    std::string data;
    if(!ReadFile(filename, &amp;data)) {
        Error("Couldn't read from '%s'", filename.raw.c_str());
        return;
    }

    bool asConstruction = true;
    if(SS.GW.LockedInWorkplane()) {
        DxfCheck3D checker = {};
        read(data, &amp;checker);
        if(checker.is3d) {
            Message("This %s file contains entities with non-zero Z coordinate; "
                    "the entire file will be imported as construction entities in 3d.",
                    fileType.c_str());
            SS.GW.SetWorkplaneFreeIn3d();
            SS.GW.EnsureValidActives();
        } else {
            asConstruction = false;
        }
    }

    SS.UndoRemember();

    DxfImport importer = {};
    importer.asConstruction = asConstruction;
    importer.clearBlockTransform();
    if(!read(data, &amp;importer)) {
        Error("Corrupted %s file.", fileType.c_str());
    }
    if(importer.unknownEntities &gt; 0) {
        Message("%u %s entities of unknown type were ignored.",
                importer.unknownEntities, fileType.c_str());
    }
}

</t>
<t tx="leo1.20171224221224.68">void ImportDxf(const Platform::Path &amp;filename) {
    ImportDwgDxf(filename, [](const std::string &amp;data, DRW_Interface *intf) {
        std::stringstream stream(data);
        return dxfRW().read(stream, intf, /*ext=*/false);
    });
}

</t>
<t tx="leo1.20171224221224.69">void ImportDwg(const Platform::Path &amp;filename) {
    ImportDwgDxf(filename, [](const std::string &amp;data, DRW_Interface *intf) {
        std::stringstream stream(data);
        return dwgR().read(stream, intf, /*ext=*/false);
    });
}

}
</t>
<t tx="leo1.20171224221224.7">void Group::GenerateShellAndMesh() {
    bool prevBooleanFailed = booleanFailed;
    booleanFailed = false;

    Group *srcg = this;

    thisShell.Clear();
    thisMesh.Clear();
    runningShell.Clear();
    runningMesh.Clear();

    // Don't attempt a lathe or extrusion unless the source section is good:
    // planar and not self-intersecting.
    bool haveSrc = true;
    if(type == Type::EXTRUDE || type == Type::LATHE) {
        Group *src = SK.GetGroup(opA);
        if(src-&gt;polyError.how != PolyError::GOOD) {
            haveSrc = false;
        }
    }

    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        // A step and repeat gets merged against the group's prevous group,
        // not our own previous group.
        srcg = SK.GetGroup(opA);

        if(!srcg-&gt;suppress) {
            if(!IsForcedToMesh()) {
                GenerateForStepAndRepeat&lt;SShell&gt;(&amp;(srcg-&gt;thisShell), &amp;thisShell, srcg-&gt;meshCombine);
            } else {
                SMesh prevm = {};
                prevm.MakeFromCopyOf(&amp;srcg-&gt;thisMesh);
                srcg-&gt;thisShell.TriangulateInto(&amp;prevm);
                GenerateForStepAndRepeat&lt;SMesh&gt; (&amp;prevm, &amp;thisMesh, srcg-&gt;meshCombine);
            }
        }
    } else if(type == Type::EXTRUDE &amp;&amp; haveSrc) {
        Group *src = SK.GetGroup(opA);
        Vector translate = Vector::From(h.param(0), h.param(1), h.param(2));

        Vector tbot, ttop;
        if(subtype == Subtype::ONE_SIDED) {
            tbot = Vector::From(0, 0, 0); ttop = translate.ScaledBy(2);
        } else {
            tbot = translate.ScaledBy(-1); ttop = translate.ScaledBy(1);
        }

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            int is = thisShell.surface.n;
            // Extrude this outer contour (plus its inner contours, if present)
            thisShell.MakeFromExtrusionOf(sbls, tbot, ttop, color);

            // And for any plane faces, annotate the model with the entity for
            // that face, so that the user can select them with the mouse.
            Vector onOrig = sbls-&gt;point;
            int i;
            for(i = is; i &lt; thisShell.surface.n; i++) {
                SSurface *ss = &amp;(thisShell.surface.elem[i]);
                hEntity face = Entity::NO_ENTITY;

                Vector p = ss-&gt;PointAt(0, 0),
                       n = ss-&gt;NormalAt(0, 0).WithMagnitude(1);
                double d = n.Dot(p);

                if(i == is || i == (is + 1)) {
                    // These are the top and bottom of the shell.
                    if(fabs((onOrig.Plus(ttop)).Dot(n) - d) &lt; LENGTH_EPS) {
                        face = Remap(Entity::NO_ENTITY, REMAP_TOP);
                        ss-&gt;face = face.v;
                    }
                    if(fabs((onOrig.Plus(tbot)).Dot(n) - d) &lt; LENGTH_EPS) {
                        face = Remap(Entity::NO_ENTITY, REMAP_BOTTOM);
                        ss-&gt;face = face.v;
                    }
                    continue;
                }

                // So these are the sides
                if(ss-&gt;degm != 1 || ss-&gt;degn != 1) continue;

                Entity *e;
                for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                    if(e-&gt;group.v != opA.v) continue;
                    if(e-&gt;type != Entity::Type::LINE_SEGMENT) continue;

                    Vector a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum(),
                           b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                    a = a.Plus(ttop);
                    b = b.Plus(ttop);
                    // Could get taken backwards, so check all cases.
                    if((a.Equals(ss-&gt;ctrl[0][0]) &amp;&amp; b.Equals(ss-&gt;ctrl[1][0])) ||
                       (b.Equals(ss-&gt;ctrl[0][0]) &amp;&amp; a.Equals(ss-&gt;ctrl[1][0])) ||
                       (a.Equals(ss-&gt;ctrl[0][1]) &amp;&amp; b.Equals(ss-&gt;ctrl[1][1])) ||
                       (b.Equals(ss-&gt;ctrl[0][1]) &amp;&amp; a.Equals(ss-&gt;ctrl[1][1])))
                    {
                        face = Remap(e-&gt;h, REMAP_LINE_TO_FACE);
                        ss-&gt;face = face.v;
                        break;
                    }
                }
            }
        }
    } else if(type == Type::LATHE &amp;&amp; haveSrc) {
        Group *src = SK.GetGroup(opA);

        Vector pt   = SK.GetEntity(predef.origin)-&gt;PointGetNum(),
               axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis = axis.WithMagnitude(1);

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            thisShell.MakeFromRevolutionOf(sbls, pt, axis, color, this);
        }
    } else if(type == Type::LINKED) {
        // The imported shell or mesh are copied over, with the appropriate
        // transformation applied. We also must remap the face entities.
        Vector offset = {
            SK.GetParam(h.param(0))-&gt;val,
            SK.GetParam(h.param(1))-&gt;val,
            SK.GetParam(h.param(2))-&gt;val };
        Quaternion q = {
            SK.GetParam(h.param(3))-&gt;val,
            SK.GetParam(h.param(4))-&gt;val,
            SK.GetParam(h.param(5))-&gt;val,
            SK.GetParam(h.param(6))-&gt;val };

        thisMesh.MakeFromTransformationOf(&amp;impMesh, offset, q, scale);
        thisMesh.RemapFaces(this, 0);

        thisShell.MakeFromTransformationOf(&amp;impShell, offset, q, scale);
        thisShell.RemapFaces(this, 0);
    }

    if(srcg-&gt;meshCombine != CombineAs::ASSEMBLE) {
        thisShell.MergeCoincidentSurfaces();
    }

    // So now we've got the mesh or shell for this group. Combine it with
    // the previous group's mesh or shell with the requested Boolean, and
    // we're done.

    Group *prevg = srcg-&gt;RunningMeshGroup();

    if(!IsForcedToMesh()) {
        SShell *prevs = &amp;(prevg-&gt;runningShell);
        GenerateForBoolean&lt;SShell&gt;(prevs, &amp;thisShell, &amp;runningShell,
            srcg-&gt;meshCombine);

        if(srcg-&gt;meshCombine != CombineAs::ASSEMBLE) {
            runningShell.MergeCoincidentSurfaces();
        }

        // If the Boolean failed, then we should note that in the text screen
        // for this group.
        booleanFailed = runningShell.booleanFailed;
        if(booleanFailed != prevBooleanFailed) {
            SS.ScheduleShowTW();
        }
    } else {
        SMesh prevm, thism;
        prevm = {};
        thism = {};

        prevm.MakeFromCopyOf(&amp;(prevg-&gt;runningMesh));
        prevg-&gt;runningShell.TriangulateInto(&amp;prevm);

        thism.MakeFromCopyOf(&amp;thisMesh);
        thisShell.TriangulateInto(&amp;thism);

        SMesh outm = {};
        GenerateForBoolean&lt;SMesh&gt;(&amp;prevm, &amp;thism, &amp;outm, srcg-&gt;meshCombine);

        // Remove degenerate triangles; if we don't, they'll get split in SnapToMesh
        // in every generated group, resulting in polynomial increase in triangle count,
        // and corresponding slowdown.
        outm.RemoveDegenerateTriangles();

        // And make sure that the output mesh is vertex-to-vertex.
        SKdNode *root = SKdNode::From(&amp;outm);
        root-&gt;SnapToMesh(&amp;outm);
        root-&gt;MakeMeshInto(&amp;runningMesh);

        outm.Clear();
        thism.Clear();
        prevm.Clear();
    }

    displayDirty = true;
}

</t>
<t tx="leo1.20171224221224.70">//-----------------------------------------------------------------------------
// A library wrapper around SolveSpace, to permit someone to use its constraint
// solver without coupling their program too much to SolveSpace's internals.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#define EXPORT_DLL
#include &lt;slvs.h&gt;

Sketch SolveSpace::SK = {};
static System SYS;

static int IsInit = 0;

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221224.71">void Group::GenerateEquations(IdList&lt;Equation,hEquation&gt; *) {
    // Nothing to do for now.
}

</t>
<t tx="leo1.20171224221224.72">void SolveSpace::CnfFreezeInt(uint32_t, const std::string &amp;)
{
    abort();
}

uint32_t SolveSpace::CnfThawInt(uint32_t, const std::string &amp;)
{
    abort();
    return 0;
}

</t>
<t tx="leo1.20171224221224.73">void SolveSpace::DoMessageBox(const char *, int, int, bool)
{
    abort();
}

</t>
<t tx="leo1.20171224221224.74">extern "C" {

@others
} /* extern "C" */
</t>
<t tx="leo1.20171224221224.75">void Slvs_QuaternionU(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationU();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo1.20171224221224.76">void Slvs_QuaternionV(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationV();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo1.20171224221224.77">void Slvs_QuaternionN(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationN();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo1.20171224221224.78">void Slvs_MakeQuaternion(double ux, double uy, double uz,
                         double vx, double vy, double vz,
                         double *qw, double *qx, double *qy, double *qz)
{
    Vector u = Vector::From(ux, uy, uz),
           v = Vector::From(vx, vy, vz);
    Quaternion q = Quaternion::From(u, v);
    *qw = q.w;
    *qx = q.vx;
    *qy = q.vy;
    *qz = q.vz;
}

</t>
<t tx="leo1.20171224221224.79">void Slvs_Solve(Slvs_System *ssys, Slvs_hGroup shg)
{
    if(!IsInit) {
        InitPlatform(0, NULL);
        IsInit = 1;
    }

    int i;
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        Param p = {};

        p.h.v = sp-&gt;h;
        p.val = sp-&gt;val;
        SK.param.Add(&amp;p);
        if(sp-&gt;group == shg) {
            SYS.param.Add(&amp;p);
        }
    }

    for(i = 0; i &lt; ssys-&gt;entities; i++) {
        Slvs_Entity *se = &amp;(ssys-&gt;entity[i]);
        EntityBase e = {};

        switch(se-&gt;type) {
case SLVS_E_POINT_IN_3D:        e.type = Entity::Type::POINT_IN_3D; break;
case SLVS_E_POINT_IN_2D:        e.type = Entity::Type::POINT_IN_2D; break;
case SLVS_E_NORMAL_IN_3D:       e.type = Entity::Type::NORMAL_IN_3D; break;
case SLVS_E_NORMAL_IN_2D:       e.type = Entity::Type::NORMAL_IN_2D; break;
case SLVS_E_DISTANCE:           e.type = Entity::Type::DISTANCE; break;
case SLVS_E_WORKPLANE:          e.type = Entity::Type::WORKPLANE; break;
case SLVS_E_LINE_SEGMENT:       e.type = Entity::Type::LINE_SEGMENT; break;
case SLVS_E_CUBIC:              e.type = Entity::Type::CUBIC; break;
case SLVS_E_CIRCLE:             e.type = Entity::Type::CIRCLE; break;
case SLVS_E_ARC_OF_CIRCLE:      e.type = Entity::Type::ARC_OF_CIRCLE; break;

default: dbp("bad entity type %d", se-&gt;type); return;
        }
        e.h.v           = se-&gt;h;
        e.group.v       = se-&gt;group;
        e.workplane.v   = se-&gt;wrkpl;
        e.point[0].v    = se-&gt;point[0];
        e.point[1].v    = se-&gt;point[1];
        e.point[2].v    = se-&gt;point[2];
        e.point[3].v    = se-&gt;point[3];
        e.normal.v      = se-&gt;normal;
        e.distance.v    = se-&gt;distance;
        e.param[0].v    = se-&gt;param[0];
        e.param[1].v    = se-&gt;param[1];
        e.param[2].v    = se-&gt;param[2];
        e.param[3].v    = se-&gt;param[3];

        SK.entity.Add(&amp;e);
    }
    IdList&lt;Param, hParam&gt; params = {};
    for(i = 0; i &lt; ssys-&gt;constraints; i++) {
        Slvs_Constraint *sc = &amp;(ssys-&gt;constraint[i]);
        ConstraintBase c = {};

        Constraint::Type t;
        switch(sc-&gt;type) {
case SLVS_C_POINTS_COINCIDENT:  t = Constraint::Type::POINTS_COINCIDENT; break;
case SLVS_C_PT_PT_DISTANCE:     t = Constraint::Type::PT_PT_DISTANCE; break;
case SLVS_C_PT_PLANE_DISTANCE:  t = Constraint::Type::PT_PLANE_DISTANCE; break;
case SLVS_C_PT_LINE_DISTANCE:   t = Constraint::Type::PT_LINE_DISTANCE; break;
case SLVS_C_PT_FACE_DISTANCE:   t = Constraint::Type::PT_FACE_DISTANCE; break;
case SLVS_C_PT_IN_PLANE:        t = Constraint::Type::PT_IN_PLANE; break;
case SLVS_C_PT_ON_LINE:         t = Constraint::Type::PT_ON_LINE; break;
case SLVS_C_PT_ON_FACE:         t = Constraint::Type::PT_ON_FACE; break;
case SLVS_C_EQUAL_LENGTH_LINES: t = Constraint::Type::EQUAL_LENGTH_LINES; break;
case SLVS_C_LENGTH_RATIO:       t = Constraint::Type::LENGTH_RATIO; break;
case SLVS_C_EQ_LEN_PT_LINE_D:   t = Constraint::Type::EQ_LEN_PT_LINE_D; break;
case SLVS_C_EQ_PT_LN_DISTANCES: t = Constraint::Type::EQ_PT_LN_DISTANCES; break;
case SLVS_C_EQUAL_ANGLE:        t = Constraint::Type::EQUAL_ANGLE; break;
case SLVS_C_EQUAL_LINE_ARC_LEN: t = Constraint::Type::EQUAL_LINE_ARC_LEN; break;
case SLVS_C_LENGTH_DIFFERENCE:  t = Constraint::Type::LENGTH_DIFFERENCE; break;
case SLVS_C_SYMMETRIC:          t = Constraint::Type::SYMMETRIC; break;
case SLVS_C_SYMMETRIC_HORIZ:    t = Constraint::Type::SYMMETRIC_HORIZ; break;
case SLVS_C_SYMMETRIC_VERT:     t = Constraint::Type::SYMMETRIC_VERT; break;
case SLVS_C_SYMMETRIC_LINE:     t = Constraint::Type::SYMMETRIC_LINE; break;
case SLVS_C_AT_MIDPOINT:        t = Constraint::Type::AT_MIDPOINT; break;
case SLVS_C_HORIZONTAL:         t = Constraint::Type::HORIZONTAL; break;
case SLVS_C_VERTICAL:           t = Constraint::Type::VERTICAL; break;
case SLVS_C_DIAMETER:           t = Constraint::Type::DIAMETER; break;
case SLVS_C_PT_ON_CIRCLE:       t = Constraint::Type::PT_ON_CIRCLE; break;
case SLVS_C_SAME_ORIENTATION:   t = Constraint::Type::SAME_ORIENTATION; break;
case SLVS_C_ANGLE:              t = Constraint::Type::ANGLE; break;
case SLVS_C_PARALLEL:           t = Constraint::Type::PARALLEL; break;
case SLVS_C_PERPENDICULAR:      t = Constraint::Type::PERPENDICULAR; break;
case SLVS_C_ARC_LINE_TANGENT:   t = Constraint::Type::ARC_LINE_TANGENT; break;
case SLVS_C_CUBIC_LINE_TANGENT: t = Constraint::Type::CUBIC_LINE_TANGENT; break;
case SLVS_C_EQUAL_RADIUS:       t = Constraint::Type::EQUAL_RADIUS; break;
case SLVS_C_PROJ_PT_DISTANCE:   t = Constraint::Type::PROJ_PT_DISTANCE; break;
case SLVS_C_WHERE_DRAGGED:      t = Constraint::Type::WHERE_DRAGGED; break;
case SLVS_C_CURVE_CURVE_TANGENT:t = Constraint::Type::CURVE_CURVE_TANGENT; break;

default: dbp("bad constraint type %d", sc-&gt;type); return;
        }

        c.type = t;

        c.h.v           = sc-&gt;h;
        c.group.v       = sc-&gt;group;
        c.workplane.v   = sc-&gt;wrkpl;
        c.valA          = sc-&gt;valA;
        c.ptA.v         = sc-&gt;ptA;
        c.ptB.v         = sc-&gt;ptB;
        c.entityA.v     = sc-&gt;entityA;
        c.entityB.v     = sc-&gt;entityB;
        c.entityC.v     = sc-&gt;entityC;
        c.entityD.v     = sc-&gt;entityD;
        c.other         = (sc-&gt;other) ? true : false;
        c.other2        = (sc-&gt;other2) ? true : false;

        c.Generate(&amp;params);
        if(params.n &gt; 0) {
            for(Param &amp;p : params) {
                p.h = SK.param.AddAndAssignId(&amp;p);
                c.valP = p.h;
                SYS.param.Add(&amp;p);
            }
            params.Clear();
            c.ModifyToSatisfy();
        }

        SK.constraint.Add(&amp;c);
    }

    for(i = 0; i &lt; (int)arraylen(ssys-&gt;dragged); i++) {
        if(ssys-&gt;dragged[i]) {
            hParam hp = { ssys-&gt;dragged[i] };
            SYS.dragged.Add(&amp;hp);
        }
    }

    Group g = {};
    g.h.v = shg;

    List&lt;hConstraint&gt; bad = {};

    // Now we're finally ready to solve!
    bool andFindBad = ssys-&gt;calculateFaileds ? true : false;
    SolveResult how = SYS.Solve(&amp;g, &amp;(ssys-&gt;dof), &amp;bad, andFindBad, /*andFindFree=*/false);

    switch(how) {
        case SolveResult::OKAY:
            ssys-&gt;result = SLVS_RESULT_OKAY;
            break;

        case SolveResult::DIDNT_CONVERGE:
            ssys-&gt;result = SLVS_RESULT_DIDNT_CONVERGE;
            break;

        case SolveResult::REDUNDANT_DIDNT_CONVERGE:
        case SolveResult::REDUNDANT_OKAY:
            ssys-&gt;result = SLVS_RESULT_INCONSISTENT;
            break;

        case SolveResult::TOO_MANY_UNKNOWNS:
            ssys-&gt;result = SLVS_RESULT_TOO_MANY_UNKNOWNS;
            break;
    }

    // Write the new parameter values back to our caller.
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        hParam hp = { sp-&gt;h };
        sp-&gt;val = SK.GetParam(hp)-&gt;val;
    }

    if(ssys-&gt;failed) {
        // Copy over any the list of problematic constraints.
        for(i = 0; i &lt; ssys-&gt;faileds &amp;&amp; i &lt; bad.n; i++) {
            ssys-&gt;failed[i] = bad.elem[i].v;
        }
        ssys-&gt;faileds = bad.n;
    }

    bad.Clear();
    SYS.param.Clear();
    SYS.entity.Clear();
    SYS.eq.Clear();
    SYS.dragged.Clear();

    SK.param.Clear();
    SK.entity.Clear();
    SK.constraint.Clear();

    FreeAllTemporary();
}

</t>
<t tx="leo1.20171224221224.8">void Group::GenerateDisplayItems() {
    // This is potentially slow (since we've got to triangulate a shell, or
    // to find the emphasized edges for a mesh), so we will run it only
    // if its inputs have changed.
    if(displayDirty) {
        Group *pg = RunningMeshGroup();
        if(pg &amp;&amp; thisMesh.IsEmpty() &amp;&amp; thisShell.IsEmpty()) {
            // We don't contribute any new solid model in this group, so our
            // display items are identical to the previous group's; which means
            // that we can just display those, and stop ourselves from
            // recalculating for those every time we get a change in this group.
            //
            // Note that this can end up recursing multiple times (if multiple
            // groups that contribute no solid model exist in sequence), but
            // that's okay.
            pg-&gt;GenerateDisplayItems();

            displayMesh.Clear();
            displayMesh.MakeFromCopyOf(&amp;(pg-&gt;displayMesh));

            displayOutlines.Clear();
            if(SS.GW.showEdges || SS.GW.showOutlines) {
                displayOutlines.MakeFromCopyOf(&amp;pg-&gt;displayOutlines);
            }
        } else {
            // We do contribute new solid model, so we have to triangulate the
            // shell, and edge-find the mesh.
            displayMesh.Clear();
            runningShell.TriangulateInto(&amp;displayMesh);
            STriangle *t;
            for(t = runningMesh.l.First(); t; t = runningMesh.l.NextAfter(t)) {
                STriangle trn = *t;
                Vector n = trn.Normal();
                trn.an = n;
                trn.bn = n;
                trn.cn = n;
                displayMesh.AddTriangle(&amp;trn);
            }

            displayOutlines.Clear();

            if(SS.GW.showEdges || SS.GW.showOutlines) {
                SOutlineList rawOutlines = {};
                if(runningMesh.l.n &gt; 0) {
                    // Triangle mesh only; no shell or emphasized edges.
                    runningMesh.MakeOutlinesInto(&amp;rawOutlines, EdgeKind::EMPHASIZED);
                } else {
                    displayMesh.MakeOutlinesInto(&amp;rawOutlines, EdgeKind::SHARP);
                }

                PolylineBuilder builder;
                builder.MakeFromOutlines(rawOutlines);
                builder.GenerateOutlines(&amp;displayOutlines);
                rawOutlines.Clear();
            }
        }

        // If we render this mesh, we need to know whether it's transparent,
        // and we'll want all transparent triangles last, to make the depth test
        // work correctly.
        displayMesh.PrecomputeTransparency();

        // Recalculate mass center if needed
        if(SS.centerOfMass.draw &amp;&amp; SS.centerOfMass.dirty &amp;&amp; h.v == SS.GW.activeGroup.v) {
            SS.UpdateCenterOfMass();
        }
        displayDirty = false;
    }
}

Group *Group::PreviousGroup() const {
    int i;
    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        if(g-&gt;h.v == h.v) break;
    }
    if(i == 0 || i &gt;= SK.groupOrder.n) return NULL;
    return SK.GetGroup(SK.groupOrder.elem[i - 1]);
}

Group *Group::RunningMeshGroup() const {
    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        return SK.GetGroup(opA)-&gt;RunningMeshGroup();
    } else {
        return PreviousGroup();
    }
}

</t>
<t tx="leo1.20171224221224.80">//-----------------------------------------------------------------------------
// Operations on triangle meshes, like our mesh Booleans using the BSP, and
// the stuff to check for watertightness.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

#include &lt;set&gt;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221224.81">void SMesh::Clear() {
    l.Clear();
}

</t>
<t tx="leo1.20171224221224.82">void SMesh::AddTriangle(STriMeta meta, Vector n, Vector a, Vector b, Vector c) {
    Vector ab = b.Minus(a), bc = c.Minus(b);
    Vector np = ab.Cross(bc);
    if(np.Magnitude() &lt; 1e-10) {
        // ugh; gl sometimes tesselates to collinear triangles
        return;
    }
    if(np.Dot(n) &gt; 0) {
        AddTriangle(meta, a, b, c);
    } else {
        AddTriangle(meta, c, b, a);
    }
}
</t>
<t tx="leo1.20171224221224.83">void SMesh::AddTriangle(STriMeta meta, Vector a, Vector b, Vector c) {
    STriangle t = {};
    t.meta = meta;
    t.a = a;
    t.b = b;
    t.c = c;
    AddTriangle(&amp;t);
}
</t>
<t tx="leo1.20171224221224.84">void SMesh::AddTriangle(const STriangle *st) {
    l.Add(st);
}

</t>
<t tx="leo1.20171224221224.85">void SMesh::DoBounding(Vector v, Vector *vmax, Vector *vmin) const {
    vmax-&gt;x = max(vmax-&gt;x, v.x);
    vmax-&gt;y = max(vmax-&gt;y, v.y);
    vmax-&gt;z = max(vmax-&gt;z, v.z);

    vmin-&gt;x = min(vmin-&gt;x, v.x);
    vmin-&gt;y = min(vmin-&gt;y, v.y);
    vmin-&gt;z = min(vmin-&gt;z, v.z);
}
</t>
<t tx="leo1.20171224221224.86">void SMesh::GetBounding(Vector *vmax, Vector *vmin) const {
    int i;
    *vmin = Vector::From( 1e12,  1e12,  1e12);
    *vmax = Vector::From(-1e12, -1e12, -1e12);
    for(i = 0; i &lt; l.n; i++) {
        STriangle *st = &amp;(l.elem[i]);
        DoBounding(st-&gt;a, vmax, vmin);
        DoBounding(st-&gt;b, vmax, vmin);
        DoBounding(st-&gt;c, vmax, vmin);
    }
}

//----------------------------------------------------------------------------
// Report the edges of the boundary of the region(s) of our mesh that lie
// within the plane n dot p = d.
//----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.87">void SMesh::MakeEdgesInPlaneInto(SEdgeList *sel, Vector n, double d) {
    SMesh m = {};
    m.MakeFromCopyOf(this);

    // Delete all triangles in the mesh that do not lie in our export plane.
    m.l.ClearTags();
    int i;
    for(i = 0; i &lt; m.l.n; i++) {
        STriangle *tr = &amp;(m.l.elem[i]);

        if((fabs(n.Dot(tr-&gt;a) - d) &gt;= LENGTH_EPS) ||
           (fabs(n.Dot(tr-&gt;b) - d) &gt;= LENGTH_EPS) ||
           (fabs(n.Dot(tr-&gt;c) - d) &gt;= LENGTH_EPS))
        {
            tr-&gt;tag  = 1;
        }
    }
    m.l.RemoveTagged();

    // Select the naked edges in our resulting open mesh.
    SKdNode *root = SKdNode::From(&amp;m);
    root-&gt;SnapToMesh(&amp;m);
    root-&gt;MakeCertainEdgesInto(sel, EdgeKind::NAKED_OR_SELF_INTER,
                               /*coplanarIsInter=*/false, NULL, NULL);

    m.Clear();
}

</t>
<t tx="leo1.20171224221224.88">void SMesh::MakeOutlinesInto(SOutlineList *sol, EdgeKind edgeKind) {
    SKdNode *root = SKdNode::From(this);
    root-&gt;MakeOutlinesInto(sol, edgeKind);
}

//-----------------------------------------------------------------------------
// When we are called, all of the triangles from l.elem[start] to the end must
// be coplanar. So we try to find a set of fewer triangles that covers the
// exact same area, in order to reduce the number of triangles in the mesh.
// We use this after a triangle has been split against the BSP.
//
// This is really ugly code; basically it just pastes things together to
// form convex polygons, merging collinear edges when possible, then
// triangulates the convex poly.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221224.89">void SMesh::Simplify(int start) {
    int maxTriangles = (l.n - start) + 10;

    STriMeta meta = l.elem[start].meta;

    STriangle *tout = (STriangle *)AllocTemporary(maxTriangles*sizeof(*tout));
    int toutc = 0;

    Vector n = Vector::From(0, 0, 0);
    Vector *conv = (Vector *)AllocTemporary(maxTriangles*3*sizeof(*conv));
    int convc = 0;

    int start0 = start;

    int i, j;
    for(i = start; i &lt; l.n; i++) {
        STriangle *tr = &amp;(l.elem[i]);
        if(tr-&gt;MinAltitude() &lt; LENGTH_EPS) {
            tr-&gt;tag = 1;
        } else {
            tr-&gt;tag = 0;
        }
    }

    for(;;) {
        bool didAdd;
        convc = 0;
        for(i = start; i &lt; l.n; i++) {
            STriangle *tr = &amp;(l.elem[i]);
            if(tr-&gt;tag) continue;

            tr-&gt;tag = 1;
            n = (tr-&gt;Normal()).WithMagnitude(1);
            conv[convc++] = tr-&gt;a;
            conv[convc++] = tr-&gt;b;
            conv[convc++] = tr-&gt;c;

            start = i+1;
            break;
        }
        if(i &gt;= l.n) break;

        do {
            didAdd = false;

            for(j = 0; j &lt; convc; j++) {
                Vector a = conv[WRAP((j-1), convc)],
                       b = conv[j],
                       d = conv[WRAP((j+1), convc)],
                       e = conv[WRAP((j+2), convc)];

                Vector c;
                for(i = start; i &lt; l.n; i++) {
                    STriangle *tr = &amp;(l.elem[i]);
                    if(tr-&gt;tag) continue;

                    if((tr-&gt;a).Equals(d) &amp;&amp; (tr-&gt;b).Equals(b)) {
                        c = tr-&gt;c;
                    } else if((tr-&gt;b).Equals(d) &amp;&amp; (tr-&gt;c).Equals(b)) {
                        c = tr-&gt;a;
                    } else if((tr-&gt;c).Equals(d) &amp;&amp; (tr-&gt;a).Equals(b)) {
                        c = tr-&gt;b;
                    } else {
                        continue;
                    }
                    // The vertex at C must be convex; but the others must
                    // be tested
                    Vector ab = b.Minus(a);
                    Vector bc = c.Minus(b);
                    Vector cd = d.Minus(c);
                    Vector de = e.Minus(d);

                    double bDot = (ab.Cross(bc)).Dot(n);
                    double dDot = (cd.Cross(de)).Dot(n);

                    bDot /= min(ab.Magnitude(), bc.Magnitude());
                    dDot /= min(cd.Magnitude(), de.Magnitude());

                    if(fabs(bDot) &lt; LENGTH_EPS &amp;&amp; fabs(dDot) &lt; LENGTH_EPS) {
                        conv[WRAP((j+1), convc)] = c;
                        // and remove the vertex at j, which is a dup
                        memmove(conv+j, conv+j+1,
                                          (convc - j - 1)*sizeof(conv[0]));
                        convc--;
                    } else if(fabs(bDot) &lt; LENGTH_EPS &amp;&amp; dDot &gt; 0) {
                        conv[j] = c;
                    } else if(fabs(dDot) &lt; LENGTH_EPS &amp;&amp; bDot &gt; 0) {
                        conv[WRAP((j+1), convc)] = c;
                    } else if(bDot &gt; 0 &amp;&amp; dDot &gt; 0) {
                        // conv[j] is unchanged, conv[j+1] goes to [j+2]
                        memmove(conv+j+2, conv+j+1,
                                            (convc - j - 1)*sizeof(conv[0]));
                        conv[j+1] = c;
                        convc++;
                    } else {
                        continue;
                    }

                    didAdd = true;
                    tr-&gt;tag = 1;
                    break;
                }
            }
        } while(didAdd);

        // I need to debug why this is required; sometimes the above code
        // still generates a convex polygon
        for(i = 0; i &lt; convc; i++) {
            Vector a = conv[WRAP((i-1), convc)],
                   b = conv[i],
                   c = conv[WRAP((i+1), convc)];
            Vector ab = b.Minus(a);
            Vector bc = c.Minus(b);
            double bDot = (ab.Cross(bc)).Dot(n);
            bDot /= min(ab.Magnitude(), bc.Magnitude());

            if(bDot &lt; 0) return; // XXX, shouldn't happen
        }

        for(i = 0; i &lt; convc - 2; i++) {
            STriangle tr = STriangle::From(meta, conv[0], conv[i+1], conv[i+2]);
            if(tr.MinAltitude() &gt; LENGTH_EPS) {
                tout[toutc++] = tr;
            }
        }
    }

    l.n = start0;
    for(i = 0; i &lt; toutc; i++) {
        AddTriangle(&amp;(tout[i]));
    }
    FreeTemporary(tout);
    FreeTemporary(conv);
}

</t>
<t tx="leo1.20171224221224.9">bool Group::IsMeshGroup() {
    switch(type) {
        case Group::Type::EXTRUDE:
        case Group::Type::LATHE:
        case Group::Type::ROTATE:
        case Group::Type::TRANSLATE:
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo1.20171224221224.90">void SMesh::AddAgainstBsp(SMesh *srcm, SBsp3 *bsp3) {
    int i;

    for(i = 0; i &lt; srcm-&gt;l.n; i++) {
        STriangle *st = &amp;(srcm-&gt;l.elem[i]);
        int pn = l.n;
        atLeastOneDiscarded = false;
        SBsp3::InsertOrCreate(bsp3, st, this);
        if(!atLeastOneDiscarded &amp;&amp; (l.n != (pn+1))) {
            l.n = pn;
            if(flipNormal) {
                AddTriangle(st-&gt;meta, st-&gt;c, st-&gt;b, st-&gt;a);
            } else {
                AddTriangle(st-&gt;meta, st-&gt;a, st-&gt;b, st-&gt;c);
            }
        }
        if(l.n - pn &gt; 1) {
            Simplify(pn);
        }
    }
}

</t>
<t tx="leo1.20171224221224.91">void SMesh::MakeFromUnionOf(SMesh *a, SMesh *b) {
    SBsp3 *bspa = SBsp3::FromMesh(a);
    SBsp3 *bspb = SBsp3::FromMesh(b);

    flipNormal = false;
    keepCoplanar = false;
    AddAgainstBsp(b, bspa);

    flipNormal = false;
    keepCoplanar = true;
    AddAgainstBsp(a, bspb);
}

</t>
<t tx="leo1.20171224221224.92">void SMesh::MakeFromDifferenceOf(SMesh *a, SMesh *b) {
    SBsp3 *bspa = SBsp3::FromMesh(a);
    SBsp3 *bspb = SBsp3::FromMesh(b);

    flipNormal = true;
    keepCoplanar = true;
    AddAgainstBsp(b, bspa);

    flipNormal = false;
    keepCoplanar = false;
    AddAgainstBsp(a, bspb);
}

</t>
<t tx="leo1.20171224221224.93">void SMesh::MakeFromCopyOf(SMesh *a) {
    int i;
    for(i = 0; i &lt; a-&gt;l.n; i++) {
        AddTriangle(&amp;(a-&gt;l.elem[i]));
    }
}

</t>
<t tx="leo1.20171224221224.94">void SMesh::MakeFromAssemblyOf(SMesh *a, SMesh *b) {
    MakeFromCopyOf(a);
    MakeFromCopyOf(b);
}

</t>
<t tx="leo1.20171224221224.95">void SMesh::MakeFromTransformationOf(SMesh *a, Vector trans,
                                     Quaternion q, double scale)
{
    STriangle *tr;
    for(tr = a-&gt;l.First(); tr; tr = a-&gt;l.NextAfter(tr)) {
        STriangle tt = *tr;
        tt.a = (tt.a).ScaledBy(scale);
        tt.b = (tt.b).ScaledBy(scale);
        tt.c = (tt.c).ScaledBy(scale);
        if(scale &lt; 0) {
            // The mirroring would otherwise turn a closed mesh inside out.
            swap(tt.a, tt.b);
        }
        tt.a = (q.Rotate(tt.a)).Plus(trans);
        tt.b = (q.Rotate(tt.b)).Plus(trans);
        tt.c = (q.Rotate(tt.c)).Plus(trans);
        AddTriangle(&amp;tt);
    }
}

</t>
<t tx="leo1.20171224221224.96">bool SMesh::IsEmpty() const {
    return (l.n == 0);
}

uint32_t SMesh::FirstIntersectionWith(Point2d mp) const {
    Vector rayPoint = SS.GW.UnProjectPoint3(Vector::From(mp.x, mp.y, 0.0));
    Vector rayDir = SS.GW.UnProjectPoint3(Vector::From(mp.x, mp.y, 1.0)).Minus(rayPoint);

    uint32_t face = 0;
    double faceT = VERY_NEGATIVE;
    for(int i = 0; i &lt; l.n; i++) {
        const STriangle &amp;tr = l.elem[i];
        if(tr.meta.face == 0) continue;

        double t;
        if(!tr.Raytrace(rayPoint, rayDir, &amp;t, NULL)) continue;
        if(t &gt; faceT) {
            face  = tr.meta.face;
            faceT = t;
        }
    }

    return face;
}

Vector SMesh::GetCenterOfMass() const {
    Vector center = {};
    double vol = 0.0;
    for(int i = 0; i &lt; l.n; i++) {
        STriangle &amp;tr = l.elem[i];
        double tvol = tr.SignedVolume();
        center = center.Plus(tr.a.Plus(tr.b.Plus(tr.c)).ScaledBy(tvol / 4.0));
        vol += tvol;
    }
    return center.ScaledBy(1.0 / vol);
}

STriangleLl *STriangleLl::Alloc()
    { return (STriangleLl *)AllocTemporary(sizeof(STriangleLl)); }
SKdNode *SKdNode::Alloc()
    { return (SKdNode *)AllocTemporary(sizeof(SKdNode)); }

SKdNode *SKdNode::From(SMesh *m) {
    int i;
    STriangle *tra = (STriangle *)AllocTemporary((m-&gt;l.n) * sizeof(*tra));

    for(i = 0; i &lt; m-&gt;l.n; i++) {
        tra[i] = m-&gt;l.elem[i];
    }

    srand(0);
    int n = m-&gt;l.n;
    while(n &gt; 1) {
        int k = rand() % n;
        n--;
        swap(tra[k], tra[n]);
    }

    STriangleLl *tll = NULL;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangleLl *tn = STriangleLl::Alloc();
        tn-&gt;tri = &amp;(tra[i]);
        tn-&gt;next = tll;
        tll = tn;
    }

    return SKdNode::From(tll);
}

SKdNode *SKdNode::From(STriangleLl *tll) {
    int which = 0;
    SKdNode *ret = Alloc();

    int i;
    int gtc[3] = { 0, 0, 0 }, ltc[3] = { 0, 0, 0 }, allc = 0;
    double badness[3] = { 0, 0, 0 };
    double split[3] = { 0, 0, 0 };

    if(!tll) {
        goto leaf;
    }

    for(i = 0; i &lt; 3; i++) {
        int tcnt = 0;
        STriangleLl *ll;
        for(ll = tll; ll; ll = ll-&gt;next) {
            split[i] += (ll-&gt;tri-&gt;a).Element(i);
            split[i] += (ll-&gt;tri-&gt;b).Element(i);
            split[i] += (ll-&gt;tri-&gt;c).Element(i);
            tcnt++;
        }
        split[i] /= (tcnt*3);

        for(ll = tll; ll; ll = ll-&gt;next) {
            STriangle *tr = ll-&gt;tri;

</t>
<t tx="leo1.20171224221224.97">        double a = (tr-&gt;a).Element(i),
               b = (tr-&gt;b).Element(i),
               c = (tr-&gt;c).Element(i);

        if(a &lt; split[i] + KDTREE_EPS ||
           b &lt; split[i] + KDTREE_EPS ||
           c &lt; split[i] + KDTREE_EPS)
        {
            ltc[i]++;
        }
        if(a &gt; split[i] - KDTREE_EPS ||
           b &gt; split[i] - KDTREE_EPS ||
           c &gt; split[i] - KDTREE_EPS)
        {
            gtc[i]++;
        }
        if(i == 0) allc++;
    }
    badness[i] = pow((double)ltc[i], 4) + pow((double)gtc[i], 4);
}
if(badness[0] &lt; badness[1] &amp;&amp; badness[0] &lt; badness[2]) {
    which = 0;
} else if(badness[1] &lt; badness[2]) {
    which = 1;
} else {
    which = 2;
}

if(allc &lt; 3 || allc == gtc[which] || allc == ltc[which]) {
    goto leaf;
}

STriangleLl *ll;
STriangleLl *lgt, *llt; lgt = llt = NULL;
for(ll = tll; ll; ll = ll-&gt;next) {
    STriangle *tr = ll-&gt;tri;

</t>
<t tx="leo1.20171224221224.98">        double a = (tr-&gt;a).Element(which),
               b = (tr-&gt;b).Element(which),
               c = (tr-&gt;c).Element(which);

        if(a &lt; split[which] + KDTREE_EPS ||
           b &lt; split[which] + KDTREE_EPS ||
           c &lt; split[which] + KDTREE_EPS)
        {
            STriangleLl *n = STriangleLl::Alloc();
            *n = *ll;
            n-&gt;next = llt;
            llt = n;
        }
        if(a &gt; split[which] - KDTREE_EPS ||
           b &gt; split[which] - KDTREE_EPS ||
           c &gt; split[which] - KDTREE_EPS)
        {
            STriangleLl *n = STriangleLl::Alloc();
            *n = *ll;
            n-&gt;next = lgt;
            lgt = n;
        }
    }

    ret-&gt;which = which;
    ret-&gt;c = split[which];
    ret-&gt;gt = SKdNode::From(lgt);
    ret-&gt;lt = SKdNode::From(llt);
    return ret;

leaf:
    ret-&gt;tris = tll;
    return ret;
}

</t>
<t tx="leo1.20171224221224.99">void SKdNode::ClearTags() const {
    if(gt &amp;&amp; lt) {
        gt-&gt;ClearTags();
        lt-&gt;ClearTags();
    } else {
        STriangleLl *ll;
        for(ll = tris; ll; ll = ll-&gt;next) {
            ll-&gt;tri-&gt;tag = 0;
        }
    }
}

</t>
<t tx="leo1.20171224221225.1">void GraphicsWindow::ReplacePointInConstraints(hEntity oldpt, hEntity newpt) {
    int i;
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;ptA.v == oldpt.v) c-&gt;ptA = newpt;
        if(c-&gt;ptB.v == oldpt.v) c-&gt;ptB = newpt;
    }
}

//-----------------------------------------------------------------------------
// Remove constraints on hpt. Useful when removing bezier points.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221225.10">//-----------------------------------------------------------------------------
// Anything relating to mouse, keyboard, or 6-DOF mouse input.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221225.2">void GraphicsWindow::RemoveConstraintsForPointBeingDeleted(hEntity hpt) {
    SK.constraint.ClearTags();
    for(int i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;ptA.v == hpt.v || c-&gt;ptB.v == hpt.v) {
            c-&gt;tag = 1;
            (SS.deleted.constraints)++;
            if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp;
               c-&gt;type != Constraint::Type::HORIZONTAL &amp;&amp;
               c-&gt;type != Constraint::Type::VERTICAL)
            {
                (SS.deleted.nonTrivialConstraints)++;
            }
        }
    }
    SK.constraint.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Let's say that A is coincident with B, and B is coincident with C. This
// implies that A is coincident with C; but if we delete B, then both
// constraints must be deleted too (since they reference B), and A is no
// longer constrained to C. This routine adds back that constraint.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221225.3">void GraphicsWindow::FixConstraintsForRequestBeingDeleted(hRequest hr) {
    Request *r = SK.GetRequest(hr);
    if(r-&gt;group.v != SS.GW.activeGroup.v) return;

    Entity *e;
    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(!(e-&gt;h.isFromRequest())) continue;
        if(e-&gt;h.request().v != hr.v) continue;

        if(e-&gt;type != Entity::Type::POINT_IN_2D &amp;&amp;
           e-&gt;type != Entity::Type::POINT_IN_3D)
        {
            continue;
        }

        // This is a point generated by the request being deleted; so fix
        // the constraints for that.
        FixConstraintsForPointBeingDeleted(e-&gt;h);
    }
}
</t>
<t tx="leo1.20171224221225.4">void GraphicsWindow::FixConstraintsForPointBeingDeleted(hEntity hpt) {
    List&lt;hEntity&gt; ld = {};

    Constraint *c;
    SK.constraint.ClearTags();
    for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
        if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
        if(c-&gt;group.v != SS.GW.activeGroup.v) continue;

        if(c-&gt;ptA.v == hpt.v) {
            ld.Add(&amp;(c-&gt;ptB));
            c-&gt;tag = 1;
        }
        if(c-&gt;ptB.v == hpt.v) {
            ld.Add(&amp;(c-&gt;ptA));
            c-&gt;tag = 1;
        }
    }
    // Remove constraints without waiting for regeneration; this way
    // if another point takes the place of the deleted one (e.g. when
    // removing control points of a bezier) the constraint doesn't
    // spuriously move. Similarly, subsequent calls of this function
    // (if multiple coincident points are getting deleted) will work
    // correctly.
    SK.constraint.RemoveTagged();

    // If more than one point was constrained coincident with hpt, then
    // those two points were implicitly coincident with each other. By
    // deleting hpt (and all constraints that mention it), we will delete
    // that relationship. So put it back here now.
    int i;
    for(i = 1; i &lt; ld.n; i++) {
        Constraint::ConstrainCoincident(ld.elem[i-1], ld.elem[i]);
    }
    ld.Clear();
}

//-----------------------------------------------------------------------------
// A curve by its parametric equation, helper functions for computing tangent
// arcs by a numerical method.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221225.5">void GraphicsWindow::ParametricCurve::MakeFromEntity(hEntity he, bool reverse) {
    *this = {};
    Entity *e = SK.GetEntity(he);
    if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        isLine = true;
        p0 = e-&gt;EndpointStart(),
        p1 = e-&gt;EndpointFinish();
        if(reverse) {
            swap(p0, p1);
        }
    } else if(e-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
        isLine = false;
        p0 = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
        Vector pe = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
        r = (pe.Minus(p0)).Magnitude();
        e-&gt;ArcGetAngles(&amp;theta0, &amp;theta1, &amp;dtheta);
        if(reverse) {
            swap(theta0, theta1);
            dtheta = -dtheta;
        }
        EntityBase *wrkpln = SK.GetEntity(e-&gt;workplane)-&gt;Normal();
        u = wrkpln-&gt;NormalU();
        v = wrkpln-&gt;NormalV();
    } else ssassert(false, "Unexpected entity type");
}
double GraphicsWindow::ParametricCurve::LengthForAuto() {
    if(isLine) {
        // Allow a third of the line to disappear with auto radius
        return (p1.Minus(p0)).Magnitude() / 3;
    } else {
        // But only a twentieth of the arc; shorter means fewer numerical
        // problems since the curve is more linear over shorter sections.
        return (fabs(dtheta)*r)/20;
    }
}
Vector GraphicsWindow::ParametricCurve::PointAt(double t) {
    if(isLine) {
        return p0.Plus((p1.Minus(p0)).ScaledBy(t));
    } else {
        double theta = theta0 + dtheta*t;
        return p0.Plus(u.ScaledBy(r*cos(theta)).Plus(v.ScaledBy(r*sin(theta))));
    }
}
Vector GraphicsWindow::ParametricCurve::TangentAt(double t) {
    if(isLine) {
        return p1.Minus(p0);
    } else {
        double theta = theta0 + dtheta*t;
        Vector t =  u.ScaledBy(-r*sin(theta)).Plus(v.ScaledBy(r*cos(theta)));
        t = t.ScaledBy(dtheta);
        return t;
    }
}
hRequest GraphicsWindow::ParametricCurve::CreateRequestTrimmedTo(double t,
</t>
<t tx="leo1.20171224221225.6">    bool extraConstraints, hEntity orig, hEntity arc, bool arcFinish)
{
    hRequest hr;
    Entity *e;
    if(isLine) {
        hr = SS.GW.AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false),
        e = SK.GetEntity(hr.entity(0));
        SK.GetEntity(e-&gt;point[0])-&gt;PointForceTo(PointAt(t));
        SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(1));
        ConstrainPointIfCoincident(e-&gt;point[0]);
        ConstrainPointIfCoincident(e-&gt;point[1]);
        if(extraConstraints) {
            Constraint::Constrain(Constraint::Type::PT_ON_LINE,
                hr.entity(1), Entity::NO_ENTITY, orig);
        }
        Constraint::Constrain(Constraint::Type::ARC_LINE_TANGENT,
            Entity::NO_ENTITY, Entity::NO_ENTITY,
            arc, e-&gt;h, /*other=*/arcFinish, /*other2=*/false);
    } else {
        hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false),
        e = SK.GetEntity(hr.entity(0));
        SK.GetEntity(e-&gt;point[0])-&gt;PointForceTo(p0);
        if(dtheta &gt; 0) {
            SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(t));
            SK.GetEntity(e-&gt;point[2])-&gt;PointForceTo(PointAt(1));
        } else {
            SK.GetEntity(e-&gt;point[2])-&gt;PointForceTo(PointAt(t));
            SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(1));
        }
        ConstrainPointIfCoincident(e-&gt;point[0]);
        ConstrainPointIfCoincident(e-&gt;point[1]);
        ConstrainPointIfCoincident(e-&gt;point[2]);
        // The tangency constraint alone is enough to fully constrain it,
        // so there's no need for more.
        Constraint::Constrain(Constraint::Type::CURVE_CURVE_TANGENT,
            Entity::NO_ENTITY, Entity::NO_ENTITY,
            arc, e-&gt;h, /*other=*/arcFinish, /*other2=*/(dtheta &lt; 0));
    }
    return hr;
}

//-----------------------------------------------------------------------------
// If a point in the same group as hpt, and numerically coincident with hpt,
// happens to exist, then constrain that point coincident to hpt.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221225.7">void GraphicsWindow::ParametricCurve::ConstrainPointIfCoincident(hEntity hpt) {
    Entity *e, *pt;
    pt = SK.GetEntity(hpt);
    Vector ev, ptv;
    ptv = pt-&gt;PointGetNum();

    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(e-&gt;h.v == pt-&gt;h.v) continue;
        if(!e-&gt;IsPoint()) continue;
        if(e-&gt;group.v != pt-&gt;group.v) continue;
        if(e-&gt;workplane.v != pt-&gt;workplane.v) continue;

        ev = e-&gt;PointGetNum();
        if(!ev.Equals(ptv)) continue;

        Constraint::ConstrainCoincident(hpt, e-&gt;h);
        break;
    }
}

//-----------------------------------------------------------------------------
// A single point must be selected when this function is called. We find two
// non-construction line segments that join at this point, and create a
// tangent arc joining them.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221225.8">void GraphicsWindow::MakeTangentArc() {
    if(!LockedInWorkplane()) {
        Error(_("Must be sketching in workplane to create tangent arc."));
        return;
    }

    // The point corresponding to the vertex to be rounded.
    Vector pshared = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
    ClearSelection();

    // First, find two requests (that are not construction, and that are
    // in our group and workplane) that generate entities that have an
    // endpoint at our vertex to be rounded.
    int i, c = 0;
    Entity *ent[2];
    Request *req[2];
    hRequest hreq[2];
    hEntity hent[2];
    bool pointf[2];
    for(i = 0; i &lt; SK.request.n; i++) {
        Request *r = &amp;(SK.request.elem[i]);
        if(r-&gt;group.v != activeGroup.v) continue;
        if(r-&gt;workplane.v != ActiveWorkplane().v) continue;
        if(r-&gt;construction) continue;
        if(r-&gt;type != Request::Type::LINE_SEGMENT &amp;&amp;
           r-&gt;type != Request::Type::ARC_OF_CIRCLE)
        {
            continue;
        }

        Entity *e = SK.GetEntity(r-&gt;h.entity(0));
        Vector ps = e-&gt;EndpointStart(),
               pf = e-&gt;EndpointFinish();

        if(ps.Equals(pshared) || pf.Equals(pshared)) {
            if(c &lt; 2) {
                // We record the entity and request and their handles,
                // and whether the vertex to be rounded is the start or
                // finish of this entity.
                ent[c] = e;
                hent[c] = e-&gt;h;
                req[c] = r;
                hreq[c] = r-&gt;h;
                pointf[c] = (pf.Equals(pshared));
            }
            c++;
        }
    }
    if(c != 2) {
        Error(_("To create a tangent arc, select a point where two "
                "non-construction lines or circles in this group and "
                "workplane join."));
        return;
    }

    Entity *wrkpl = SK.GetEntity(ActiveWorkplane());
    Vector wn = wrkpl-&gt;Normal()-&gt;NormalN();

    // Based on these two entities, we make the objects that we'll use to
    // numerically find the tangent arc.
    ParametricCurve pc[2];
    pc[0].MakeFromEntity(ent[0]-&gt;h, pointf[0]);
    pc[1].MakeFromEntity(ent[1]-&gt;h, pointf[1]);

    // And thereafter we mustn't touch the entity or req ptrs,
    // because the new requests/entities we add might force a
    // realloc.
    memset(ent, 0, sizeof(ent));
    memset(req, 0, sizeof(req));

    Vector pinter;
    double r = 0.0, vv = 0.0;
    // We now do Newton iterations to find the tangent arc, and its positions
    // t back along the two curves, starting from shared point of the curves
    // at t = 0. Lots of iterations helps convergence, and this is still
    // ~10 ms for everything.
    int iters = 1000;
    double t[2] = { 0, 0 }, tp[2];
    for(i = 0; i &lt; iters + 20; i++) {
        Vector p0 = pc[0].PointAt(t[0]),
               p1 = pc[1].PointAt(t[1]),
               t0 = pc[0].TangentAt(t[0]),
               t1 = pc[1].TangentAt(t[1]);

        pinter = Vector::AtIntersectionOfLines(p0, p0.Plus(t0),
                                               p1, p1.Plus(t1),
                                               NULL, NULL, NULL);

        // The sign of vv determines whether shortest distance is
        // clockwise or anti-clockwise.
        Vector v = (wn.Cross(t0)).WithMagnitude(1);
        vv = t1.Dot(v);

        double dot = (t0.WithMagnitude(1)).Dot(t1.WithMagnitude(1));
        double theta = acos(dot);

        if(SS.tangentArcManual) {
            r = SS.tangentArcRadius;
        } else {
            r = 200/scale;
            // Set the radius so that no more than one third of the
            // line segment disappears.
            r = min(r, pc[0].LengthForAuto()*tan(theta/2));
            r = min(r, pc[1].LengthForAuto()*tan(theta/2));;
        }
        // We are source-stepping the radius, to improve convergence. So
        // ramp that for most of the iterations, and then do a few at
        // the end with that constant for polishing.
        if(i &lt; iters) {
            r *= 0.1 + 0.9*i/((double)iters);
        }

        // The distance from the intersection of the lines to the endpoint
        // of the arc, along each line.
        double el = r/tan(theta/2);

        // Compute the endpoints of the arc, for each curve
        Vector pa0 = pinter.Plus(t0.WithMagnitude(el)),
               pa1 = pinter.Plus(t1.WithMagnitude(el));

        tp[0] = t[0];
        tp[1] = t[1];

        // And convert those points to parameter values along the curve.
        t[0] += (pa0.Minus(p0)).DivPivoting(t0);
        t[1] += (pa1.Minus(p1)).DivPivoting(t1);
    }

    // Stupid check for convergence, and for an out of range result (as
    // we would get, for example, if the line is too short to fit the
    // rounding arc).
    if(fabs(tp[0] - t[0]) &gt; 1e-3 || fabs(tp[1] - t[1]) &gt; 1e-3 ||
        t[0] &lt; 0.01 || t[1] &lt; 0.01 ||
        t[0] &gt; 0.99 || t[1] &gt; 0.99 ||
        isnan(t[0]) || isnan(t[1]))
    {
        Error(_("Couldn't round this corner. Try a smaller radius, or try "
                "creating the desired geometry by hand with tangency "
                "constraints."));
        return;
    }

    // Compute the location of the center of the arc
    Vector center = pc[0].PointAt(t[0]),
           v0inter = pinter.Minus(center);
    int a, b;
    if(vv &lt; 0) {
        a = 1; b = 2;
        center = center.Minus(v0inter.Cross(wn).WithMagnitude(r));
    } else {
        a = 2; b = 1;
        center = center.Plus(v0inter.Cross(wn).WithMagnitude(r));
    }

    SS.UndoRemember();

    hRequest harc = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    Entity *earc = SK.GetEntity(harc.entity(0));
    hEntity hearc = earc-&gt;h;

    SK.GetEntity(earc-&gt;point[0])-&gt;PointForceTo(center);
    SK.GetEntity(earc-&gt;point[a])-&gt;PointForceTo(pc[0].PointAt(t[0]));
    SK.GetEntity(earc-&gt;point[b])-&gt;PointForceTo(pc[1].PointAt(t[1]));

    earc = NULL;

    pc[0].CreateRequestTrimmedTo(t[0], !SS.tangentArcDeleteOld,
                hent[0], hearc, /*arcFinish=*/(b == 1));
    pc[1].CreateRequestTrimmedTo(t[1], !SS.tangentArcDeleteOld,
                hent[1], hearc, /*arcFinish=*/(a == 1));

    // Now either make the original entities construction, or delete them
    // entirely, according to user preference.
    Request *re;
    SK.request.ClearTags();
    for(re = SK.request.First(); re; re = SK.request.NextAfter(re)) {
        if(re-&gt;h.v == hreq[0].v || re-&gt;h.v == hreq[1].v) {
            if(SS.tangentArcDeleteOld) {
                re-&gt;tag = 1;
            } else {
                re-&gt;construction = true;
            }
        }
    }
    if(SS.tangentArcDeleteOld) {
        DeleteTaggedRequests();
    }
}

hEntity GraphicsWindow::SplitLine(hEntity he, Vector pinter) {
    // Save the original endpoints, since we're about to delete this entity.
    Entity *e01 = SK.GetEntity(he);
    hEntity hep0 = e01-&gt;point[0], hep1 = e01-&gt;point[1];
    Vector p0 = SK.GetEntity(hep0)-&gt;PointGetNum(),
           p1 = SK.GetEntity(hep1)-&gt;PointGetNum();

    // Add the two line segments this one gets split into.
    hRequest r0i = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false),
             ri1 = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
    // Don't get entities till after adding, realloc issues

    Entity *e0i = SK.GetEntity(r0i.entity(0)),
           *ei1 = SK.GetEntity(ri1.entity(0));

    SK.GetEntity(e0i-&gt;point[0])-&gt;PointForceTo(p0);
    SK.GetEntity(e0i-&gt;point[1])-&gt;PointForceTo(pinter);
    SK.GetEntity(ei1-&gt;point[0])-&gt;PointForceTo(pinter);
    SK.GetEntity(ei1-&gt;point[1])-&gt;PointForceTo(p1);

    ReplacePointInConstraints(hep0, e0i-&gt;point[0]);
    ReplacePointInConstraints(hep1, ei1-&gt;point[1]);
    Constraint::ConstrainCoincident(e0i-&gt;point[1], ei1-&gt;point[0]);
    return e0i-&gt;point[1];
}

hEntity GraphicsWindow::SplitCircle(hEntity he, Vector pinter) {
    Entity *circle = SK.GetEntity(he);
    if(circle-&gt;type == Entity::Type::CIRCLE) {
        // Start with an unbroken circle, split it into a 360 degree arc.
        Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();

        circle = NULL; // shortly invalid!
        hRequest hr = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);

        Entity *arc = SK.GetEntity(hr.entity(0));

        SK.GetEntity(arc-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc-&gt;point[1])-&gt;PointForceTo(pinter);
        SK.GetEntity(arc-&gt;point[2])-&gt;PointForceTo(pinter);

        Constraint::ConstrainCoincident(arc-&gt;point[1], arc-&gt;point[2]);
        return arc-&gt;point[1];
    } else {
        // Start with an arc, break it in to two arcs
        hEntity hc = circle-&gt;point[0],
                hs = circle-&gt;point[1],
                hf = circle-&gt;point[2];
        Vector center = SK.GetEntity(hc)-&gt;PointGetNum(),
               start  = SK.GetEntity(hs)-&gt;PointGetNum(),
               finish = SK.GetEntity(hf)-&gt;PointGetNum();

        circle = NULL; // shortly invalid!
        hRequest hr0 = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false),
                 hr1 = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);

        Entity *arc0 = SK.GetEntity(hr0.entity(0)),
               *arc1 = SK.GetEntity(hr1.entity(0));

        SK.GetEntity(arc0-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc0-&gt;point[1])-&gt;PointForceTo(start);
        SK.GetEntity(arc0-&gt;point[2])-&gt;PointForceTo(pinter);

        SK.GetEntity(arc1-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc1-&gt;point[1])-&gt;PointForceTo(pinter);
        SK.GetEntity(arc1-&gt;point[2])-&gt;PointForceTo(finish);

        ReplacePointInConstraints(hs, arc0-&gt;point[1]);
        ReplacePointInConstraints(hf, arc1-&gt;point[2]);
        Constraint::ConstrainCoincident(arc0-&gt;point[2], arc1-&gt;point[1]);
        return arc0-&gt;point[2];
    }
}

hEntity GraphicsWindow::SplitCubic(hEntity he, Vector pinter) {
    // Save the original endpoints, since we're about to delete this entity.
    Entity *e01 = SK.GetEntity(he);
    SBezierList sbl = {};
    e01-&gt;GenerateBezierCurves(&amp;sbl);

    hEntity hep0 = e01-&gt;point[0],
            hep1 = e01-&gt;point[3+e01-&gt;extraPoints],
            hep0n = Entity::NO_ENTITY, // the new start point
            hep1n = Entity::NO_ENTITY, // the new finish point
            hepin = Entity::NO_ENTITY; // the intersection point

    // The curve may consist of multiple cubic segments. So find which one
    // contains the intersection point.
    double t;
    int i, j;
    for(i = 0; i &lt; sbl.l.n; i++) {
        SBezier *sb = &amp;(sbl.l.elem[i]);
        ssassert(sb-&gt;deg == 3, "Expected a cubic bezier");

        sb-&gt;ClosestPointTo(pinter, &amp;t, /*mustConverge=*/false);
        if(pinter.Equals(sb-&gt;PointAt(t))) {
            // Split that segment at the intersection.
            SBezier b0i, bi1, b01 = *sb;
            b01.SplitAt(t, &amp;b0i, &amp;bi1);

            // Add the two cubic segments this one gets split into.
            hRequest r0i = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false),
                     ri1 = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
            // Don't get entities till after adding, realloc issues

            Entity *e0i = SK.GetEntity(r0i.entity(0)),
                   *ei1 = SK.GetEntity(ri1.entity(0));

            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(e0i-&gt;point[j])-&gt;PointForceTo(b0i.ctrl[j]);
            }
            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(ei1-&gt;point[j])-&gt;PointForceTo(bi1.ctrl[j]);
            }

            Constraint::ConstrainCoincident(e0i-&gt;point[3], ei1-&gt;point[0]);
            if(i == 0) hep0n = e0i-&gt;point[0];
            hep1n = ei1-&gt;point[3];
            hepin = e0i-&gt;point[3];
        } else {
            hRequest r = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
            Entity *e = SK.GetEntity(r.entity(0));

            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(e-&gt;point[j])-&gt;PointForceTo(sb-&gt;ctrl[j]);
            }

            if(i == 0) hep0n = e-&gt;point[0];
            hep1n = e-&gt;point[3];
        }
    }

    sbl.Clear();

    ReplacePointInConstraints(hep0, hep0n);
    ReplacePointInConstraints(hep1, hep1n);
    return hepin;
}

hEntity GraphicsWindow::SplitEntity(hEntity he, Vector pinter) {
    Entity *e = SK.GetEntity(he);
    Entity::Type entityType = e-&gt;type;

    hEntity ret;
    if(e-&gt;IsCircle()) {
        ret = SplitCircle(he, pinter);
    } else if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        ret = SplitLine(he, pinter);
    } else if(e-&gt;type == Entity::Type::CUBIC || e-&gt;type == Entity::Type::CUBIC_PERIODIC) {
        ret = SplitCubic(he, pinter);
    } else {
        Error(_("Couldn't split this entity; lines, circles, or cubics only."));
        return Entity::NO_ENTITY;
    }

    // Finally, delete the request that generated the original entity.
    Request::Type reqType = EntReqTable::GetRequestForEntity(entityType);
    SK.request.ClearTags();
    for(int i = 0; i &lt; SK.request.n; i++) {
        Request *r = &amp;(SK.request.elem[i]);
        if(r-&gt;group.v != activeGroup.v) continue;
        if(r-&gt;type != reqType) continue;

        // If the user wants to keep the old entities around, they can just
        // mark them construction first.
        if(he.v == r-&gt;h.entity(0).v &amp;&amp; !r-&gt;construction) {
            r-&gt;tag = 1;
            break;
        }
    }
    DeleteTaggedRequests();

    return ret;
}

</t>
<t tx="leo1.20171224221225.9">void GraphicsWindow::SplitLinesOrCurves() {
    if(!LockedInWorkplane()) {
        Error(_("Must be sketching in workplane to split."));
        return;
    }

    GroupSelection();
    if(!(gs.n == 2 &amp;&amp;(gs.lineSegments +
                      gs.circlesOrArcs +
                      gs.cubics +
                      gs.periodicCubics) == 2))
    {
        Error(_("Select two entities that intersect each other (e.g. two lines "
                "or two circles or a circle and a line)."));
        return;
    }

    hEntity ha = gs.entity[0],
            hb = gs.entity[1];
    Entity *ea = SK.GetEntity(ha),
           *eb = SK.GetEntity(hb);

    // Compute the possibly-rational Bezier curves for each of these entities
    SBezierList sbla, sblb;
    sbla = {};
    sblb = {};
    ea-&gt;GenerateBezierCurves(&amp;sbla);
    eb-&gt;GenerateBezierCurves(&amp;sblb);
    // and then compute the points where they intersect, based on those curves.
    SPointList inters = {};
    sbla.AllIntersectionsWith(&amp;sblb, &amp;inters);

    if(inters.l.n &gt; 0) {
        Vector pi = Vector::From(0, 0, 0);
        // If there's multiple points, then take the one closest to the
        // mouse pointer.
        double dmin = VERY_POSITIVE;
        SPoint *sp;
        for(sp = inters.l.First(); sp; sp = inters.l.NextAfter(sp)) {
            double d = ProjectPoint(sp-&gt;p).DistanceTo(currentMousePosition);
            if(d &lt; dmin) {
                dmin = d;
                pi = sp-&gt;p;
            }
        }

        SS.UndoRemember();
        hEntity hia = SplitEntity(ha, pi),
                hib = SplitEntity(hb, pi);
        // SplitEntity adds the coincident constraints to join the split halves
        // of each original entity; and then we add the constraint to join
        // the two entities together at the split point.
        if(hia.v &amp;&amp; hib.v) {
            Constraint::ConstrainCoincident(hia, hib);
        }
    } else {
        Error(_("Can't split; no intersection found."));
    }

    // All done, clean up and regenerate.
    inters.Clear();
    sbla.Clear();
    sblb.Clear();
    ClearSelection();
}

</t>
<t tx="leo1.20171224221227.1">void GraphicsWindow::UpdateDraggedPoint(hEntity hp, double mx, double my) {
    Entity *p = SK.GetEntity(hp);
    Vector pos = p-&gt;PointGetNum();
    UpdateDraggedNum(&amp;pos, mx, my);
    p-&gt;PointForceTo(pos);
}

</t>
<t tx="leo1.20171224221227.10">void GraphicsWindow::ReplacePending(hRequest before, hRequest after) {
    for(auto &amp;req : pending.requests) {
        if(req.v == before.v) {
            req.v = after.v;
        }
    }
}

</t>
<t tx="leo1.20171224221227.11">void GraphicsWindow::MouseMiddleOrRightDown(double x, double y) {
    if(GraphicsEditControlIsVisible()) return;

    orig.offset = offset;
    orig.projUp = projUp;
    orig.projRight = projRight;
    orig.mouse.x = x;
    orig.mouse.y = y;
    orig.startedMoving = false;
}

</t>
<t tx="leo1.20171224221227.12">void GraphicsWindow::ContextMenuListStyles() {
    CreateContextSubmenu();
    Style *s;
    bool empty = true;
    for(s = SK.style.First(); s; s = SK.style.NextAfter(s)) {
        if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) continue;

        AddContextMenuItem(s-&gt;DescriptionString().c_str(),
                           (ContextCommand)((uint32_t)ContextCommand::FIRST_STYLE + s-&gt;h.v));
        empty = false;
    }

    if(!empty) AddContextMenuItem(NULL, ContextCommand::SEPARATOR);

    AddContextMenuItem(_("No Style"), ContextCommand::NO_STYLE);
    AddContextMenuItem(_("Newly Created Custom Style..."), ContextCommand::NEW_CUSTOM_STYLE);
}

</t>
<t tx="leo1.20171224221227.13">void GraphicsWindow::MouseRightUp(double x, double y) {
    SS.extraLine.draw = false;
    InvalidateGraphics();

    // Don't show a context menu if the user is right-clicking the toolbar,
    // or if they are finishing a pan.
    if(ToolbarMouseMoved((int)x, (int)y)) return;
    if(orig.startedMoving) return;

    if(context.active) return;

    if(pending.operation == Pending::DRAGGING_NEW_LINE_POINT &amp;&amp; pending.hasSuggestion) {
        Constraint::Constrain(SS.GW.pending.suggestion,
            Entity::NO_ENTITY, Entity::NO_ENTITY, pending.request.entity(0));
    }

    if(pending.operation == Pending::DRAGGING_NEW_LINE_POINT ||
       pending.operation == Pending::DRAGGING_NEW_CUBIC_POINT)
    {
        // Special case; use a right click to stop drawing lines, since
        // a left click would draw another one. This is quicker and more
        // intuitive than hitting escape. Likewise for new cubic segments.
        ClearPending();
        return;
    }

    // The current mouse location
    Vector v = offset.ScaledBy(-1);
    v = v.Plus(projRight.ScaledBy(x/scale));
    v = v.Plus(projUp.ScaledBy(y/scale));

    context.active = true;

    if(!hover.IsEmpty()) {
        MakeSelected(&amp;hover);
        SS.ScheduleShowTW();
    }
    GroupSelection();

    bool itemsSelected = (gs.n &gt; 0 || gs.constraints &gt; 0);
    int addAfterPoint = -1;

    if(itemsSelected) {
        if(gs.stylables &gt; 0) {
            ContextMenuListStyles();
            AddContextMenuItem(_("Assign to Style"), ContextCommand::SUBMENU);
        }
        if(gs.n + gs.constraints == 1) {
            AddContextMenuItem(_("Group Info"), ContextCommand::GROUP_INFO);
        }
        if(gs.n + gs.constraints == 1 &amp;&amp; gs.stylables == 1) {
            AddContextMenuItem(_("Style Info"), ContextCommand::STYLE_INFO);
        }
        if(gs.withEndpoints &gt; 0) {
            AddContextMenuItem(_("Select Edge Chain"), ContextCommand::SELECT_CHAIN);
        }
        if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
            Constraint *c = SK.GetConstraint(gs.constraint[0]);
            if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Constraint::Type::COMMENT) {
                AddContextMenuItem(_("Toggle Reference Dimension"),
                    ContextCommand::REFERENCE_DIM);
            }
            if(c-&gt;type == Constraint::Type::ANGLE ||
               c-&gt;type == Constraint::Type::EQUAL_ANGLE)
            {
                AddContextMenuItem(_("Other Supplementary Angle"),
                    ContextCommand::OTHER_ANGLE);
            }
        }
        if(gs.constraintLabels &gt; 0 || gs.points &gt; 0) {
            AddContextMenuItem(_("Snap to Grid"), ContextCommand::SNAP_TO_GRID);
        }

        if(gs.points == 1 &amp;&amp; gs.point[0].isFromRequest()) {
            Request *r = SK.GetRequest(gs.point[0].request());
            int index = r-&gt;IndexOfPoint(gs.point[0]);
            if((r-&gt;type == Request::Type::CUBIC &amp;&amp; (index &gt; 1 &amp;&amp; index &lt; r-&gt;extraPoints + 2)) ||
                    r-&gt;type == Request::Type::CUBIC_PERIODIC) {
                AddContextMenuItem(_("Remove Spline Point"), ContextCommand::REMOVE_SPLINE_PT);
            }
        }
        if(gs.entities == 1 &amp;&amp; gs.entity[0].isFromRequest()) {
            Request *r = SK.GetRequest(gs.entity[0].request());
            if(r-&gt;type == Request::Type::CUBIC || r-&gt;type == Request::Type::CUBIC_PERIODIC) {
                Entity *e = SK.GetEntity(gs.entity[0]);
                addAfterPoint = e-&gt;GetPositionOfPoint(GetCamera(), Point2d::From(x, y));
                ssassert(addAfterPoint != -1, "Expected a nearest bezier point to be located");
                // Skip derivative point.
                if(r-&gt;type == Request::Type::CUBIC) addAfterPoint++;
                AddContextMenuItem(_("Add Spline Point"), ContextCommand::ADD_SPLINE_PT);
            }
        }
        if(gs.entities == gs.n) {
            AddContextMenuItem(_("Toggle Construction"), ContextCommand::CONSTRUCTION);
        }

        if(gs.points == 1) {
            Entity *p = SK.GetEntity(gs.point[0]);
            Constraint *c;
            IdList&lt;Constraint,hConstraint&gt; *lc = &amp;(SK.constraint);
            for(c = lc-&gt;First(); c; c = lc-&gt;NextAfter(c)) {
                if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
                if(c-&gt;ptA.v == p-&gt;h.v || c-&gt;ptB.v == p-&gt;h.v) {
                    break;
                }
            }
            if(c) {
                AddContextMenuItem(_("Delete Point-Coincident Constraint"),
                                   ContextCommand::DEL_COINCIDENT);
            }
        }
        AddContextMenuItem(NULL, ContextCommand::SEPARATOR);
        if(LockedInWorkplane()) {
            AddContextMenuItem(_("Cut"),  ContextCommand::CUT_SEL);
            AddContextMenuItem(_("Copy"), ContextCommand::COPY_SEL);
        }
    } else {
        AddContextMenuItem(_("Select All"), ContextCommand::SELECT_ALL);
    }

    if((SS.clipboard.r.n &gt; 0 || SS.clipboard.c.n &gt; 0) &amp;&amp; LockedInWorkplane()) {
        AddContextMenuItem(_("Paste"), ContextCommand::PASTE);
        AddContextMenuItem(_("Paste Transformed..."), ContextCommand::PASTE_XFRM);
    }

    if(itemsSelected) {
        AddContextMenuItem(_("Delete"), ContextCommand::DELETE_SEL);
        AddContextMenuItem(NULL, ContextCommand::SEPARATOR);
        AddContextMenuItem(_("Unselect All"), ContextCommand::UNSELECT_ALL);
    }
    // If only one item is selected, then it must be the one that we just
    // selected from the hovered item; in which case unselect all and hovered
    // are equivalent.
    if(!hover.IsEmpty() &amp;&amp; selection.n &gt; 1) {
        AddContextMenuItem(_("Unselect Hovered"), ContextCommand::UNSELECT_HOVERED);
    }

    if(itemsSelected) {
        AddContextMenuItem(NULL, ContextCommand::SEPARATOR);
        AddContextMenuItem(_("Zoom to Fit"), ContextCommand::ZOOM_TO_FIT);
    }

    ContextCommand ret = ShowContextMenu();
    switch(ret) {
        case ContextCommand::CANCELLED:
            // otherwise it was cancelled, so do nothing
            contextMenuCancelTime = GetMilliseconds();
            break;

        case ContextCommand::UNSELECT_ALL:
            MenuEdit(Command::UNSELECT_ALL);
            break;

        case ContextCommand::UNSELECT_HOVERED:
            if(!hover.IsEmpty()) {
                MakeUnselected(&amp;hover, /*coincidentPointTrick=*/true);
            }
            break;

        case ContextCommand::SELECT_CHAIN:
            MenuEdit(Command::SELECT_CHAIN);
            break;

        case ContextCommand::CUT_SEL:
            MenuClipboard(Command::CUT);
            break;

        case ContextCommand::COPY_SEL:
            MenuClipboard(Command::COPY);
            break;

        case ContextCommand::PASTE:
            MenuClipboard(Command::PASTE);
            break;

        case ContextCommand::PASTE_XFRM:
            MenuClipboard(Command::PASTE_TRANSFORM);
            break;

        case ContextCommand::DELETE_SEL:
            MenuClipboard(Command::DELETE);
            break;

        case ContextCommand::REFERENCE_DIM:
            Constraint::MenuConstrain(Command::REFERENCE);
            break;

        case ContextCommand::OTHER_ANGLE:
            Constraint::MenuConstrain(Command::OTHER_ANGLE);
            break;

        case ContextCommand::DEL_COINCIDENT: {
            SS.UndoRemember();
            if(!gs.point[0].v) break;
            Entity *p = SK.GetEntity(gs.point[0]);
            if(!p-&gt;IsPoint()) break;

            SK.constraint.ClearTags();
            Constraint *c;
            for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
                if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
                if(c-&gt;ptA.v == p-&gt;h.v || c-&gt;ptB.v == p-&gt;h.v) {
                    c-&gt;tag = 1;
                }
            }
            SK.constraint.RemoveTagged();
            ClearSelection();
            break;
        }

        case ContextCommand::SNAP_TO_GRID:
            MenuEdit(Command::SNAP_TO_GRID);
            break;

        case ContextCommand::CONSTRUCTION:
            MenuRequest(Command::CONSTRUCTION);
            break;

        case ContextCommand::ZOOM_TO_FIT:
            MenuView(Command::ZOOM_TO_FIT);
            break;

        case ContextCommand::SELECT_ALL:
            MenuEdit(Command::SELECT_ALL);
            break;

        case ContextCommand::REMOVE_SPLINE_PT: {
            hRequest hr = gs.point[0].request();
            Request *r = SK.GetRequest(hr);

            int index = r-&gt;IndexOfPoint(gs.point[0]);
            ssassert(r-&gt;extraPoints != 0, "Expected a bezier with interior control points");

            SS.UndoRemember();
            Entity *e = SK.GetEntity(r-&gt;h.entity(0));

            // First, fix point-coincident constraints involving this point.
            // Then, remove all other constraints, since they would otherwise
            // jump to an adjacent one and mess up the bezier after generation.
            FixConstraintsForPointBeingDeleted(e-&gt;point[index]);
            RemoveConstraintsForPointBeingDeleted(e-&gt;point[index]);

            for(int i = index; i &lt; MAX_POINTS_IN_ENTITY - 1; i++) {
                if(e-&gt;point[i + 1].v == 0) break;
                Entity *p0 = SK.GetEntity(e-&gt;point[i]);
                Entity *p1 = SK.GetEntity(e-&gt;point[i + 1]);
                ReplacePointInConstraints(p1-&gt;h, p0-&gt;h);
                p0-&gt;PointForceTo(p1-&gt;PointGetNum());
            }
            r-&gt;extraPoints--;
            SS.MarkGroupDirtyByEntity(gs.point[0]);
            ClearSelection();
            break;
        }

        case ContextCommand::ADD_SPLINE_PT: {
            hRequest hr = gs.entity[0].request();
            Request *r = SK.GetRequest(hr);

            int pointCount = r-&gt;extraPoints + ((r-&gt;type == Request::Type::CUBIC_PERIODIC) ? 3 : 4);
            if(pointCount &lt; MAX_POINTS_IN_ENTITY) {
                SS.UndoRemember();
                r-&gt;extraPoints++;
                SS.MarkGroupDirtyByEntity(gs.entity[0]);
                SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

                Entity *e = SK.GetEntity(r-&gt;h.entity(0));
                for(int i = MAX_POINTS_IN_ENTITY; i &gt; addAfterPoint + 1; i--) {
                    Entity *p0 = SK.entity.FindByIdNoOops(e-&gt;point[i]);
                    if(p0 == NULL) continue;
                    Entity *p1 = SK.GetEntity(e-&gt;point[i - 1]);
                    ReplacePointInConstraints(p1-&gt;h, p0-&gt;h);
                    p0-&gt;PointForceTo(p1-&gt;PointGetNum());
                }
                Entity *p = SK.GetEntity(e-&gt;point[addAfterPoint + 1]);
                p-&gt;PointForceTo(v);
                SS.MarkGroupDirtyByEntity(gs.entity[0]);
                ClearSelection();
            } else {
                Error(_("Cannot add spline point: maximum number of points reached."));
            }
            break;
        }

        case ContextCommand::GROUP_INFO: {
            hGroup hg;
            if(gs.entities == 1) {
                hg = SK.GetEntity(gs.entity[0])-&gt;group;
            } else if(gs.points == 1) {
                hg = SK.GetEntity(gs.point[0])-&gt;group;
            } else if(gs.constraints == 1) {
                hg = SK.GetConstraint(gs.constraint[0])-&gt;group;
            } else {
                break;
            }
            ClearSelection();

            SS.TW.GoToScreen(TextWindow::Screen::GROUP_INFO);
            SS.TW.shown.group = hg;
            SS.ScheduleShowTW();
            ForceTextWindowShown();
            break;
        }

        case ContextCommand::STYLE_INFO: {
            hStyle hs;
            if(gs.entities == 1) {
                hs = Style::ForEntity(gs.entity[0]);
            } else if(gs.points == 1) {
                hs = Style::ForEntity(gs.point[0]);
            } else if(gs.constraints == 1) {
                hs = SK.GetConstraint(gs.constraint[0])-&gt;GetStyle();
            } else {
                break;
            }
            ClearSelection();

            SS.TW.GoToScreen(TextWindow::Screen::STYLE_INFO);
            SS.TW.shown.style = hs;
            SS.ScheduleShowTW();
            ForceTextWindowShown();
            break;
        }

        case ContextCommand::NEW_CUSTOM_STYLE: {
            uint32_t v = Style::CreateCustomStyle();
            Style::AssignSelectionToStyle(v);
            ForceTextWindowShown();
            break;
        }

        case ContextCommand::NO_STYLE:
            Style::AssignSelectionToStyle(0);
            break;

        default:
            ssassert(ret &gt;= ContextCommand::FIRST_STYLE, "Expected a style to be chosen");
            Style::AssignSelectionToStyle((uint32_t)ret - (uint32_t)ContextCommand::FIRST_STYLE);
            break;
    }

    context.active = false;
    SS.ScheduleShowTW();
}

hRequest GraphicsWindow::AddRequest(Request::Type type) {
    return AddRequest(type, /*rememberForUndo=*/true);
}
hRequest GraphicsWindow::AddRequest(Request::Type type, bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();

    Request r = {};
    r.group = activeGroup;
    Group *g = SK.GetGroup(activeGroup);
    if(g-&gt;type == Group::Type::DRAWING_3D || g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        r.construction = false;
    } else {
        r.construction = true;
    }
    r.workplane = ActiveWorkplane();
    r.type = type;
    SK.request.AddAndAssignId(&amp;r);

    // We must regenerate the parameters, so that the code that tries to
    // place this request's entities where the mouse is can do so. But
    // we mustn't try to solve until reasonable values have been supplied
    // for these new parameters, or else we'll get a numerical blowup.
    r.Generate(&amp;SK.entity, &amp;SK.param);
    SS.MarkGroupDirty(r.group);
    return r.h;
}

Vector GraphicsWindow::SnapToEntityByScreenPoint(Point2d pp, hEntity he) {
    Entity *e = SK.GetEntity(he);
    if(e-&gt;IsPoint()) return e-&gt;PointGetNum();
    SEdgeList *edges = e-&gt;GetOrGenerateEdges();

    double minD = -1.0f;
    double k;
    const SEdge *edge = NULL;
    for(const auto &amp;e : edges-&gt;l) {
        Point2d p0 = ProjectPoint(e.a);
        Point2d p1 = ProjectPoint(e.b);
        Point2d dir = p1.Minus(p0);
        double d = pp.DistanceToLine(p0, dir, /*asSegment=*/true);
        if(minD &gt; 0.0 &amp;&amp; d &gt; minD) continue;
        minD = d;
        k = pp.Minus(p0).Dot(dir) / dir.Dot(dir);
        edge = &amp;e;
    }
    if(edge == NULL) return UnProjectPoint(pp);
    return edge-&gt;a.Plus(edge-&gt;b.Minus(edge-&gt;a).ScaledBy(k));
}

</t>
<t tx="leo1.20171224221227.14">bool GraphicsWindow::ConstrainPointByHovered(hEntity pt, const Point2d *projected) {
    if(!hover.entity.v) return false;

    Entity *point = SK.GetEntity(pt);
    Entity *e = SK.GetEntity(hover.entity);
    if(e-&gt;IsPoint()) {
        point-&gt;PointForceTo(e-&gt;PointGetNum());
        Constraint::ConstrainCoincident(e-&gt;h, pt);
        return true;
    }
    if(e-&gt;IsCircle()) {
        if(projected != NULL) {
            Vector snapPos = SnapToEntityByScreenPoint(*projected, e-&gt;h);
            point-&gt;PointForceTo(snapPos);
        }
        Constraint::Constrain(Constraint::Type::PT_ON_CIRCLE,
            pt, Entity::NO_ENTITY, e-&gt;h);
        return true;
    }
    if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        if(projected != NULL) {
            Vector snapPos = SnapToEntityByScreenPoint(*projected, e-&gt;h);
            point-&gt;PointForceTo(snapPos);
        }
        Constraint::Constrain(Constraint::Type::PT_ON_LINE,
            pt, Entity::NO_ENTITY, e-&gt;h);
        return true;
    }

    return false;
}

</t>
<t tx="leo1.20171224221227.15">void GraphicsWindow::MouseLeftDown(double mx, double my) {
    orig.mouseDown = true;

    if(GraphicsEditControlIsVisible()) {
        orig.mouse = Point2d::From(mx, my);
        orig.mouseOnButtonDown = orig.mouse;
        HideGraphicsEditControl();
        return;
    }
    SS.TW.HideEditControl();

    if(SS.showToolbar) {
        if(ToolbarMouseDown((int)mx, (int)my)) return;
    }

    // This will be clobbered by MouseMoved below.
    bool hasConstraintSuggestion = SS.GW.pending.hasSuggestion;

    // Make sure the hover is up to date.
    MouseMoved(mx, my, /*leftDown=*/false, /*middleDown=*/false, /*rightDown=*/false,
        /*shiftDown=*/false, /*ctrlDown=*/false);
    orig.mouse.x = mx;
    orig.mouse.y = my;
    orig.mouseOnButtonDown = orig.mouse;
    Point2d mouse = Point2d::From(mx, my);

    // The current mouse location
    Vector v = offset.ScaledBy(-1);
    v = v.Plus(projRight.ScaledBy(mx/scale));
    v = v.Plus(projUp.ScaledBy(my/scale));

    hRequest hr = {};
    hConstraint hc = {};
    switch(pending.operation) {
        case Pending::COMMAND:
            switch(pending.command) {
                case Command::DATUM_POINT:
                    hr = AddRequest(Request::Type::DATUM_POINT);
                    SK.GetEntity(hr.entity(0))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(0), &amp;mouse);

                    ClearSuper();
                    break;

                case Command::LINE_SEGMENT:
                case Command::CONSTR_SEGMENT:
                    hr = AddRequest(Request::Type::LINE_SEGMENT);
                    SK.GetRequest(hr)-&gt;construction = (pending.command == Command::CONSTR_SEGMENT);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_LINE_POINT;
                    pending.request = hr;
                    pending.point = hr.entity(2);
                    pending.description = _("click next point of line, or press Esc");
                    SK.GetEntity(pending.point)-&gt;PointForceTo(v);
                    break;

                case Command::RECTANGLE: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw rectangle in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hRequest lns[4];
                    int i;
                    SS.UndoRemember();
                    for(i = 0; i &lt; 4; i++) {
                        lns[i] = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
                        AddToPending(lns[i]);
                    }
                    for(i = 0; i &lt; 4; i++) {
                        Constraint::ConstrainCoincident(
                            lns[i].entity(1), lns[(i+1)%4].entity(2));
                        SK.GetEntity(lns[i].entity(1))-&gt;PointForceTo(v);
                        SK.GetEntity(lns[i].entity(2))-&gt;PointForceTo(v);
                    }
                    for(i = 0; i &lt; 4; i++) {
                        Constraint::Constrain(
                            (i % 2) ? Constraint::Type::HORIZONTAL : Constraint::Type::VERTICAL,
                            Entity::NO_ENTITY, Entity::NO_ENTITY,
                            lns[i].entity(0));
                    }
                    if(ConstrainPointByHovered(lns[2].entity(1), &amp;mouse)) {
                        Vector pos = SK.GetEntity(lns[2].entity(1))-&gt;PointGetNum();
                        for(i = 0; i &lt; 4; i++) {
                            SK.GetEntity(lns[i].entity(1))-&gt;PointForceTo(pos);
                            SK.GetEntity(lns[i].entity(2))-&gt;PointForceTo(pos);
                        }
                    }

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = lns[1].entity(2);
                    pending.description = _("click to place other corner of rectangle");
                    hr = lns[0];
                    break;
                }
                case Command::CIRCLE:
                    hr = AddRequest(Request::Type::CIRCLE);
                    // Centered where we clicked
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    // Normal to the screen
                    SK.GetEntity(hr.entity(32))-&gt;NormalForceTo(
                        Quaternion::From(SS.GW.projRight, SS.GW.projUp));
                    // Initial radius zero
                    SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(0);

                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();

                    pending.operation = Pending::DRAGGING_NEW_RADIUS;
                    pending.circle = hr.entity(0);
                    pending.description = _("click to set radius");
                    break;

                case Command::ARC: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw arc in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearPending();
                        break;
                    }
                    hr = AddRequest(Request::Type::ARC_OF_CIRCLE);
                    // This fudge factor stops us from immediately failing to solve
                    // because of the arc's implicit (equal radius) tangent.
                    Vector adj = SS.GW.projRight.WithMagnitude(2/SS.GW.scale);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v.Minus(adj));
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(2), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_ARC_POINT;
                    pending.point = hr.entity(3);
                    pending.description = _("click to place point");
                    break;
                }
                case Command::CUBIC:
                    hr = AddRequest(Request::Type::CUBIC);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(4))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_CUBIC_POINT;
                    pending.point = hr.entity(4);
                    pending.description = _("click next point of cubic, or press Esc");
                    break;

                case Command::WORKPLANE:
                    if(LockedInWorkplane()) {
                        Error(_("Sketching in a workplane already; sketch in 3d before "
                                "creating new workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::WORKPLANE);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(32))-&gt;NormalForceTo(
                        Quaternion::From(SS.GW.projRight, SS.GW.projUp));
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    break;

                case Command::TTF_TEXT: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw text in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::TTF_TEXT);
                    AddToPending(hr);
                    Request *r = SK.GetRequest(hr);
                    r-&gt;str = "Abc";
                    r-&gt;font = "arial.ttf";

                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = hr.entity(2);
                    pending.description = _("click to place bottom left of text");
                    break;
                }

                case Command::IMAGE: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw image in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::IMAGE);
                    AddToPending(hr);
                    Request *r = SK.GetRequest(hr);
                    r-&gt;file = pending.filename;

                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = hr.entity(2);
                    pending.description = "click to place bottom left of image";
                    break;
                }

                case Command::COMMENT: {
                    ClearSuper();
                    Constraint c = {};
                    c.group       = SS.GW.activeGroup;
                    c.workplane   = SS.GW.ActiveWorkplane();
                    c.type        = Constraint::Type::COMMENT;
                    c.disp.offset = v;
                    c.comment     = _("NEW COMMENT -- DOUBLE-CLICK TO EDIT");
                    hc = Constraint::AddConstraint(&amp;c);
                    break;
                }
                default: ssassert(false, "Unexpected pending menu id");
            }
            break;

        case Pending::DRAGGING_RADIUS:
            ClearPending();
            break;

        case Pending::DRAGGING_NEW_POINT:
        case Pending::DRAGGING_NEW_ARC_POINT:
            ConstrainPointByHovered(pending.point, &amp;mouse);
            ClearPending();
            break;

        case Pending::DRAGGING_NEW_CUBIC_POINT: {
            hRequest hr = pending.point.request();
            Request *r = SK.GetRequest(hr);

            if(hover.entity.v == hr.entity(1).v &amp;&amp; r-&gt;extraPoints &gt;= 2) {
                // They want the endpoints coincident, which means a periodic
                // spline instead.
                r-&gt;type = Request::Type::CUBIC_PERIODIC;
                // Remove the off-curve control points, which are no longer
                // needed here; so move [2,ep+1] down, skipping first pt.
                int i;
                for(i = 2; i &lt;= r-&gt;extraPoints+1; i++) {
                    SK.GetEntity(hr.entity((i-1)+1))-&gt;PointForceTo(
                        SK.GetEntity(hr.entity(i+1))-&gt;PointGetNum());
                }
                // and move ep+3 down by two, skipping both
                SK.GetEntity(hr.entity((r-&gt;extraPoints+1)+1))-&gt;PointForceTo(
                  SK.GetEntity(hr.entity((r-&gt;extraPoints+3)+1))-&gt;PointGetNum());
                r-&gt;extraPoints -= 2;
                // And we're done.
                SS.MarkGroupDirty(r-&gt;group);
                ClearPending();
                break;
            }

            if(ConstrainPointByHovered(pending.point, &amp;mouse)) {
                ClearPending();
                break;
            }

            Entity e;
            if(r-&gt;extraPoints &gt;= (int)arraylen(e.point) - 4) {
                ClearPending();
                break;
            }

            (SK.GetRequest(hr)-&gt;extraPoints)++;
            SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

            int ep = r-&gt;extraPoints;
            Vector last = SK.GetEntity(hr.entity(3+ep))-&gt;PointGetNum();

            SK.GetEntity(hr.entity(2+ep))-&gt;PointForceTo(last);
            SK.GetEntity(hr.entity(3+ep))-&gt;PointForceTo(v);
            SK.GetEntity(hr.entity(4+ep))-&gt;PointForceTo(v);
            pending.point = hr.entity(4+ep);
            break;
        }

        case Pending::DRAGGING_NEW_LINE_POINT: {
            // Constrain the line segment horizontal or vertical if close enough
            if(hasConstraintSuggestion) {
                Constraint::Constrain(SS.GW.pending.suggestion,
                    Entity::NO_ENTITY, Entity::NO_ENTITY, pending.request.entity(0));
            }

            if(hover.entity.v) {
                Entity *e = SK.GetEntity(hover.entity);
                if(e-&gt;IsPoint()) {
                    hRequest hrl = pending.point.request();
                    Entity *sp = SK.GetEntity(hrl.entity(1));
                    if(( e-&gt;PointGetNum()).Equals(
                       (sp-&gt;PointGetNum())))
                    {
                        // If we constrained by the hovered point, then we
                        // would create a zero-length line segment. That's
                        // not good, so just stop drawing.
                        ClearPending();
                        break;
                    }
                }
            }

            if(ConstrainPointByHovered(pending.point, &amp;mouse)) {
                ClearPending();
                break;
            }

            // Create a new line segment, so that we continue drawing.
            hRequest hr = AddRequest(Request::Type::LINE_SEGMENT);
            ReplacePending(pending.request, hr);
            SK.GetRequest(hr)-&gt;construction = SK.GetRequest(pending.request)-&gt;construction;
            // Displace the second point of the new line segment slightly,
            // to avoid creating zero-length edge warnings.
            SK.GetEntity(hr.entity(2))-&gt;PointForceTo(
                v.Plus(projRight.ScaledBy(0.5/scale)));

            // Constrain the line segments to share an endpoint
            Constraint::ConstrainCoincident(pending.point, hr.entity(1));
            Vector pendingPos = SK.GetEntity(pending.point)-&gt;PointGetNum();
            SK.GetEntity(hr.entity(1))-&gt;PointForceTo(pendingPos);

            // And drag an endpoint of the new line segment
            pending.operation = Pending::DRAGGING_NEW_LINE_POINT;
            pending.request = hr;
            pending.point = hr.entity(2);
            pending.description = _("click next point of line, or press Esc");

            break;
        }

        case Pending::NONE:
        default:
            ClearPending();
            if(!hover.IsEmpty()) {
                hoverWasSelectedOnMousedown = IsSelected(&amp;hover);
                MakeSelected(&amp;hover);
            }
            break;
    }

    // Activate group with newly created request/constraint
    Group *g = NULL;
    if(hr.v != 0) {
        g = SK.GetGroup(SK.GetRequest(hr)-&gt;group);
    }
    if(hc.v != 0) {
        g = SK.GetGroup(SK.GetConstraint(hc)-&gt;group);
    }
    if(g != NULL) {
        g-&gt;visible = true;
    }

    SS.ScheduleShowTW();
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221227.16">void GraphicsWindow::MouseLeftUp(double mx, double my) {
    orig.mouseDown = false;
    hoverWasSelectedOnMousedown = false;

    switch(pending.operation) {
        case Pending::DRAGGING_POINTS:
            SS.extraLine.draw = false;
            // fall through
        case Pending::DRAGGING_CONSTRAINT:
        case Pending::DRAGGING_NORMAL:
        case Pending::DRAGGING_RADIUS:
            ClearPending();
            InvalidateGraphics();
            break;

        case Pending::DRAGGING_MARQUEE:
            SelectByMarquee();
            ClearPending();
            InvalidateGraphics();
            break;

        case Pending::NONE:
            // We need to clear the selection here, and not in the mouse down
            // event, since a mouse down without anything hovered could also
            // be the start of marquee selection. But don't do that on the
            // left click to cancel a context menu. The time delay is an ugly
            // hack.
            if(hover.IsEmpty() &amp;&amp;
                (contextMenuCancelTime == 0 ||
                 (GetMilliseconds() - contextMenuCancelTime) &gt; 200))
            {
                ClearSelection();
            }
            break;

        default:
            break;  // do nothing
    }
}

</t>
<t tx="leo1.20171224221227.17">void GraphicsWindow::MouseLeftDoubleClick(double mx, double my) {
    if(GraphicsEditControlIsVisible()) return;
    SS.TW.HideEditControl();

    if(hover.constraint.v) {
        constraintBeingEdited = hover.constraint;
        ClearSuper();

        Constraint *c = SK.GetConstraint(constraintBeingEdited);
        if(!c-&gt;HasLabel()) {
            // Not meaningful to edit a constraint without a dimension
            return;
        }
        if(c-&gt;reference) {
            // Not meaningful to edit a reference dimension
            return;
        }

        Vector p3 = c-&gt;GetLabelPos(GetCamera());
        Point2d p2 = ProjectPoint(p3);

        std::string editValue;
        int editMinWidthChar;
        switch(c-&gt;type) {
            case Constraint::Type::COMMENT:
                editValue = c-&gt;comment;
                editMinWidthChar = 30;
                break;

            case Constraint::Type::ANGLE:
            case Constraint::Type::LENGTH_RATIO:
                editValue = ssprintf("%.3f", c-&gt;valA);
                editMinWidthChar = 5;
                break;

            default: {
                double v = fabs(c-&gt;valA);

                // If displayed as radius, also edit as radius.
                if(c-&gt;type == Constraint::Type::DIAMETER &amp;&amp; c-&gt;other)
                    v /= 2;

                std::string def = SS.MmToString(v);
                double eps = 1e-12;
                if(fabs(SS.StringToMm(def) - v) &lt; eps) {
                    // Show value with default number of digits after decimal,
                    // which is at least enough to represent it exactly.
                    editValue = def;
                } else {
                    // Show value with as many digits after decimal as
                    // required to represent it exactly, up to 10.
                    v /= SS.MmPerUnit();
                    int i;
                    for(i = 0; i &lt;= 10; i++) {
                        editValue = ssprintf("%.*f", i, v);
                        if(fabs(std::stod(editValue) - v) &lt; eps) break;
                    }
                }
                editMinWidthChar = 5;
                break;
            }
        }
        hStyle hs = c-&gt;disp.style;
        if(hs.v == 0) hs.v = Style::CONSTRAINT;
        ShowGraphicsEditControl((int)p2.x, (int)p2.y,
                                (int)(VectorFont::Builtin()-&gt;GetHeight(Style::TextHeight(hs))),
                                editMinWidthChar, editValue);
    }
}

</t>
<t tx="leo1.20171224221227.18">void GraphicsWindow::EditControlDone(const char *s) {
    HideGraphicsEditControl();
    Constraint *c = SK.GetConstraint(constraintBeingEdited);

    if(c-&gt;type == Constraint::Type::COMMENT) {
        SS.UndoRemember();
        c-&gt;comment = s;
        return;
    }

    Expr *e = Expr::From(s, true);
    if(e) {
        SS.UndoRemember();

        switch(c-&gt;type) {
            case Constraint::Type::PROJ_PT_DISTANCE:
            case Constraint::Type::PT_LINE_DISTANCE:
            case Constraint::Type::PT_FACE_DISTANCE:
            case Constraint::Type::PT_PLANE_DISTANCE:
            case Constraint::Type::LENGTH_DIFFERENCE: {
                // The sign is not displayed to the user, but this is a signed
                // distance internally. To flip the sign, the user enters a
                // negative distance.
                bool wasNeg = (c-&gt;valA &lt; 0);
                if(wasNeg) {
                    c-&gt;valA = -SS.ExprToMm(e);
                } else {
                    c-&gt;valA = SS.ExprToMm(e);
                }
                break;
            }
            case Constraint::Type::ANGLE:
            case Constraint::Type::LENGTH_RATIO:
                // These don't get the units conversion for distance, and
                // they're always positive
                c-&gt;valA = fabs(e-&gt;Eval());
                break;

            case Constraint::Type::DIAMETER:
                c-&gt;valA = fabs(SS.ExprToMm(e));

                // If displayed and edited as radius, convert back
                // to diameter
                if(c-&gt;other)
                    c-&gt;valA *= 2;
                break;

            default:
                // These are always positive, and they get the units conversion.
                c-&gt;valA = fabs(SS.ExprToMm(e));
                break;
        }
        SS.MarkGroupDirty(c-&gt;group);
    }
}

</t>
<t tx="leo1.20171224221227.19">bool GraphicsWindow::KeyDown(int c) {
    if(c == '\b') {
        // Treat backspace identically to escape.
        MenuEdit(Command::UNSELECT_ALL);
        return true;
    } else if(c == '=') {
        // Treat = as +. This is specific to US (and US-compatible) keyboard layouts,
        // but makes zooming from keyboard much more usable on these.
        // Ideally we'd have a platform-independent way of binding to a particular
        // physical key regardless of shift status...
        MenuView(Command::ZOOM_IN);
        return true;
    }

    return false;
}

</t>
<t tx="leo1.20171224221227.2">void GraphicsWindow::UpdateDraggedNum(Vector *pos, double mx, double my) {
    *pos = pos-&gt;Plus(projRight.ScaledBy((mx - orig.mouse.x)/scale));
    *pos = pos-&gt;Plus(projUp.ScaledBy((my - orig.mouse.y)/scale));
}

</t>
<t tx="leo1.20171224221227.20">void GraphicsWindow::MouseScroll(double x, double y, int delta) {
    double offsetRight = offset.Dot(projRight);
    double offsetUp = offset.Dot(projUp);

    double righti = x/scale - offsetRight;
    double upi = y/scale - offsetUp;

    if(delta &gt; 0) {
        scale *= 1.2;
    } else if(delta &lt; 0) {
        scale /= 1.2;
    } else return;

    double rightf = x/scale - offsetRight;
    double upf = y/scale - offsetUp;

    offset = offset.Plus(projRight.ScaledBy(rightf - righti));
    offset = offset.Plus(projUp.ScaledBy(upf - upi));

    if(SS.TW.shown.screen == TextWindow::Screen::EDIT_VIEW) {
        if(havePainted) {
            SS.ScheduleShowTW();
        }
    }
    havePainted = false;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221227.21">void GraphicsWindow::MouseLeave() {
    // Un-hover everything when the mouse leaves our window, unless there's
    // currently a context menu shown.
    if(!context.active) {
        hover.Clear();
        toolbarTooltipped = Command::NONE;
        toolbarHovered = Command::NONE;
        PaintGraphics();
    }
    SS.extraLine.draw = false;
}

</t>
<t tx="leo1.20171224221227.22">void GraphicsWindow::SpaceNavigatorMoved(double tx, double ty, double tz,
                                         double rx, double ry, double rz,
                                         bool shiftDown)
{
    if(!havePainted) return;
    Vector out = projRight.Cross(projUp);

    // rotation vector is axis of rotation, and its magnitude is angle
    Vector aa = Vector::From(rx, ry, rz);
    // but it's given with respect to screen projection frame
    aa = aa.ScaleOutOfCsys(projRight, projUp, out);
    double aam = aa.Magnitude();
    if(aam &gt; 0.0) aa = aa.WithMagnitude(1);

    // This can either transform our view, or transform a linked part.
    GroupSelection();
    Entity *e = NULL;
    Group *g = NULL;
    if(gs.points == 1   &amp;&amp; gs.n == 1) e = SK.GetEntity(gs.point [0]);
    if(gs.entities == 1 &amp;&amp; gs.n == 1) e = SK.GetEntity(gs.entity[0]);
    if(e) g = SK.GetGroup(e-&gt;group);
    if(g &amp;&amp; g-&gt;type == Group::Type::LINKED &amp;&amp; !shiftDown) {
        // Apply the transformation to a linked part. Gain down the Z
        // axis, since it's hard to see what you're doing on that one since
        // it's normal to the screen.
        Vector t = projRight.ScaledBy(tx/scale).Plus(
                   projUp   .ScaledBy(ty/scale).Plus(
                   out      .ScaledBy(0.1*tz/scale)));
        Quaternion q = Quaternion::From(aa, aam);

        // If we go five seconds without SpaceNavigator input, or if we've
        // switched groups, then consider that a new action and save an undo
        // point.
        int64_t now = GetMilliseconds();
        if(now - lastSpaceNavigatorTime &gt; 5000 ||
           lastSpaceNavigatorGroup.v != g-&gt;h.v)
        {
            SS.UndoRemember();
        }

        g-&gt;TransformImportedBy(t, q);

        lastSpaceNavigatorTime = now;
        lastSpaceNavigatorGroup = g-&gt;h;
        SS.MarkGroupDirty(g-&gt;h);
    } else {
        // Apply the transformation to the view of the everything. The
        // x and y components are translation; but z component is scale,
        // not translation, or else it would do nothing in a parallel
        // projection
        offset = offset.Plus(projRight.ScaledBy(tx/scale));
        offset = offset.Plus(projUp.ScaledBy(ty/scale));
        scale *= exp(0.001*tz);

        if(aam &gt; 0.0) {
            projRight = projRight.RotatedAbout(aa, -aam);
            projUp    = projUp.   RotatedAbout(aa, -aam);
            NormalizeProjectionVectors();
        }
    }

    havePainted = false;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221227.23">void GraphicsWindow::SpaceNavigatorButtonUp() {
    ZoomToFit(/*includingInvisibles=*/false, /*useSelection=*/true);
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221227.24">//-----------------------------------------------------------------------------
// Operations on polygons (planar, of line segment edges).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

Vector STriangle::Normal() const {
    Vector ab = b.Minus(a), bc = c.Minus(b);
    return ab.Cross(bc);
}

double STriangle::MinAltitude() const {
    @others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221227.3">void GraphicsWindow::AddPointToDraggedList(hEntity hp) {
    Entity *p = SK.GetEntity(hp);
    // If an entity and its points are both selected, then its points could
    // end up in the list twice. This would be bad, because it would move
    // twice as far as the mouse pointer...
    List&lt;hEntity&gt; *lhe = &amp;(pending.points);
    for(hEntity *hee = lhe-&gt;First(); hee; hee = lhe-&gt;NextAfter(hee)) {
        if(hee-&gt;v == hp.v) {
            // Exact same point.
            return;
        }
        Entity *pe = SK.GetEntity(*hee);
        if(pe-&gt;type == p-&gt;type &amp;&amp;
           pe-&gt;type != Entity::Type::POINT_IN_2D &amp;&amp;
           pe-&gt;type != Entity::Type::POINT_IN_3D &amp;&amp;
           pe-&gt;group.v == p-&gt;group.v)
        {
            // Transform-type point, from the same group. So it handles the
            // same unknowns.
            return;
        }
    }
    pending.points.Add(&amp;hp);
}

</t>
<t tx="leo1.20171224221227.4">void GraphicsWindow::StartDraggingByEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    if(e-&gt;IsPoint()) {
        AddPointToDraggedList(e-&gt;h);
    } else if(e-&gt;type == Entity::Type::LINE_SEGMENT ||
              e-&gt;type == Entity::Type::ARC_OF_CIRCLE ||
              e-&gt;type == Entity::Type::CUBIC ||
              e-&gt;type == Entity::Type::CUBIC_PERIODIC ||
              e-&gt;type == Entity::Type::CIRCLE ||
              e-&gt;type == Entity::Type::TTF_TEXT ||
              e-&gt;type == Entity::Type::IMAGE)
    {
        int pts;
        EntReqTable::GetEntityInfo(e-&gt;type, e-&gt;extraPoints,
            NULL, &amp;pts, NULL, NULL);
        for(int i = 0; i &lt; pts; i++) {
            AddPointToDraggedList(e-&gt;point[i]);
        }
    }
}

</t>
<t tx="leo1.20171224221227.5">void GraphicsWindow::StartDraggingBySelection() {
    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;entity.v) continue;

        StartDraggingByEntity(s-&gt;entity);
    }
    // The user might select a point, and then click it again to start
    // dragging; but the point just got unselected by that click. So drag
    // the hovered item too, and they'll always have it.
    if(hover.entity.v) {
        hEntity dragEntity = ChooseFromHoverToDrag().entity;
        if(dragEntity.v != Entity::NO_ENTITY.v) {
            StartDraggingByEntity(dragEntity);
        }
    }
}

</t>
<t tx="leo1.20171224221227.6">void GraphicsWindow::MouseMoved(double x, double y, bool leftDown,
            bool middleDown, bool rightDown, bool shiftDown, bool ctrlDown)
{
    if(GraphicsEditControlIsVisible()) return;
    if(context.active) return;

    SS.extraLine.draw = false;

    if(!orig.mouseDown) {
        // If someone drags the mouse into our window with the left button
        // already depressed, then we don't have our starting point; so
        // don't try.
        leftDown = false;
    }

    if(rightDown) {
        middleDown = true;
        shiftDown = !shiftDown;
    }

    if(SS.showToolbar) {
        if(ToolbarMouseMoved((int)x, (int)y)) {
            hover.Clear();
            return;
        }
    }

    if(!leftDown &amp;&amp; (pending.operation == Pending::DRAGGING_POINTS ||
                     pending.operation == Pending::DRAGGING_MARQUEE))
    {
        ClearPending();
        InvalidateGraphics();
    }

    Point2d mp = Point2d::From(x, y);
    currentMousePosition = mp;

    if(rightDown &amp;&amp; orig.mouse.DistanceTo(mp) &lt; 5 &amp;&amp; !orig.startedMoving) {
        // Avoid accidentally panning (or rotating if shift is down) if the
        // user wants a context menu.
        return;
    }
    orig.startedMoving = true;

    // If the middle button is down, then mouse movement is used to pan and
    // rotate our view. This wins over everything else.
    if(middleDown) {
        hover.Clear();

        double dx = (x - orig.mouse.x) / scale;
        double dy = (y - orig.mouse.y) / scale;

        if(!(shiftDown || ctrlDown)) {
            double s = 0.3*(PI/180)*scale; // degrees per pixel
            projRight = orig.projRight.RotatedAbout(orig.projUp, -s*dx);
            projUp = orig.projUp.RotatedAbout(orig.projRight, s*dy);

            NormalizeProjectionVectors();
        } else if(ctrlDown) {
            double theta = atan2(orig.mouse.y, orig.mouse.x);
            theta -= atan2(y, x);
            SS.extraLine.draw = true;
            SS.extraLine.ptA = UnProjectPoint(Point2d::From(0, 0));
            SS.extraLine.ptB = UnProjectPoint(mp);

            Vector normal = orig.projRight.Cross(orig.projUp);
            projRight = orig.projRight.RotatedAbout(normal, theta);
            projUp = orig.projUp.RotatedAbout(normal, theta);

            NormalizeProjectionVectors();
        } else {
            offset.x = orig.offset.x + dx*projRight.x + dy*projUp.x;
            offset.y = orig.offset.y + dx*projRight.y + dy*projUp.y;
            offset.z = orig.offset.z + dx*projRight.z + dy*projUp.z;
        }

        orig.projRight = projRight;
        orig.projUp = projUp;
        orig.offset = offset;
        orig.mouse.x = x;
        orig.mouse.y = y;

        if(SS.TW.shown.screen == TextWindow::Screen::EDIT_VIEW) {
            if(havePainted) {
                SS.ScheduleShowTW();
            }
        }
        InvalidateGraphics();
        havePainted = false;
        return;
    }

    if(pending.operation == Pending::NONE) {
        double dm = orig.mouse.DistanceTo(mp);
        // If we're currently not doing anything, then see if we should
        // start dragging something.
        if(leftDown &amp;&amp; dm &gt; 3) {
            Entity *e = NULL;
            hEntity dragEntity = ChooseFromHoverToDrag().entity;
            if(dragEntity.v) e = SK.GetEntity(dragEntity);
            if(e &amp;&amp; e-&gt;type != Entity::Type::WORKPLANE) {
                Entity *e = SK.GetEntity(dragEntity);
                if(e-&gt;type == Entity::Type::CIRCLE &amp;&amp; selection.n &lt;= 1) {
                    // Drag the radius.
                    ClearSelection();
                    pending.circle = dragEntity;
                    pending.operation = Pending::DRAGGING_RADIUS;
                } else if(e-&gt;IsNormal()) {
                    ClearSelection();
                    pending.normal = dragEntity;
                    pending.operation = Pending::DRAGGING_NORMAL;
                } else {
                    if(!hoverWasSelectedOnMousedown) {
                        // The user clicked an unselected entity, which
                        // means they're dragging just the hovered thing,
                        // not the full selection. So clear all the selection
                        // except that entity.
                        ClearSelection();
                        MakeSelected(e-&gt;h);
                    }
                    StartDraggingBySelection();
                    if(!hoverWasSelectedOnMousedown) {
                        // And then clear the selection again, since they
                        // probably didn't want that selected if they just
                        // were dragging it.
                        ClearSelection();
                    }
                    hover.Clear();
                    pending.operation = Pending::DRAGGING_POINTS;
                }
            } else if(hover.constraint.v &amp;&amp;
                            SK.GetConstraint(hover.constraint)-&gt;HasLabel())
            {
                ClearSelection();
                pending.constraint = hover.constraint;
                pending.operation = Pending::DRAGGING_CONSTRAINT;
            }
            if(pending.operation != Pending::NONE) {
                // We just started a drag, so remember for the undo before
                // the drag changes anything.
                SS.UndoRemember();
            } else {
                if(!hover.constraint.v) {
                    // That's just marquee selection, which should not cause
                    // an undo remember.
                    if(dm &gt; 10) {
                        if(hover.entity.v) {
                            // Avoid accidentally selecting workplanes when
                            // starting drags.
                            MakeUnselected(hover.entity, /*coincidentPointTrick=*/false);
                            hover.Clear();
                        }
                        pending.operation = Pending::DRAGGING_MARQUEE;
                        orig.marqueePoint =
                            UnProjectPoint(orig.mouseOnButtonDown);
                    }
                }
            }
        } else {
            // Otherwise, just hit test and give up; but don't hit test
            // if the mouse is down, because then the user could hover
            // a point, mouse down (thus selecting it), and drag, in an
            // effort to drag the point, but instead hover a different
            // entity before we move far enough to start the drag.
            if(!leftDown) {
                // Hit testing can potentially take a lot of time.
                // If we haven't painted since last time we highlighted
                // something, don't hit test again, since this just causes
                // a lag.
                if(!havePainted) return;
                HitTestMakeSelection(mp);
            }
        }
        return;
    }

    // If the user has started an operation from the menu, but not
    // completed it, then just do the selection.
    if(pending.operation == Pending::COMMAND) {
        HitTestMakeSelection(mp);
        return;
    }

    // We're currently dragging something; so do that. But if we haven't
    // painted since the last time we solved, do nothing, because there's
    // no sense solving a frame and not displaying it.
    if(!havePainted) {
        if(pending.operation == Pending::DRAGGING_POINTS &amp;&amp; ctrlDown) {
            SS.extraLine.ptA = UnProjectPoint(orig.mouseOnButtonDown);
            SS.extraLine.ptB = UnProjectPoint(mp);
            SS.extraLine.draw = true;
        }
        return;
    }

    havePainted = false;
    switch(pending.operation) {
        case Pending::DRAGGING_CONSTRAINT: {
            Constraint *c = SK.constraint.FindById(pending.constraint);
            UpdateDraggedNum(&amp;(c-&gt;disp.offset), x, y);
            orig.mouse = mp;
            InvalidateGraphics();
            return;
        }

        case Pending::DRAGGING_NEW_LINE_POINT:
            if(!ctrlDown) {
                SS.GW.pending.hasSuggestion =
                    SS.GW.SuggestLineConstraint(SS.GW.pending.request, &amp;SS.GW.pending.suggestion);
            } else {
                SS.GW.pending.hasSuggestion = false;
            }
        case Pending::DRAGGING_NEW_POINT:
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);
            SS.MarkGroupDirtyByEntity(pending.point);
            orig.mouse = mp;
            InvalidateGraphics();
            break;

        case Pending::DRAGGING_POINTS:
            if(shiftDown || ctrlDown) {
                // Edit the rotation associated with a POINT_N_ROT_TRANS,
                // either within (ctrlDown) or out of (shiftDown) the plane
                // of the screen. So first get the rotation to apply, in qt.
                Quaternion qt;
                if(ctrlDown) {
                    double d = mp.DistanceTo(orig.mouseOnButtonDown);
                    if(d &lt; 25) {
                        // Don't start dragging the position about the normal
                        // until we're a little ways out, to get a reasonable
                        // reference pos
                        orig.mouse = mp;
                        break;
                    }
                    double theta = atan2(orig.mouse.y-orig.mouseOnButtonDown.y,
                } else {
                    double dx = -(x - orig.mouse.x);
                    double dy = -(y - orig.mouse.y);
                    double s = 0.3*(PI/180); // degrees per pixel
                    qt = Quaternion::From(projUp,   -s*dx).Times(
                         Quaternion::From(projRight, s*dy));
                }
                orig.mouse = mp;

                // Now apply this rotation to the points being dragged.
                List&lt;hEntity&gt; *lhe = &amp;(pending.points);
                for(hEntity *he = lhe-&gt;First(); he; he = lhe-&gt;NextAfter(he)) {
                    Entity *e = SK.GetEntity(*he);
                    if(e-&gt;type != Entity::Type::POINT_N_ROT_TRANS) {
                        if(ctrlDown) {
                            Vector p = e-&gt;PointGetNum();
                            p = p.Minus(SS.extraLine.ptA);
                            p = qt.Rotate(p);
                            p = p.Plus(SS.extraLine.ptA);
                            e-&gt;PointForceTo(p);
                            SS.MarkGroupDirtyByEntity(e-&gt;h);
                        }
                        continue;
                    }

                    Quaternion q = e-&gt;PointGetQuaternion();
                    Vector     p = e-&gt;PointGetNum();
                    q = qt.Times(q);
                    e-&gt;PointForceQuaternionTo(q);
                    // Let's rotate about the selected point; so fix up the
                    // translation so that that point didn't move.
                    e-&gt;PointForceTo(p);
                    SS.MarkGroupDirtyByEntity(e-&gt;h);
                }
            } else {
                List&lt;hEntity&gt; *lhe = &amp;(pending.points);
                for(hEntity *he = lhe-&gt;First(); he; he = lhe-&gt;NextAfter(he)) {
                    UpdateDraggedPoint(*he, x, y);
                    SS.MarkGroupDirtyByEntity(*he);
                }
                orig.mouse = mp;
            }
            break;

        case Pending::DRAGGING_NEW_CUBIC_POINT: {
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);

            hRequest hr = pending.point.request();
            if(pending.point.v == hr.entity(4).v) {
                // The very first segment; dragging final point drags both
                // tangent points.
                Vector p0 = SK.GetEntity(hr.entity(1))-&gt;PointGetNum(),
                       p3 = SK.GetEntity(hr.entity(4))-&gt;PointGetNum(),
                       p1 = p0.ScaledBy(2.0/3).Plus(p3.ScaledBy(1.0/3)),
                       p2 = p0.ScaledBy(1.0/3).Plus(p3.ScaledBy(2.0/3));
                SK.GetEntity(hr.entity(1+1))-&gt;PointForceTo(p1);
                SK.GetEntity(hr.entity(1+2))-&gt;PointForceTo(p2);
            } else {
                // A subsequent segment; dragging point drags only final
                // tangent point.
                int i = SK.GetEntity(hr.entity(0))-&gt;extraPoints;
                Vector pn   = SK.GetEntity(hr.entity(4+i))-&gt;PointGetNum(),
                       pnm2 = SK.GetEntity(hr.entity(2+i))-&gt;PointGetNum(),
                       pnm1 = (pn.Plus(pnm2)).ScaledBy(0.5);
                SK.GetEntity(hr.entity(3+i))-&gt;PointForceTo(pnm1);
            }

            orig.mouse = mp;
            SS.MarkGroupDirtyByEntity(pending.point);
            break;
        }
        case Pending::DRAGGING_NEW_ARC_POINT: {
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);

            hRequest hr = pending.point.request();
            Vector ona = SK.GetEntity(hr.entity(2))-&gt;PointGetNum();
            Vector onb = SK.GetEntity(hr.entity(3))-&gt;PointGetNum();
            Vector center = (ona.Plus(onb)).ScaledBy(0.5);

            SK.GetEntity(hr.entity(1))-&gt;PointForceTo(center);

            orig.mouse = mp;
            SS.MarkGroupDirtyByEntity(pending.point);
            break;
        }
        case Pending::DRAGGING_NEW_RADIUS:
        case Pending::DRAGGING_RADIUS: {
            Entity *circle = SK.GetEntity(pending.circle);
            Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
            Point2d c2 = ProjectPoint(center);
            double r = c2.DistanceTo(mp)/scale;
            SK.GetEntity(circle-&gt;distance)-&gt;DistanceForceTo(r);

            SS.MarkGroupDirtyByEntity(pending.circle);
            break;
        }

        case Pending::DRAGGING_NORMAL: {
            Entity *normal = SK.GetEntity(pending.normal);
            Vector p = SK.GetEntity(normal-&gt;point[0])-&gt;PointGetNum();
            Point2d p2 = ProjectPoint(p);

            Quaternion q = normal-&gt;NormalGetNum();
            Vector u = q.RotationU(), v = q.RotationV();

            if(ctrlDown) {
                double theta = atan2(orig.mouse.y-p2.y, orig.mouse.x-p2.x);
                theta -= atan2(y-p2.y, x-p2.x);

                Vector normal = projRight.Cross(projUp);
                u = u.RotatedAbout(normal, -theta);
                v = v.RotatedAbout(normal, -theta);
            } else {
                double dx = -(x - orig.mouse.x);
                double dy = -(y - orig.mouse.y);
                double s = 0.3*(PI/180); // degrees per pixel
                u = u.RotatedAbout(projUp, -s*dx);
                u = u.RotatedAbout(projRight, s*dy);
                v = v.RotatedAbout(projUp, -s*dx);
                v = v.RotatedAbout(projRight, s*dy);
            }
            orig.mouse = mp;
            normal-&gt;NormalForceTo(Quaternion::From(u, v));

            SS.MarkGroupDirtyByEntity(pending.normal);
            break;
        }

        case Pending::DRAGGING_MARQUEE:
            orig.mouse = mp;
            InvalidateGraphics();
            return;

        case Pending::NONE:
        case Pending::COMMAND:
            ssassert(false, "Unexpected pending operation");
    }
}

</t>
<t tx="leo1.20171224221227.7">void GraphicsWindow::ClearPending() {
    pending.points.Clear();
    pending.requests.Clear();
    pending = {};
    SS.ScheduleShowTW();
}

</t>
<t tx="leo1.20171224221227.8">bool GraphicsWindow::IsFromPending(hRequest r) {
    for(auto &amp;req : pending.requests) {
        if(req.v == r.v) return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221227.9">void GraphicsWindow::AddToPending(hRequest r) {
    pending.requests.Add(&amp;r);
}

</t>
<t tx="leo1.20171224221228.1">    double altA = a.DistanceToLine(b, c.Minus(b)),
           altB = b.DistanceToLine(c, a.Minus(c)),
           altC = c.DistanceToLine(a, b.Minus(a));

    return min(altA, min(altB, altC));
}

bool STriangle::ContainsPoint(Vector p) const {
    Vector n = Normal();
    if(MinAltitude() &lt; LENGTH_EPS) {
        // shouldn't happen; zero-area triangle
        return false;
    }
    return ContainsPointProjd(n.WithMagnitude(1), p);
}

</t>
<t tx="leo1.20171224221228.10">int SEdgeList::AnyEdgeCrossings(Vector a, Vector b,
                                Vector *ppi, SPointList *spl) const
{
    int cnt = 0;
    for(const SEdge *se = l.First(); se; se = l.NextAfter(se)) {
        if(se-&gt;EdgeCrosses(a, b, ppi, spl)) {
            cnt++;
        }
    }
    return cnt;
}

//-----------------------------------------------------------------------------
// Returns true if the intersecting edge list contains an edge that shares
// an endpoint with one of our edges.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221228.11">bool SEdgeList::ContainsEdgeFrom(const SEdgeList *sel) const {
    for(const SEdge *se = l.First(); se; se = l.NextAfter(se)) {
        if(sel-&gt;ContainsEdge(se)) return true;
    }
    return false;
}
</t>
<t tx="leo1.20171224221228.12">bool SEdgeList::ContainsEdge(const SEdge *set) const {
    for(const SEdge *se = l.First(); se; se = l.NextAfter(se)) {
        if((se-&gt;a).Equals(set-&gt;a) &amp;&amp; (se-&gt;b).Equals(set-&gt;b)) return true;
        if((se-&gt;b).Equals(set-&gt;a) &amp;&amp; (se-&gt;a).Equals(set-&gt;b)) return true;
    }
    return false;
}

//-----------------------------------------------------------------------------
// Remove unnecessary edges: if two are anti-parallel then remove both, and if
// two are parallel then remove one.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221228.13">void SEdgeList::CullExtraneousEdges() {
    l.ClearTags();
    int i, j;
    for(i = 0; i &lt; l.n; i++) {
        SEdge *se = &amp;(l.elem[i]);
        for(j = i+1; j &lt; l.n; j++) {
            SEdge *set = &amp;(l.elem[j]);
            if((set-&gt;a).Equals(se-&gt;a) &amp;&amp; (set-&gt;b).Equals(se-&gt;b)) {
                // Two parallel edges exist; so keep only the first one.
                set-&gt;tag = 1;
            }
            if((set-&gt;a).Equals(se-&gt;b) &amp;&amp; (set-&gt;b).Equals(se-&gt;a)) {
                // Two anti-parallel edges exist; so keep neither.
                se-&gt;tag = 1;
                set-&gt;tag = 1;
            }
        }
    }
    l.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Make a kd-tree of edges. This is used for O(log(n)) implementations of stuff
// that would naively be O(n).
//-----------------------------------------------------------------------------
SKdNodeEdges *SKdNodeEdges::Alloc() {
    SKdNodeEdges *ne = (SKdNodeEdges *)AllocTemporary(sizeof(SKdNodeEdges));
    *ne = {};
    return ne;
}
SEdgeLl *SEdgeLl::Alloc() {
    SEdgeLl *sell = (SEdgeLl *)AllocTemporary(sizeof(SEdgeLl));
    *sell = {};
    return sell;
}
SKdNodeEdges *SKdNodeEdges::From(SEdgeList *sel) {
    SEdgeLl *sell = NULL;
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        SEdgeLl *n = SEdgeLl::Alloc();
        n-&gt;se = se;
        n-&gt;next = sell;
        sell = n;
    }
    return SKdNodeEdges::From(sell);
}
SKdNodeEdges *SKdNodeEdges::From(SEdgeLl *sell) {
    SKdNodeEdges *n = SKdNodeEdges::Alloc();

    // Compute the midpoints (just mean, though median would be better) of
    // each component.
    Vector ptAve = Vector::From(0, 0, 0);
    SEdgeLl *flip;
    int totaln = 0;
    for(flip = sell; flip; flip = flip-&gt;next) {
        ptAve = ptAve.Plus(flip-&gt;se-&gt;a);
        ptAve = ptAve.Plus(flip-&gt;se-&gt;b);
        totaln++;
    }
    ptAve = ptAve.ScaledBy(1.0 / (2*totaln));

    // For each component, see how it splits.
    int ltln[3] = { 0, 0, 0 }, gtln[3] = { 0, 0, 0 };
    double badness[3];
    for(flip = sell; flip; flip = flip-&gt;next) {
        for(int i = 0; i &lt; 3; i++) {
            if(flip-&gt;se-&gt;a.Element(i) &lt; ptAve.Element(i) + KDTREE_EPS ||
               flip-&gt;se-&gt;b.Element(i) &lt; ptAve.Element(i) + KDTREE_EPS)
            {
                ltln[i]++;
            }
            if(flip-&gt;se-&gt;a.Element(i) &gt; ptAve.Element(i) - KDTREE_EPS ||
               flip-&gt;se-&gt;b.Element(i) &gt; ptAve.Element(i) - KDTREE_EPS)
            {
                gtln[i]++;
            }
        }
    }
    for(int i = 0; i &lt; 3; i++) {
        badness[i] = pow((double)ltln[i], 4) + pow((double)gtln[i], 4);
    }

    // Choose the least bad coordinate to split along.
    if(badness[0] &lt; badness[1] &amp;&amp; badness[0] &lt; badness[2]) {
        n-&gt;which = 0;
    } else if(badness[1] &lt; badness[2]) {
        n-&gt;which = 1;
    } else {
        n-&gt;which = 2;
    }
    n-&gt;c = ptAve.Element(n-&gt;which);

    if(totaln &lt; 3 || totaln == gtln[n-&gt;which] || totaln == ltln[n-&gt;which]) {
        n-&gt;edges = sell;
        // and we're a leaf node
        return n;
    }

    // Sort the edges according to which side(s) of the split plane they're on.
    SEdgeLl *gtl = NULL, *ltl = NULL;
    for(flip = sell; flip; flip = flip-&gt;next) {
        if(flip-&gt;se-&gt;a.Element(n-&gt;which) &lt; n-&gt;c + KDTREE_EPS ||
           flip-&gt;se-&gt;b.Element(n-&gt;which) &lt; n-&gt;c + KDTREE_EPS)
        {
            SEdgeLl *selln = SEdgeLl::Alloc();
            selln-&gt;se = flip-&gt;se;
            selln-&gt;next = ltl;
            ltl = selln;
        }
        if(flip-&gt;se-&gt;a.Element(n-&gt;which) &gt; n-&gt;c - KDTREE_EPS ||
           flip-&gt;se-&gt;b.Element(n-&gt;which) &gt; n-&gt;c - KDTREE_EPS)
        {
            SEdgeLl *selln = SEdgeLl::Alloc();
            selln-&gt;se = flip-&gt;se;
            selln-&gt;next = gtl;
            gtl = selln;
        }
    }

    n-&gt;lt = SKdNodeEdges::From(ltl);
    n-&gt;gt = SKdNodeEdges::From(gtl);
    return n;
}

</t>
<t tx="leo1.20171224221228.14">int SKdNodeEdges::AnyEdgeCrossings(Vector a, Vector b, int cnt,
        Vector *pi, SPointList *spl) const
{
    int inters = 0;
    if(gt &amp;&amp; lt) {
        if(a.Element(which) &lt; c + KDTREE_EPS ||
           b.Element(which) &lt; c + KDTREE_EPS)
        {
            inters += lt-&gt;AnyEdgeCrossings(a, b, cnt, pi, spl);
        }
        if(a.Element(which) &gt; c - KDTREE_EPS ||
           b.Element(which) &gt; c - KDTREE_EPS)
        {
            inters += gt-&gt;AnyEdgeCrossings(a, b, cnt, pi, spl);
        }
    } else {
        SEdgeLl *sell;
        for(sell = edges; sell; sell = sell-&gt;next) {
            SEdge *se = sell-&gt;se;
            if(se-&gt;tag == cnt) continue;
            if(se-&gt;EdgeCrosses(a, b, pi, spl)) {
                inters++;
            }
            se-&gt;tag = cnt;
        }
    }
    return inters;
}

//-----------------------------------------------------------------------------
// We have an edge list that contains only collinear edges, maybe with more
// splits than necessary. Merge any collinear segments that join.
//-----------------------------------------------------------------------------
static Vector LineStart, LineDirection;
</t>
<t tx="leo1.20171224221228.15">static int ByTAlongLine(const void *av, const void *bv)
{
    SEdge *a = (SEdge *)av,
          *b = (SEdge *)bv;

    @others
}

</t>
<t tx="leo1.20171224221228.16">    double ta = (a-&gt;a.Minus(LineStart)).DivPivoting(LineDirection),
           tb = (b-&gt;a.Minus(LineStart)).DivPivoting(LineDirection);

    return (ta &gt; tb) ? 1 : -1;
}
void SEdgeList::MergeCollinearSegments(Vector a, Vector b) {
    LineStart = a;
    LineDirection = b.Minus(a);
    qsort(l.elem, l.n, sizeof(l.elem[0]), ByTAlongLine);

    l.ClearTags();
    int i;
    for(i = 1; i &lt; l.n; i++) {
        SEdge *prev = &amp;(l.elem[i-1]),
              *now  = &amp;(l.elem[i]);

        if((prev-&gt;b).Equals(now-&gt;a) &amp;&amp; prev-&gt;auxA == now-&gt;auxA) {
            // The previous segment joins up to us; so merge it into us.
            prev-&gt;tag = 1;
            now-&gt;a = prev-&gt;a;
        }
    }
    l.RemoveTagged();
</t>
<t tx="leo1.20171224221228.17">void SPointList::Clear() {
    l.Clear();
}

</t>
<t tx="leo1.20171224221228.18">bool SPointList::ContainsPoint(Vector pt) const {
    return (IndexForPoint(pt) &gt;= 0);
}

</t>
<t tx="leo1.20171224221228.19">int SPointList::IndexForPoint(Vector pt) const {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        SPoint *p = &amp;(l.elem[i]);
        if(pt.Equals(p-&gt;p)) {
            return i;
        }
    }
    // Not found, so return negative to indicate that.
    return -1;
}

</t>
<t tx="leo1.20171224221228.2">bool STriangle::ContainsPointProjd(Vector n, Vector p) const {
    Vector ab = b.Minus(a), bc = c.Minus(b), ca = a.Minus(c);

    Vector no_ab = n.Cross(ab);
    if(no_ab.Dot(p) &lt; no_ab.Dot(a) - LENGTH_EPS) return false;

    Vector no_bc = n.Cross(bc);
    if(no_bc.Dot(p) &lt; no_bc.Dot(b) - LENGTH_EPS) return false;

    Vector no_ca = n.Cross(ca);
    if(no_ca.Dot(p) &lt; no_ca.Dot(c) - LENGTH_EPS) return false;

    return true;
}

</t>
<t tx="leo1.20171224221228.20">void SPointList::IncrementTagFor(Vector pt) {
    SPoint *p;
    for(p = l.First(); p; p = l.NextAfter(p)) {
        if(pt.Equals(p-&gt;p)) {
            (p-&gt;tag)++;
            return;
        }
    }
    SPoint pa;
    pa.p = pt;
    pa.tag = 1;
    l.Add(&amp;pa);
}

</t>
<t tx="leo1.20171224221228.21">void SPointList::Add(Vector pt) {
    SPoint p = {};
    p.p = pt;
    l.Add(&amp;p);
}

</t>
<t tx="leo1.20171224221228.22">void SContour::AddPoint(Vector p) {
    SPoint sp;
    sp.tag = 0;
    sp.p = p;

    l.Add(&amp;sp);
}

</t>
<t tx="leo1.20171224221228.23">void SContour::MakeEdgesInto(SEdgeList *el) const {
    int i;
    for(i = 0; i &lt; (l.n - 1); i++) {
        el-&gt;AddEdge(l.elem[i].p, l.elem[i+1].p);
    }
}

</t>
<t tx="leo1.20171224221228.24">void SContour::CopyInto(SContour *dest) const {
    for(const SPoint *sp = l.First(); sp; sp = l.NextAfter(sp)) {
        dest-&gt;AddPoint(sp-&gt;p);
    }
}

</t>
<t tx="leo1.20171224221228.25">void SContour::FindPointWithMinX() {
    xminPt = Vector::From(1e10, 1e10, 1e10);
    for(const SPoint *sp = l.First(); sp; sp = l.NextAfter(sp)) {
        if(sp-&gt;p.x &lt; xminPt.x) {
            xminPt = sp-&gt;p;
        }
    }
}

Vector SContour::ComputeNormal() const {
    Vector n = Vector::From(0, 0, 0);

    for(int i = 0; i &lt; l.n - 2; i++) {
        Vector u = (l.elem[i+1].p).Minus(l.elem[i+0].p).WithMagnitude(1);
        Vector v = (l.elem[i+2].p).Minus(l.elem[i+1].p).WithMagnitude(1);
        Vector nt = u.Cross(v);
        if(nt.Magnitude() &gt; n.Magnitude()) {
            n = nt;
        }
    }
    return n.WithMagnitude(1);
}

Vector SContour::AnyEdgeMidpoint() const {
    ssassert(l.n &gt;= 2, "Need two points to find a midpoint");
    return ((l.elem[0].p).Plus(l.elem[1].p)).ScaledBy(0.5);
}

</t>
<t tx="leo1.20171224221228.26">bool SContour::IsClockwiseProjdToNormal(Vector n) const {
    // Degenerate things might happen as we draw; doesn't really matter
    // what we do then.
    if(n.Magnitude() &lt; 0.01) return true;

    return (SignedAreaProjdToNormal(n) &lt; 0);
}

double SContour::SignedAreaProjdToNormal(Vector n) const {
    // An arbitrary 2d coordinate system that has n as its normal
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    double area = 0;
    for(int i = 0; i &lt; (l.n - 1); i++) {
        double u0 = (l.elem[i  ].p).Dot(u);
        double v0 = (l.elem[i  ].p).Dot(v);
        double u1 = (l.elem[i+1].p).Dot(u);
        double v1 = (l.elem[i+1].p).Dot(v);

        area += ((v0 + v1)/2)*(u1 - u0);
    }
    return area;
}

</t>
<t tx="leo1.20171224221228.27">bool SContour::ContainsPointProjdToNormal(Vector n, Vector p) const {
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    double up = p.Dot(u);
    double vp = p.Dot(v);

    bool inside = false;
    for(int i = 0; i &lt; (l.n - 1); i++) {
        double ua = (l.elem[i  ].p).Dot(u);
        double va = (l.elem[i  ].p).Dot(v);
        // The curve needs to be exactly closed; approximation is death.
        double ub = (l.elem[(i+1)%(l.n-1)].p).Dot(u);
        double vb = (l.elem[(i+1)%(l.n-1)].p).Dot(v);

        if ((((va &lt;= vp) &amp;&amp; (vp &lt; vb)) ||
             ((vb &lt;= vp) &amp;&amp; (vp &lt; va))) &amp;&amp;
            (up &lt; (ub - ua) * (vp - va) / (vb - va) + ua))
        {
          inside = !inside;
        }
    }

    return inside;
}

</t>
<t tx="leo1.20171224221228.28">void SContour::Reverse() {
    l.Reverse();
}


</t>
<t tx="leo1.20171224221228.29">void SPolygon::Clear() {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l.elem[i]).l.Clear();
    }
    l.Clear();
}

</t>
<t tx="leo1.20171224221228.3">bool STriangle::Raytrace(const Vector &amp;rayPoint, const Vector &amp;rayDir,
                         double *t, Vector *inters) const {
    // Algorithm from: "Fast, Minimum Storage Ray/Triangle Intersection" by
    // Tomas Moeller and Ben Trumbore.

    // Find vectors for two edges sharing vertex A.
    Vector edge1 = b.Minus(a);
    Vector edge2 = c.Minus(a);

    // Begin calculating determinant - also used to calculate U parameter.
    Vector pvec = rayDir.Cross(edge2);

    // If determinant is near zero, ray lies in plane of triangle.
    // Also, cull back facing triangles here.
    double det = edge1.Dot(pvec);
    if(-det &lt; LENGTH_EPS) return false;
    double inv_det = 1.0f / det;

    // Calculate distance from vertex A to ray origin.
    Vector tvec = rayPoint.Minus(a);

    // Calculate U parameter and test bounds.
    double u = tvec.Dot(pvec) * inv_det;
    if (u &lt; 0.0f || u &gt; 1.0f) return false;

    // Prepare to test V parameter.
    Vector qvec = tvec.Cross(edge1);

    // Calculate V parameter and test bounds.
    double v = rayDir.Dot(qvec) * inv_det;
    if (v &lt; 0.0f || u + v &gt; 1.0f) return false;

    // Calculate t, ray intersects triangle.
    *t = edge2.Dot(qvec) * inv_det;

    // Calculate intersection point.
    if(inters != NULL) *inters = rayPoint.Plus(rayDir.ScaledBy(*t));

    return true;
}

double STriangle::SignedVolume() const {
    return a.Dot(b.Cross(c)) / 6.0;
}

</t>
<t tx="leo1.20171224221228.30">void SPolygon::AddEmptyContour() {
    SContour c = {};
    l.Add(&amp;c);
}

</t>
<t tx="leo1.20171224221228.31">void SPolygon::MakeEdgesInto(SEdgeList *el) const {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l.elem[i]).MakeEdgesInto(el);
    }
}

Vector SPolygon::ComputeNormal() const {
    if(l.n &lt; 1) return Vector::From(0, 0, 0);
    return (l.elem[0]).ComputeNormal();
}

double SPolygon::SignedArea() const {
    double area = 0;
    // This returns the true area only if the contours are all oriented
    // correctly, with the holes backwards from the outer contours.
    for(const SContour *sc = l.First(); sc; sc = l.NextAfter(sc)) {
        area += sc-&gt;SignedAreaProjdToNormal(normal);
    }
    return area;
}

</t>
<t tx="leo1.20171224221228.32">bool SPolygon::ContainsPoint(Vector p) const {
    return (WindingNumberForPoint(p) % 2) == 1;
}

</t>
<t tx="leo1.20171224221228.33">int SPolygon::WindingNumberForPoint(Vector p) const {
    int winding = 0;
    int i;
    for(i = 0; i &lt; l.n; i++) {
        SContour *sc = &amp;(l.elem[i]);
        if(sc-&gt;ContainsPointProjdToNormal(normal, p)) {
            winding++;
        }
    }
    return winding;
}

</t>
<t tx="leo1.20171224221228.34">void SPolygon::FixContourDirections() {
    // At output, the contour's tag will be 1 if we reversed it, else 0.
    l.ClearTags();

    // Outside curve looks counterclockwise, projected against our normal.
    int i, j;
    for(i = 0; i &lt; l.n; i++) {
        SContour *sc = &amp;(l.elem[i]);
        if(sc-&gt;l.n &lt; 2) continue;
        // The contours may not intersect, but they may share vertices; so
        // testing a vertex for point-in-polygon may fail, but the midpoint
        // of an edge is okay.
        Vector pt = (((sc-&gt;l.elem[0]).p).Plus(sc-&gt;l.elem[1].p)).ScaledBy(0.5);

        sc-&gt;timesEnclosed = 0;
        bool outer = true;
        for(j = 0; j &lt; l.n; j++) {
            if(i == j) continue;
            SContour *sct = &amp;(l.elem[j]);
            if(sct-&gt;ContainsPointProjdToNormal(normal, pt)) {
                outer = !outer;
                (sc-&gt;timesEnclosed)++;
            }
        }

        bool clockwise = sc-&gt;IsClockwiseProjdToNormal(normal);
        if((clockwise &amp;&amp; outer) || (!clockwise &amp;&amp; !outer)) {
            sc-&gt;Reverse();
            sc-&gt;tag = 1;
        }
    }
}

</t>
<t tx="leo1.20171224221228.35">bool SPolygon::IsEmpty() const {
    if(l.n == 0 || l.elem[0].l.n == 0) return true;
    return false;
}

Vector SPolygon::AnyPoint() const {
    ssassert(!IsEmpty(), "Need at least one point");
    return l.elem[0].l.elem[0].p;
}

</t>
<t tx="leo1.20171224221228.36">bool SPolygon::SelfIntersecting(Vector *intersectsAt) const {
    SEdgeList el = {};
    MakeEdgesInto(&amp;el);
    SKdNodeEdges *kdtree = SKdNodeEdges::From(&amp;el);

    int cnt = 1;
    el.l.ClearTags();

    bool ret = false;
    SEdge *se;
    for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
        int inters = kdtree-&gt;AnyEdgeCrossings(se-&gt;a, se-&gt;b, cnt, intersectsAt);
        if(inters != 1) {
            ret = true;
            break;
        }
        cnt++;
    }

    el.Clear();
    return ret;
}

</t>
<t tx="leo1.20171224221228.37">void SPolygon::InverseTransformInto(SPolygon *sp, Vector u, Vector v, Vector n) const {
    for(const SContour &amp;sc : l) {
        SContour tsc = {};
        tsc.timesEnclosed = sc.timesEnclosed;
        for(const SPoint &amp;sp : sc.l) {
            tsc.AddPoint(sp.p.DotInToCsys(u, v, n));
        }
        sp-&gt;l.Add(&amp;tsc);
    }
}

//-----------------------------------------------------------------------------
// Low-quality routines to cutter radius compensate a polygon. Assumes the
// polygon is in the xy plane, and the contours all go in the right direction
// with respect to normal (0, 0, -1).
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221228.38">void SPolygon::OffsetInto(SPolygon *dest, double r) const {
    int i;
    dest-&gt;Clear();
    for(i = 0; i &lt; l.n; i++) {
        SContour *sc = &amp;(l.elem[i]);
        dest-&gt;AddEmptyContour();
        sc-&gt;OffsetInto(&amp;(dest-&gt;l.elem[dest-&gt;l.n-1]), r);
    }
}
//-----------------------------------------------------------------------------
// Calculate the intersection point of two lines. Returns true for success,
// false if they're parallel.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221228.39">static bool IntersectionOfLines(double x0A, double y0A, double dxA, double dyA,
                                double x0B, double y0B, double dxB, double dyB,
                                double *xi, double *yi)
{
    double A[2][2];
    double b[2];

    // The line is given to us in the form:
    //    (x(t), y(t)) = (x0, y0) + t*(dx, dy)
    // so first rewrite it as
    //    (x - x0, y - y0) dot (dy, -dx) = 0
    //    x*dy - x0*dy - y*dx + y0*dx = 0
    //    x*dy - y*dx = (x0*dy - y0*dx)

    // So write the matrix, pre-pivoted.
    if(fabs(dyA) &gt; fabs(dyB)) {
        A[0][0] = dyA;  A[0][1] = -dxA;  b[0] = x0A*dyA - y0A*dxA;
        A[1][0] = dyB;  A[1][1] = -dxB;  b[1] = x0B*dyB - y0B*dxB;
    } else {
        A[1][0] = dyA;  A[1][1] = -dxA;  b[1] = x0A*dyA - y0A*dxA;
        A[0][0] = dyB;  A[0][1] = -dxB;  b[0] = x0B*dyB - y0B*dxB;
    }

    // Check the determinant; if it's zero then no solution.
    if(fabs(A[0][0]*A[1][1] - A[0][1]*A[1][0]) &lt; LENGTH_EPS) {
        return false;
    }

    // Solve
    double v = A[1][0] / A[0][0];
    A[1][0] -= A[0][0]*v;
    A[1][1] -= A[0][1]*v;
    b[1] -= b[0]*v;

    // Back-substitute.
    *yi = b[1] / A[1][1];
    *xi = (b[0] - A[0][1]*(*yi)) / A[0][0];

    return true;
}
</t>
<t tx="leo1.20171224221228.4">void STriangle::FlipNormal() {
    swap(a, b);
    swap(an, bn);
}

STriangle STriangle::Transform(Vector u, Vector v, Vector n) const {
    STriangle tr = *this;
    tr.a  = tr.a.ScaleOutOfCsys(u, v, n);
    tr.an = tr.an.ScaleOutOfCsys(u, v, n);
    tr.b  = tr.b.ScaleOutOfCsys(u, v, n);
    tr.bn = tr.bn.ScaleOutOfCsys(u, v, n);
    tr.c  = tr.c.ScaleOutOfCsys(u, v, n);
    tr.cn = tr.cn.ScaleOutOfCsys(u, v, n);
    return tr;
}

STriangle STriangle::From(STriMeta meta, Vector a, Vector b, Vector c) {
    STriangle tr = {};
    tr.meta = meta;
    tr.a = a;
    tr.b = b;
    tr.c = c;
    return tr;
}

SEdge SEdge::From(Vector a, Vector b) {
    SEdge se = {};
    se.a = a;
    se.b = b;
    return se;
}

</t>
<t tx="leo1.20171224221228.40">void SContour::OffsetInto(SContour *dest, double r) const {
    int i;

    for(i = 0; i &lt; l.n; i++) {
        Vector a, b, c;
        Vector dp, dn;
        double thetan, thetap;

        a = l.elem[WRAP(i-1, (l.n-1))].p;
        b = l.elem[WRAP(i,   (l.n-1))].p;
        c = l.elem[WRAP(i+1, (l.n-1))].p;

        dp = a.Minus(b);
        thetap = atan2(dp.y, dp.x);

        dn = b.Minus(c);
        thetan = atan2(dn.y, dn.x);

        // A short line segment in a badly-generated polygon might look
        // okay but screw up our sense of direction.
        if(dp.Magnitude() &lt; LENGTH_EPS || dn.Magnitude() &lt; LENGTH_EPS) {
            continue;
        }

        if(thetan &gt; thetap &amp;&amp; (thetan - thetap) &gt; PI) {
            thetap += 2*PI;
        }
        if(thetan &lt; thetap &amp;&amp; (thetap - thetan) &gt; PI) {
            thetan += 2*PI;
        }

        if(fabs(thetan - thetap) &lt; (1*PI)/180) {
            Vector p = { b.x - r*sin(thetap), b.y + r*cos(thetap), 0 };
            dest-&gt;AddPoint(p);
        } else if(thetan &lt; thetap) {
            // This is an inside corner. We have two edges, Ep and En. Move
            // out from their intersection by radius, normal to En, and
            // then draw a line parallel to En. Move out from their
            // intersection by radius, normal to Ep, and then draw a second
            // line parallel to Ep. The point that we want to generate is
            // the intersection of these two lines--it removes as much
            // material as we can without removing any that we shouldn't.
            double px0, py0, pdx, pdy;
            double nx0, ny0, ndx, ndy;
            double x = 0.0, y = 0.0;

            px0 = b.x - r*sin(thetap);
            py0 = b.y + r*cos(thetap);
            pdx = cos(thetap);
            pdy = sin(thetap);

            nx0 = b.x - r*sin(thetan);
            ny0 = b.y + r*cos(thetan);
            ndx = cos(thetan);
            ndy = sin(thetan);

            IntersectionOfLines(px0, py0, pdx, pdy,
                                nx0, ny0, ndx, ndy,
                                &amp;x, &amp;y);

            dest-&gt;AddPoint(Vector::From(x, y, 0));
        } else {
            if(fabs(thetap - thetan) &lt; (6*PI)/180) {
                Vector pp = { b.x - r*sin(thetap),
                              b.y + r*cos(thetap), 0 };
                dest-&gt;AddPoint(pp);

                Vector pn = { b.x - r*sin(thetan),
                              b.y + r*cos(thetan), 0 };
                dest-&gt;AddPoint(pn);
            } else {
                double theta;
                for(theta = thetap; theta &lt;= thetan; theta += (6*PI)/180) {
                    Vector p = { b.x - r*sin(theta),
                                 b.y + r*cos(theta), 0 };
                    dest-&gt;AddPoint(p);
                }
            }
        }
    }
}

</t>
<t tx="leo1.20171224221228.41">//-----------------------------------------------------------------------------
// A helper class to assemble scattered edges into contiguous polylines,
// as nicely as possible.
//
// Copyright 2016 M-Labs Ltd
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221228.42">bool PolylineBuilder::Vertex::GetNext(uint32_t kind, Vertex **next, Edge **nextEdge) {
    @others
}

</t>
<t tx="leo1.20171224221228.43">auto it = std::find_if(edges.begin(), edges.end(), [&amp;](const Edge *e) {
    return e-&gt;tag == 0 &amp;&amp; e-&gt;kind == kind;
});

if(it != edges.end()) {
    (*it)-&gt;tag = 1;
    *next = (*it)-&gt;GetOtherVertex(this);
    *nextEdge = *it;
    return true;
}

return false;
</t>
<t tx="leo1.20171224221228.44">bool PolylineBuilder::Vertex::GetNext(uint32_t kind, Vector plane, double dist,
                                      Vertex **next, Edge **nextEdge) {
    Edge *best = NULL;
    double minD = VERY_POSITIVE;
    for(Edge *e : edges) {
        if(e-&gt;tag != 0) continue;
        if(e-&gt;kind != kind) continue;

        // We choose the best next edge with minimal distance from the current plane
        Vector nextPos = e-&gt;GetOtherVertex(this)-&gt;pos;
        double curD = fabs(plane.Dot(nextPos) - dist);
        if(best != NULL &amp;&amp; curD &gt; minD) continue;
        best = e;
        minD = curD;
    }

    if(best != NULL) {
        best-&gt;tag = 1;
        *next = best-&gt;GetOtherVertex(this);
        *nextEdge = best;
        return true;
    }

    return false;
}


size_t PolylineBuilder::Vertex::CountEdgesWithTagAndKind(int tag, uint32_t kind) const {
    return std::count_if(edges.begin(), edges.end(), [&amp;](const Edge *e) {
        return e-&gt;tag == tag &amp;&amp; e-&gt;kind == kind;
    });
}

PolylineBuilder::Vertex *PolylineBuilder::Edge::GetOtherVertex(PolylineBuilder::Vertex *v) const {
    if(a == v) return b;
    if(b == v) return a;
    return NULL;
}

size_t PolylineBuilder::VertexPairHash::operator()(const std::pair&lt;Vertex *, Vertex *&gt; &amp;v) const {
    return ((uintptr_t)v.first / sizeof(Vertex)) ^
           ((uintptr_t)v.second / sizeof(Vertex));
}

</t>
<t tx="leo1.20171224221228.45">bool PolylineBuilder::Edge::GetStartAndNext(PolylineBuilder::Vertex **start,
                                            PolylineBuilder::Vertex **next, bool loop) const {
    size_t numA = a-&gt;CountEdgesWithTagAndKind(0, kind);
    size_t numB = b-&gt;CountEdgesWithTagAndKind(0, kind);

    if((numA == 1 &amp;&amp; numB &gt; 1) || (loop &amp;&amp; numA &gt; 1 &amp;&amp; numB &gt; 1)) {
        *start = a;
        *next = b;
        return true;
    }

    if(numA &gt; 1 &amp;&amp; numB == 1) {
        *start = b;
        *next = a;
        return true;
    }

    return false;
}

PolylineBuilder::~PolylineBuilder() {
    Clear();
}

</t>
<t tx="leo1.20171224221228.46">void PolylineBuilder::Clear() {
    for(Edge *e : edges) {
        delete e;
    }
    edges.clear();

    for(auto &amp;v : vertices) {
        delete v.second;
    }
    vertices.clear();
}

PolylineBuilder::Vertex *PolylineBuilder::AddVertex(const Vector &amp;pos) {
    auto it = vertices.find(pos);
    if(it != vertices.end()) {
        return it-&gt;second;
    }

    Vertex *result = new Vertex;
    result-&gt;pos = pos;
    vertices.emplace(pos, result);

    return result;
}

PolylineBuilder::Edge *PolylineBuilder::AddEdge(const Vector &amp;p0, const Vector &amp;p1,
                                                uint32_t kind, uintptr_t data) {
    Vertex *v0 = AddVertex(p0);
    Vertex *v1 = AddVertex(p1);
    if(v0 == v1) return NULL;

    auto it = edgeMap.find(std::make_pair(v0, v1));
    if(it != edgeMap.end()) {
        return it-&gt;second;
    }

    PolylineBuilder::Edge *edge = new PolylineBuilder::Edge {};
    edge-&gt;a = v0;
    edge-&gt;b = v1;
    edge-&gt;kind = kind;
    edge-&gt;tag = 0;
    edge-&gt;data = data;
    edges.push_back(edge);
    edgeMap.emplace(std::make_pair(v0, v1), edge);

    v0-&gt;edges.push_back(edge);
    v1-&gt;edges.push_back(edge);

    return edge;
}

</t>
<t tx="leo1.20171224221228.47">void PolylineBuilder::Generate(
        std::function&lt;void(Vertex *start, Vertex *next, Edge *edge)&gt; startFunc,
        std::function&lt;void(Vertex *next, Edge *edge)&gt; nextFunc,
        std::function&lt;void(Edge *alone)&gt; aloneFunc,
        std::function&lt;void()&gt; endFunc) {
    bool found;
    bool loop = false;
    do {
        found = false;
        for(PolylineBuilder::Edge *e : edges) {
            if(e-&gt;tag != 0) continue;

            Vertex *start;
            Vertex *next;
            if(!e-&gt;GetStartAndNext(&amp;start, &amp;next, loop)) continue;

            Vector startPos = start-&gt;pos;
            Vector nextPos = next-&gt;pos;
            found = true;
            e-&gt;tag = 1;

            startFunc(start, next, e);

            Edge *nextEdge;
            if(next-&gt;GetNext(e-&gt;kind, &amp;next, &amp;nextEdge)) {
                Vector plane = nextPos.Minus(startPos).Cross(next-&gt;pos.Minus(startPos));
                double dist = plane.Dot(startPos);
                nextFunc(next, nextEdge);
                while(next-&gt;GetNext(e-&gt;kind, plane, dist, &amp;next, &amp;nextEdge)) {
                    nextFunc(next, nextEdge);
                }
            }

            endFunc();
        }

        if(!found &amp;&amp; !loop) {
            loop  = true;
            found = true;
        }
    } while(found);

    for(PolylineBuilder::Edge *e : edges) {
        if(e-&gt;tag != 0) continue;
        aloneFunc(e);
    }
}

</t>
<t tx="leo1.20171224221228.48">void PolylineBuilder::MakeFromEdges(const SEdgeList &amp;sel) {
    for(const SEdge &amp;se : sel.l) {
        AddEdge(se.a, se.b, (uint32_t)se.auxA, reinterpret_cast&lt;uintptr_t&gt;(&amp;se));
    }
}

</t>
<t tx="leo1.20171224221228.49">void PolylineBuilder::MakeFromOutlines(const SOutlineList &amp;ol) {
    for(const SOutline &amp;so : ol.l) {
        // Use outline tag as kind, so that emphasized and contour outlines
        // would not be composed together.
        AddEdge(so.a, so.b, (uint32_t)so.tag, reinterpret_cast&lt;uintptr_t&gt;(&amp;so));
    }
}

</t>
<t tx="leo1.20171224221228.5">bool SEdge::EdgeCrosses(Vector ea, Vector eb, Vector *ppi, SPointList *spl) const {
    Vector d = eb.Minus(ea);
    double t_eps = LENGTH_EPS/d.Magnitude();

    double t, tthis;
    bool skew;
    Vector pi;
    bool inOrEdge0, inOrEdge1;

    Vector dthis = b.Minus(a);
    double tthis_eps = LENGTH_EPS/dthis.Magnitude();

    if((ea.Equals(a) &amp;&amp; eb.Equals(b)) ||
       (eb.Equals(a) &amp;&amp; ea.Equals(b)))
    {
        if(ppi) *ppi = a;
        if(spl) spl-&gt;Add(a);
        return true;
    }

    // Can't just test if distance between d and a equals distance between d and b;
    // they could be on opposite sides, since we don't have the sign.
    double m = sqrt(d.Magnitude()*dthis.Magnitude());
    if(sqrt(fabs(d.Dot(dthis))) &gt; (m - LENGTH_EPS)) {
        // The edges are parallel.
        if(fabs(a.DistanceToLine(ea, d)) &gt; LENGTH_EPS) {
            // and not coincident, so can't be interesecting
            return false;
        }
        // The edges are coincident. Make sure that neither endpoint lies
        // on the other
        bool inters = false;
        double t;
        t = a.Minus(ea).DivPivoting(d);
        if(t &gt; t_eps &amp;&amp; t &lt; (1 - t_eps)) inters = true;
        t = b.Minus(ea).DivPivoting(d);
        if(t &gt; t_eps &amp;&amp; t &lt; (1 - t_eps)) inters = true;
        t = ea.Minus(a).DivPivoting(dthis);
        if(t &gt; tthis_eps &amp;&amp; t &lt; (1 - tthis_eps)) inters = true;
        t = eb.Minus(a).DivPivoting(dthis);
        if(t &gt; tthis_eps &amp;&amp; t &lt; (1 - tthis_eps)) inters = true;

        if(inters) {
            if(ppi) *ppi = a;
            if(spl) spl-&gt;Add(a);
            return true;
        } else {
            // So coincident but disjoint, okay.
            return false;
        }
    }

    // Lines are not parallel, so look for an intersection.
    pi = Vector::AtIntersectionOfLines(ea, eb, a, b,
                                       &amp;skew,
                                       &amp;t, &amp;tthis);
    if(skew) return false;

    inOrEdge0 = (t     &gt; -t_eps)     &amp;&amp; (t     &lt; (1 + t_eps));
    inOrEdge1 = (tthis &gt; -tthis_eps) &amp;&amp; (tthis &lt; (1 + tthis_eps));

    if(inOrEdge0 &amp;&amp; inOrEdge1) {
        if(a.Equals(ea) || b.Equals(ea) ||
           a.Equals(eb) || b.Equals(eb))
        {
            // Not an intersection if we share an endpoint with an edge
            return false;
        }
        // But it's an intersection if a vertex of one edge lies on the
        // inside of the other (or if they cross away from either's
        // vertex).
        if(ppi) *ppi = pi;
        if(spl) spl-&gt;Add(pi);
        return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221228.50">void PolylineBuilder::GenerateEdges(SEdgeList *sel) {
    Vector prev;
    @others
}

</t>
<t tx="leo1.20171224221228.51">auto startFunc = [&amp;](Vertex *start, Vertex *next, Edge *e) {
    sel-&gt;AddEdge(start-&gt;pos, next-&gt;pos, e-&gt;kind);
    prev = next-&gt;pos;
};

</t>
<t tx="leo1.20171224221228.52">auto nextFunc = [&amp;](Vertex *next, Edge *e) {
    sel-&gt;AddEdge(prev, next-&gt;pos, e-&gt;kind);
    prev = next-&gt;pos;
};

</t>
<t tx="leo1.20171224221228.53">auto aloneFunc = [&amp;](Edge *e) {
    sel-&gt;AddEdge(e-&gt;a-&gt;pos, e-&gt;b-&gt;pos, e-&gt;kind);
};

Generate(startFunc, nextFunc, aloneFunc);
</t>
<t tx="leo1.20171224221228.54">void PolylineBuilder::GenerateOutlines(SOutlineList *sol) {
    Vector prev;
    @others
}
</t>
<t tx="leo1.20171224221228.55">auto startFunc = [&amp;](Vertex *start, Vertex *next, Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(start-&gt;pos, next-&gt;pos, so-&gt;nl, so-&gt;nr, so-&gt;tag);
    prev = next-&gt;pos;
};

</t>
<t tx="leo1.20171224221228.56">auto nextFunc = [&amp;](Vertex *next, Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(prev, next-&gt;pos, so-&gt;nl, so-&gt;nr, so-&gt;tag);
    prev = next-&gt;pos;
};

</t>
<t tx="leo1.20171224221228.57">auto aloneFunc = [&amp;](Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(so-&gt;a, so-&gt;b, so-&gt;nl, so-&gt;nr, so-&gt;tag);
};

Generate(startFunc, nextFunc, aloneFunc);
</t>
<t tx="leo1.20171224221228.58">//-----------------------------------------------------------------------------
// Implementation of our Request class; a request is a user-created thing
// that will generate an entity (line, curve) when the sketch is generated,
// in the same way that other entities are generated automatically, like
// by an extrude or a step and repeat.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hRequest Request::HREQUEST_REFERENCE_XY = { 1 };
const hRequest Request::HREQUEST_REFERENCE_YZ = { 2 };
const hRequest Request::HREQUEST_REFERENCE_ZX = { 3 };

struct EntReqMapping {
    Request::Type  reqType;
    Entity::Type   entType;
    int            points;
    bool           useExtraPoints;
    bool           hasNormal;
    bool           hasDistance;
};
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221228.59">static const EntReqMapping EntReqMap[] = {
// request type                   entity type                 pts   xtra?   norml   dist
{ Request::Type::WORKPLANE,       Entity::Type::WORKPLANE,      1,  false,  true,   false },
{ Request::Type::DATUM_POINT,     (Entity::Type)0,              1,  false,  false,  false },
{ Request::Type::LINE_SEGMENT,    Entity::Type::LINE_SEGMENT,   2,  false,  false,  false },
{ Request::Type::CUBIC,           Entity::Type::CUBIC,          4,  true,   false,  false },
{ Request::Type::CUBIC_PERIODIC,  Entity::Type::CUBIC_PERIODIC, 3,  true,   false,  false },
{ Request::Type::CIRCLE,          Entity::Type::CIRCLE,         1,  false,  true,   true  },
{ Request::Type::ARC_OF_CIRCLE,   Entity::Type::ARC_OF_CIRCLE,  3,  false,  true,   false },
{ Request::Type::TTF_TEXT,        Entity::Type::TTF_TEXT,       4,  false,  true,   false },
{ Request::Type::IMAGE,           Entity::Type::IMAGE,          4,  false,  true,   false },
};

</t>
<t tx="leo1.20171224221228.6">void SEdgeList::Clear() {
    l.Clear();
}

</t>
<t tx="leo1.20171224221228.60">static void CopyEntityInfo(const EntReqMapping *te, int extraPoints,
                           Entity::Type *ent, Request::Type *req,
                           int *pts, bool *hasNormal, bool *hasDistance)
{
    int points = te-&gt;points;
    if(te-&gt;useExtraPoints) points += extraPoints;

    if(ent)         *ent         = te-&gt;entType;
    if(req)         *req         = te-&gt;reqType;
    if(pts)         *pts         = points;
    if(hasNormal)   *hasNormal   = te-&gt;hasNormal;
    if(hasDistance) *hasDistance = te-&gt;hasDistance;
}

</t>
<t tx="leo1.20171224221228.61">bool EntReqTable::GetRequestInfo(Request::Type req, int extraPoints,
                                 Entity::Type *ent, int *pts, bool *hasNormal, bool *hasDistance)
{
    for(const EntReqMapping &amp;te : EntReqMap) {
        if(req == te.reqType) {
            CopyEntityInfo(&amp;te, extraPoints, ent, NULL, pts, hasNormal, hasDistance);
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo1.20171224221228.62">bool EntReqTable::GetEntityInfo(Entity::Type ent, int extraPoints,
                                Request::Type *req, int *pts, bool *hasNormal, bool *hasDistance)
{
    for(const EntReqMapping &amp;te : EntReqMap) {
        if(ent == te.entType) {
            CopyEntityInfo(&amp;te, extraPoints, NULL, req, pts, hasNormal, hasDistance);
            return true;
        }
    }
    return false;
}

Request::Type EntReqTable::GetRequestForEntity(Entity::Type ent) {
    Request::Type req;
    ssassert(GetEntityInfo(ent, 0, &amp;req, NULL, NULL, NULL),
             "No entity for request");
    return req;
}

</t>
<t tx="leo1.20171224221228.63">void Request::Generate(IdList&lt;Entity,hEntity&gt; *entity,
                       IdList&lt;Param,hParam&gt; *param)
{
    int points = 0;
    Entity::Type et = (Entity::Type)0;
    bool hasNormal = false;
    bool hasDistance = false;
    int i;

    // Request-specific generation.
    switch(type) {
        case Type::TTF_TEXT: {
            double actualAspectRatio = SS.fonts.AspectRatio(font, str);
            if(EXACT(actualAspectRatio != 0.0)) {
                // We could load the font, so use the actual value.
                aspectRatio = actualAspectRatio;
            }
            if(EXACT(aspectRatio == 0.0)) {
                // We couldn't load the font and we don't have anything saved,
                // so just use 1:1, which is valid for the missing font symbol anyhow.
                aspectRatio = 1.0;
            }
            break;
        }

        case Type::IMAGE: {
            auto image = SS.images.find(file);
            if(image != SS.images.end()) {
                std::shared_ptr&lt;Pixmap&gt; pixmap = (*image).second;
                if(pixmap != NULL) {
                    aspectRatio = (double)pixmap-&gt;width / (double)pixmap-&gt;height;
                }
            }
            if(EXACT(aspectRatio == 0.0)) {
                aspectRatio = 1.0;
            }
            break;
        }

        default: // most requests don't do anything else
            break;
    }

    Entity e = {};
    EntReqTable::GetRequestInfo(type, extraPoints, &amp;et, &amp;points, &amp;hasNormal, &amp;hasDistance);

    // Generate the entity that's specific to this request.
    e.type = et;
    e.extraPoints = extraPoints;
    e.group = group;
    e.style = style;
    e.workplane = workplane;
    e.construction = construction;
    e.str = str;
    e.font = font;
    e.file = file;
    e.aspectRatio = aspectRatio;
    e.h = h.entity(0);

    // And generate entities for the points
    for(i = 0; i &lt; points; i++) {
        Entity p = {};
        p.workplane = workplane;
        // points start from entity 1, except for datum point case
        p.h = h.entity(i+((et != (Entity::Type)0) ? 1 : 0));
        p.group = group;
        p.style = style;
        if(type == Request::Type::ARC_OF_CIRCLE &amp;&amp; i == 0) {
            // mark arc center point as construction, since it shouldn't be included
            // in bounding box calculation
            p.construction = true;
        }

        if(workplane.v == Entity::FREE_IN_3D.v) {
            p.type = Entity::Type::POINT_IN_3D;
            // params for x y z
            p.param[0] = AddParam(param, h.param(16 + 3*i + 0));
            p.param[1] = AddParam(param, h.param(16 + 3*i + 1));
            p.param[2] = AddParam(param, h.param(16 + 3*i + 2));
        } else {
            p.type = Entity::Type::POINT_IN_2D;
            // params for u v
            p.param[0] = AddParam(param, h.param(16 + 3*i + 0));
            p.param[1] = AddParam(param, h.param(16 + 3*i + 1));
        }
        entity-&gt;Add(&amp;p);
        e.point[i] = p.h;
    }
    if(hasNormal) {
        Entity n = {};
        n.workplane = workplane;
        n.h = h.entity(32);
        n.group = group;
        n.style = style;
        if(workplane.v == Entity::FREE_IN_3D.v) {
            n.type = Entity::Type::NORMAL_IN_3D;
            n.param[0] = AddParam(param, h.param(32+0));
            n.param[1] = AddParam(param, h.param(32+1));
            n.param[2] = AddParam(param, h.param(32+2));
            n.param[3] = AddParam(param, h.param(32+3));
        } else {
            n.type = Entity::Type::NORMAL_IN_2D;
            // and this is just a copy of the workplane quaternion,
            // so no params required
        }
        ssassert(points &gt;= 1, "Positioning a normal requires a point");
        // The point determines where the normal gets displayed on-screen;
        // it's entirely cosmetic.
        n.point[0] = e.point[0];
        entity-&gt;Add(&amp;n);
        e.normal = n.h;
    }
    if(hasDistance) {
        Entity d = {};
        d.workplane = workplane;
        d.h = h.entity(64);
        d.group = group;
        d.style = style;
        d.type = Entity::Type::DISTANCE;
        d.param[0] = AddParam(param, h.param(64));
        entity-&gt;Add(&amp;d);
        e.distance = d.h;
    }

    if(et != (Entity::Type)0) entity-&gt;Add(&amp;e);
}

std::string Request::DescriptionString() const {
    const char *s = "";
    if(h.v == Request::HREQUEST_REFERENCE_XY.v) {
        s = "#XY";
    } else if(h.v == Request::HREQUEST_REFERENCE_YZ.v) {
        s = "#YZ";
    } else if(h.v == Request::HREQUEST_REFERENCE_ZX.v) {
        s = "#ZX";
    } else {
        switch(type) {
            case Type::WORKPLANE:       s = "workplane";      break;
            case Type::DATUM_POINT:     s = "datum-point";    break;
            case Type::LINE_SEGMENT:    s = "line-segment";   break;
            case Type::CUBIC:           s = "cubic-bezier";   break;
            case Type::CUBIC_PERIODIC:  s = "periodic-cubic"; break;
            case Type::CIRCLE:          s = "circle";         break;
            case Type::ARC_OF_CIRCLE:   s = "arc-of-circle";  break;
            case Type::TTF_TEXT:        s = "ttf-text";       break;
            case Type::IMAGE:           s = "image";          break;
        }
    }
    ssassert(s != NULL, "Unexpected request type");
    return ssprintf("r%03x-%s", h.v, s);
}

</t>
<t tx="leo1.20171224221228.64">int Request::IndexOfPoint(hEntity he) const {
    if(type == Type::DATUM_POINT) {
        return (he.v == h.entity(0).v) ? 0 : -1;
    }
    for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
        if(he.v == h.entity(i + 1).v) {
            return i;
        }
    }
    return -1;
}

hParam Request::AddParam(IdList&lt;Param,hParam&gt; *param, hParam hp) {
    Param pa = {};
    pa.h = hp;
    param-&gt;Add(&amp;pa);
    return hp;
}

</t>
<t tx="leo1.20171224221228.65">//-----------------------------------------------------------------------------
// Discovery and loading of our resources (icons, fonts, templates, etc).
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include &lt;zlib.h&gt;
#include &lt;png.h&gt;
#include &lt;regex&gt;
#include "solvespace.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Resource loading functions
//-----------------------------------------------------------------------------

std::string LoadString(const std::string &amp;name) {
    size_t size;
    const void *data = Platform::LoadResource(name, &amp;size);
    std::string result(static_cast&lt;const char *&gt;(data), size);

    // When editing resources under Windows, Windows newlines may sneak in.
    // Any files with them won't be merged, but ignoring them during development
    // helps external contributors.
    result.erase(std::remove(result.begin(), result.end(), '\r'),
                 result.end());

    return result;
}

std::string LoadStringFromGzip(const std::string &amp;name) {
    size_t deflatedSize;
    const void *data = Platform::LoadResource(name, &amp;deflatedSize);

    z_stream stream;
    stream.zalloc = Z_NULL;
    stream.zfree = Z_NULL;
    stream.opaque = Z_NULL;
    const int windowBits = /*maximum window*/ 15 + /*decode gzip header*/16;
    ssassert(inflateInit2(&amp;stream, windowBits) == Z_OK, "Cannot start inflation");

    // Extract length mod 2**32 from the gzip trailer.
    std::string result;
    ssassert(deflatedSize &gt;= 4, "Resource too small to have gzip trailer");

    // *(uint32_t *) may perform an unaligned access, so do a memcpy.
    uint32_t inflatedSize;
    memcpy(&amp;inflatedSize, (uint32_t *)((uintptr_t)data + deflatedSize - 4), sizeof(uint32_t));
    result.resize(inflatedSize);

    stream.next_in = (Bytef *)data;
    stream.avail_in = (uInt)deflatedSize;
    stream.next_out = (Bytef *)&amp;result[0];
    stream.avail_out = (uInt)result.length();
    ssassert(inflate(&amp;stream, Z_NO_FLUSH) == Z_STREAM_END, "Cannot inflate resource");
    ssassert(stream.avail_out == 0, "Inflated resource larger than what trailer indicates");

    inflateEnd(&amp;stream);

    return result;
}

std::shared_ptr&lt;Pixmap&gt; LoadPng(const std::string &amp;name) {
    size_t size;
    const void *data = Platform::LoadResource(name, &amp;size);

    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::FromPng(static_cast&lt;const uint8_t *&gt;(data), size);
    ssassert(pixmap != nullptr, "Cannot load pixmap");

    return pixmap;
}

//-----------------------------------------------------------------------------
// Pixmap manipulation
//-----------------------------------------------------------------------------

size_t Pixmap::GetBytesPerPixel() const {
    switch(format) {
        case Format::RGBA: return 4;
        case Format::BGRA: return 4;
        case Format::RGB:  return 3;
        case Format::BGR:  return 3;
        case Format::A:    return 1;
    }
    ssassert(false, "Unexpected pixmap format");
}

RgbaColor Pixmap::GetPixel(size_t x, size_t y) const {
    const uint8_t *pixel = &amp;data[y * stride + x * GetBytesPerPixel()];

    switch(format) {
        case Format::RGBA:
            return RgbaColor::From(pixel[0], pixel[1], pixel[2], pixel[3]);

        case Format::RGB:
            return RgbaColor::From(pixel[0], pixel[1], pixel[2],      255);

        case Format::BGRA:
            return RgbaColor::From(pixel[2], pixel[1], pixel[0], pixel[3]);

        case Format::BGR:
            return RgbaColor::From(pixel[2], pixel[1], pixel[0],      255);

        case Format::A:
            return RgbaColor::From(     255,      255,      255, pixel[0]);
    }
    ssassert(false, "Unexpected resource format");
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221228.66">void Pixmap::SetPixel(size_t x, size_t y, RgbaColor color) {
    uint8_t *pixel = &amp;data[y * stride + x * GetBytesPerPixel()];

    switch(format) {
        case Format::RGBA:
            pixel[0] = color.red;
            pixel[1] = color.green;
            pixel[2] = color.blue;
            pixel[3] = color.alpha;
            break;

        case Format::RGB:
            pixel[0] = color.red;
            pixel[1] = color.green;
            pixel[2] = color.blue;
            break;

        case Format::BGRA:
            pixel[0] = color.blue;
            pixel[1] = color.green;
            pixel[2] = color.red;
            pixel[3] = color.alpha;
            break;

        case Format::BGR:
            pixel[0] = color.blue;
            pixel[1] = color.green;
            pixel[2] = color.red;
            break;

        case Format::A:
            pixel[0] = color.alpha;
            break;
    }
}

</t>
<t tx="leo1.20171224221228.67">void Pixmap::ConvertTo(Format newFormat) {
    switch(format) {
        case Format::RGBA:
            ssassert(newFormat == Format::BGRA, "Unexpected target format");
            break;

        case Format::BGRA:
            ssassert(newFormat == Format::RGBA, "Unexpected target format");
            break;

        case Format::RGB:
            ssassert(newFormat == Format::BGR, "Unexpected target format");
            break;

        case Format::BGR:
            ssassert(newFormat == Format::RGB, "Unexpected target format");
            break;

        case Format::A:
            ssassert(false, "Unexpected target format");
    }

    size_t bpp = GetBytesPerPixel();
    for(size_t j = 0; j != height; j++) {
        uint8_t *row = &amp;data[j * stride];
        for(size_t i = 0; i != width * bpp; i += bpp) {
            // This handles both RGB&lt;&gt;BGR and RGBA&lt;&gt;BGRA.
            std::swap(row[i], row[i + 2]);
        }
    }

    format = newFormat;
}

</t>
<t tx="leo1.20171224221228.68">static std::shared_ptr&lt;Pixmap&gt; ReadPngIntoPixmap(png_struct *png_ptr, png_info *info_ptr,
                                                 bool flip) {
    png_read_png(png_ptr, info_ptr, PNG_TRANSFORM_EXPAND | PNG_TRANSFORM_GRAY_TO_RGB, NULL);

    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;width    = png_get_image_width(png_ptr, info_ptr);
    pixmap-&gt;height   = png_get_image_height(png_ptr, info_ptr);
    if((png_get_color_type(png_ptr, info_ptr) &amp; PNG_COLOR_MASK_ALPHA) != 0) {
        pixmap-&gt;format = Pixmap::Format::RGBA;
    } else {
        pixmap-&gt;format = Pixmap::Format::RGB;
    }

    size_t stride = pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel();
    if(stride % 4 != 0) stride += 4 - stride % 4;
    pixmap-&gt;stride = stride;

    pixmap-&gt;data = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    uint8_t **rows = png_get_rows(png_ptr, info_ptr);
    for(size_t y = 0; y &lt; pixmap-&gt;height; y++) {
        uint8_t *srcRow = flip ? rows[pixmap-&gt;height - y - 1] : rows[y];
        memcpy(&amp;pixmap-&gt;data[pixmap-&gt;stride * y], srcRow,
               pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel());
    }

    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return pixmap;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::FromPng(const uint8_t *data, size_t size, bool flip) {
    struct Slice { const uint8_t *data; size_t size; };
    Slice dataSlice = { data, size };
    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_set_read_fn(png_ptr, &amp;dataSlice,
        [](png_struct *png_ptr, uint8_t *data, size_t size) {
            Slice *dataSlice = (Slice *)png_get_io_ptr(png_ptr);
            if(size &lt;= dataSlice-&gt;size) {
                memcpy(data, dataSlice-&gt;data, size);
                dataSlice-&gt;data += size;
                dataSlice-&gt;size -= size;
            } else {
                png_error(png_ptr, "EOF");
            }
        });

    return ReadPngIntoPixmap(png_ptr, info_ptr, flip);

exit:
    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return nullptr;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::ReadPng(FILE *f, bool flip) {
    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    uint8_t header[8];
    if(fread(header, 1, sizeof(header), f) != sizeof(header)) goto exit;
    if(png_sig_cmp(header, 0, sizeof(header))) goto exit;

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_init_io(png_ptr, f);
    png_set_sig_bytes(png_ptr, sizeof(header));

    return ReadPngIntoPixmap(png_ptr, info_ptr, flip);

exit:
    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return nullptr;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::ReadPng(const Platform::Path &amp;filename, bool flip) {
    FILE *f = OpenFile(filename, "rb");
    if(!f) return NULL;
    std::shared_ptr&lt;Pixmap&gt; pixmap = ReadPng(f, flip);
    fclose(f);
    return pixmap;
}

</t>
<t tx="leo1.20171224221228.69">bool Pixmap::WritePng(FILE *f, bool flip) {
    int colorType = 0;
    bool bgr = false;
    switch(format) {
        case Format::RGBA: colorType = PNG_COLOR_TYPE_RGBA; bgr = false; break;
        case Format::BGRA: colorType = PNG_COLOR_TYPE_RGBA; bgr = true;  break;
        case Format::RGB:  colorType = PNG_COLOR_TYPE_RGB;  bgr = false; break;
        case Format::BGR:  colorType = PNG_COLOR_TYPE_RGB;  bgr = true;  break;
        case Format::A:    colorType = PNG_COLOR_TYPE_GRAY; bgr = false; break;
    }

    std::vector&lt;uint8_t *&gt; rows;
    for(size_t y = 0; y &lt; height; y++) {
        if(flip) {
            rows.push_back(&amp;data[stride * (height - y - 1)]);
        } else {
            rows.push_back(&amp;data[stride * y]);
        }
    }

    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_init_io(png_ptr, f);
    png_set_IHDR(png_ptr, info_ptr,
                 (png_uint_32)width, (png_uint_32)height, 8, colorType,
                 PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
    if(bgr) png_set_bgr(png_ptr);
    png_write_info(png_ptr, info_ptr);
    png_write_image(png_ptr, &amp;rows[0]);
    png_write_end(png_ptr, info_ptr);

    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
    return true;

exit:
    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
    return false;
}

</t>
<t tx="leo1.20171224221228.7">void SEdgeList::AddEdge(Vector a, Vector b, int auxA, int auxB, int tag) {
    SEdge e = {};
    e.tag = tag;
    e.a = a;
    e.b = b;
    e.auxA = auxA;
    e.auxB = auxB;
    l.Add(&amp;e);
}

</t>
<t tx="leo1.20171224221228.70">bool Pixmap::WritePng(const Platform::Path &amp;filename, bool flip) {
    FILE *f = OpenFile(filename, "wb");
    if(!f) return false;
    bool success = WritePng(f, flip);
    fclose(f);
    return success;
}

</t>
<t tx="leo1.20171224221228.71">bool Pixmap::Equals(const Pixmap &amp;other) const {
    if(format != other.format || width != other.width || height != other.height) {
        return false;
    }

    size_t rowLength = width * GetBytesPerPixel();
    for(size_t y = 0; y &lt; height; y++) {
        if(memcmp(&amp;data[y * stride], &amp;other.data[y * other.stride], rowLength)) {
            return false;
        }
    }

    return true;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::Create(Format format, size_t width, size_t height) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;format = format;
    pixmap-&gt;width  = width;
    pixmap-&gt;height = height;
    // Align to fulfill OpenGL texture requirements.
    size_t stride = pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel();
    if(stride % 4 != 0) stride += 4 - stride % 4;
    pixmap-&gt;stride = stride;
    pixmap-&gt;data   = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    return pixmap;
}

//-----------------------------------------------------------------------------
// ASCII sequence parsing
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221228.72">class ASCIIReader {
public:
    std::string::const_iterator pos, end;

    @others
};

//-----------------------------------------------------------------------------
// Bitmap font manipulation
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221228.73">static ASCIIReader From(const std::string &amp;str) {
    return ASCIIReader({ str.cbegin(), str.cend() });
}

</t>
<t tx="leo1.20171224221228.74">bool AtEnd() const {
    return pos == end;
}

</t>
<t tx="leo1.20171224221228.75">bool SkipSpace() {
    bool skipped = false;
    while(!AtEnd()) {
        char c = *pos;
        if(!(c == ' ' || c == '\t' || c == '\n')) break;
        skipped = true;
        pos++;
    }
    return skipped;
}

</t>
<t tx="leo1.20171224221228.76">char PeekChar() {
    ssassert(!AtEnd(), "Unexpected EOF");
    return *pos;
}

</t>
<t tx="leo1.20171224221228.77">char ReadChar() {
    ssassert(!AtEnd(), "Unexpected EOF");
    return *pos++;
}

</t>
<t tx="leo1.20171224221228.78">bool TryChar(char c) {
    if(AtEnd()) {
        return false;
    } else if(*pos == c) {
        pos++;
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221228.79">void ExpectChar(char c) {
    if(!TryChar(c)) {
        dbp("Expecting character '%c'", c);
        ssassert(false, "Unexpected character");
    }
}

</t>
<t tx="leo1.20171224221228.8">bool SEdgeList::AssembleContour(Vector first, Vector last, SContour *dest,
                                SEdge *errorAt, bool keepDir) const
{
    int i;

    dest-&gt;AddPoint(first);
    dest-&gt;AddPoint(last);

    do {
        for(i = 0; i &lt; l.n; i++) {
            SEdge *se = &amp;(l.elem[i]);
            if(se-&gt;tag) continue;

            if(se-&gt;a.Equals(last)) {
                dest-&gt;AddPoint(se-&gt;b);
                last = se-&gt;b;
                se-&gt;tag = 1;
                break;
            }
            // Don't allow backwards edges if keepDir is true.
            if(!keepDir &amp;&amp; se-&gt;b.Equals(last)) {
                dest-&gt;AddPoint(se-&gt;a);
                last = se-&gt;a;
                se-&gt;tag = 1;
                break;
            }
        }
        if(i &gt;= l.n) {
            // Couldn't assemble a closed contour; mark where.
            if(errorAt) {
                errorAt-&gt;a = first;
                errorAt-&gt;b = last;
            }
            return false;
        }

    } while(!last.Equals(first));

    return true;
}

</t>
<t tx="leo1.20171224221228.80">bool TryString(const std::string &amp;s) {
    if((size_t)(end - pos) &gt;= s.size() &amp;&amp; std::string(pos, pos + s.size()) == s) {
        pos += s.size();
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221228.81">void ExpectString(const std::string &amp;s) {
    if(!TryString(s)) {
        dbp("Expecting string '%s'", s.c_str());
        ssassert(false, "Unexpected string");
    }
}

size_t CountUntilEol() const {
    return std::find(pos, end, '\n') - pos;
}

</t>
<t tx="leo1.20171224221228.82">void SkipUntilEol() {
    pos = std::find(pos, end, '\n');
}

std::string ReadUntilEol() {
    auto eol = std::find(pos, end, '\n');
    std::string result(pos, eol);
    if(eol != end) {
        pos = eol + 1;
    } else {
        pos = end;
    }
    return result;
}

uint8_t Read4HexBits() {
    char c = ReadChar();
    if(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        return c - '0';
    } else if(c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
        return 10 + (c - 'a');
    } else if(c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
        return 10 + (c - 'A');
    } else ssassert(false, "Unexpected hex digit");
}

uint8_t Read8HexBits() {
    uint8_t h = Read4HexBits(),
            l = Read4HexBits();
    return (h &lt;&lt; 4) + l;
}

uint16_t Read16HexBits() {
    uint16_t h = Read8HexBits(),
             l = Read8HexBits();
    return (h &lt;&lt; 8) + l;
}

long ReadIntegerDecimal(int base = 10) {
    char *endptr;
    long l = strtol(&amp;*pos, &amp;endptr, base);
    ssassert(&amp;*pos != endptr, "Cannot read an integer number");
    pos += endptr - &amp;*pos;
    return l;
}

</t>
<t tx="leo1.20171224221228.83">double ReadFloatDecimal() {
    char *endptr;
    double d = strtod(&amp;*pos, &amp;endptr);
    ssassert(&amp;*pos != endptr, "Cannot read a floating-point number");
    pos += endptr - &amp;*pos;
    return d;
}

</t>
<t tx="leo1.20171224221228.84">bool TryRegex(const std::regex &amp;re, std::smatch *m) {
    if(std::regex_search(pos, end, *m, re, std::regex_constants::match_continuous)) {
        pos += m-&gt;length();
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221228.85">void ExpectRegex(const std::regex &amp;re, std::smatch *m) {
    ssassert(TryRegex(re, m), "Unmatched regex");
}
</t>
<t tx="leo1.20171224221228.86">static uint8_t *BitmapFontTextureRow(std::shared_ptr&lt;Pixmap&gt; texture,
                                     uint16_t position, size_t y) {
    // position = 0;
    size_t col = position % (texture-&gt;width / 16),
           row = position / (texture-&gt;width / 16);
    return &amp;texture-&gt;data[texture-&gt;stride * (16 * row + y) + 16 * col];
}

BitmapFont BitmapFont::From(std::string &amp;&amp;unifontData) {
    BitmapFont font  = {};
    font.unifontData = std::move(unifontData);
    font.texture     = Pixmap::Create(Pixmap::Format::A, 1024, 1024);

    return font;
}

</t>
<t tx="leo1.20171224221228.87">void BitmapFont::AddGlyph(char32_t codepoint, std::shared_ptr&lt;const Pixmap&gt; pixmap) {
    ssassert((pixmap-&gt;width == 8 || pixmap-&gt;width == 16) &amp;&amp; pixmap-&gt;height == 16,
             "Unexpected pixmap dimensions");
    ssassert(pixmap-&gt;format == Pixmap::Format::RGB,
             "Unexpected pixmap format");
    ssassert(glyphs.find(codepoint) == glyphs.end(),
             "Glyph with this codepoint already exists");
    ssassert(nextPosition != 0xffff,
             "Too many glyphs for current texture size");

    BitmapFont::Glyph glyph = {};
    glyph.advanceCells = (uint8_t)(pixmap-&gt;width / 8);
    glyph.position     = nextPosition++;
    glyphs.emplace(codepoint, std::move(glyph));

    for(size_t y = 0; y &lt; pixmap-&gt;height; y++) {
        uint8_t *row = BitmapFontTextureRow(texture, glyph.position, y);
        for(size_t x = 0; x &lt; pixmap-&gt;width; x++) {
            if((pixmap-&gt;GetPixel(x, y).ToPackedInt() &amp; 0xffffff) != 0) {
                row[x] = 255;
            }
        }
    }
}

</t>
<t tx="leo1.20171224221228.88">const BitmapFont::Glyph &amp;BitmapFont::GetGlyph(char32_t codepoint) {
    auto it = glyphs.find(codepoint);
    if(it != glyphs.end()) {
        return (*it).second;
    }

    ssassert(nextPosition != 0xffff,
             "Too many glyphs for current texture size");

    // Find the hex representation in the (sorted) Unifont file.
    @others
}

</t>
<t tx="leo1.20171224221228.89">auto first = unifontData.cbegin(),
     last  = unifontData.cend();
while(first &lt;= last) {
    auto mid = first + (last - first) / 2;
    while(mid != unifontData.cbegin()) {
        if(*mid == '\n') {
            mid++;
            break;
        }
        mid--;
    }

    ASCIIReader reader = { mid, unifontData.cend() };
    if(reader.AtEnd()) break;

    // Read the codepoint.
    char32_t foundCodepoint = reader.Read16HexBits();
    reader.ExpectChar(':');

    if(foundCodepoint &gt; codepoint) {
        last = mid - 1;
        continue; // and first stays the same
    }
    if(foundCodepoint &lt; codepoint) {
        first = mid + 1;
        while(first != unifontData.cend()) {
            if(*first == '\n') break;
            first++;
        }
        continue; // and last stays the same
    }

    // Found the codepoint.
    Glyph glyph = {};
    glyph.position = nextPosition++;

    // Read glyph bits.
    unsigned short glyphBits[16];
    size_t glyphLength = reader.CountUntilEol();
    if(glyphLength == 4 * 16) {
        glyph.advanceCells = 2;
        for(size_t i = 0; i &lt; 16; i++) {
            glyphBits[i] = reader.Read16HexBits();
        }
    } else if(glyphLength == 2 * 16) {
        glyph.advanceCells = 1;
        for(size_t i = 0; i &lt; 16; i++) {
            glyphBits[i] = (uint16_t)reader.Read8HexBits() &lt;&lt; 8;
        }
    } else ssassert(false, "Unexpected glyph bitmap length");

    // Fill in the texture (one texture byte per glyph bit).
    for(size_t y = 0; y &lt; 16; y++) {
        uint8_t *row = BitmapFontTextureRow(texture, glyph.position, y);
        for(size_t x = 0; x &lt; 16; x++) {
            if(glyphBits[y] &amp; (1 &lt;&lt; (15 - x))) {
                row[x] = 255;
            }
        }
    }

    it = glyphs.emplace(codepoint, std::move(glyph)).first;
    textureUpdated = true;
    return (*it).second;
}

// Glyph doesn't exist; return replacement glyph instead.
ssassert(codepoint != 0xfffd, "Cannot parse replacement glyph");
return GetGlyph(0xfffd);
</t>
<t tx="leo1.20171224221228.9">bool SEdgeList::AssemblePolygon(SPolygon *dest, SEdge *errorAt, bool keepDir) const {
    dest-&gt;Clear();

    bool allClosed = true;
    for(;;) {
        Vector first = Vector::From(0, 0, 0);
        Vector last  = Vector::From(0, 0, 0);
        int i;
        for(i = 0; i &lt; l.n; i++) {
            if(!l.elem[i].tag) {
                first = l.elem[i].a;
                last = l.elem[i].b;
                l.elem[i].tag = 1;
                break;
            }
        }
        if(i &gt;= l.n) {
            return allClosed;
        }

        // Create a new empty contour in our polygon, and finish assembling
        // into that contour.
        dest-&gt;AddEmptyContour();
        if(!AssembleContour(first, last, &amp;(dest-&gt;l.elem[dest-&gt;l.n-1]),
                errorAt, keepDir))
        {
            allClosed = false;
        }
        // But continue assembling, even if some of the contours are open
    }
}

//-----------------------------------------------------------------------------
// Test if the specified edge crosses any of the edges in our list. Two edges
// are not considered to cross if they share an endpoint (within LENGTH_EPS),
// but they are considered to cross if they are coincident and overlapping.
// If pi is not NULL, then a crossing is returned in that.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221228.90">void BitmapFont::LocateGlyph(char32_t codepoint,
                             double *s0, double *t0, double *s1, double *t1,
                             size_t *w, size_t *h) {
    const Glyph &amp;glyph = GetGlyph(codepoint);
    *w  = glyph.advanceCells * 8;
    *h  = 16;
    *s0 = (16.0 * (glyph.position % (texture-&gt;width / 16))) / texture-&gt;width;
    *s1 = *s0 + (double)(*w) / texture-&gt;width;
    *t0 = (16.0 * (glyph.position / (texture-&gt;width / 16))) / texture-&gt;height;
    *t1 = *t0 + (double)(*h) / texture-&gt;height;
}

size_t BitmapFont::GetWidth(char32_t codepoint) {
    if(codepoint &gt;= 0xe000 &amp;&amp; codepoint &lt;= 0xefff) {
        // These are special-cased because checkboxes predate support for 2 cell wide
        // characters; and so all Printf() calls pad them with spaces.
        return 1;
    }

    return GetGlyph(codepoint).advanceCells;
}

size_t BitmapFont::GetWidth(const std::string &amp;str) {
    size_t width = 0;
    for(char32_t codepoint : ReadUTF8(str)) {
        width += GetWidth(codepoint);
    }
    return width;
}

BitmapFont BitmapFont::Create() {
    BitmapFont Font = BitmapFont::From(LoadStringFromGzip("fonts/unifont.hex.gz"));
    // Unifont doesn't have a glyph for U+0020.
    Font.AddGlyph(0x0020, Pixmap::Create(Pixmap::Format::RGB, 8, 16));
    Font.AddGlyph(0xE000, LoadPng("fonts/private/0-check-false.png"));
    Font.AddGlyph(0xE001, LoadPng("fonts/private/1-check-true.png"));
    Font.AddGlyph(0xE002, LoadPng("fonts/private/2-radio-false.png"));
    Font.AddGlyph(0xE003, LoadPng("fonts/private/3-radio-true.png"));
    Font.AddGlyph(0xE004, LoadPng("fonts/private/4-stipple-dot.png"));
    Font.AddGlyph(0xE005, LoadPng("fonts/private/5-stipple-dash-long.png"));
    Font.AddGlyph(0xE006, LoadPng("fonts/private/6-stipple-dash.png"));
    Font.AddGlyph(0xE007, LoadPng("fonts/private/7-stipple-zigzag.png"));
    return Font;
}

//-----------------------------------------------------------------------------
// Vector font manipulation
//-----------------------------------------------------------------------------

const static int ARC_POINTS = 8;
</t>
<t tx="leo1.20171224221228.91">static void MakePwlArc(VectorFont::Contour *contour, bool isReversed,
                       const Point2d &amp;cp, double radius, double a1, double a2) {
    if(radius &lt; LENGTH_EPS) return;

    double aSign = 1.0;
    if(isReversed) {
        if(a1 &lt;= a2 + LENGTH_EPS) a1 += 2.0 * M_PI;
        aSign = -1.0;
    } else {
        if(a2 &lt;= a1 + LENGTH_EPS) a2 += 2.0 * M_PI;
    }

    double aStep = aSign * fabs(a2 - a1) / (double)ARC_POINTS;
    for(int i = 0; i &lt;= ARC_POINTS; i++) {
        contour-&gt;points.emplace_back(cp.Plus(Point2d::FromPolar(radius, a1 + aStep * i)));
    }
}

</t>
<t tx="leo1.20171224221228.92">static void MakePwlBulge(VectorFont::Contour *contour, const Point2d &amp;v, double bulge) {
    bool reversed = bulge &lt; 0.0;
    double alpha = atan(bulge) * 4.0;
    const Point2d &amp;point = contour-&gt;points.back();

    Point2d middle = point.Plus(v).ScaledBy(0.5);
    double dist = point.DistanceTo(v) / 2.0;
    double angle = point.AngleTo(v);

    // alpha can't be 0.0 at this point
    double radius = fabs(dist / sin(alpha / 2.0));
    double wu = fabs(radius*radius - dist*dist);
    double h = sqrt(wu);

    if(bulge &gt; 0.0) {
        angle += M_PI_2;
    } else {
        angle -= M_PI_2;
    }

    if(fabs(alpha) &gt; M_PI) {
        h = -h;
    }

    Point2d center = Point2d::FromPolar(h, angle).Plus(middle);
    double a1 = center.AngleTo(point);
    double a2 = center.AngleTo(v);
    MakePwlArc(contour, reversed, center, radius, a1, a2);
}

</t>
<t tx="leo1.20171224221228.93">static void GetGlyphBBox(const VectorFont::Glyph &amp;glyph,
                         double *rminx, double *rmaxx, double *rminy, double *rmaxy) {
    double minx = 0.0, maxx = 0.0, miny = 0.0, maxy = 0.0;
    if(!glyph.contours.empty()) {
        const Point2d &amp;start = glyph.contours[0].points[0];
        minx = maxx = start.x;
        miny = maxy = start.y;
        for(const VectorFont::Contour &amp;c : glyph.contours) {
            for(const Point2d &amp;p : c.points) {
                maxx = std::max(maxx, p.x);
                minx = std::min(minx, p.x);
                maxy = std::max(maxy, p.y);
                miny = std::min(miny, p.y);
            }
        }
    }

    if(rminx) *rminx = minx;
    if(rmaxx) *rmaxx = maxx;
    if(rminy) *rminy = miny;
    if(rmaxy) *rmaxy = maxy;
}

VectorFont VectorFont::From(std::string &amp;&amp;lffData) {
    VectorFont font = {};
    font.lffData = std::move(lffData);

    ASCIIReader reader = ASCIIReader::From(font.lffData);
    std::smatch m;
    while(reader.TryRegex(std::regex("#\\s*(\\w+)\\s*:\\s*(.+?)\n"), &amp;m)) {
        std::string name  = m.str(1),
                    value = m.str(2);
        std::transform(name.begin(), name.end(), name.begin(), ::tolower);
        if(name == "letterspacing") {
            font.rightSideBearing = std::stod(value);
        } else if(name == "wordspacing") {
            Glyph space = {};
            space.advanceWidth = std::stod(value);
            font.glyphs.emplace(' ', std::move(space));
        }
    }

    GetGlyphBBox(font.GetGlyph('A'), nullptr, nullptr, nullptr, &amp;font.capHeight);
    GetGlyphBBox(font.GetGlyph('h'), nullptr, nullptr, nullptr, &amp;font.ascender);
    GetGlyphBBox(font.GetGlyph('p'), nullptr, nullptr, &amp;font.descender, nullptr);

    ssassert(!font.IsEmpty(), "Expected to load a font");
    return font;
}

</t>
<t tx="leo1.20171224221229.1">const VectorFont::Glyph &amp;VectorFont::GetGlyph(char32_t codepoint) {
    auto it = glyphs.find(codepoint);
    if(it != glyphs.end()) {
        return (*it).second;
    }

    auto firstGlyph = std::find(lffData.cbegin(), lffData.cend(), '[');
    ssassert(firstGlyph != lffData.cend(), "Vector font contains no glyphs");

    // Find the serialized representation in the (sorted) lff file.
    @others
}

VectorFont *VectorFont::Builtin() {
    static VectorFont Font;
    if(Font.IsEmpty()) {
        Font = VectorFont::From(LoadStringFromGzip("fonts/unicode.lff.gz"));
    }
    return &amp;Font;
}

double VectorFont::GetCapHeight(double forCapHeight) const {
    ssassert(!IsEmpty(), "Expected a loaded font");

    return forCapHeight;
}

double VectorFont::GetHeight(double forCapHeight) const {
    ssassert(!IsEmpty(), "Expected a loaded font");

    return (ascender - descender) * (forCapHeight / capHeight);
}

double VectorFont::GetWidth(double forCapHeight, const std::string &amp;str) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    double width = 0;
    for(char32_t codepoint : ReadUTF8(str)) {
        width += GetGlyph(codepoint).advanceWidth;
    }
    width -= rightSideBearing;
    return width * (forCapHeight / capHeight);
}

Vector VectorFont::GetExtents(double forCapHeight, const std::string &amp;str) {
    Vector ex = {};
    ex.x = GetWidth(forCapHeight, str);
    ex.y = GetHeight(forCapHeight);
    return ex;
}

</t>
<t tx="leo1.20171224221229.10">unsigned PluralExpr::Eval(const std::string &amp;s, unsigned n) {
    PluralExpr expr = {};
    expr.reader = ASCIIReader::From(s);
    expr.value  = n;
    expr.Eval();

    Token t = expr.PopToken();
    ssassert(t.type == Token::Type::VALUE, "Expected a value");
    return t.value;
}

//-----------------------------------------------------------------------------
// Gettext message keys
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221229.100">void TextWindow::ShowHeader(bool withNav) {
    ClearScreen();

    const char *header;
    std::string desc;
    if(SS.GW.LockedInWorkplane()) {
        header = "in plane: ";
        desc = SK.GetEntity(SS.GW.ActiveWorkplane())-&gt;DescriptionString();
    } else {
        header = "drawing / constraining in 3d";
        desc = "";
    }

    // Navigation buttons
    if(withNav) {
        Printf(false, " %Fl%Lh%fhome%E   %Ft%s%E%s",
            (&amp;TextWindow::ScreenHome), header, desc.c_str());
    } else {
        Printf(false, "        %Ft%s%E%s", header, desc.c_str());
    }

    // Leave space for the icons that are painted here.
    Printf(false, "");
    Printf(false, "");
}

//-----------------------------------------------------------------------------
// The screen that shows a list of every group in the sketch, with options
// to hide or show them, and to view them in detail. This is our home page.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.101">void TextWindow::ScreenSelectGroup(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::GROUP_INFO);
    SS.TW.shown.group.v = v;
}
</t>
<t tx="leo1.20171224221229.102">void TextWindow::ScreenToggleGroupShown(int link, uint32_t v) {
    hGroup hg = { v };
    Group *g = SK.GetGroup(hg);
    g-&gt;visible = !(g-&gt;visible);
    // If a group was just shown, then it might not have been generated
    // previously, so regenerate.
    SS.GenerateAll();
}
</t>
<t tx="leo1.20171224221229.103">void TextWindow::ScreenShowGroupsSpecial(int link, uint32_t v) {
    bool state = link == 's';
    for(int i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        g-&gt;visible = state;
    }
    SS.GW.persistentDirty = true;
}
</t>
<t tx="leo1.20171224221229.104">void TextWindow::ScreenActivateGroup(int link, uint32_t v) {
    SS.GW.activeGroup.v = v;
    SK.GetGroup(SS.GW.activeGroup)-&gt;Activate();
    SS.GW.ClearSuper();
}
</t>
<t tx="leo1.20171224221229.105">void TextWindow::ReportHowGroupSolved(hGroup hg) {
    SS.GW.ClearSuper();
    SS.TW.GoToScreen(Screen::GROUP_SOLVE_INFO);
    SS.TW.shown.group.v = hg.v;
    SS.ScheduleShowTW();
}
</t>
<t tx="leo1.20171224221229.106">void TextWindow::ScreenHowGroupSolved(int link, uint32_t v) {
    if(SS.GW.activeGroup.v != v) {
        ScreenActivateGroup(link, v);
    }
    SS.TW.GoToScreen(Screen::GROUP_SOLVE_INFO);
    SS.TW.shown.group.v = v;
}
</t>
<t tx="leo1.20171224221229.107">void TextWindow::ScreenShowConfiguration(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::CONFIGURATION);
}
</t>
<t tx="leo1.20171224221229.108">void TextWindow::ScreenShowEditView(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::EDIT_VIEW);
}
</t>
<t tx="leo1.20171224221229.109">void TextWindow::ScreenGoToWebsite(int link, uint32_t v) {
    OpenWebsite("http://solvespace.com/txtlink");
}
</t>
<t tx="leo1.20171224221229.11">class TranslationKey {
public:
    bool        hasContext;
    std::string context;
    std::string ident;
};

struct TranslationKeyLess {
</t>
<t tx="leo1.20171224221229.110">void TextWindow::ShowListOfGroups() {
    @others
}


//-----------------------------------------------------------------------------
// The screen that shows information about a specific group, and allows the
// user to edit various things about it.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.111">const char *radioTrue  = " " RADIO_TRUE  " ",
           *radioFalse = " " RADIO_FALSE " ",
           *checkTrue  = " " CHECK_TRUE  " ",
           *checkFalse = " " CHECK_FALSE " ";

Printf(true, "%Ft active");
Printf(false, "%Ft    shown ok  group-name%E");
int i;
bool afterActive = false;
for(i = 0; i &lt; SK.groupOrder.n; i++) {
    Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
    std::string s = g-&gt;DescriptionString();
    bool active = (g-&gt;h.v == SS.GW.activeGroup.v);
    bool shown = g-&gt;visible;
    bool ok = g-&gt;IsSolvedOkay();
    bool ref = (g-&gt;h.v == Group::HGROUP_REFERENCES.v);
    Printf(false, "%Bp%Fd "
           "%Ft%s%Fb%D%f%Ll%s%E "
           "%Fb%s%D%f%Ll%s%E  "
           "%Fp%D%f%s%Ll%s%E  "
           "%Fl%Ll%D%f%s",
        // Alternate between light and dark backgrounds, for readability
            (i &amp; 1) ? 'd' : 'a',
        // Link that activates the group
            ref ? "   " : "",
            g-&gt;h.v, (&amp;TextWindow::ScreenActivateGroup),
            ref ? "" : (active ? radioTrue : radioFalse),
        // Link that hides or shows the group
            afterActive ? " - " : "",
            g-&gt;h.v, (&amp;TextWindow::ScreenToggleGroupShown),
            afterActive ? "" : (shown ? checkTrue : checkFalse),
        // Link to the errors, if a problem occured while solving
        ok ? 's' : 'x', g-&gt;h.v, (&amp;TextWindow::ScreenHowGroupSolved),
            ok ? "ok" : "",
            ok ? "" : "NO",
        // Link to a screen that gives more details on the group
        g-&gt;h.v, (&amp;TextWindow::ScreenSelectGroup), s.c_str());

    if(active) afterActive = true;
}

Printf(true,  "  %Fl%Ls%fshow all%E / %Fl%Lh%fhide all%E",
    &amp;(TextWindow::ScreenShowGroupsSpecial),
    &amp;(TextWindow::ScreenShowGroupsSpecial));
Printf(true,  "  %Fl%Ls%fline styles%E /"
               " %Fl%Ls%fview%E /"
               " %Fl%Ls%fconfiguration%E",
    &amp;(TextWindow::ScreenShowListOfStyles),
    &amp;(TextWindow::ScreenShowEditView),
    &amp;(TextWindow::ScreenShowConfiguration));
</t>
<t tx="leo1.20171224221229.112">void TextWindow::ScreenHoverConstraint(int link, uint32_t v) {
    if(!SS.GW.showConstraints) return;

    hConstraint hc = { v };
    SS.GW.hover.Clear();
    SS.GW.hover.constraint = hc;
    SS.GW.hover.emphasized = true;
}
</t>
<t tx="leo1.20171224221229.113">void TextWindow::ScreenHoverRequest(int link, uint32_t v) {
    SS.GW.hover.Clear();
    hRequest hr = { v };
    SS.GW.hover.entity = hr.entity(0);
    SS.GW.hover.emphasized = true;
}
</t>
<t tx="leo1.20171224221229.114">void TextWindow::ScreenSelectConstraint(int link, uint32_t v) {
    SS.GW.ClearSelection();
    GraphicsWindow::Selection sel = {};
    sel.constraint.v = v;
    SS.GW.selection.Add(&amp;sel);
}
</t>
<t tx="leo1.20171224221229.115">void TextWindow::ScreenSelectRequest(int link, uint32_t v) {
    SS.GW.ClearSelection();
    GraphicsWindow::Selection sel = {};
    hRequest hr = { v };
    sel.entity = hr.entity(0);
    SS.GW.selection.Add(&amp;sel);
}

</t>
<t tx="leo1.20171224221229.116">void TextWindow::ScreenChangeGroupOption(int link, uint32_t v) {
    SS.UndoRemember();
    Group *g = SK.GetGroup(SS.TW.shown.group);

    switch(link) {
        case 's': g-&gt;subtype = Group::Subtype::ONE_SIDED; break;
        case 'S': g-&gt;subtype = Group::Subtype::TWO_SIDED; break;

        case 'k': g-&gt;skipFirst = true; break;
        case 'K': g-&gt;skipFirst = false; break;

        case 'c':
            if(g-&gt;type == Group::Type::EXTRUDE) {
                // When an extrude group is first created, it's positioned for a union
                // extrusion. If no constraints were added, flip it when we switch between
                // union and difference modes to avoid manual work doing the smae.
                if(g-&gt;meshCombine != (Group::CombineAs)v &amp;&amp; g-&gt;GetNumConstraints() == 0 &amp;&amp;
                        ((Group::CombineAs)v == Group::CombineAs::DIFFERENCE ||
                        g-&gt;meshCombine == Group::CombineAs::DIFFERENCE)) {
                    g-&gt;ExtrusionForceVectorTo(g-&gt;ExtrusionGetVector().Negated());
                }
            }
            g-&gt;meshCombine = (Group::CombineAs)v;
            break;

        case 'P': g-&gt;suppress = !(g-&gt;suppress); break;

        case 'r': g-&gt;relaxConstraints = !(g-&gt;relaxConstraints); break;

        case 'e': g-&gt;allowRedundant = !(g-&gt;allowRedundant); break;

        case 'v': g-&gt;visible = !(g-&gt;visible); break;

        case 'd': g-&gt;allDimsReference = !(g-&gt;allDimsReference); break;

        case 'f': g-&gt;forceToMesh = !(g-&gt;forceToMesh); break;
    }

    SS.MarkGroupDirty(g-&gt;h);
    SS.GW.ClearSuper();
}

</t>
<t tx="leo1.20171224221229.117">void TextWindow::ScreenColor(int link, uint32_t v) {
    SS.UndoRemember();

    Group *g = SK.GetGroup(SS.TW.shown.group);
    SS.TW.ShowEditControlWithColorPicker(3, g-&gt;color);
    SS.TW.edit.meaning = Edit::GROUP_COLOR;
}
</t>
<t tx="leo1.20171224221229.118">void TextWindow::ScreenOpacity(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(11, ssprintf("%.2f", g-&gt;color.alphaF()));
    SS.TW.edit.meaning = Edit::GROUP_OPACITY;
    SS.TW.edit.group.v = g-&gt;h.v;
}
</t>
<t tx="leo1.20171224221229.119">void TextWindow::ScreenChangeExprA(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(10, ssprintf("%d", (int)g-&gt;valA));
    SS.TW.edit.meaning = Edit::TIMES_REPEATED;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo1.20171224221229.12">    bool operator()(const TranslationKey &amp;a, const TranslationKey &amp;b) const {
        return a.hasContext &lt; b.hasContext ||
            (a.hasContext == b.hasContext &amp;&amp; a.context &lt; b.context) ||
            (a.hasContext == b.hasContext &amp;&amp; a.context == b.context &amp;&amp; a.ident &lt; b.ident);
    }
};

//-----------------------------------------------------------------------------
// Gettext .po file parsing
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221229.120">void TextWindow::ScreenChangeGroupName(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);
    SS.TW.ShowEditControl(12, g-&gt;DescriptionString().substr(5));
    SS.TW.edit.meaning = Edit::GROUP_NAME;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo1.20171224221229.121">void TextWindow::ScreenChangeGroupScale(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(13, ssprintf("%.3f", g-&gt;scale));
    SS.TW.edit.meaning = Edit::GROUP_SCALE;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo1.20171224221229.122">void TextWindow::ScreenDeleteGroup(int link, uint32_t v) {
    SS.UndoRemember();

    hGroup hg = SS.TW.shown.group;
    if(hg.v == SS.GW.activeGroup.v) {
        SS.GW.activeGroup = SK.GetGroup(SS.GW.activeGroup)-&gt;PreviousGroup()-&gt;h;
    }

    // Reset the text window, since we're displaying information about
    // the group that's about to get deleted.
    SS.TW.ClearSuper();

    // This is a major change, so let's re-solve everything.
    SK.group.RemoveById(hg);
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);

    // Reset the graphics window. This will also recreate the default
    // group if it was removed.
    SS.GW.ClearSuper();
}
</t>
<t tx="leo1.20171224221229.123">void TextWindow::ShowGroupInfo() {
    Group *g = SK.GetGroup(shown.group);
    const char *s = "???";

    if(shown.group.v == Group::HGROUP_REFERENCES.v) {
        Printf(true, "%FtGROUP  %E%s", g-&gt;DescriptionString().c_str());
        goto list_items;
    } else {
        Printf(true, "%FtGROUP  %E%s [%Fl%Ll%D%frename%E/%Fl%Ll%D%fdel%E]",
            g-&gt;DescriptionString().c_str(),
            g-&gt;h.v, &amp;TextWindow::ScreenChangeGroupName,
            g-&gt;h.v, &amp;TextWindow::ScreenDeleteGroup);
    }

    if(g-&gt;type == Group::Type::LATHE) {
        Printf(true, " %Ftlathe plane sketch");
    } else if(g-&gt;type == Group::Type::EXTRUDE || g-&gt;type == Group::Type::ROTATE ||
              g-&gt;type == Group::Type::TRANSLATE)
    {
        if(g-&gt;type == Group::Type::EXTRUDE) {
            s = "extrude plane sketch";
        } else if(g-&gt;type == Group::Type::TRANSLATE) {
            s = "translate original sketch";
        } else if(g-&gt;type == Group::Type::ROTATE) {
            s = "rotate original sketch";
        }
        Printf(true, " %Ft%s%E", s);

        bool one = (g-&gt;subtype == Group::Subtype::ONE_SIDED);
        Printf(false,
            "%Ba   %f%Ls%Fd%s one-sided%E  "
                  "%f%LS%Fd%s two-sided%E",
            &amp;TextWindow::ScreenChangeGroupOption,
            one ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            !one ? RADIO_TRUE : RADIO_FALSE);

        if(g-&gt;type == Group::Type::ROTATE || g-&gt;type == Group::Type::TRANSLATE) {
            if(g-&gt;subtype == Group::Subtype::ONE_SIDED) {
                bool skip = g-&gt;skipFirst;
                Printf(false,
                   "%Bd   %Ftstart  %f%LK%Fd%s with original%E  "
                         "%f%Lk%Fd%s with copy #1%E",
                    &amp;ScreenChangeGroupOption,
                    !skip ? RADIO_TRUE : RADIO_FALSE,
                    &amp;ScreenChangeGroupOption,
                    skip ? RADIO_TRUE : RADIO_FALSE);
            }

            int times = (int)(g-&gt;valA);
            Printf(false, "%Bp   %Ftrepeat%E %d time%s %Fl%Ll%D%f[change]%E",
                (g-&gt;subtype == Group::Subtype::ONE_SIDED) ? 'a' : 'd',
                times, times == 1 ? "" : "s",
                g-&gt;h.v, &amp;TextWindow::ScreenChangeExprA);
        }
    } else if(g-&gt;type == Group::Type::LINKED) {
        Printf(true, " %Ftlink geometry from file%E");
        Platform::Path relativePath = g-&gt;linkFile.RelativeTo(SS.saveFile.Parent());
        if(relativePath.IsEmpty()) {
            Printf(false, "%Ba   '%s'", g-&gt;linkFile.raw.c_str());
        } else {
            Printf(false, "%Ba   '%s'", relativePath.raw.c_str());
        }
        Printf(false, "%Bd   %Ftscaled by%E %# %Fl%Ll%f%D[change]%E",
            g-&gt;scale,
            &amp;TextWindow::ScreenChangeGroupScale, g-&gt;h.v);
    } else if(g-&gt;type == Group::Type::DRAWING_3D) {
        Printf(true, " %Ftsketch in 3d%E");
    } else if(g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        Printf(true, " %Ftsketch in new workplane%E");
    } else {
        Printf(true, "???");
    }
    Printf(false, "");

    if(g-&gt;type == Group::Type::EXTRUDE ||
       g-&gt;type == Group::Type::LATHE ||
       g-&gt;type == Group::Type::LINKED)
    {
        bool un   = (g-&gt;meshCombine == Group::CombineAs::UNION);
        bool diff = (g-&gt;meshCombine == Group::CombineAs::DIFFERENCE);
        bool asy  = (g-&gt;meshCombine == Group::CombineAs::ASSEMBLE);

        Printf(false, " %Ftsolid model as");
        Printf(false, "%Ba   %f%D%Lc%Fd%s union%E  "
                             "%f%D%Lc%Fd%s difference%E  "
                             "%f%D%Lc%Fd%s assemble%E  ",
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::UNION,
            un ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::DIFFERENCE,
            diff ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::ASSEMBLE,
            (asy ? RADIO_TRUE : RADIO_FALSE));

        if(g-&gt;type == Group::Type::EXTRUDE ||
           g-&gt;type == Group::Type::LATHE)
        {
            Printf(false,
                "%Bd   %Ftcolor   %E%Bz  %Bd (%@, %@, %@) %f%D%Lf%Fl[change]%E",
                &amp;g-&gt;color,
                g-&gt;color.redF(), g-&gt;color.greenF(), g-&gt;color.blueF(),
                ScreenColor, top[rows-1] + 2);
            Printf(false, "%Bd   %Ftopacity%E %@ %f%Lf%Fl[change]%E",
                g-&gt;color.alphaF(),
                &amp;TextWindow::ScreenOpacity);
        }

        if(g-&gt;type == Group::Type::EXTRUDE ||
           g-&gt;type == Group::Type::LATHE ||
           g-&gt;type == Group::Type::LINKED) {
            Printf(false, "   %Fd%f%LP%s  suppress this group's solid model",
                &amp;TextWindow::ScreenChangeGroupOption,
                g-&gt;suppress ? CHECK_TRUE : CHECK_FALSE);
        }

        Printf(false, "");
    }

    Printf(false, " %f%Lv%Fd%s  show entities from this group",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;visible ? CHECK_TRUE : CHECK_FALSE);

    if(!g-&gt;IsForcedToMeshBySource()) {
        Printf(false, " %f%Lf%Fd%s  force NURBS surfaces to triangle mesh",
            &amp;TextWindow::ScreenChangeGroupOption,
            g-&gt;forceToMesh ? CHECK_TRUE : CHECK_FALSE);
    } else {
        Printf(false, " (model already forced to triangle mesh)");
    }

    Printf(true, " %f%Lr%Fd%s  relax constraints and dimensions",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;relaxConstraints ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, " %f%Le%Fd%s  allow redundant constraints",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;allowRedundant ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, " %f%Ld%Fd%s  treat all dimensions as reference",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;allDimsReference ? CHECK_TRUE : CHECK_FALSE);

    if(g-&gt;booleanFailed) {
        Printf(false, "");
        Printf(false, "The Boolean operation failed. It may be ");
        Printf(false, "possible to fix the problem by choosing ");
        Printf(false, "'force NURBS surfaces to triangle mesh'.");
    }

list_items:
    Printf(false, "");
    Printf(false, "%Ft requests in group");

    int i, a = 0;
    for(i = 0; i &lt; SK.request.n; i++) {
        Request *r = &amp;(SK.request.elem[i]);

        if(r-&gt;group.v == shown.group.v) {
            std::string s = r-&gt;DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
                (a &amp; 1) ? 'd' : 'a',
                r-&gt;h.v, (&amp;TextWindow::ScreenSelectRequest),
                &amp;(TextWindow::ScreenHoverRequest), s.c_str());
            a++;
        }
    }
    if(a == 0) Printf(false, "%Ba   (none)");

    a = 0;
    Printf(false, "");
    Printf(false, "%Ft constraints in group (%d DOF)", g-&gt;solved.dof);
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *c = &amp;(SK.constraint.elem[i]);

        if(c-&gt;group.v == shown.group.v) {
            std::string s = c-&gt;DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E %s",
                (a &amp; 1) ? 'd' : 'a',
                c-&gt;h.v, (&amp;TextWindow::ScreenSelectConstraint),
                (&amp;TextWindow::ScreenHoverConstraint), s.c_str(),
                c-&gt;reference ? "(ref)" : "");
            a++;
        }
    }
    if(a == 0) Printf(false, "%Ba   (none)");
}

//-----------------------------------------------------------------------------
// The screen that's displayed when the sketch fails to solve. A report of
// what failed, and (if the problem is a singular Jacobian) a list of
// constraints that could be removed to fix it.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.124">void TextWindow::ScreenAllowRedundant(int link, uint32_t v) {
    SS.UndoRemember();

    Group *g = SK.GetGroup(SS.TW.shown.group);
    g-&gt;allowRedundant = true;
    SS.MarkGroupDirty(SS.TW.shown.group);

    SS.TW.shown.screen = Screen::GROUP_INFO;
    SS.TW.Show();
}
</t>
<t tx="leo1.20171224221229.125">void TextWindow::ShowGroupSolveInfo() {
    Group *g = SK.GetGroup(shown.group);
    if(g-&gt;IsSolvedOkay()) {
        // Go back to the default group info screen
        shown.screen = Screen::GROUP_INFO;
        Show();
        return;
    }

    Printf(true, "%FtGROUP   %E%s", g-&gt;DescriptionString().c_str());
    switch(g-&gt;solved.how) {
        case SolveResult::DIDNT_CONVERGE:
            Printf(true, "%FxSOLVE FAILED!%Fd unsolvable constraints");
            Printf(true, "the following constraints are incompatible");
            break;

        case SolveResult::REDUNDANT_DIDNT_CONVERGE:
            Printf(true, "%FxSOLVE FAILED!%Fd unsolvable constraints");
            Printf(true, "the following constraints are unsatisfied");
            break;

        case SolveResult::REDUNDANT_OKAY:
            Printf(true, "%FxSOLVE FAILED!%Fd redundant constraints");
            Printf(true, "remove any one of these to fix it");
            break;

        case SolveResult::TOO_MANY_UNKNOWNS:
            Printf(true, "Too many unknowns in a single group!");
            return;

        default: ssassert(false, "Unexpected solve result");
    }

    for(int i = 0; i &lt; g-&gt;solved.remove.n; i++) {
        hConstraint hc = g-&gt;solved.remove.elem[i];
        Constraint *c = SK.constraint.FindByIdNoOops(hc);
        if(!c) continue;

        Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
            (i &amp; 1) ? 'd' : 'a',
            c-&gt;h.v, (&amp;TextWindow::ScreenSelectConstraint),
            (&amp;TextWindow::ScreenHoverConstraint),
            c-&gt;DescriptionString().c_str());
    }

    Printf(true,  "It may be possible to fix the problem ");
    Printf(false, "by selecting Edit -&gt; Undo.");

    if(g-&gt;solved.how == SolveResult::REDUNDANT_OKAY) {
        Printf(true,  "It is possible to suppress this error ");
        Printf(false, "by %Fl%f%Llallowing redundant constraints%E in ",
                      &amp;TextWindow::ScreenAllowRedundant);
        Printf(false, "this group.");
    }
}

//-----------------------------------------------------------------------------
// When we're stepping a dimension. User specifies the finish value, and
// how many steps to take in between current and finish, re-solving each
// time.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.126">void TextWindow::ScreenStepDimFinish(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::STEP_DIM_FINISH;
    std::string edit_value;
    if(SS.TW.shown.dimIsDistance) {
        edit_value = SS.MmToString(SS.TW.shown.dimFinish);
    } else {
        edit_value = ssprintf("%.3f", SS.TW.shown.dimFinish);
    }
    SS.TW.ShowEditControl(12, edit_value);
}
</t>
<t tx="leo1.20171224221229.127">void TextWindow::ScreenStepDimSteps(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::STEP_DIM_STEPS;
    SS.TW.ShowEditControl(12, ssprintf("%d", SS.TW.shown.dimSteps));
}
</t>
<t tx="leo1.20171224221229.128">void TextWindow::ScreenStepDimGo(int link, uint32_t v) {
    hConstraint hc = SS.TW.shown.constraint;
    Constraint *c = SK.constraint.FindByIdNoOops(hc);
    if(c) {
        SS.UndoRemember();
        double start = c-&gt;valA, finish = SS.TW.shown.dimFinish;
        int i, n = SS.TW.shown.dimSteps;
        for(i = 1; i &lt;= n; i++) {
            c = SK.GetConstraint(hc);
            c-&gt;valA = start + ((finish - start)*i)/n;
            SS.MarkGroupDirty(c-&gt;group);
            SS.GenerateAll();
            if(!SS.ActiveGroupsOkay()) {
                // Failed to solve, so quit
                break;
            }
            PaintGraphics();
        }
    }
    InvalidateGraphics();
    SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
}
</t>
<t tx="leo1.20171224221229.129">void TextWindow::ShowStepDimension() {
    Constraint *c = SK.constraint.FindByIdNoOops(shown.constraint);
    if(!c) {
        shown.screen = Screen::LIST_OF_GROUPS;
        Show();
        return;
    }

    Printf(true, "%FtSTEP DIMENSION%E %s", c-&gt;DescriptionString().c_str());

    if(shown.dimIsDistance) {
        Printf(true,  "%Ba   %Ftstart%E    %s", SS.MmToString(c-&gt;valA).c_str());
        Printf(false, "%Bd   %Ftfinish%E   %s %Fl%Ll%f[change]%E",
            SS.MmToString(shown.dimFinish).c_str(), &amp;ScreenStepDimFinish);
    } else {
        Printf(true,  "%Ba   %Ftstart%E    %@", c-&gt;valA);
        Printf(false, "%Bd   %Ftfinish%E   %@ %Fl%Ll%f[change]%E",
            shown.dimFinish, &amp;ScreenStepDimFinish);
    }
    Printf(false, "%Ba   %Ftsteps%E    %d %Fl%Ll%f%D[change]%E",
        shown.dimSteps, &amp;ScreenStepDimSteps);

    Printf(true, " %Fl%Ll%fstep dimension now%E", &amp;ScreenStepDimGo);

    Printf(true, "(or %Fl%Ll%fcancel operation%E)", &amp;ScreenHome);
}

//-----------------------------------------------------------------------------
// When we're creating tangent arcs (as requests, not as some parametric
// thing). User gets to specify the radius, and whether the old untrimmed
// curves are kept or deleted.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.13">class GettextParser {
public:
    ASCIIReader reader;

    unsigned    pluralCount;
    std::string pluralExpr;

    std::map&lt;TranslationKey, std::vector&lt;std::string&gt;, TranslationKeyLess&gt; messages;

    void SkipSpace();
    std::string ReadString();
    void ParseHeader(const std::string &amp;header);
    void Parse();
};

</t>
<t tx="leo1.20171224221229.130">void TextWindow::ScreenChangeTangentArc(int link, uint32_t v) {
    switch(link) {
        case 'r': {
            SS.TW.edit.meaning = Edit::TANGENT_ARC_RADIUS;
            SS.TW.ShowEditControl(3, SS.MmToString(SS.tangentArcRadius));
            break;
        }

        case 'a': SS.tangentArcManual = !SS.tangentArcManual; break;
        case 'd': SS.tangentArcDeleteOld = !SS.tangentArcDeleteOld; break;
    }
}
</t>
<t tx="leo1.20171224221229.131">void TextWindow::ShowTangentArc() {
    Printf(true, "%FtTANGENT ARC PARAMETERS%E");

    Printf(true,  "%Ft radius of created arc%E");
    if(SS.tangentArcManual) {
        Printf(false, "%Ba   %s %Fl%Lr%f[change]%E",
            SS.MmToString(SS.tangentArcRadius).c_str(),
            &amp;(TextWindow::ScreenChangeTangentArc));
    } else {
        Printf(false, "%Ba   automatic");
    }

    Printf(false, "");
    Printf(false, "  %Fd%f%La%s  choose radius automatically%E",
        &amp;ScreenChangeTangentArc,
        !SS.tangentArcManual ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ld%s  delete original entities afterward%E",
        &amp;ScreenChangeTangentArc,
        SS.tangentArcDeleteOld ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "To create a tangent arc at a point,");
    Printf(false, "select that point and then choose");
    Printf(false, "Sketch -&gt; Tangent Arc at Point.");
    Printf(true, "(or %Fl%Ll%fback to home screen%E)", &amp;ScreenHome);
}

//-----------------------------------------------------------------------------
// The edit control is visible, and the user just pressed enter.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.132">void TextWindow::EditControlDone(const char *s) {
    edit.showAgain = false;

    switch(edit.meaning) {
        case Edit::TIMES_REPEATED: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                SS.UndoRemember();

                double ev = e-&gt;Eval();
                if((int)ev &lt; 1) {
                    Error(_("Can't repeat fewer than 1 time."));
                    break;
                }
                if((int)ev &gt; 999) {
                    Error(_("Can't repeat more than 999 times."));
                    break;
                }

                Group *g = SK.GetGroup(edit.group);
                g-&gt;valA = ev;

                if(g-&gt;type == Group::Type::ROTATE) {
                    int i, c = 0;
                    for(i = 0; i &lt; SK.constraint.n; i++) {
                        if(SK.constraint.elem[i].group.v == g-&gt;h.v) c++;
                    }
                    // If the group does not contain any constraints, then
                    // set the numerical guess to space the copies uniformly
                    // over one rotation. Don't touch the guess if we're
                    // already constrained, because that would break
                    // convergence.
                    if(c == 0) {
                        double copies = (g-&gt;skipFirst) ? (ev + 1) : ev;
                        SK.GetParam(g-&gt;h.param(3))-&gt;val = PI/(2*copies);
                    }
                }

                SS.MarkGroupDirty(g-&gt;h);
            }
            break;
        }
        case Edit::GROUP_NAME: {
            if(!*s) {
                Error(_("Group name cannot be empty"));
            } else {
                SS.UndoRemember();

                Group *g = SK.GetGroup(edit.group);
                g-&gt;name = s;
            }
            break;
        }
        case Edit::GROUP_SCALE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double ev = e-&gt;Eval();
                if(fabs(ev) &lt; 1e-6) {
                    Error(_("Scale cannot be zero."));
                } else {
                    Group *g = SK.GetGroup(edit.group);
                    g-&gt;scale = ev;
                    SS.MarkGroupDirty(g-&gt;h);
                }
            }
            break;
        }
        case Edit::GROUP_COLOR: {
            Vector rgb;
            if(sscanf(s, "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);

                Group *g = SK.group.FindByIdNoOops(SS.TW.shown.group);
                if(!g) break;
                g-&gt;color = RGBf(rgb.x, rgb.y, rgb.z);

                SS.MarkGroupDirty(g-&gt;h);
                SS.GW.ClearSuper();
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::GROUP_OPACITY: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double alpha = e-&gt;Eval();
                if(alpha &lt; 0 || alpha &gt; 1) {
                    Error(_("Opacity must be between zero and one."));
                } else {
                    Group *g = SK.GetGroup(edit.group);
                    g-&gt;color.alpha = (int)(255.1f * alpha);
                    SS.MarkGroupDirty(g-&gt;h);
                    SS.GW.ClearSuper();
                }
            }
            break;
        }
        case Edit::TTF_TEXT: {
            SS.UndoRemember();
            Request *r = SK.request.FindByIdNoOops(edit.request);
            if(r) {
                r-&gt;str = s;
                SS.MarkGroupDirty(r-&gt;group);
            }
            break;
        }
        case Edit::STEP_DIM_FINISH: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(!e) {
                break;
            }
            if(shown.dimIsDistance) {
                shown.dimFinish = SS.ExprToMm(e);
            } else {
                shown.dimFinish = e-&gt;Eval();
            }
            break;
        }
        case Edit::STEP_DIM_STEPS:
            shown.dimSteps = min(300, max(1, atoi(s)));
            break;

        case Edit::TANGENT_ARC_RADIUS: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(!e) break;
            if(e-&gt;Eval() &lt; LENGTH_EPS) {
                Error(_("Radius cannot be zero or negative."));
                break;
            }
            SS.tangentArcRadius = SS.ExprToMm(e);
            break;
        }

        default: {
            int cnt = 0;
            if(EditControlDoneForStyles(s))         cnt++;
            if(EditControlDoneForConfiguration(s))  cnt++;
            if(EditControlDoneForPaste(s))          cnt++;
            if(EditControlDoneForView(s))           cnt++;
            ssassert(cnt == 1, "Expected exactly one parameter to be edited");
            break;
        }
    }
    InvalidateGraphics();
    SS.ScheduleShowTW();

    if(!edit.showAgain) {
        HideEditControl();
        edit.meaning = Edit::NOTHING;
    }
}

</t>
<t tx="leo1.20171224221229.133">//-----------------------------------------------------------------------------
// Helper functions for the text-based browser window.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221229.134">class Button {
public:
    virtual std::string Tooltip() = 0;
    virtual void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) = 0;
    virtual int AdvanceWidth() = 0;
    virtual void Click() = 0;
};

</t>
<t tx="leo1.20171224221229.135">class SpacerButton : public Button {
public:
    std::string Tooltip() override { return ""; }

    @others
};

</t>
<t tx="leo1.20171224221229.136">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    // Draw a darker-grey spacer in between the groups of icons.
    uiCanvas-&gt;DrawRect(x, x + 4, y, y - 24,
                       /*fillColor=*/{ 45, 45, 45, 255 },
                       /*outlineColor=*/{});
}

int AdvanceWidth() override { return 12; }

</t>
<t tx="leo1.20171224221229.137">    void Click() override {}
};

class ShowHideButton : public Button {
public:
    bool        *variable;
    std::string tooltip;
    std::string iconName;
    std::shared_ptr&lt;Pixmap&gt; icon;

    ShowHideButton(bool *variable, std::string iconName, std::string tooltip)
            : variable(variable), tooltip(tooltip), iconName(iconName) {}

    std::string Tooltip() override {
        return ((*variable) ? "Hide " : "Show ") + tooltip;
    }

</t>
<t tx="leo1.20171224221229.138">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    if(icon == NULL) {
        icon = LoadPng("icons/text-window/" + iconName + ".png");
    }

    uiCanvas-&gt;DrawPixmap(icon, x, y - 24);
    if(asHovered) {
        uiCanvas-&gt;DrawRect(x - 2, x + 26, y + 2, y - 26,
                           /*fillColor=*/{ 255, 255, 0, 75 },
                           /*outlineColor=*/{});
    }
    if(!*(variable)) {
        int s = 0, f = 24;
        RgbaColor color = { 255, 0, 0, 150 };
        uiCanvas-&gt;DrawLine(x+s, y-s, x+f, y-f, color, 2);
        uiCanvas-&gt;DrawLine(x+s, y-f, x+f, y-s, color, 2);
    }
}

int AdvanceWidth() override { return 32; }

void Click() override { SS.GW.ToggleBool(variable); }
</t>
<t tx="leo1.20171224221229.139">class FacesButton : public ShowHideButton {
public:
    FacesButton()
        : ShowHideButton(&amp;(SS.GW.showFaces), "faces", "") {}

    std::string Tooltip() override {
        if(*variable) {
            return "Don't make faces selectable with mouse";
        } else {
            return "Make faces selectable with mouse";
        }
    }
};

</t>
<t tx="leo1.20171224221229.14">void GettextParser::SkipSpace() {
    while(!reader.AtEnd()) {
        if(reader.TryChar('#')) {
            reader.SkipUntilEol();
        } else if(!reader.SkipSpace()) {
            break;
        }
    }
}

std::string GettextParser::ReadString() {
    SkipSpace();
    reader.ExpectChar('"');

    std::string result;
    while(true) {
        if(reader.AtEnd()) {
            ssassert(false, "Unexpected EOF within a string");
        } else if(reader.TryChar('\"')) {
            SkipSpace();
            if(!reader.TryChar('\"')) {
                break;
            }
        } else if(reader.TryChar('\\')) {
            if(reader.TryChar('\\')) {
                result += '\\';
            } else if(reader.TryChar('n')) {
                result += '\n';
            } else if(reader.TryChar('t')) {
                result += '\t';
            } else if(reader.TryChar('"')) {
                result += '"';
            } else {
                ssassert(false, "Unexpected escape sequence");
            }
        } else {
            result += reader.ReadChar();
        }
    }
    return result;
}

</t>
<t tx="leo1.20171224221229.140">class OccludedLinesButton : public Button {
public:
    std::shared_ptr&lt;Pixmap&gt; visibleIcon;
    std::shared_ptr&lt;Pixmap&gt; stippledIcon;
    std::shared_ptr&lt;Pixmap&gt; invisibleIcon;

    std::string Tooltip() override {
        switch(SS.GW.drawOccludedAs) {
            case GraphicsWindow::DrawOccludedAs::INVISIBLE:
                return "Stipple occluded lines";

            case GraphicsWindow::DrawOccludedAs::STIPPLED:
                return "Draw occluded lines";

            case GraphicsWindow::DrawOccludedAs::VISIBLE:
                return "Don't draw occluded lines";

            default: ssassert(false, "Unexpected mode");
        }
    }

    @others
};

static SpacerButton   spacerButton;

static ShowHideButton workplanesButton =
</t>
<t tx="leo1.20171224221229.141">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    if(visibleIcon == NULL) {
        visibleIcon = LoadPng("icons/text-window/occluded-visible.png");
    }
    if(stippledIcon == NULL) {
        stippledIcon = LoadPng("icons/text-window/occluded-stippled.png");
    }
    if(invisibleIcon == NULL) {
        invisibleIcon = LoadPng("icons/text-window/occluded-invisible.png");
    }

    std::shared_ptr&lt;Pixmap&gt; icon;
    switch(SS.GW.drawOccludedAs) {
        case GraphicsWindow::DrawOccludedAs::INVISIBLE: icon = invisibleIcon; break;
        case GraphicsWindow::DrawOccludedAs::STIPPLED:  icon = stippledIcon;  break;
        case GraphicsWindow::DrawOccludedAs::VISIBLE:   icon = visibleIcon;   break;
    }

    uiCanvas-&gt;DrawPixmap(icon, x, y - 24);
    if(asHovered) {
        uiCanvas-&gt;DrawRect(x - 2, x + 26, y + 2, y - 26,
                           /*fillColor=*/{ 255, 255, 0, 75 },
                           /*outlineColor=*/{});
    }
}

int AdvanceWidth() override { return 32; }

</t>
<t tx="leo1.20171224221229.142">void Click() override {
    switch(SS.GW.drawOccludedAs) {
        case GraphicsWindow::DrawOccludedAs::INVISIBLE:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::STIPPLED;
            break;

        case GraphicsWindow::DrawOccludedAs::STIPPLED:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::VISIBLE;
            break;

        case GraphicsWindow::DrawOccludedAs::VISIBLE:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::INVISIBLE;
            break;
    }

    SS.GenerateAll();
    InvalidateGraphics();
    SS.ScheduleShowTW();
}
</t>
<t tx="leo1.20171224221229.143">static ShowHideButton edgesButton =
    { &amp;(SS.GW.showEdges),       "edges",         "edges of solid model"            };
static ShowHideButton outlinesButton =
    { &amp;(SS.GW.showOutlines),    "outlines",      "outline of solid model"          };
static ShowHideButton meshButton =
    { &amp;(SS.GW.showMesh),        "mesh",          "triangle mesh of solid model"    };
static OccludedLinesButton occludedLinesButton;

static Button *buttons[] = {
    &amp;workplanesButton,
    &amp;normalsButton,
    &amp;pointsButton,
    &amp;constraintsButton,
    &amp;facesButton,
    &amp;spacerButton,
    &amp;shadedButton,
    &amp;edgesButton,
    &amp;outlinesButton,
    &amp;meshButton,
    &amp;spacerButton,
    &amp;occludedLinesButton,
};

</t>
<t tx="leo1.20171224221229.144">const TextWindow::Color TextWindow::fgColors[] = {
    { 'd', RGBi(255, 255, 255) },
    { 'l', RGBi(100, 100, 255) },
    { 't', RGBi(255, 200,   0) },
    { 'h', RGBi( 90,  90,  90) },
    { 's', RGBi( 40, 255,  40) },
    { 'm', RGBi(200, 200,   0) },
    { 'r', RGBi(  0,   0,   0) },
    { 'x', RGBi(255,  20,  20) },
    { 'i', RGBi(  0, 255, 255) },
    { 'g', RGBi(160, 160, 160) },
    { 'b', RGBi(200, 200, 200) },
    { 0,   RGBi(  0,   0,   0) }
};
</t>
<t tx="leo1.20171224221229.145">const TextWindow::Color TextWindow::bgColors[] = {
    { 'd', RGBi(  0,   0,   0) },
    { 't', RGBi( 34,  15,  15) },
    { 'a', RGBi( 25,  25,  25) },
    { 'r', RGBi(255, 255, 255) },
    { 0,   RGBi(  0,   0,   0) }
};

</t>
<t tx="leo1.20171224221229.146">void TextWindow::MakeColorTable(const Color *in, float *out) {
    int i;
    for(i = 0; in[i].c != 0; i++) {
        int c = in[i].c;
        ssassert(c &gt;= 0 &amp;&amp; c &lt;= 255, "Unexpected color index");
        out[c*3 + 0] = in[i].color.redF();
        out[c*3 + 1] = in[i].color.greenF();
        out[c*3 + 2] = in[i].color.blueF();
    }
}

</t>
<t tx="leo1.20171224221229.147">void TextWindow::Init() {
    canvas = CreateRenderer();

    ClearSuper();
}

</t>
<t tx="leo1.20171224221229.148">void TextWindow::ClearSuper() {
    HideEditControl();

    // Ugly hack, but not so ugly as the next line
    std::shared_ptr&lt;ViewportCanvas&gt; oldCanvas = canvas;

    // Cannot use *this = {} here because TextWindow instances
    // are 2.4MB long; this causes stack overflows in prologue
    // when built with MSVC, even with optimizations.
    memset(this, 0, sizeof(*this));

    // Return old canvas
    canvas = oldCanvas;

    MakeColorTable(fgColors, fgColorTable);
    MakeColorTable(bgColors, bgColorTable);

    ClearScreen();
    Show();
}

</t>
<t tx="leo1.20171224221229.149">void TextWindow::HideEditControl() {
    editControl.colorPicker.show = false;
    HideTextEditControl();
}

</t>
<t tx="leo1.20171224221229.15">void GettextParser::ParseHeader(const std::string &amp;header) {
    ASCIIReader reader = ASCIIReader::From(header);
    while(!reader.AtEnd()) {
        reader.SkipSpace();
        if(reader.TryString("Plural-Forms:")) {
            reader.SkipSpace();
            reader.ExpectString("nplurals=");
            reader.SkipSpace();
            pluralCount = reader.ReadIntegerDecimal();
            reader.SkipSpace();
            reader.ExpectString(";");
            reader.SkipSpace();
            reader.ExpectString("plural=");
            pluralExpr = reader.ReadUntilEol();
        } else {
            reader.SkipUntilEol();
        }
    }
}

</t>
<t tx="leo1.20171224221229.150">void TextWindow::ShowEditControl(int col, const std::string &amp;str, int halfRow) {
    if(halfRow &lt; 0) halfRow = top[hoveredRow];
    editControl.halfRow = halfRow;
    editControl.col = col;

    int x = LEFT_MARGIN + CHAR_WIDTH_*col;
    int y = (halfRow - SS.TW.scrollPos)*(LINE_HEIGHT/2);

    ShowTextEditControl(x, y + 18, str);
}

</t>
<t tx="leo1.20171224221229.151">void TextWindow::ShowEditControlWithColorPicker(int col, RgbaColor rgb)
{
    SS.ScheduleShowTW();

    editControl.colorPicker.show = true;
    editControl.colorPicker.rgb = rgb;
    editControl.colorPicker.h = 0;
    editControl.colorPicker.s = 0;
    editControl.colorPicker.v = 1;
    ShowEditControl(col, ssprintf("%.2f, %.2f, %.2f", rgb.redF(), rgb.greenF(), rgb.blueF()));
}

</t>
<t tx="leo1.20171224221229.152">void TextWindow::ClearScreen() {
    int i, j;
    for(i = 0; i &lt; MAX_ROWS; i++) {
        for(j = 0; j &lt; MAX_COLS; j++) {
            text[i][j] = ' ';
            meta[i][j].fg = 'd';
            meta[i][j].bg = 'd';
            meta[i][j].link = NOT_A_LINK;
        }
        top[i] = i*2;
    }
    rows = 0;
}

</t>
<t tx="leo1.20171224221229.153">void TextWindow::Printf(bool halfLine, const char *fmt, ...) {
    if(!canvas) return;

    va_list vl;
    va_start(vl, fmt);

    if(rows &gt;= MAX_ROWS) return;

    int r, c;
    r = rows;
    top[r] = (r == 0) ? 0 : (top[r-1] + (halfLine ? 3 : 2));
    rows++;

    for(c = 0; c &lt; MAX_COLS; c++) {
        text[r][c] = ' ';
        meta[r][c].link = NOT_A_LINK;
    }

    char fg = 'd';
    char bg = 'd';
    RgbaColor bgRgb = RGBi(0, 0, 0);
    int link = NOT_A_LINK;
    uint32_t data = 0;
    LinkFunction *f = NULL, *h = NULL;

    c = 0;
    while(*fmt) {
        char buf[1024];

        if(*fmt == '%') {
            fmt++;
            if(*fmt == '\0') goto done;
            strcpy(buf, "");
            switch(*fmt) {
                case 'd': {
                    int v = va_arg(vl, int);
                    sprintf(buf, "%d", v);
                    break;
                }
                case 'x': {
                    unsigned int v = va_arg(vl, unsigned int);
                    sprintf(buf, "%08x", v);
                    break;
                }
                case '@': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%.2f", v);
                    break;
                }
                case '2': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%s%.2f", v &lt; 0 ? "" : " ", v);
                    break;
                }
                case '3': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%s%.3f", v &lt; 0 ? "" : " ", v);
                    break;
                }
                case '#': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%.3f", v);
                    break;
                }
                case 's': {
                    char *s = va_arg(vl, char *);
                    memcpy(buf, s, min(sizeof(buf), strlen(s)+1));
                    break;
                }
                case 'c': {
                    // 'char' is promoted to 'int' when passed through '...'
                    int v = va_arg(vl, int);
                    if(v == 0) {
                        strcpy(buf, "");
                    } else {
                        sprintf(buf, "%c", v);
                    }
                    break;
                }
                case 'E':
                    fg = 'd';
                    // leave the background, though
                    link = NOT_A_LINK;
                    data = 0;
                    f = NULL;
                    h = NULL;
                    break;

                case 'F':
                case 'B': {
                    char cc = fmt[1];  // color code
                    RgbaColor *rgbPtr = NULL;
                    switch(cc) {
                        case 0:   goto done;  // truncated directive
                        case 'p': cc = (char)va_arg(vl, int); break;
                        case 'z': rgbPtr = va_arg(vl, RgbaColor *); break;
                    }
                    if(*fmt == 'F') {
                        fg = cc;
                    } else {
                        bg = cc;
                        if(rgbPtr) bgRgb = *rgbPtr;
                    }
                    fmt++;
                    break;
                }
                case 'L':
                    if(fmt[1] == '\0') goto done;
                    fmt++;
                    if(*fmt == 'p') {
                        link = va_arg(vl, int);
                    } else {
                        link = *fmt;
                    }
                    break;

                case 'f':
                    f = va_arg(vl, LinkFunction *);
                    break;

                case 'h':
                    h = va_arg(vl, LinkFunction *);
                    break;

                case 'D': {
                    unsigned int v = va_arg(vl, unsigned int);
                    data = (uint32_t)v;
                    break;
                }
                case '%':
                    strcpy(buf, "%");
                    break;
            }
        } else {
            utf8_iterator it2(fmt), it1 = it2++;
            strncpy(buf, fmt, it2 - it1);
            buf[it2 - it1] = '\0';
        }

        for(utf8_iterator it(buf); *it; ++it) {
            for(size_t i = 0; i &lt; canvas-&gt;GetBitmapFont()-&gt;GetWidth(*it); i++) {
                if(c &gt;= MAX_COLS) goto done;
                text[r][c] = (i == 0) ? *it : ' ';
                meta[r][c].fg = fg;
                meta[r][c].bg = bg;
                meta[r][c].bgRgb = bgRgb;
                meta[r][c].link = link;
                meta[r][c].data = data;
                meta[r][c].f = f;
                meta[r][c].h = h;
                c++;
            }
        }

        fmt++;
    }
    while(c &lt; MAX_COLS) {
        meta[r][c].fg = fg;
        meta[r][c].bg = bg;
        meta[r][c].bgRgb = bgRgb;
        c++;
    }

done:
    va_end(vl);
}

</t>
<t tx="leo1.20171224221229.154">void TextWindow::Show() {
    if(SS.GW.pending.operation == GraphicsWindow::Pending::NONE) SS.GW.ClearPending();

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    // Make sure these tests agree with test used to draw indicator line on
    // main list of groups screen.
    if(SS.GW.pending.description) {
        // A pending operation (that must be completed with the mouse in
        // the graphics window) will preempt our usual display.
        HideEditControl();
        ShowHeader(false);
        Printf(false, "");
        Printf(false, "%s", SS.GW.pending.description);
        Printf(true, "%Fl%f%Ll(cancel operation)%E",
            &amp;TextWindow::ScreenUnselectAll);
    } else if((gs.n &gt; 0 || gs.constraints &gt; 0) &amp;&amp;
                                    shown.screen != Screen::PASTE_TRANSFORMED)
    {
        if(edit.meaning != Edit::TTF_TEXT) HideEditControl();
        ShowHeader(false);
        DescribeSelection();
    } else {
        if(edit.meaning == Edit::TTF_TEXT) HideEditControl();
        ShowHeader(true);
        switch(shown.screen) {
            default:
                shown.screen = Screen::LIST_OF_GROUPS;
                // fall through
            case Screen::LIST_OF_GROUPS:     ShowListOfGroups();     break;
            case Screen::GROUP_INFO:         ShowGroupInfo();        break;
            case Screen::GROUP_SOLVE_INFO:   ShowGroupSolveInfo();   break;
            case Screen::CONFIGURATION:      ShowConfiguration();    break;
            case Screen::STEP_DIMENSION:     ShowStepDimension();    break;
            case Screen::LIST_OF_STYLES:     ShowListOfStyles();     break;
            case Screen::STYLE_INFO:         ShowStyleInfo();        break;
            case Screen::PASTE_TRANSFORMED:  ShowPasteTransformed(); break;
            case Screen::EDIT_VIEW:          ShowEditView();         break;
            case Screen::TANGENT_ARC:        ShowTangentArc();       break;
        }
    }
    Printf(false, "");

    // Make sure there's room for the color picker
    if(editControl.colorPicker.show) {
        int pickerHeight = 25;
        int halfRow = editControl.halfRow;
        if(top[rows-1] - halfRow &lt; pickerHeight &amp;&amp; rows &lt; MAX_ROWS) {
            rows++;
            top[rows-1] = halfRow + pickerHeight;
        }
    }

    InvalidateText();
}

</t>
<t tx="leo1.20171224221229.155">void TextWindow::TimerCallback()
{
    tooltippedButton = hoveredButton;
    InvalidateText();
}

</t>
<t tx="leo1.20171224221229.156">void TextWindow::DrawOrHitTestIcons(UiCanvas *uiCanvas, TextWindow::DrawOrHitHow how,
                                    double mx, double my)
{
    int width, height;
    GetTextWindowSize(&amp;width, &amp;height);

    int x = 20, y = 33 + LINE_HEIGHT;
    y -= scrollPos*(LINE_HEIGHT/2);

    if(how == PAINT) {
        int top = y - 28, bot = y + 4;
        uiCanvas-&gt;DrawRect(0, width, top, bot,
                           /*fillColor=*/{ 30, 30, 30, 255 }, /*outlineColor=*/{});
    }

    Button *oldHovered = hoveredButton;
    if(how != PAINT) {
        hoveredButton = NULL;
    }

    for(Button *button : buttons) {
        if(how == PAINT) {
            button-&gt;Draw(uiCanvas, x, y, (button == hoveredButton));
        } else if(mx &gt; x - 2 &amp;&amp; mx &lt; x + 26 &amp;&amp;
                  my &lt; y + 2 &amp;&amp; my &gt; y - 26) {
            // The mouse is hovered over this icon, so do the tooltip
            // stuff.
            if(button != tooltippedButton) {
                oldMousePos = Point2d::From(mx, my);
            }
            if(button != oldHovered || how == CLICK) {
                SetTimerFor(1000);
            }
            hoveredButton = button;
            if(how == CLICK) {
                button-&gt;Click();
            }
        }

        x += button-&gt;AdvanceWidth();
    }

    if(how != PAINT &amp;&amp; hoveredButton != oldHovered) {
        InvalidateText();
    }

    if(tooltippedButton &amp;&amp; !tooltippedButton-&gt;Tooltip().empty()) {
        if(how == PAINT) {
            std::string tooltip = tooltippedButton-&gt;Tooltip();

            int ox = (int)oldMousePos.x, oy = (int)oldMousePos.y - LINE_HEIGHT;
            ox += 3;
            oy -= 3;
            int tw = (tooltip.length() + 1) * (CHAR_WIDTH_ - 1);
            ox = min(ox, (width - 25) - tw);
            oy = max(oy, 5);

            uiCanvas-&gt;DrawRect(ox, ox+tw, oy, oy+LINE_HEIGHT,
                               /*fillColor=*/{ 255, 255, 150, 255 },
                               /*outlineColor=*/{ 0, 0, 0, 255 },
                               /*zIndex=*/1);
            uiCanvas-&gt;DrawBitmapText(tooltip, ox+5, oy-3+LINE_HEIGHT, { 0, 0, 0, 255 },
                                     /*zIndex=*/1);
        } else {
            if(!hoveredButton || (hoveredButton != tooltippedButton)) {
                tooltippedButton = NULL;
                InvalidateGraphics();
            }
            // And if we're hovered, then we've set a timer that will cause
            // us to show the tool tip later.
        }
    }
}

//----------------------------------------------------------------------------
// Given (x, y, z) = (h, s, v) in [0,6), [0,1], [0,1], return (x, y, z) =
// (r, g, b) all in [0, 1].
//----------------------------------------------------------------------------
Vector TextWindow::HsvToRgb(Vector hsv) {
    if(hsv.x &gt;= 6) hsv.x -= 6;

    Vector rgb;
    double hmod2 = hsv.x;
    while(hmod2 &gt;= 2) hmod2 -= 2;
    double x = (1 - fabs(hmod2 - 1));
    if(hsv.x &lt; 1) {
        rgb = Vector::From(1, x, 0);
    } else if(hsv.x &lt; 2) {
        rgb = Vector::From(x, 1, 0);
    } else if(hsv.x &lt; 3) {
        rgb = Vector::From(0, 1, x);
    } else if(hsv.x &lt; 4) {
        rgb = Vector::From(0, x, 1);
    } else if(hsv.x &lt; 5) {
        rgb = Vector::From(x, 0, 1);
    } else {
        rgb = Vector::From(1, 0, x);
    }
    double c = hsv.y*hsv.z;
    double m = 1 - hsv.z;
    rgb = rgb.ScaledBy(c);
    rgb = rgb.Plus(Vector::From(m, m, m));

    return rgb;
}

std::shared_ptr&lt;Pixmap&gt; TextWindow::HsvPattern2d(int w, int h) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::Create(Pixmap::Format::RGB, w, h);
    for(size_t j = 0; j &lt; pixmap-&gt;height; j++) {
        size_t p = pixmap-&gt;stride * j;
        for(size_t i = 0; i &lt; pixmap-&gt;width; i++) {
            Vector hsv = Vector::From(6.0*i/(pixmap-&gt;width-1), 1.0*j/(pixmap-&gt;height-1), 1);
            Vector rgb = HsvToRgb(hsv);
            rgb = rgb.ScaledBy(255);
            pixmap-&gt;data[p++] = (uint8_t)rgb.x;
            pixmap-&gt;data[p++] = (uint8_t)rgb.y;
            pixmap-&gt;data[p++] = (uint8_t)rgb.z;
        }
    }
    return pixmap;
}

std::shared_ptr&lt;Pixmap&gt; TextWindow::HsvPattern1d(double hue, double sat, int w, int h) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::Create(Pixmap::Format::RGB, w, h);
    for(size_t i = 0; i &lt; pixmap-&gt;height; i++) {
        size_t p = i * pixmap-&gt;stride;
        for(size_t j = 0; j &lt; pixmap-&gt;width; j++) {
            Vector hsv = Vector::From(6*hue, sat, 1.0*(pixmap-&gt;width - 1 - j)/pixmap-&gt;width);
            Vector rgb = HsvToRgb(hsv);
            rgb = rgb.ScaledBy(255);
            pixmap-&gt;data[p++] = (uint8_t)rgb.x;
            pixmap-&gt;data[p++] = (uint8_t)rgb.y;
            pixmap-&gt;data[p++] = (uint8_t)rgb.z;
        }
    }
    return pixmap;
}

</t>
<t tx="leo1.20171224221229.157">void TextWindow::ColorPickerDone() {
    RgbaColor rgb = editControl.colorPicker.rgb;
    EditControlDone(ssprintf("%.2f, %.2f, %.3f", rgb.redF(), rgb.greenF(), rgb.blueF()).c_str());
}

</t>
<t tx="leo1.20171224221229.158">bool TextWindow::DrawOrHitTestColorPicker(UiCanvas *uiCanvas, DrawOrHitHow how, bool leftDown,
                                          double x, double y)
{
    bool mousePointerAsHand = false;

    if(how == HOVER &amp;&amp; !leftDown) {
        editControl.colorPicker.picker1dActive = false;
        editControl.colorPicker.picker2dActive = false;
    }

    if(!editControl.colorPicker.show) return false;
    if(how == CLICK || (how == HOVER &amp;&amp; leftDown)) InvalidateText();

    @others
}

</t>
<t tx="leo1.20171224221229.159">static const RgbaColor BaseColor[12] = {
    RGBi(255,   0,   0),
    RGBi(  0, 255,   0),
    RGBi(  0,   0, 255),

    RGBi(  0, 255, 255),
    RGBi(255,   0, 255),
    RGBi(255, 255,   0),

    RGBi(255, 127,   0),
    RGBi(255,   0, 127),
    RGBi(  0, 255, 127),
    RGBi(127, 255,   0),
    RGBi(127,   0, 255),
    RGBi(  0, 127, 255),
};

int width, height;
GetTextWindowSize(&amp;width, &amp;height);

int px = LEFT_MARGIN + CHAR_WIDTH_*editControl.col;
int py = (editControl.halfRow - SS.TW.scrollPos)*(LINE_HEIGHT/2);

py += LINE_HEIGHT + 5;

static const int WIDTH = 16, HEIGHT = 12;
static const int PITCH = 18, SIZE = 15;

px = min(px, width - (WIDTH*PITCH + 40));

</t>
<t tx="leo1.20171224221229.16">void GettextParser::Parse() {
    // Default to a single form, in case a header is missing.
    pluralCount = 1;
    pluralExpr  = "0";

    SkipSpace();
    while(!reader.AtEnd()) {
        TranslationKey key = {};

        if(reader.TryString("msgctxt")) {
            key.hasContext = true;
            key.context = ReadString();
        }

        reader.ExpectString("msgid");
        key.ident = ReadString();

        if(reader.TryString("msgid_plural")) {
            ReadString(); // we don't need it
        }

        std::vector&lt;std::string&gt; msgstrs;
        while(reader.TryString("msgstr")) {
            if(reader.TryChar('[')) {
                unsigned index = reader.ReadIntegerDecimal();
                reader.ExpectChar(']');
                if(msgstrs.size() &lt;= index) {
                    msgstrs.resize(index + 1);
                }
                msgstrs[index] = ReadString();
            } else {
                msgstrs.emplace_back(ReadString());
                break;
            }
        }

        if(key.ident == "") {
            ssassert(msgstrs.size() == 1,
                     "Expected exactly one header msgstr");
            ParseHeader(msgstrs[0]);
        } else {
            ssassert(msgstrs.size() == 1 ||
                     msgstrs.size() == pluralCount,
                     "Expected msgstr count to match plural form count");
            messages.emplace(key, msgstrs);
        }
    }
}

//-----------------------------------------------------------------------------
// Translation management
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221229.160">int pxm = px + WIDTH*PITCH + 11,
    pym = py + HEIGHT*PITCH + 7;

int bw = 6;
if(how == PAINT) {
    uiCanvas-&gt;DrawRect(px, pxm+bw, py, pym+bw,
                       /*fillColor=*/{ 50, 50, 50, 255 },
                       /*outlineColor=*/{});
    uiCanvas-&gt;DrawRect(px+(bw/2), pxm+(bw/2), py+(bw/2), pym+(bw/2),
                       /*fillColor=*/{ 0, 0, 0, 255 },
                       /*outlineColor=*/{});
} else {
    if(x &lt; px || x &gt; pxm+(bw/2) ||
       y &lt; py || y &gt; pym+(bw/2))
    {
        return false;
    }
}
px += (bw/2);
py += (bw/2);

int i, j;
for(i = 0; i &lt; WIDTH/2; i++) {
    for(j = 0; j &lt; HEIGHT; j++) {
        Vector rgb;
        RgbaColor d;
        if(i == 0 &amp;&amp; j &lt; 8) {
            d = SS.modelColor[j];
            rgb = Vector::From(d.redF(), d.greenF(), d.blueF());
        } else if(i == 0) {
            double a = (j - 8.0)/3.0;
            rgb = Vector::From(a, a, a);
        } else {
            d = BaseColor[j];
            rgb = Vector::From(d.redF(), d.greenF(), d.blueF());
            if(i &gt;= 2 &amp;&amp; i &lt;= 4) {
                double a = (i == 2) ? 0.2 : (i == 3) ? 0.3 : 0.4;
                rgb = rgb.Plus(Vector::From(a, a, a));
            }
            if(i &gt;= 5 &amp;&amp; i &lt;= 7) {
                double a = (i == 5) ? 0.7 : (i == 6) ? 0.4 : 0.18;
                rgb = rgb.ScaledBy(a);
            }
        }

        rgb = rgb.ClampWithin(0, 1);
        int sx = px + 5 + PITCH*(i + 8) + 4, sy = py + 5 + PITCH*j;

        if(how == PAINT) {
            uiCanvas-&gt;DrawRect(sx, sx+SIZE, sy, sy+SIZE,
                               /*fillColor=*/RGBf(rgb.x, rgb.y, rgb.z),
                               /*outlineColor=*/{});
        } else if(how == CLICK) {
            if(x &gt;= sx &amp;&amp; x &lt;= sx+SIZE &amp;&amp; y &gt;= sy &amp;&amp; y &lt;= sy+SIZE) {
                editControl.colorPicker.rgb = RGBf(rgb.x, rgb.y, rgb.z);
                ColorPickerDone();
            }
        } else if(how == HOVER) {
            if(x &gt;= sx &amp;&amp; x &lt;= sx+SIZE &amp;&amp; y &gt;= sy &amp;&amp; y &lt;= sy+SIZE) {
                mousePointerAsHand = true;
            }
        }
    }
}

int hxm, hym;
int hx = px + 5, hy = py + 5;
hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*2 + SIZE;
if(how == PAINT) {
    uiCanvas-&gt;DrawRect(hx, hxm, hy, hym,
                       /*fillColor=*/editControl.colorPicker.rgb,
                       /*outlineColor=*/{});
} else if(how == CLICK) {
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        ColorPickerDone();
    }
} else if(how == HOVER) {
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        mousePointerAsHand = true;
    }
}

hy += PITCH*3;

hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*1 + SIZE;
// The one-dimensional thing to pick the color's value
if(how == PAINT) {
    uiCanvas-&gt;DrawPixmap(HsvPattern1d(editControl.colorPicker.h,
                                      editControl.colorPicker.s,
                                      hxm-hx, hym-hy),
                         hx, hy);

    int cx = hx+(int)((hxm-hx)*(1.0 - editControl.colorPicker.v));
    uiCanvas-&gt;DrawLine(cx, hy, cx, hym, { 0, 0, 0, 255 });
} else if(how == CLICK ||
      (how == HOVER &amp;&amp; leftDown &amp;&amp; editControl.colorPicker.picker1dActive))
{
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        editControl.colorPicker.v = 1 - (x - hx)/(hxm - hx);

        Vector rgb = HsvToRgb(Vector::From(
                        6*editControl.colorPicker.h,
                        editControl.colorPicker.s,
                        editControl.colorPicker.v));
        editControl.colorPicker.rgb = RGBf(rgb.x, rgb.y, rgb.z);

        editControl.colorPicker.picker1dActive = true;
    }
}
// and advance our vertical position
hy += PITCH*2;

hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*6 + SIZE;
// Two-dimensional thing to pick a color by hue and saturation
if(how == PAINT) {
    uiCanvas-&gt;DrawPixmap(HsvPattern2d(hxm-hx, hym-hy), hx, hy);

</t>
<t tx="leo1.20171224221229.161">    int cx = hx+(int)((hxm-hx)*editControl.colorPicker.h),
        cy = hy+(int)((hym-hy)*editControl.colorPicker.s);
    uiCanvas-&gt;DrawLine(cx - 5, cy, cx + 4, cy, { 255, 255, 255, 255 });
    uiCanvas-&gt;DrawLine(cx, cy - 5, cx, cy + 4, { 255, 255, 255, 255 });
} else if(how == CLICK ||
      (how == HOVER &amp;&amp; leftDown &amp;&amp; editControl.colorPicker.picker2dActive))
{
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        double h = (x - hx)/(hxm - hx),
        editControl.colorPicker.picker2dActive = true;
    }
}

SetMousePointerToHand(mousePointerAsHand);
return true;
</t>
<t tx="leo1.20171224221229.162">void TextWindow::Paint() {
    if (!canvas) return;

    int width, height;
    GetTextWindowSize(&amp;width, &amp;height);

    Camera camera = {};
    camera.width  = width;
    camera.height = height;
    camera.LoadIdentity();
    camera.offset.x = -(double)camera.width  / 2.0;
    camera.offset.y = -(double)camera.height / 2.0;

    Lighting lighting = {};
    lighting.backgroundColor = RGBi(0, 0, 0);

    canvas-&gt;SetLighting(lighting);
    canvas-&gt;SetCamera(camera);
    canvas-&gt;NewFrame();

    UiCanvas uiCanvas = {};
    uiCanvas.canvas = canvas;
    uiCanvas.flip = true;

    halfRows = camera.height / (LINE_HEIGHT/2);

    int bottom = top[rows-1] + 2;
    scrollPos = min(scrollPos, bottom - halfRows);
    scrollPos = max(scrollPos, 0);

    // Let's set up the scroll bar first
    MoveTextScrollbarTo(scrollPos, top[rows - 1] + 1, halfRows);

    // Now paint the window.
    int r, c, a;
    for(a = 0; a &lt; 2; a++) {
        for(r = 0; r &lt; rows; r++) {
            int ltop = top[r];
            if(ltop &lt; (scrollPos-1)) continue;
            if(ltop &gt; scrollPos+halfRows) break;

            for(c = 0; c &lt; min((width/CHAR_WIDTH_)+1, (int) MAX_COLS); c++) {
                int x = LEFT_MARGIN + c*CHAR_WIDTH_;
                int y = (ltop-scrollPos)*(LINE_HEIGHT/2) + 4;

                int fg = meta[r][c].fg;
                int bg = meta[r][c].bg;

                // On the first pass, all the background quads; on the next
                // pass, all the foreground (i.e., font) quads.
                if(a == 0) {
                    RgbaColor bgRgb = meta[r][c].bgRgb;
                    int bh = LINE_HEIGHT, adj = 0;
                    if(bg == 'z') {
                        bh = CHAR_HEIGHT;
                        adj += 2;
                    } else {
                        bgRgb = RgbaColor::FromFloat(bgColorTable[bg*3+0],
                                                     bgColorTable[bg*3+1],
                                                     bgColorTable[bg*3+2]);
                    }

                    if(bg != 'd') {
                        // Move the quad down a bit, so that the descenders
                        // still have the correct background.
                        uiCanvas.DrawRect(x, x + CHAR_WIDTH_, y + adj, y + adj + bh,
                                          /*fillColor=*/bgRgb, /*outlineColor=*/{});
                    }
                } else if(a == 1) {
                    RgbaColor fgRgb = RgbaColor::FromFloat(fgColorTable[fg*3+0],
                                                           fgColorTable[fg*3+1],
                                                           fgColorTable[fg*3+2]);
                    if(text[r][c] != ' ') {
                        uiCanvas.DrawBitmapChar(text[r][c], x, y + CHAR_HEIGHT, fgRgb);
                    }

                    // If this is a link and it's hovered, then draw the
                    // underline
                    if(meta[r][c].link &amp;&amp; meta[r][c].link != 'n' &amp;&amp;
                        (r == hoveredRow &amp;&amp; c == hoveredCol))
                    {
                        int cs = c, cf = c;
                        while(cs &gt;= 0 &amp;&amp; meta[r][cs].link &amp;&amp;
                                         meta[r][cs].f    == meta[r][c].f &amp;&amp;
                                         meta[r][cs].data == meta[r][c].data)
                        {
                            cs--;
                        }
                        cs++;

                        while(          meta[r][cf].link &amp;&amp;
                                        meta[r][cf].f    == meta[r][c].f &amp;&amp;
                                        meta[r][cf].data == meta[r][c].data)
                        {
                            cf++;
                        }

                        // But don't underline checkboxes or radio buttons
                        while(((text[r][cs] &gt;= 0xe000 &amp;&amp; text[r][cs] &lt;= 0xefff) ||
                                text[r][cs] == ' ') &amp;&amp;
                              cs &lt; cf)
                        {
                            cs++;
                        }

                        // Always use the color of the rightmost character
                        // in the link, so that underline is consistent color
                        fg = meta[r][cf-1].fg;
                        fgRgb = RgbaColor::FromFloat(fgColorTable[fg*3+0],
                                                     fgColorTable[fg*3+1],
                                                     fgColorTable[fg*3+2]);
                        int yp = y + CHAR_HEIGHT;
                        uiCanvas.DrawLine(LEFT_MARGIN + cs*CHAR_WIDTH_, yp,
                                          LEFT_MARGIN + cf*CHAR_WIDTH_, yp,
                                          fgRgb);
                    }
                }
            }
        }
    }

    // The line to indicate the column of radio buttons that indicates the
    // active group.
    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    // Make sure this test agrees with test to determine which screen is drawn
    if(!SS.GW.pending.description &amp;&amp; gs.n == 0 &amp;&amp; gs.constraints == 0 &amp;&amp;
        shown.screen == Screen::LIST_OF_GROUPS)
    {
        int x = 29, y = 70 + LINE_HEIGHT;
        y -= scrollPos*(LINE_HEIGHT/2);

        RgbaColor color = RgbaColor::FromFloat(fgColorTable['t'*3+0],
                                               fgColorTable['t'*3+1],
                                               fgColorTable['t'*3+2]);
        uiCanvas.DrawLine(x, y, x, y+40, color);
    }

    // The header has some icons that are drawn separately from the text
    DrawOrHitTestIcons(&amp;uiCanvas, PAINT, 0, 0);

    // And we may show a color picker for certain editable fields
    DrawOrHitTestColorPicker(&amp;uiCanvas, PAINT, false, 0, 0);

    canvas-&gt;FlushFrame();
    canvas-&gt;Clear();
}

</t>
<t tx="leo1.20171224221229.163">void TextWindow::MouseEvent(bool leftClick, bool leftDown, double x, double y) {
    if(TextEditControlIsVisible() || GraphicsEditControlIsVisible()) {
        if(DrawOrHitTestColorPicker(NULL, leftClick ? CLICK : HOVER, leftDown, x, y))
        {
            return;
        }

        if(leftClick) {
            HideEditControl();
            HideGraphicsEditControl();
        } else {
            SetMousePointerToHand(false);
        }
        return;
    }

    DrawOrHitTestIcons(NULL, leftClick ? CLICK : HOVER, x, y);

    GraphicsWindow::Selection ps = SS.GW.hover;
    SS.GW.hover.Clear();

    int prevHoveredRow = hoveredRow,
        if(y &gt;= top[r]*hh &amp;&amp; y &lt;= (top[r]+2)*hh) {
            break;
        }
    }
    if(r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &lt; MAX_COLS) {
        SetMousePointerToHand(false);

        hoveredRow = r;
        hoveredCol = c;

        const auto &amp;item = meta[r][c];
        if(leftClick) {
            if(item.link &amp;&amp; item.f) {
                (item.f)(item.link, item.data);
                Show();
                InvalidateGraphics();
            }
        } else {
            if(item.link) {
                SetMousePointerToHand(true);
                if(item.h) {
                    (item.h)(item.link, item.data);
                }
            } else {
                SetMousePointerToHand(false);
            }
        }
    }

    if((!ps.Equals(&amp;(SS.GW.hover))) ||
        prevHoveredRow != hoveredRow ||
        prevHoveredCol != hoveredCol)
    {
        InvalidateGraphics();
        InvalidateText();
    }
}

</t>
<t tx="leo1.20171224221229.164">void TextWindow::MouseLeave() {
    tooltippedButton = NULL;
    hoveredButton = NULL;
    hoveredRow = 0;
    hoveredCol = 0;
    InvalidateText();
}

</t>
<t tx="leo1.20171224221229.165">void TextWindow::ScrollbarEvent(int newPos) {
    if(TextEditControlIsVisible())
        return;

    int bottom = top[rows-1] + 2;
    newPos = min(newPos, bottom - halfRows);
    newPos = max(newPos, 0);

    if(newPos != scrollPos) {
        scrollPos = newPos;
        MoveTextScrollbarTo(scrollPos, top[rows - 1] + 1, halfRows);
        InvalidateText();
    }
}

}
</t>
<t tx="leo1.20171224221229.17">class Translation {
public:
    unsigned    pluralCount;
    std::string pluralExpr;

    std::map&lt;TranslationKey, std::vector&lt;std::string&gt;, TranslationKeyLess&gt; messages;

    static Translation From(const std::string &amp;poData);

    const std::string &amp;Translate(const TranslationKey &amp;key);
    const std::string &amp;TranslatePlural(const TranslationKey &amp;key, unsigned n);
};

Translation Translation::From(const std::string &amp;poData) {
    GettextParser parser = {};
    parser.reader = ASCIIReader::From(poData);
    parser.Parse();

    Translation trans = {};
    trans.pluralCount = parser.pluralCount;
    trans.pluralExpr  = parser.pluralExpr;
    trans.messages    = parser.messages;
    return trans;
}

</t>
<t tx="leo1.20171224221229.18">const std::string &amp;Translation::Translate(const TranslationKey &amp;key) {
    auto it = messages.find(key);
    if(it == messages.end()) {
        dbp("Missing (absent) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        messages[key].emplace_back(key.ident);
        it = messages.find(key);
    }
    if(it-&gt;second[0].empty()) {
        dbp("Missing (empty) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        it-&gt;second[0] = key.ident;
    }
    if(it-&gt;second.size() != 1) {
        dbp("Incorrect use of translated message %s'%s'", key.context.c_str(), key.ident.c_str());
        ssassert(false, "Using a message with a plural form without a number");
    }
    return it-&gt;second[0];
}

</t>
<t tx="leo1.20171224221229.19">const std::string &amp;Translation::TranslatePlural(const TranslationKey &amp;key, unsigned n) {
    unsigned pluralForm = PluralExpr::Eval(pluralExpr, n);

    auto it = messages.find(key);
    if(it == messages.end()) {
        dbp("Missing (absent) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        for(unsigned i = 0; i &lt; pluralCount; i++) {
            messages[key].emplace_back(key.ident);
        }
        it = messages.find(key);
    }
    if(it-&gt;second[pluralForm].empty()) {
        dbp("Missing (empty) translation for %s'%s'[%d]",
            key.context.c_str(), key.ident.c_str(), pluralForm);
        it-&gt;second[pluralForm] = key.ident;
    }
    return it-&gt;second[pluralForm];
}

//-----------------------------------------------------------------------------
// Locale management
//-----------------------------------------------------------------------------

static std::set&lt;Locale, LocaleLess&gt; locales;
static std::map&lt;Locale, Translation, LocaleLess&gt; translations;
static Translation dummyTranslation;
static Translation *currentTranslation = &amp;dummyTranslation;

</t>
<t tx="leo1.20171224221229.2">auto first = firstGlyph,
     last  = lffData.cend();
while(first &lt;= last) {
    auto mid = first + (last - first) / 2;
    while(mid &gt; first) {
        if(*mid == '[' &amp;&amp; *(mid - 1) == '\n') break;
        mid--;
    }

    ASCIIReader reader = { mid, lffData.cend() };
    if(reader.AtEnd()) break;

    // Read the codepoint.
    reader.ExpectChar('[');
    char32_t foundCodepoint = reader.Read16HexBits();
    reader.ExpectChar(']');
    reader.SkipUntilEol();

    if(foundCodepoint &gt; codepoint) {
        last = mid - 1;
        continue; // and first stays the same
    }
    if(foundCodepoint &lt; codepoint) {
        first = mid + 1;
        while(first != lffData.cend()) {
            if(*first == '[' &amp;&amp; *(first - 1) == '\n') break;
            first++;
        }
        continue; // and last stays the same
    }

    // Found the codepoint.
    VectorFont::Glyph glyph = {};

    // Read glyph contours.
    while(!reader.AtEnd()) {
        if(reader.TryChar('\n')) {
            // Skip.
        } else if(reader.TryChar('[')) {
            // End of glyph.
            if(glyph.contours.back().points.empty()) {
                // Remove an useless empty contour, if any.
                glyph.contours.pop_back();
            }
            break;
        } else if(reader.TryChar('C')) {
            // Another character is referenced in this one.
            char32_t baseCodepoint = reader.Read16HexBits();
            const VectorFont::Glyph &amp;baseGlyph = GetGlyph(baseCodepoint);
            std::copy(baseGlyph.contours.begin(), baseGlyph.contours.end(),
                      std::back_inserter(glyph.contours));
        } else {
            Contour contour;
            do {
                Point2d p;
                p.x = reader.ReadFloatDecimal();
                reader.ExpectChar(',');
                p.y = reader.ReadFloatDecimal();

                if(reader.TryChar(',')) {
                    // Point with a bulge.
                    reader.ExpectChar('A');
                    double bulge = reader.ReadFloatDecimal();
                    MakePwlBulge(&amp;contour, p, bulge);
                } else {
                    // Just a point.
                    contour.points.emplace_back(std::move(p));
                }
            } while(reader.TryChar(';'));
            reader.ExpectChar('\n');
            glyph.contours.emplace_back(std::move(contour));
        }
    }

    // Calculate metrics.
    GetGlyphBBox(glyph, &amp;glyph.leftSideBearing, &amp;glyph.boundingWidth, nullptr, nullptr);
    glyph.advanceWidth = glyph.leftSideBearing + glyph.boundingWidth + rightSideBearing;

    it = glyphs.emplace(codepoint, std::move(glyph)).first;
    return (*it).second;
}

// Glyph doesn't exist; return replacement glyph instead.
ssassert(codepoint != 0xfffd, "Cannot parse replacement glyph");
return GetGlyph(0xfffd);
</t>
<t tx="leo1.20171224221229.20">const std::set&lt;Locale, LocaleLess&gt; &amp;Locales() {
    if(!locales.empty()) return locales;

    std::string localeList = LoadString("locales.txt");
    ASCIIReader reader = ASCIIReader::From(localeList);
    while(!reader.AtEnd()) {
        reader.SkipSpace();
        if(reader.TryChar('#')) {
            reader.SkipUntilEol();
            continue;
        }

        std::smatch m;
        reader.ExpectRegex(std::regex("([a-z]{2})-([A-Z]{2}),([0-9A-F]{4}),(.+?)\n"), &amp;m);
        Locale locale = {};
        locale.language    = m.str(1);
        locale.region      = m.str(2);
        locale.lcid        = std::stoi(m.str(3), NULL, 16);
        locale.displayName = m.str(4);
        locales.emplace(locale);
    }
    return locales;
}

template&lt;class Predicate&gt;
</t>
<t tx="leo1.20171224221229.21">bool SetLocale(Predicate pred) {
    auto it = std::find_if(Locales().begin(), Locales().end(), pred);
    if(it != locales.end()) {
        std::string filename = "locales/" + it-&gt;language + "_" + it-&gt;region + ".po";
        translations[*it] = Translation::From(LoadString(filename));
        currentTranslation = &amp;translations[*it];
        RefreshLocale();
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221229.22">bool SetLocale(const std::string &amp;name) {
    return SetLocale([&amp;](const Locale &amp;locale) {
        if(name == locale.language + "-" + locale.region) {
            return true;
        } else if(name == locale.language + "_" + locale.region) {
            return true;
        } else if(name == locale.language) {
            return true;
        } else {
            return false;
        }
    });
}

</t>
<t tx="leo1.20171224221229.23">bool SetLocale(uint16_t lcid) {
    return SetLocale([&amp;](const Locale &amp;locale) {
        return locale.lcid == lcid;
    });
}

</t>
<t tx="leo1.20171224221229.24">const std::string &amp;Translate(const char *msgid) {
    TranslationKey key = {};
    key.ident      = msgid;
    return currentTranslation-&gt;Translate(key);
}

</t>
<t tx="leo1.20171224221229.25">const std::string &amp;Translate(const char *msgctxt, const char *msgid) {
    TranslationKey key = {};
    key.hasContext = true;
    key.context    = msgctxt;
    key.ident      = msgid;
    return currentTranslation-&gt;Translate(key);
}

</t>
<t tx="leo1.20171224221229.26">const std::string &amp;TranslatePlural(const char *msgid, unsigned n) {
    TranslationKey key = {};
    key.ident      = msgid;
    return currentTranslation-&gt;TranslatePlural(key, n);
}

</t>
<t tx="leo1.20171224221229.27">const std::string &amp;TranslatePlural(const char *msgctxt, const char *msgid, unsigned n) {
    TranslationKey key = {};
    key.hasContext = true;
    key.context    = msgctxt;
    key.ident      = msgid;
    return currentTranslation-&gt;TranslatePlural(key, n);
}

}
</t>
<t tx="leo1.20171224221229.28">//-----------------------------------------------------------------------------
// Entry point in to the program, our registry-stored settings and top-level
// housekeeping when we open, save, and create new files.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "config.h"

SolveSpaceUI SolveSpace::SS = {};
Sketch SolveSpace::SK = {};

Platform::Path SolveSpace::RecentFile[MAX_RECENT] = {};

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221229.29">void SolveSpaceUI::Init() {
#if !defined(HEADLESS)
    // Check that the resource system works.
    dbp("%s", LoadString("banner.txt").data());
#endif

    SS.tangentArcRadius = 10.0;

    // Then, load the registry settings.
    // Default list of colors for the model material
    modelColor[0] = CnfThawColor(RGBi(150, 150, 150), "ModelColor_0");
    modelColor[1] = CnfThawColor(RGBi(100, 100, 100), "ModelColor_1");
    modelColor[2] = CnfThawColor(RGBi( 30,  30,  30), "ModelColor_2");
    modelColor[3] = CnfThawColor(RGBi(150,   0,   0), "ModelColor_3");
    modelColor[4] = CnfThawColor(RGBi(  0, 100,   0), "ModelColor_4");
    modelColor[5] = CnfThawColor(RGBi(  0,  80,  80), "ModelColor_5");
    modelColor[6] = CnfThawColor(RGBi(  0,   0, 130), "ModelColor_6");
    modelColor[7] = CnfThawColor(RGBi( 80,   0,  80), "ModelColor_7");
    // Light intensities
    lightIntensity[0] = CnfThawFloat(1.0f, "LightIntensity_0");
    lightIntensity[1] = CnfThawFloat(0.5f, "LightIntensity_1");
    ambientIntensity = 0.3; // no setting for that yet
    // Light positions
    lightDir[0].x = CnfThawFloat(-1.0f, "LightDir_0_Right"     );
    lightDir[0].y = CnfThawFloat( 1.0f, "LightDir_0_Up"        );
    lightDir[0].z = CnfThawFloat( 0.0f, "LightDir_0_Forward"   );
    lightDir[1].x = CnfThawFloat( 1.0f, "LightDir_1_Right"     );
    lightDir[1].y = CnfThawFloat( 0.0f, "LightDir_1_Up"        );
    lightDir[1].z = CnfThawFloat( 0.0f, "LightDir_1_Forward"   );

    exportMode = false;
    // Chord tolerance
    chordTol = CnfThawFloat(0.5f, "ChordTolerancePct");
    // Max pwl segments to generate
    maxSegments = CnfThawInt(10, "MaxSegments");
    // Chord tolerance
    exportChordTol = CnfThawFloat(0.1f, "ExportChordTolerance");
    // Max pwl segments to generate
    exportMaxSegments = CnfThawInt(64, "ExportMaxSegments");
    // View units
    viewUnits = (Unit)CnfThawInt((uint32_t)Unit::MM, "ViewUnits");
    // Number of digits after the decimal point
    afterDecimalMm = CnfThawInt(2, "AfterDecimalMm");
    afterDecimalInch = CnfThawInt(3, "AfterDecimalInch");
    // Camera tangent (determines perspective)
    cameraTangent = CnfThawFloat(0.3f/1e3f, "CameraTangent");
    // Grid spacing
    gridSpacing = CnfThawFloat(5.0f, "GridSpacing");
    // Export scale factor
    exportScale = CnfThawFloat(1.0f, "ExportScale");
    // Export offset (cutter radius comp)
    exportOffset = CnfThawFloat(0.0f, "ExportOffset");
    // Rewrite exported colors close to white into black (assuming white bg)
    fixExportColors = CnfThawBool(true, "FixExportColors");
    // Draw back faces of triangles (when mesh is leaky/self-intersecting)
    drawBackFaces = CnfThawBool(true, "DrawBackFaces");
    // Check that contours are closed and not self-intersecting
    checkClosedContour = CnfThawBool(true, "CheckClosedContour");
    // Draw closed polygons areas
    showContourAreas = CnfThawBool(false, "ShowContourAreas");
    // Export shaded triangles in a 2d view
    exportShadedTriangles = CnfThawBool(true, "ExportShadedTriangles");
    // Export pwl curves (instead of exact) always
    exportPwlCurves = CnfThawBool(false, "ExportPwlCurves");
    // Background color on-screen
    backgroundColor = CnfThawColor(RGBi(0, 0, 0), "BackgroundColor");
    // Whether export canvas size is fixed or derived from bbox
    exportCanvasSizeAuto = CnfThawBool(true, "ExportCanvasSizeAuto");
    // Margins for automatic canvas size
    exportMargin.left   = CnfThawFloat(5.0f, "ExportMargin_Left");
    exportMargin.right  = CnfThawFloat(5.0f, "ExportMargin_Right");
    exportMargin.bottom = CnfThawFloat(5.0f, "ExportMargin_Bottom");
    exportMargin.top    = CnfThawFloat(5.0f, "ExportMargin_Top");
    // Dimensions for fixed canvas size
    exportCanvas.width  = CnfThawFloat(100.0f, "ExportCanvas_Width");
    exportCanvas.height = CnfThawFloat(100.0f, "ExportCanvas_Height");
    exportCanvas.dx     = CnfThawFloat(  5.0f, "ExportCanvas_Dx");
    exportCanvas.dy     = CnfThawFloat(  5.0f, "ExportCanvas_Dy");
    // Extra parameters when exporting G code
    gCode.depth         = CnfThawFloat(10.0f, "GCode_Depth");
    gCode.passes        = CnfThawInt(1, "GCode_Passes");
    gCode.feed          = CnfThawFloat(10.0f, "GCode_Feed");
    gCode.plungeFeed    = CnfThawFloat(10.0f, "GCode_PlungeFeed");
    // Show toolbar in the graphics window
    showToolbar = CnfThawBool(true, "ShowToolbar");
    // Recent files menus
    for(size_t i = 0; i &lt; MAX_RECENT; i++) {
        RecentFile[i] = Platform::Path::From(CnfThawString("", "RecentFile_" + std::to_string(i)));
    }
    RefreshRecentMenus();
    // Autosave timer
    autosaveInterval = CnfThawInt(5, "AutosaveInterval");
    // Locale
    std::string locale = CnfThawString("", "Locale");
    if(!locale.empty()) {
        SetLocale(locale);
    }

    // The default styles (colors, line widths, etc.) are also stored in the
    // configuration file, but we will automatically load those as we need
    // them.

    SetAutosaveTimerFor(autosaveInterval);

    NewFile();
    AfterNewFile();
}

</t>
<t tx="leo1.20171224221229.3">void VectorFont::Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
                       std::function&lt;void(Vector, Vector)&gt; traceEdge) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    double scale = (forCapHeight / capHeight);
    u = u.ScaledBy(scale);
    v = v.ScaledBy(scale);

    for(char32_t codepoint : ReadUTF8(str)) {
        const Glyph &amp;glyph = GetGlyph(codepoint);

        for(const VectorFont::Contour &amp;contour : glyph.contours) {
            Vector prevp;
            bool penUp = true;
            for(const Point2d &amp;pt : contour.points) {
                Vector p = o.Plus(u.ScaledBy(pt.x))
                            .Plus(v.ScaledBy(pt.y));
                if(!penUp) traceEdge(prevp, p);
                prevp = p;
                penUp = false;
            }
        }

        o = o.Plus(u.ScaledBy(glyph.advanceWidth));
    }
}

</t>
<t tx="leo1.20171224221229.30">bool SolveSpaceUI::LoadAutosaveFor(const Platform::Path &amp;filename) {
    Platform::Path autosaveFile = filename.WithExtension(AUTOSAVE_EXT);

    FILE *f = OpenFile(autosaveFile, "rb");
    if(!f)
        return false;
    fclose(f);

    if(LoadAutosaveYesNo() == DIALOG_YES) {
        unsaved = true;
        return LoadFromFile(autosaveFile, /*canCancel=*/true);
    }

    return false;
}

</t>
<t tx="leo1.20171224221229.31">bool SolveSpaceUI::Load(const Platform::Path &amp;filename) {
    bool autosaveLoaded = LoadAutosaveFor(filename);
    bool fileLoaded = autosaveLoaded || LoadFromFile(filename, /*canCancel=*/true);
    if(fileLoaded) {
        saveFile = filename;
        AddToRecentList(filename);
    } else {
        saveFile.Clear();
        NewFile();
    }
    AfterNewFile();
    unsaved = autosaveLoaded;
    return fileLoaded;
}

</t>
<t tx="leo1.20171224221229.32">void SolveSpaceUI::Exit() {
    // Recent files
    for(size_t i = 0; i &lt; MAX_RECENT; i++)
        CnfFreezeString(RecentFile[i].raw, "RecentFile_" + std::to_string(i));
    // Model colors
    for(size_t i = 0; i &lt; MODEL_COLORS; i++)
        CnfFreezeColor(modelColor[i], "ModelColor_" + std::to_string(i));
    // Light intensities
    CnfFreezeFloat((float)lightIntensity[0], "LightIntensity_0");
    CnfFreezeFloat((float)lightIntensity[1], "LightIntensity_1");
    // Light directions
    CnfFreezeFloat((float)lightDir[0].x, "LightDir_0_Right");
    CnfFreezeFloat((float)lightDir[0].y, "LightDir_0_Up");
    CnfFreezeFloat((float)lightDir[0].z, "LightDir_0_Forward");
    CnfFreezeFloat((float)lightDir[1].x, "LightDir_1_Right");
    CnfFreezeFloat((float)lightDir[1].y, "LightDir_1_Up");
    CnfFreezeFloat((float)lightDir[1].z, "LightDir_1_Forward");
    // Chord tolerance
    CnfFreezeFloat((float)chordTol, "ChordTolerancePct");
    // Max pwl segments to generate
    CnfFreezeInt((uint32_t)maxSegments, "MaxSegments");
    // Export Chord tolerance
    CnfFreezeFloat((float)exportChordTol, "ExportChordTolerance");
    // Export Max pwl segments to generate
    CnfFreezeInt((uint32_t)exportMaxSegments, "ExportMaxSegments");
    // View units
    CnfFreezeInt((uint32_t)viewUnits, "ViewUnits");
    // Number of digits after the decimal point
    CnfFreezeInt((uint32_t)afterDecimalMm, "AfterDecimalMm");
    CnfFreezeInt((uint32_t)afterDecimalInch, "AfterDecimalInch");
    // Camera tangent (determines perspective)
    CnfFreezeFloat((float)cameraTangent, "CameraTangent");
    // Grid spacing
    CnfFreezeFloat(gridSpacing, "GridSpacing");
    // Export scale
    CnfFreezeFloat(exportScale, "ExportScale");
    // Export offset (cutter radius comp)
    CnfFreezeFloat(exportOffset, "ExportOffset");
    // Rewrite exported colors close to white into black (assuming white bg)
    CnfFreezeBool(fixExportColors, "FixExportColors");
    // Draw back faces of triangles (when mesh is leaky/self-intersecting)
    CnfFreezeBool(drawBackFaces, "DrawBackFaces");
    // Draw closed polygons areas
    CnfFreezeBool(showContourAreas, "ShowContourAreas");
    // Check that contours are closed and not self-intersecting
    CnfFreezeBool(checkClosedContour, "CheckClosedContour");
    // Export shaded triangles in a 2d view
    CnfFreezeBool(exportShadedTriangles, "ExportShadedTriangles");
    // Export pwl curves (instead of exact) always
    CnfFreezeBool(exportPwlCurves, "ExportPwlCurves");
    // Background color on-screen
    CnfFreezeColor(backgroundColor, "BackgroundColor");
    // Whether export canvas size is fixed or derived from bbox
    CnfFreezeBool(exportCanvasSizeAuto, "ExportCanvasSizeAuto");
    // Margins for automatic canvas size
    CnfFreezeFloat(exportMargin.left,   "ExportMargin_Left");
    CnfFreezeFloat(exportMargin.right,  "ExportMargin_Right");
    CnfFreezeFloat(exportMargin.bottom, "ExportMargin_Bottom");
    CnfFreezeFloat(exportMargin.top,    "ExportMargin_Top");
    // Dimensions for fixed canvas size
    CnfFreezeFloat(exportCanvas.width,  "ExportCanvas_Width");
    CnfFreezeFloat(exportCanvas.height, "ExportCanvas_Height");
    CnfFreezeFloat(exportCanvas.dx,     "ExportCanvas_Dx");
    CnfFreezeFloat(exportCanvas.dy,     "ExportCanvas_Dy");
     // Extra parameters when exporting G code
    CnfFreezeFloat(gCode.depth,         "GCode_Depth");
    CnfFreezeInt(gCode.passes,          "GCode_Passes");
    CnfFreezeFloat(gCode.feed,          "GCode_Feed");
    CnfFreezeFloat(gCode.plungeFeed,    "GCode_PlungeFeed");
    // Show toolbar in the graphics window
    CnfFreezeBool(showToolbar, "ShowToolbar");
    // Autosave timer
    CnfFreezeInt(autosaveInterval, "AutosaveInterval");

    // And the default styles, colors and line widths and such.
    Style::FreezeDefaultStyles();

    ExitNow();
}

</t>
<t tx="leo1.20171224221229.33">void SolveSpaceUI::ScheduleGenerateAll() {
    if(!later.scheduled) ScheduleLater();
    later.scheduled = true;
    later.generateAll = true;
}

</t>
<t tx="leo1.20171224221229.34">void SolveSpaceUI::ScheduleShowTW() {
    if(!later.scheduled) ScheduleLater();
    later.scheduled = true;
    later.showTW = true;
}

</t>
<t tx="leo1.20171224221229.35">void SolveSpaceUI::DoLater() {
    if(later.generateAll) GenerateAll();
    if(later.showTW) TW.Show();
    later = {};
}

double SolveSpaceUI::MmPerUnit() {
    if(viewUnits == Unit::INCHES) {
        return 25.4;
    } else {
        return 1.0;
    }
}
</t>
<t tx="leo1.20171224221229.36">const char *SolveSpaceUI::UnitName() {
    if(viewUnits == Unit::INCHES) {
        return "inch";
    } else {
        return "mm";
    }
}
std::string SolveSpaceUI::MmToString(double v) {
    if(viewUnits == Unit::INCHES) {
        return ssprintf("%.*f", afterDecimalInch, v/25.4);
    } else {
        return ssprintf("%.*f", afterDecimalMm, v);
    }
}
double SolveSpaceUI::ExprToMm(Expr *e) {
    return (e-&gt;Eval()) * MmPerUnit();
}
double SolveSpaceUI::StringToMm(const std::string &amp;str) {
    return std::stod(str) * MmPerUnit();
}
double SolveSpaceUI::ChordTolMm() {
    if(exportMode) return ExportChordTolMm();
    return chordTolCalculated;
}
double SolveSpaceUI::ExportChordTolMm() {
    return exportChordTol / exportScale;
}
</t>
<t tx="leo1.20171224221229.37">int SolveSpaceUI::GetMaxSegments() {
    if(exportMode) return exportMaxSegments;
    return maxSegments;
}
</t>
<t tx="leo1.20171224221229.38">int SolveSpaceUI::UnitDigitsAfterDecimal() {
    return (viewUnits == Unit::INCHES) ? afterDecimalInch : afterDecimalMm;
}
</t>
<t tx="leo1.20171224221229.39">void SolveSpaceUI::SetUnitDigitsAfterDecimal(int v) {
    if(viewUnits == Unit::INCHES) {
        afterDecimalInch = v;
    } else {
        afterDecimalMm = v;
    }
}

double SolveSpaceUI::CameraTangent() {
    if(!usePerspectiveProj) {
        return 0;
    } else {
        return cameraTangent;
    }
}

</t>
<t tx="leo1.20171224221229.4">void VectorFont::Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
                       std::function&lt;void(Vector, Vector)&gt; traceEdge, const Camera &amp;camera) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    // Perform grid-fitting only when the text is parallel to the view plane.
    if(camera.hasPixels &amp;&amp; !(u.WithMagnitude(1).Equals(camera.projRight) &amp;&amp;
                             v.WithMagnitude(1).Equals(camera.projUp))) {
        return Trace(forCapHeight, o, u, v, str, traceEdge);
    }

    double scale = forCapHeight / capHeight;
    u = u.ScaledBy(scale);
    v = v.ScaledBy(scale);

    for(char32_t codepoint : ReadUTF8(str)) {
        const Glyph &amp;glyph = GetGlyph(codepoint);
        double actualWidth = std::max(1.0, glyph.boundingWidth);

        // Align (o+lsb), (o+lsb+u) and (o+lsb+v) to pixel grid.
        Vector ao =  o.Plus(u.ScaledBy(glyph.leftSideBearing));
        Vector au = ao.Plus(u.ScaledBy(actualWidth));
        Vector av = ao.Plus(v.ScaledBy(capHeight));

        ao = camera.AlignToPixelGrid(ao);
        au = camera.AlignToPixelGrid(au);
        av = camera.AlignToPixelGrid(av);

        au = au.Minus(ao).ScaledBy(1.0 / actualWidth);
        av = av.Minus(ao).ScaledBy(1.0 / capHeight);

        for(const VectorFont::Contour &amp;contour : glyph.contours) {
            Vector prevp;
            bool penUp = true;
            for(const Point2d &amp;pt : contour.points) {
                Vector p = ao.Plus(au.ScaledBy(pt.x - glyph.leftSideBearing))
                             .Plus(av.ScaledBy(pt.y));
                if(!penUp) traceEdge(prevp, p);
                prevp = p;
                penUp = false;
            }
        }

        o = o.Plus(u.ScaledBy(glyph.advanceWidth));
    }
}

//-----------------------------------------------------------------------------
// Gettext plural expression evaluation
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221229.40">void SolveSpaceUI::AfterNewFile() {
    // Clear out the traced point, which is no longer valid
    traced.point = Entity::NO_ENTITY;
    traced.path.l.Clear();
    // and the naked edges
    nakedEdges.Clear();

    // Quit export mode
    justExportedInfo.draw = false;
    centerOfMass.draw = false;
    exportMode = false;

    // GenerateAll() expects the view to be valid, because it uses that to
    // fill in default values for extrusion depths etc. (which won't matter
    // here, but just don't let it work on garbage)
    SS.GW.offset    = Vector::From(0, 0, 0);
    SS.GW.projRight = Vector::From(1, 0, 0);
    SS.GW.projUp    = Vector::From(0, 1, 0);

    GenerateAll(Generate::ALL);

    TW.Init();
    GW.Init();

    unsaved = false;

    int w, h;
    GetGraphicsWindowSize(&amp;w, &amp;h);
    GW.width = w;
    GW.height = h;

    GW.ZoomToFit(/*includingInvisibles=*/false);

    // Create all the default styles; they'll get created on the fly anyways,
    // but can't hurt to do it now.
    Style::CreateAllDefaultStyles();

    UpdateWindowTitle();
}

</t>
<t tx="leo1.20171224221229.41">void SolveSpaceUI::RemoveFromRecentList(const Platform::Path &amp;filename) {
    int dest = 0;
    for(int src = 0; src &lt; (int)MAX_RECENT; src++) {
        if(!filename.Equals(RecentFile[src])) {
            if(src != dest) RecentFile[dest] = RecentFile[src];
            dest++;
        }
    }
    while(dest &lt; (int)MAX_RECENT) RecentFile[dest++].Clear();
    RefreshRecentMenus();
}
</t>
<t tx="leo1.20171224221229.42">void SolveSpaceUI::AddToRecentList(const Platform::Path &amp;filename) {
    RemoveFromRecentList(filename);

    for(int src = MAX_RECENT - 2; src &gt;= 0; src--) {
        RecentFile[src+1] = RecentFile[src];
    }
    RecentFile[0] = filename;
    RefreshRecentMenus();
}

</t>
<t tx="leo1.20171224221229.43">bool SolveSpaceUI::GetFilenameAndSave(bool saveAs) {
    Platform::Path newSaveFile = saveFile;

    if(saveAs || saveFile.IsEmpty()) {
        if(!GetSaveFile(&amp;newSaveFile, "", SlvsFileFilter)) return false;
    }

    if(SaveToFile(newSaveFile)) {
        AddToRecentList(newSaveFile);
        RemoveAutosave();
        saveFile = newSaveFile;
        unsaved = false;
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221229.44">bool SolveSpaceUI::Autosave()
{
    SetAutosaveTimerFor(autosaveInterval);

    if(!saveFile.IsEmpty() &amp;&amp; unsaved)
        return SaveToFile(saveFile.WithExtension(AUTOSAVE_EXT));

    return false;
}

</t>
<t tx="leo1.20171224221229.45">void SolveSpaceUI::RemoveAutosave()
{
    Platform::Path autosaveFile = saveFile.WithExtension(AUTOSAVE_EXT);
    RemoveFile(autosaveFile);
}

</t>
<t tx="leo1.20171224221229.46">bool SolveSpaceUI::OkayToStartNewFile() {
    if(!unsaved) return true;

    switch(SaveFileYesNoCancel()) {
        case DIALOG_YES:
            return GetFilenameAndSave(/*saveAs=*/false);

        case DIALOG_NO:
            RemoveAutosave();
            return true;

        case DIALOG_CANCEL:
            return false;
    }
    ssassert(false, "Unexpected dialog choice");
}

</t>
<t tx="leo1.20171224221229.47">void SolveSpaceUI::UpdateWindowTitle() {
    SetCurrentFilename(saveFile);
}

</t>
<t tx="leo1.20171224221229.48">void SolveSpaceUI::MenuFile(Command id) {
    if((uint32_t)id &gt;= (uint32_t)Command::RECENT_OPEN &amp;&amp;
       (uint32_t)id &lt; ((uint32_t)Command::RECENT_OPEN+MAX_RECENT)) {
        if(!SS.OkayToStartNewFile()) return;

        Platform::Path newFile = RecentFile[(uint32_t)id - (uint32_t)Command::RECENT_OPEN];
        SS.Load(newFile);
        return;
    }

    switch(id) {
        case Command::NEW:
            if(!SS.OkayToStartNewFile()) break;

            SS.saveFile.Clear();
            SS.NewFile();
            SS.AfterNewFile();
            break;

        case Command::OPEN: {
            if(!SS.OkayToStartNewFile()) break;

            Platform::Path newFile;
            if(GetOpenFile(&amp;newFile, "", SlvsFileFilter)) {
                SS.Load(newFile);
            }
            break;
        }

        case Command::SAVE:
            SS.GetFilenameAndSave(/*saveAs=*/false);
            break;

        case Command::SAVE_AS:
            SS.GetFilenameAndSave(/*saveAs=*/true);
            break;

        case Command::EXPORT_PNG: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, "", RasterFileFilter)) break;
            SS.ExportAsPngTo(exportFile);
            break;
        }

        case Command::EXPORT_VIEW: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, CnfThawString("", "ViewExportFormat"),
                            VectorFileFilter)) break;
            CnfFreezeString(exportFile.Extension(), "ViewExportFormat");

            // If the user is exporting something where it would be
            // inappropriate to include the constraints, then warn.
            if(SS.GW.showConstraints &amp;&amp;
                (exportFile.HasExtension("txt") ||
                 fabs(SS.exportOffset) &gt; LENGTH_EPS))
            {
                Message(_("Constraints are currently shown, and will be exported "
                          "in the toolpath. This is probably not what you want; "
                          "hide them by clicking the link at the top of the "
                          "text window."));
            }

            SS.ExportViewOrWireframeTo(exportFile, /*exportWireframe*/false);
            break;
        }

        case Command::EXPORT_WIREFRAME: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, CnfThawString("", "WireframeExportFormat"),
                            Vector3dFileFilter)) break;
            CnfFreezeString(exportFile.Extension(), "WireframeExportFormat");

            SS.ExportViewOrWireframeTo(exportFile, /*exportWireframe*/true);
            break;
        }

        case Command::EXPORT_SECTION: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, CnfThawString("", "SectionExportFormat"),
                            VectorFileFilter)) break;
            CnfFreezeString(exportFile.Extension(), "SectionExportFormat");

            SS.ExportSectionTo(exportFile);
            break;
        }

        case Command::EXPORT_MESH: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, CnfThawString("", "MeshExportFormat"),
                            MeshFileFilter)) break;
            CnfFreezeString(exportFile.Extension(), "MeshExportFormat");

            SS.ExportMeshTo(exportFile);
            break;
        }

        case Command::EXPORT_SURFACES: {
            Platform::Path exportFile = SS.saveFile;
            if(!GetSaveFile(&amp;exportFile, CnfThawString("", "SurfacesExportFormat"),
                            SurfaceFileFilter)) break;
            CnfFreezeString(exportFile.Extension(), "SurfacesExportFormat");

            StepFileWriter sfw = {};
            sfw.ExportSurfacesTo(exportFile);
            break;
        }

        case Command::IMPORT: {
            Platform::Path importFile;
            if(!GetOpenFile(&amp;importFile, CnfThawString("", "ImportFormat"),
                            ImportableFileFilter)) break;
            CnfFreezeString(importFile.Extension(), "ImportFormat");

            if(importFile.HasExtension("dxf")) {
                ImportDxf(importFile);
            } else if(importFile.HasExtension("dwg")) {
                ImportDwg(importFile);
            } else {
                Error("Can't identify file type from file extension of "
                      "filename '%s'; try .dxf or .dwg.", importFile.raw.c_str());
            }

            SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
            SS.ScheduleShowTW();
            break;
        }

        case Command::EXIT:
            if(!SS.OkayToStartNewFile()) break;
            SS.Exit();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }

    SS.UpdateWindowTitle();
}

</t>
<t tx="leo1.20171224221229.49">void SolveSpaceUI::MenuAnalyze(Command id) {
    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::STEP_DIM:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;HasLabel() &amp;&amp; !c-&gt;reference) {
                    SS.TW.shown.dimFinish = c-&gt;valA;
                    SS.TW.shown.dimSteps = 10;
                    SS.TW.shown.dimIsDistance =
                        (c-&gt;type != Constraint::Type::ANGLE) &amp;&amp;
                        (c-&gt;type != Constraint::Type::LENGTH_RATIO) &amp;&amp;
                        (c-&gt;type != Constraint::Type::LENGTH_DIFFERENCE);
                    SS.TW.shown.constraint = c-&gt;h;
                    SS.TW.shown.screen = TextWindow::Screen::STEP_DIMENSION;

                    // The step params are specified in the text window,
                    // so force that to be shown.
                    SS.GW.ForceTextWindowShown();

                    SS.ScheduleShowTW();
                    SS.GW.ClearSelection();
                } else {
                    Error(_("Constraint must have a label, and must not be "
                            "a reference dimension."));
                }
            } else {
                Error(_("Bad selection for step dimension; select a constraint."));
            }
            break;

        case Command::NAKED_EDGES: {
            ShowNakedEdges(/*reportOnlyWhenNotOkay=*/false);
            break;
        }

        case Command::INTERFERENCE: {
            SS.nakedEdges.Clear();

            SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
            SKdNode *root = SKdNode::From(m);
            bool inters, leaks;
            root-&gt;MakeCertainEdgesInto(&amp;(SS.nakedEdges),
                EdgeKind::SELF_INTER, /*coplanarIsInter=*/false, &amp;inters, &amp;leaks);

            InvalidateGraphics();

            if(inters) {
                Error("%d edges interfere with other triangles, bad.",
                    SS.nakedEdges.l.n);
            } else {
                Message(_("The assembly does not interfere, good."));
            }
            break;
        }

        case Command::CENTER_OF_MASS: {
            SS.UpdateCenterOfMass();
            SS.centerOfMass.draw = true;
            InvalidateGraphics();
            break;
        }

        case Command::VOLUME: {
            SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);

            double vol = 0;
            int i;
            for(i = 0; i &lt; m-&gt;l.n; i++) {
                STriangle tr = m-&gt;l.elem[i];

                // Translate to place vertex A at (x, y, 0)
                Vector trans = Vector::From(tr.a.x, tr.a.y, 0);
                tr.a = (tr.a).Minus(trans);
                tr.b = (tr.b).Minus(trans);
                tr.c = (tr.c).Minus(trans);

                // Rotate to place vertex B on the y-axis. Depending on
                // whether the triangle is CW or CCW, C is either to the
                // right or to the left of the y-axis. This handles the
                // sign of our normal.
                Vector u = Vector::From(-tr.b.y, tr.b.x, 0);
                u = u.WithMagnitude(1);
                Vector v = Vector::From(tr.b.x, tr.b.y, 0);
                v = v.WithMagnitude(1);
                Vector n = Vector::From(0, 0, 1);

                tr.a = (tr.a).DotInToCsys(u, v, n);
                tr.b = (tr.b).DotInToCsys(u, v, n);
                tr.c = (tr.c).DotInToCsys(u, v, n);

                n = tr.Normal().WithMagnitude(1);

                // Triangles on edge don't contribute
                if(fabs(n.z) &lt; LENGTH_EPS) continue;

                // The plane has equation p dot n = a dot n
                double d = (tr.a).Dot(n);
                // nx*x + ny*y + nz*z = d
                // nz*z = d - nx*x - ny*y
                double A = -n.x/n.z, B = -n.y/n.z, C = d/n.z;

                double mac = tr.c.y/tr.c.x, mbc = (tr.c.y - tr.b.y)/tr.c.x;
                double xc = tr.c.x, yb = tr.b.y;

                // I asked Maple for
                //    int(int(A*x + B*y +C, y=mac*x..(mbc*x + yb)), x=0..xc);
                double integral =

            std::string msg = ssprintf("The volume of the solid model is:\n\n""    %.3f %s^3",
                vol / pow(SS.MmPerUnit(), 3),
                SS.UnitName());

            if(SS.viewUnits == Unit::MM) {
                msg += ssprintf("\n    %.2f mL", vol/(10*10*10));
            }
            msg += "\n\nCurved surfaces have been approximated as triangles.\n"
                   "This introduces error, typically of around 1%.";
            Message("%s", msg.c_str());
            break;
        }

        case Command::AREA: {
            Group *g = SK.GetGroup(SS.GW.activeGroup);
            if(g-&gt;polyError.how != PolyError::GOOD) {
                Error(_("This group does not contain a correctly-formed "
                        "2d closed area. It is open, not coplanar, or self-"
                        "intersecting."));
                break;
            }
            SEdgeList sel = {};
            g-&gt;polyLoops.MakeEdgesInto(&amp;sel);
            SPolygon sp = {};
            sel.AssemblePolygon(&amp;sp, NULL, /*keepDir=*/true);
            sp.normal = sp.ComputeNormal();
            sp.FixContourDirections();
            double area = sp.SignedArea();
            double scale = SS.MmPerUnit();
            Message("The area of the region sketched in this group is:\n\n"
                    "    %.3f %s^2\n\n"
                    "Curves have been approximated as piecewise linear.\n"
                    "This introduces error, typically of around 1%%.",
                area / (scale*scale),
                SS.UnitName());
            sel.Clear();
            sp.Clear();
            break;
        }

        case Command::PERIMETER: {
            if(gs.n &gt; 0 &amp;&amp; gs.n == gs.entities) {
                double perimeter = 0.0;
                for(int i = 0; i &lt; gs.entities; i++) {
                    Entity *e = SK.entity.FindById(gs.entity[i]);
                    SEdgeList *el = e-&gt;GetOrGenerateEdges();
                    for(const SEdge &amp;e : el-&gt;l) {
                        perimeter += e.b.Minus(e.a).Magnitude();
                    }
                }

                double scale = SS.MmPerUnit();
                Message("The total length of the selected entities is:\n\n"
                        "    %.3f %s\n\n"
                        "Curves have been approximated as piecewise linear.\n"
                        "This introduces error, typically of around 1%%.",
                    perimeter / scale,
                    SS.UnitName());
            } else {
                Error(_("Bad selection for perimeter; select line segments, arcs, and curves."));
            }
            break;
        }

        case Command::SHOW_DOF:
            // This works like a normal solve, except that it calculates
            // which variables are free/bound at the same time.
            SS.GenerateAll(SolveSpaceUI::Generate::ALL, /*andFindFree=*/true);
            break;

        case Command::TRACE_PT:
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                SS.traced.point = gs.point[0];
                SS.GW.ClearSelection();
            } else {
                Error(_("Bad selection for trace; select a single point."));
            }
            break;

        case Command::STOP_TRACING: {
            Platform::Path exportFile = SS.saveFile;
            if(GetSaveFile(&amp;exportFile, "", CsvFileFilter)) {
                FILE *f = OpenFile(exportFile, "wb");
                if(f) {
                    int i;
                    SContour *sc = &amp;(SS.traced.path);
                    for(i = 0; i &lt; sc-&gt;l.n; i++) {
                        Vector p = sc-&gt;l.elem[i].p;
                        double s = SS.exportScale;
                        fprintf(f, "%.10f, %.10f, %.10f\r\n",
                            p.x/s, p.y/s, p.z/s);
                    }
                    fclose(f);
                } else {
                    Error("Couldn't write to '%s'", exportFile.raw.c_str());
                }
            }
            // Clear the trace, and stop tracing
            SS.traced.point = Entity::NO_ENTITY;
            SS.traced.path.l.Clear();
            InvalidateGraphics();
            break;
        }

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo1.20171224221229.5">class PluralExpr {
public:
    @others
};

</t>
<t tx="leo1.20171224221229.50">void SolveSpaceUI::ShowNakedEdges(bool reportOnlyWhenNotOkay) {
    SS.nakedEdges.Clear();

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    SMesh *m = &amp;(g-&gt;displayMesh);
    SKdNode *root = SKdNode::From(m);
    bool inters, leaks;
    root-&gt;MakeCertainEdgesInto(&amp;(SS.nakedEdges),
        EdgeKind::NAKED_OR_SELF_INTER, /*coplanarIsInter=*/true, &amp;inters, &amp;leaks);

    if(reportOnlyWhenNotOkay &amp;&amp; !inters &amp;&amp; !leaks &amp;&amp; SS.nakedEdges.l.n == 0) {
        return;
    }
    InvalidateGraphics();

    const char *intersMsg = inters ?
        Message("%s\n\n%s\n\nZero problematic edges, good.%s",
            intersMsg, leaksMsg, cntMsg.c_str());
    } else {
        Error("%s\n\n%s\n\n%d problematic edges, bad.%s",
            intersMsg, leaksMsg, SS.nakedEdges.l.n, cntMsg.c_str());
    }
}

</t>
<t tx="leo1.20171224221229.51">void SolveSpaceUI::MenuHelp(Command id) {
    if((uint32_t)id &gt;= (uint32_t)Command::LOCALE &amp;&amp;
       (uint32_t)id &lt; ((uint32_t)Command::LOCALE + Locales().size())) {
        size_t offset = (uint32_t)id - (uint32_t)Command::LOCALE;
        size_t i = 0;
        for(auto locale : Locales()) {
            if(i++ == offset) {
                CnfFreezeString(locale.Culture(), "Locale");
                SetLocale(locale.Culture());
                break;
            }
        }
        return;
    }

    switch(id) {
        case Command::WEBSITE:
            OpenWebsite("http://solvespace.com/helpmenu");
            break;

        case Command::ABOUT:
            Message(
"This is SolveSpace version " PACKAGE_VERSION ".\n"
"\n"
"For more information, see http://solvespace.com/\n"
"\n"
"SolveSpace is free software: you are free to modify\n"
"and/or redistribute it under the terms of the GNU\n"
"General Public License (GPL) version 3 or later.\n"
"\n"
"There is NO WARRANTY, to the extent permitted by\n"
"law. For details, visit http://gnu.org/licenses/\n"
"\n"
" 2008-2016 Jonathan Westhues and other authors.\n"
);
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo1.20171224221229.52">void SolveSpaceUI::Clear() {
    sys.Clear();
    for(int i = 0; i &lt; MAX_UNDO; i++) {
        if(i &lt; undo.cnt) undo.d[i].Clear();
        if(i &lt; redo.cnt) redo.d[i].Clear();
    }
}

</t>
<t tx="leo1.20171224221229.53">void Sketch::Clear() {
    group.Clear();
    groupOrder.Clear();
    constraint.Clear();
    request.Clear();
    style.Clear();
    entity.Clear();
    param.Clear();
}

BBox Sketch::CalculateEntityBBox(bool includingInvisible) {
    BBox box = {};
    bool first = true;

</t>
<t tx="leo1.20171224221229.54">    auto includePoint = [&amp;](const Vector &amp;point) {
        if(first) {
            box.minp = point;
            box.maxp = point;
            first = false;
        } else {
            box.Include(point);
        }
    };

    for(const Entity &amp;e : entity) {
        if(e.construction) continue;
        if(!(includingInvisible || e.IsVisible())) continue;

        if(e.IsPoint()) {
            includePoint(e.PointGetNum());
            continue;
        }

        switch(e.type) {
            // Circles and arcs are special cases. We calculate their bounds
            // based on Bezier curve bounds. This is not exact for arcs,
            // but the implementation is rather simple.
            case Entity::Type::CIRCLE:
            case Entity::Type::ARC_OF_CIRCLE: {
                SBezierList sbl = {};
                e.GenerateBezierCurves(&amp;sbl);

                for(const SBezier &amp;sb : sbl.l) {
                    for(int j = 0; j &lt;= sb.deg; j++) {
                        includePoint(sb.ctrl[j]);
                    }
                }
                sbl.Clear();
                continue;
            }

            default:
                continue;
        }
    }

    return box;
}

Group *Sketch::GetRunningMeshGroupFor(hGroup h) {
    Group *g = GetGroup(h);
    while(g != NULL) {
        if(g-&gt;IsMeshGroup()) {
            return g;
        }
        g = g-&gt;PreviousGroup();
    }
    return NULL;
}
</t>
<t tx="leo1.20171224221229.55">//-----------------------------------------------------------------------------
// Implementation of a cosmetic line style, which determines the color and
// other appearance of a line or curve on-screen and in exported files. Some
// styles are predefined, and others can be created by the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221229.56">const Style::Default Style::Defaults[] = {
    { { ACTIVE_GRP },   "ActiveGrp",    RGBf(1.0, 1.0, 1.0), 1.5, 4 },
    { { CONSTRUCTION }, "Construction", RGBf(0.1, 0.7, 0.1), 1.5, 0 },
    { { INACTIVE_GRP }, "InactiveGrp",  RGBf(0.5, 0.3, 0.0), 1.5, 3 },
    { { DATUM },        "Datum",        RGBf(0.0, 0.8, 0.0), 1.5, 0 },
    { { SOLID_EDGE },   "SolidEdge",    RGBf(0.8, 0.8, 0.8), 1.0, 2 },
    { { CONSTRAINT },   "Constraint",   RGBf(1.0, 0.1, 1.0), 1.0, 0 },
    { { SELECTED },     "Selected",     RGBf(1.0, 0.0, 0.0), 1.5, 0 },
    { { HOVERED },      "Hovered",      RGBf(1.0, 1.0, 0.0), 1.5, 0 },
    { { CONTOUR_FILL }, "ContourFill",  RGBf(0.0, 0.1, 0.1), 1.0, 0 },
    { { NORMALS },      "Normals",      RGBf(0.0, 0.4, 0.4), 1.0, 0 },
    { { ANALYZE },      "Analyze",      RGBf(0.0, 1.0, 1.0), 3.0, 0 },
    { { DRAW_ERROR },   "DrawError",    RGBf(1.0, 0.0, 0.0), 8.0, 0 },
    { { DIM_SOLID },    "DimSolid",     RGBf(0.1, 0.1, 0.1), 1.0, 0 },
    { { HIDDEN_EDGE },  "HiddenEdge",   RGBf(0.8, 0.8, 0.8), 1.0, 1 },
    { { OUTLINE },      "Outline",      RGBf(0.8, 0.8, 0.8), 3.0, 5 },
    { { 0 },            NULL,           RGBf(0.0, 0.0, 0.0), 0.0, 0 }
};

std::string Style::CnfColor(const std::string &amp;prefix) {
    return "Style_" + prefix + "_Color";
}
std::string Style::CnfWidth(const std::string &amp;prefix) {
    return "Style_" + prefix + "_Width";
}
std::string Style::CnfTextHeight(const std::string &amp;prefix) {
    return "Style_" + prefix + "_TextHeight";
}

std::string Style::CnfPrefixToName(const std::string &amp;prefix) {
    std::string name = "#def-";

    for(size_t i = 0; i &lt; prefix.length(); i++) {
        if(isupper(prefix[i]) &amp;&amp; i != 0)
            name += '-';
        name += tolower(prefix[i]);
    }

    return name;
}

</t>
<t tx="leo1.20171224221229.57">void Style::CreateAllDefaultStyles() {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        (void)Get(d-&gt;h);
    }
}

</t>
<t tx="leo1.20171224221229.58">void Style::CreateDefaultStyle(hStyle h) {
    bool isDefaultStyle = true;
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        if(d-&gt;h.v == h.v) break;
    }
    if(!d-&gt;h.v) {
        // Not a default style; so just create it the same as our default
        // active group entity style.
        d = &amp;(Defaults[0]);
        isDefaultStyle = false;
    }

    Style ns = {};
    FillDefaultStyle(&amp;ns, d);
    ns.h = h;
    if(isDefaultStyle) {
        ns.name = CnfPrefixToName(d-&gt;cnfPrefix);
    } else {
        ns.name = "new-custom-style";
    }

    SK.style.Add(&amp;ns);
}

</t>
<t tx="leo1.20171224221229.59">void Style::FillDefaultStyle(Style *s, const Default *d, bool factory) {
    if(d == NULL) d = &amp;Defaults[0];
    s-&gt;color         = (factory) ? d-&gt;color : CnfThawColor(d-&gt;color, CnfColor(d-&gt;cnfPrefix));
    s-&gt;width         = (factory) ? d-&gt;width : CnfThawFloat((float)(d-&gt;width), CnfWidth(d-&gt;cnfPrefix));
    s-&gt;widthAs       = UnitsAs::PIXELS;
    s-&gt;textHeight    = (factory) ? 11.5
                                 : CnfThawFloat(11.5, CnfTextHeight(d-&gt;cnfPrefix));
    s-&gt;textHeightAs  = UnitsAs::PIXELS;
    s-&gt;textOrigin    = TextOrigin::NONE;
    s-&gt;textAngle     = 0;
    s-&gt;visible       = true;
    s-&gt;exportable    = true;
    s-&gt;filled        = false;
    s-&gt;fillColor     = RGBf(0.3, 0.3, 0.3);
    s-&gt;stippleType   = (d-&gt;h.v == Style::HIDDEN_EDGE) ? StipplePattern::DASH
                                                      : StipplePattern::CONTINUOUS;
    s-&gt;stippleScale  = 15.0;
    s-&gt;zIndex        = d-&gt;zIndex;
}

</t>
<t tx="leo1.20171224221229.6">class Token {
public:
    enum class Type {
        END,
        VALUE,
        BINARY_OP,
        QUERY,
        COLON,
        PAREN_LEFT,
        PAREN_RIGHT,
    };

    // Only valid for type == BINARY_OP.
    enum class Op {
        NONE,
        // comparison
        EQ,             // ==
        NEQ,            // !=
        LT,             // &lt;
        GT,             // &gt;
        LE,             // &lt;=
        GE,             // &gt;=
        // logical
        AND,            // &amp;&amp;
        OR,             // ||
        // arithmetic
        MOD,            // %
    };

    Type     type;
    Op       op;
    unsigned value;

    int Precedence();
};

ASCIIReader        reader;
std::vector&lt;Token&gt; stack;
unsigned           value;

Token Lex();

Token PopToken();
void Reduce();
void Eval();

static unsigned Eval(const std::string &amp;s, unsigned n);
</t>
<t tx="leo1.20171224221229.60">void Style::LoadFactoryDefaults() {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        Style *s = Get(d-&gt;h);
        FillDefaultStyle(s, d, /*factory=*/true);
    }
    SS.backgroundColor = RGBi(0, 0, 0);
}

</t>
<t tx="leo1.20171224221229.61">void Style::FreezeDefaultStyles() {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        CnfFreezeColor(Color(d-&gt;h), CnfColor(d-&gt;cnfPrefix));
        CnfFreezeFloat((float)Width(d-&gt;h), CnfWidth(d-&gt;cnfPrefix));
        CnfFreezeFloat((float)TextHeight(d-&gt;h), CnfTextHeight(d-&gt;cnfPrefix));
    }
}

uint32_t Style::CreateCustomStyle(bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();
    uint32_t vs = max((uint32_t)Style::FIRST_CUSTOM, SK.style.MaximumId() + 1);
    hStyle hs = { vs };
    (void)Style::Get(hs);
    return hs.v;
}

</t>
<t tx="leo1.20171224221229.62">void Style::AssignSelectionToStyle(uint32_t v) {
    bool showError = false;
    SS.GW.GroupSelection();

    SS.UndoRemember();
    int i;
    for(i = 0; i &lt; SS.GW.gs.entities; i++) {
        hEntity he = SS.GW.gs.entity[i];
        Entity *e = SK.GetEntity(he);
        if(!e-&gt;IsStylable()) continue;

        if(!he.isFromRequest()) {
            showError = true;
            continue;
        }

        hRequest hr = he.request();
        Request *r = SK.GetRequest(hr);
        r-&gt;style.v = v;
        SS.MarkGroupDirty(r-&gt;group);
    }
    for(i = 0; i &lt; SS.GW.gs.constraints; i++) {
        hConstraint hc = SS.GW.gs.constraint[i];
        Constraint *c = SK.GetConstraint(hc);
        if(!c-&gt;IsStylable()) continue;

        c-&gt;disp.style.v = v;
        SS.MarkGroupDirty(c-&gt;group);
    }

    if(showError) {
        Error(_("Can't assign style to an entity that's derived from another "
                "entity; try assigning a style to this entity's parent."));
    }

    SS.GW.ClearSelection();
    InvalidateGraphics();

    // And show that style's info screen in the text window.
    SS.TW.GoToScreen(TextWindow::Screen::STYLE_INFO);
    SS.TW.shown.style.v = v;
    SS.ScheduleShowTW();
}

//-----------------------------------------------------------------------------
// Look up a style by its handle. If that style does not exist, then create
// the style, according to our table of default styles.
//-----------------------------------------------------------------------------
Style *Style::Get(hStyle h) {
    if(h.v == 0) h.v = ACTIVE_GRP;

    Style *s = SK.style.FindByIdNoOops(h);
    if(s) {
        // It exists, good.
        return s;
    } else {
        // It doesn't exist; so we should create it and then return that.
        CreateDefaultStyle(h);
        return SK.style.FindById(h);
    }
}

//-----------------------------------------------------------------------------
// A couple of wrappers, so that I can call these functions with either an
// hStyle or with the integer corresponding to that hStyle.v.
//-----------------------------------------------------------------------------
RgbaColor Style::Color(int s, bool forExport) {
    hStyle hs = { (uint32_t)s };
    return Color(hs, forExport);
}
double Style::Width(int s) {
    hStyle hs = { (uint32_t)s };
    return Width(hs);
}

//-----------------------------------------------------------------------------
// If a color is almost white, then we can rewrite it to black, just so that
// it won't disappear on file formats with a light background.
//-----------------------------------------------------------------------------
RgbaColor Style::RewriteColor(RgbaColor rgbin) {
    Vector rgb = Vector::From(rgbin.redF(), rgbin.greenF(), rgbin.blueF());
    rgb = rgb.Minus(Vector::From(1, 1, 1));
    if(rgb.Magnitude() &lt; 0.4 &amp;&amp; SS.fixExportColors) {
        // This is an almost-white color in a default style, which is
        // good for the default on-screen view (black bg) but probably
        // not desired in the exported files, which typically are shown
        // against white backgrounds.
        return RGBi(0, 0, 0);
    } else {
        return rgbin;
    }
}

//-----------------------------------------------------------------------------
// Return the stroke color associated with our style as 8-bit RGB.
//-----------------------------------------------------------------------------
RgbaColor Style::Color(hStyle h, bool forExport) {
    Style *s = Get(h);
    if(forExport) {
        return RewriteColor(s-&gt;color);
    } else {
        return s-&gt;color;
    }
}

//-----------------------------------------------------------------------------
// Return the fill color associated with our style as 8-bit RGB.
//-----------------------------------------------------------------------------
RgbaColor Style::FillColor(hStyle h, bool forExport) {
    Style *s = Get(h);
    if(forExport) {
        return RewriteColor(s-&gt;fillColor);
    } else {
        return s-&gt;fillColor;
    }
}

//-----------------------------------------------------------------------------
// Return the width associated with our style in pixels..
//-----------------------------------------------------------------------------
double Style::Width(hStyle h) {
    Style *s = Get(h);
    switch(s-&gt;widthAs) {
        case UnitsAs::MM:     return s-&gt;width * SS.GW.scale;
        case UnitsAs::PIXELS: return s-&gt;width;
    }
    ssassert(false, "Unexpected units");
}

//-----------------------------------------------------------------------------
// Return the width associated with our style in millimeters..
//-----------------------------------------------------------------------------
double Style::WidthMm(int hs) {
    double widthpx = Width(hs);
    return widthpx / SS.GW.scale;
}

//-----------------------------------------------------------------------------
// Return the associated text height, in pixels.
//-----------------------------------------------------------------------------
double Style::TextHeight(hStyle h) {
    Style *s = Get(h);
    switch(s-&gt;textHeightAs) {
        case UnitsAs::MM:     return s-&gt;textHeight * SS.GW.scale;
        case UnitsAs::PIXELS: return s-&gt;textHeight;
    }
    ssassert(false, "Unexpected units");
}

double Style::DefaultTextHeight() {
    hStyle hs { Style::CONSTRAINT };
    return TextHeight(hs);
}

//-----------------------------------------------------------------------------
// Return the parameters of this style, as a canvas stroke.
//-----------------------------------------------------------------------------
Canvas::Stroke Style::Stroke(hStyle hs) {
    Canvas::Stroke stroke = {};
    Style *style = Style::Get(hs);
    stroke.color = style-&gt;color;
    stroke.stipplePattern = style-&gt;stippleType;
    stroke.stippleScale = style-&gt;stippleScale;
    stroke.width = style-&gt;width;
    switch(style-&gt;widthAs) {
        case Style::UnitsAs::PIXELS:
            stroke.unit = Canvas::Unit::PX;
            break;
        case Style::UnitsAs::MM:
            stroke.unit = Canvas::Unit::MM;
            break;
    }
    return stroke;
}

Canvas::Stroke Style::Stroke(int hsv) {
    hStyle hs = { (uint32_t) hsv };
    return Style::Stroke(hs);
}

//-----------------------------------------------------------------------------
// Should lines and curves from this style appear in the output file? Only
// if it's both shown and exportable.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.63">bool Style::Exportable(int si) {
    hStyle hs = { (uint32_t)si };
    Style *s = Get(hs);
    return (s-&gt;exportable) &amp;&amp; (s-&gt;visible);
}

//-----------------------------------------------------------------------------
// Return the appropriate style for our entity. If the entity has a style
// explicitly assigned, then it's that style. Otherwise it's the appropriate
// default style.
//-----------------------------------------------------------------------------
hStyle Style::ForEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    // If the entity has a special style, use that. If that style doesn't
    // exist yet, then it will get created automatically later.
    if(e-&gt;style.v != 0) {
        return e-&gt;style;
    }

    // Otherwise, we use the default rules.
    hStyle hs;
    if(e-&gt;group.v != SS.GW.activeGroup.v) {
        hs.v = INACTIVE_GRP;
    } else if(e-&gt;construction) {
        hs.v = CONSTRUCTION;
    } else {
        hs.v = ACTIVE_GRP;
    }
    return hs;
}

StipplePattern Style::PatternType(hStyle hs) {
    Style *s = Get(hs);
    return s-&gt;stippleType;
}

double Style::StippleScaleMm(hStyle hs) {
    Style *s = Get(hs);
    if(s-&gt;widthAs == UnitsAs::MM) {
        return s-&gt;stippleScale;
    } else if(s-&gt;widthAs == UnitsAs::PIXELS) {
        return s-&gt;stippleScale / SS.GW.scale;
    }
    return 1.0;
}

std::string Style::DescriptionString() const {
    if(name.empty()) {
        return ssprintf("s%03x-(unnamed)", h.v);
    } else {
        return ssprintf("s%03x-%s", h.v, name.c_str());
    }
}


</t>
<t tx="leo1.20171224221229.64">void TextWindow::ScreenShowListOfStyles(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
}
</t>
<t tx="leo1.20171224221229.65">void TextWindow::ScreenShowStyleInfo(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::STYLE_INFO);
    SS.TW.shown.style.v = v;
}

</t>
<t tx="leo1.20171224221229.66">void TextWindow::ScreenLoadFactoryDefaultStyles(int link, uint32_t v) {
    Style::LoadFactoryDefaults();
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
}

</t>
<t tx="leo1.20171224221229.67">void TextWindow::ScreenCreateCustomStyle(int link, uint32_t v) {
    Style::CreateCustomStyle();
}

</t>
<t tx="leo1.20171224221229.68">void TextWindow::ScreenChangeBackgroundColor(int link, uint32_t v) {
    RgbaColor rgb = SS.backgroundColor;
    SS.TW.ShowEditControlWithColorPicker(3, rgb);
    SS.TW.edit.meaning = Edit::BACKGROUND_COLOR;
}

</t>
<t tx="leo1.20171224221229.69">void TextWindow::ShowListOfStyles() {
    Printf(true, "%Ft color  style-name");

    bool darkbg = false;
    Style *s;
    for(s = SK.style.First(); s; s = SK.style.NextAfter(s)) {
        Printf(false, "%Bp  %Bz   %Bp   %Fl%Ll%f%D%s%E",
            darkbg ? 'd' : 'a',
            &amp;s-&gt;color,
            darkbg ? 'd' : 'a',
            ScreenShowStyleInfo, s-&gt;h.v,
            s-&gt;DescriptionString().c_str());

        darkbg = !darkbg;
    }

    Printf(true, "  %Fl%Ll%fcreate a new custom style%E",
        &amp;ScreenCreateCustomStyle);

    Printf(false, "");

    RgbaColor rgb = SS.backgroundColor;
    Printf(false, "%Ft background color (r, g, b)%E");
    Printf(false, "%Ba   %@, %@, %@ %Fl%D%f%Ll[change]%E",
        rgb.redF(), rgb.greenF(), rgb.blueF(),
        top[rows-1] + 2, &amp;ScreenChangeBackgroundColor);

    Printf(false, "");
    Printf(false, "  %Fl%Ll%fload factory defaults%E",
        &amp;ScreenLoadFactoryDefaultStyles);
}


</t>
<t tx="leo1.20171224221229.7">int PluralExpr::Token::Precedence() {
    switch(type) {
        case Type::BINARY_OP:
            switch(op) {
                case Op::MOD:
                    return 7;

                case Op::LT:
                case Op::GT:
                case Op::LE:
                case Op::GE:
                    return 6;

                case Op::EQ:
                case Op::NEQ:
                    return 5;

                case Op::AND:
                    return 4;

                case Op::OR:
                    return 3;

                case Op::NONE:
                    ssassert(false, "Unexpected operator");
            }

        case Type::QUERY:
        case Type::COLON:
            return 1;

        case Type::VALUE:
            return 0;

        default:
            ssassert(false, "Unexpected token op");
    }
}

PluralExpr::Token PluralExpr::Lex() {
    Token t = {};

    reader.SkipSpace();

    char c = reader.PeekChar();
    if(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        t.type  = Token::Type::VALUE;
        t.value = reader.ReadIntegerDecimal();
    } else if(reader.TryChar('n')) {
        t.type  = Token::Type::VALUE;
        t.value = value;
    } else if(reader.TryChar('%')) {
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::MOD;
    } else if(reader.TryChar('&lt;')) {
        t.type  = Token::Type::BINARY_OP;
        if(reader.TryChar('=')) {
            t.op = Token::Op::LE;
        } else {
            t.op = Token::Op::LT;
        }
    } else if(reader.TryChar('&gt;')) {
        t.type  = Token::Type::BINARY_OP;
        if(reader.TryChar('=')) {
            t.op = Token::Op::GE;
        } else {
            t.op = Token::Op::GT;
        }
    } else if(reader.TryChar('!')) {
        reader.ExpectChar('=');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::NEQ;
    } else if(reader.TryChar('=')) {
        reader.ExpectChar('=');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::EQ;
    } else if(reader.TryChar('&amp;')) {
        reader.ExpectChar('&amp;');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::AND;
    } else if(reader.TryChar('|')) {
        reader.ExpectChar('|');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::OR;
    } else if(reader.TryChar('?')) {
        t.type  = Token::Type::QUERY;
    } else if(reader.TryChar(':')) {
        t.type  = Token::Type::COLON;
    } else if(reader.TryChar('(')) {
        t.type  = Token::Type::PAREN_LEFT;
    } else if(reader.TryChar(')')) {
        t.type  = Token::Type::PAREN_RIGHT;
    } else if(reader.AtEnd()) {
        t.type  = Token::Type::END;
    } else {
        ssassert(false, "Unexpected character");
    }

    return t;
}

PluralExpr::Token PluralExpr::PopToken() {
    ssassert(stack.size() &gt; 0, "Expected a non-empty stack");
    Token t = stack.back();
    stack.pop_back();
    return t;
}

</t>
<t tx="leo1.20171224221229.70">void TextWindow::ScreenChangeStyleName(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    SS.TW.ShowEditControl(12, s-&gt;name);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = Edit::STYLE_NAME;
}

</t>
<t tx="leo1.20171224221229.71">void TextWindow::ScreenDeleteStyle(int link, uint32_t v) {
    SS.UndoRemember();
    hStyle hs = { v };
    Style *s = SK.style.FindByIdNoOops(hs);
    if(s) {
        SK.style.RemoveById(hs);
        // And it will get recreated automatically if something is still using
        // the style, so no need to do anything else.
    }
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221229.72">void TextWindow::ScreenChangeStylePatternType(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    s-&gt;stippleType = (StipplePattern)(link - 1);
    SS.GW.persistentDirty = true;
}

</t>
<t tx="leo1.20171224221229.73">void TextWindow::ScreenChangeStyleMetric(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    double val;
    Style::UnitsAs units;
    Edit meaning;
    int col;
    switch(link) {
        case 't':
            val = s-&gt;textHeight;
            units = s-&gt;textHeightAs;
            col = 10;
            meaning = Edit::STYLE_TEXT_HEIGHT;
            break;

        case 's':
            val = s-&gt;stippleScale;
            units = s-&gt;widthAs;
            col = 17;
            meaning = Edit::STYLE_STIPPLE_PERIOD;
            break;

        case 'w':
        case 'W':
            val = s-&gt;width;
            units = s-&gt;widthAs;
            col = 9;
            meaning = Edit::STYLE_WIDTH;
            break;

        default: ssassert(false, "Unexpected link");
    }

    std::string edit_value;
    if(units == Style::UnitsAs::PIXELS) {
        edit_value = ssprintf("%.2f", val);
    } else {
        edit_value = SS.MmToString(val);
    }
    SS.TW.ShowEditControl(col, edit_value);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = meaning;
}

</t>
<t tx="leo1.20171224221229.74">void TextWindow::ScreenChangeStyleTextAngle(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    SS.TW.ShowEditControl(9, ssprintf("%.2f", s-&gt;textAngle));
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = Edit::STYLE_TEXT_ANGLE;
}

</t>
<t tx="leo1.20171224221229.75">void TextWindow::ScreenChangeStyleColor(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    // Same function used for stroke and fill colors
    Edit em;
    RgbaColor rgb;
    if(link == 's') {
        em = Edit::STYLE_COLOR;
        rgb = s-&gt;color;
    } else if(link == 'f') {
        em = Edit::STYLE_FILL_COLOR;
        rgb = s-&gt;fillColor;
    } else ssassert(false, "Unexpected link");
    SS.TW.ShowEditControlWithColorPicker(13, rgb);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = em;
}

</t>
<t tx="leo1.20171224221229.76">void TextWindow::ScreenChangeStyleYesNo(int link, uint32_t v) {
    SS.UndoRemember();
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    switch(link) {
        // Units for the width
        case 'w':
            if(s-&gt;widthAs != Style::UnitsAs::MM) {
                s-&gt;widthAs = Style::UnitsAs::MM;
                s-&gt;width /= SS.GW.scale;
                s-&gt;stippleScale /= SS.GW.scale;
            }
            break;
        case 'W':
            if(s-&gt;widthAs != Style::UnitsAs::PIXELS) {
                s-&gt;widthAs = Style::UnitsAs::PIXELS;
                s-&gt;width *= SS.GW.scale;
                s-&gt;stippleScale *= SS.GW.scale;
            }
            break;

        // Units for the height
        case 'g':
            if(s-&gt;textHeightAs != Style::UnitsAs::MM) {
                s-&gt;textHeightAs = Style::UnitsAs::MM;
                s-&gt;textHeight /= SS.GW.scale;
            }
            break;

        case 'G':
            if(s-&gt;textHeightAs != Style::UnitsAs::PIXELS) {
                s-&gt;textHeightAs = Style::UnitsAs::PIXELS;
                s-&gt;textHeight *= SS.GW.scale;
            }
            break;

        case 'e':
            s-&gt;exportable = !(s-&gt;exportable);
            break;

        case 'v':
            s-&gt;visible = !(s-&gt;visible);
            break;

        case 'f':
            s-&gt;filled = !(s-&gt;filled);
            break;

        // Horizontal text alignment
        case 'L':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::RIGHT);
            break;
        case 'H':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::RIGHT);
            break;
        case 'R':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::RIGHT);
            break;

        // Vertical text alignment
        case 'B':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::TOP);
            break;
        case 'V':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::TOP);
            break;
        case 'T':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::TOP);
            break;
    }
    SS.GW.persistentDirty = true;
    InvalidateGraphics();
}

</t>
<t tx="leo1.20171224221229.77">bool TextWindow::EditControlDoneForStyles(const char *str) {
    Style *s;
    switch(edit.meaning) {
        case Edit::STYLE_STIPPLE_PERIOD:
        case Edit::STYLE_TEXT_HEIGHT:
        case Edit::STYLE_WIDTH: {
            SS.UndoRemember();
            s = Style::Get(edit.style);

            double v;
            Style::UnitsAs units = (edit.meaning == Edit::STYLE_TEXT_HEIGHT) ?
                            s-&gt;textHeightAs : s-&gt;widthAs;
            if(units == Style::UnitsAs::MM) {
                v = SS.StringToMm(str);
            } else {
                v = atof(str);
            }
            v = max(0.0, v);
            if(edit.meaning == Edit::STYLE_TEXT_HEIGHT) {
                s-&gt;textHeight = v;
            } else if(edit.meaning == Edit::STYLE_STIPPLE_PERIOD) {
                s-&gt;stippleScale = v;
            } else {
                s-&gt;width = v;
            }
            break;
        }
        case Edit::STYLE_TEXT_ANGLE:
            SS.UndoRemember();
            s = Style::Get(edit.style);
            s-&gt;textAngle = WRAP_SYMMETRIC(atof(str), 360);
            break;

        case Edit::BACKGROUND_COLOR:
        case Edit::STYLE_FILL_COLOR:
        case Edit::STYLE_COLOR: {
            Vector rgb;
            if(sscanf(str, "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);
                if(edit.meaning == Edit::STYLE_COLOR) {
                    SS.UndoRemember();
                    s = Style::Get(edit.style);
                    s-&gt;color = RGBf(rgb.x, rgb.y, rgb.z);
                } else if(edit.meaning == Edit::STYLE_FILL_COLOR) {
                    SS.UndoRemember();
                    s = Style::Get(edit.style);
                    s-&gt;fillColor = RGBf(rgb.x, rgb.y, rgb.z);
                } else {
                    SS.backgroundColor = RGBf(rgb.x, rgb.y, rgb.z);
                }
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::STYLE_NAME:
            if(!*str) {
                Error(_("Style name cannot be empty"));
            } else {
                SS.UndoRemember();
                s = Style::Get(edit.style);
                s-&gt;name = str;
            }
            break;

        default: return false;
    }
    SS.GW.persistentDirty = true;
    return true;
}

</t>
<t tx="leo1.20171224221229.78">void TextWindow::ShowStyleInfo() {
    Printf(true, "%Fl%f%Ll(back to list of styles)%E", &amp;ScreenShowListOfStyles);

    Style *s = Style::Get(shown.style);

    if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
        Printf(true, "%FtSTYLE  %E%s ", s-&gt;DescriptionString().c_str());
    } else {
        Printf(true, "%FtSTYLE  %E%s "
                     "[%Fl%Ll%D%frename%E/%Fl%Ll%D%fdel%E]",
            s-&gt;DescriptionString().c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleName,
            s-&gt;h.v, &amp;ScreenDeleteStyle);
    }
    Printf(true, "%Ft line stroke style%E");
    Printf(false, "%Ba   %Ftcolor %E%Bz  %Ba (%@, %@, %@) %D%f%Ls%Fl[change]%E",
        &amp;s-&gt;color,
        s-&gt;color.redF(), s-&gt;color.greenF(), s-&gt;color.blueF(),
        s-&gt;h.v, ScreenChangeStyleColor);

    // The line width, and its units
    if(s-&gt;widthAs == Style::UnitsAs::PIXELS) {
        Printf(false, "   %Ftwidth%E %@ %D%f%Lp%Fl[change]%E",
            s-&gt;width,
            s-&gt;h.v, &amp;ScreenChangeStyleMetric,
            (s-&gt;h.v &lt; Style::FIRST_CUSTOM) ? 'w' : 'W');
    } else {
        Printf(false, "   %Ftwidth%E %s %D%f%Lp%Fl[change]%E",
            SS.MmToString(s-&gt;width).c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleMetric,
            (s-&gt;h.v &lt; Style::FIRST_CUSTOM) ? 'w' : 'W');
    }

    if(s-&gt;widthAs == Style::UnitsAs::PIXELS) {
        Printf(false, "%Ba   %Ftstipple width%E %@ %D%f%Lp%Fl[change]%E",
            s-&gt;stippleScale,
            s-&gt;h.v, &amp;ScreenChangeStyleMetric, 's');
    } else {
        Printf(false, "%Ba   %Ftstipple width%E %s %D%f%Lp%Fl[change]%E",
            SS.MmToString(s-&gt;stippleScale).c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleMetric, 's');
    }

    bool widthpx = (s-&gt;widthAs == Style::UnitsAs::PIXELS);
    if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
        Printf(false,"   %Ftin units of %Fdpixels%E");
    } else {
        Printf(false,"%Ba   %Ftin units of  %Fd"
                            "%D%f%LW%s pixels%E  "
                            "%D%f%Lw%s %s",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            widthpx ? RADIO_TRUE : RADIO_FALSE,
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            !widthpx ? RADIO_TRUE : RADIO_FALSE,
            SS.UnitName());
    }

    Printf(false,"%Ba   %Ftstipple type:%E");

    const size_t patternCount = (size_t)StipplePattern::LAST + 1;
    @others
}

</t>
<t tx="leo1.20171224221229.79">const char *patternsSource[patternCount] = {
    "___________",
    "-  -  -  - ",
    "- - - - - -",
    "__ __ __ __",
    "-.-.-.-.-.-",
    "..-..-..-..",
    "...........",
    "~~~~~~~~~~~",
    "__~__~__~__"
};
std::string patterns[patternCount];

for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
    const char *str = patternsSource[i];
    do {
        switch(*str) {
            case ' ': patterns[i] += " "; break;
            case '.': patterns[i] += "\xEE\x80\x84"; break;
            case '_': patterns[i] += "\xEE\x80\x85"; break;
            case '-': patterns[i] += "\xEE\x80\x86"; break;
            case '~': patterns[i] += "\xEE\x80\x87"; break;
            default: ssassert(false, "Unexpected stipple pattern element");
        }
    } while(*(++str));
}

for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
    const char *radio = s-&gt;stippleType == (StipplePattern)i ? RADIO_TRUE : RADIO_FALSE;
    Printf(false, "%Bp     %D%f%Lp%s %s%E",
        (i % 2 == 0) ? 'd' : 'a',
        s-&gt;h.v, &amp;ScreenChangeStylePatternType,
        i + 1, radio, patterns[i].c_str());
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    // The fill color, and whether contours are filled

    Printf(false, "");
    Printf(false, "%Ft contour fill style%E");
    Printf(false,
        "%Ba   %Ftcolor %E%Bz  %Ba (%@, %@, %@) %D%f%Lf%Fl[change]%E",
        &amp;s-&gt;fillColor,
        s-&gt;fillColor.redF(), s-&gt;fillColor.greenF(), s-&gt;fillColor.blueF(),
        s-&gt;h.v, ScreenChangeStyleColor);

    Printf(false, "%Bd   %D%f%Lf%s  contours are filled%E",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        s-&gt;filled ? CHECK_TRUE : CHECK_FALSE);
}

// The text height, and its units
Printf(false, "");
Printf(false, "%Ft text style%E");

if(s-&gt;textHeightAs == Style::UnitsAs::PIXELS) {
    Printf(false, "%Ba   %Ftheight %E%@ %D%f%Lt%Fl%s%E",
        s-&gt;textHeight,
        s-&gt;h.v, &amp;ScreenChangeStyleMetric,
        "[change]");
} else {
    Printf(false, "%Ba   %Ftheight %E%s %D%f%Lt%Fl%s%E",
        SS.MmToString(s-&gt;textHeight).c_str(),
        s-&gt;h.v, &amp;ScreenChangeStyleMetric,
        "[change]");
}

bool textHeightpx = (s-&gt;textHeightAs == Style::UnitsAs::PIXELS);
if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
    Printf(false,"%Bd   %Ftin units of %Fdpixels");
} else {
    Printf(false,"%Bd   %Ftin units of  %Fd"
                        "%D%f%LG%s pixels%E  "
                        "%D%f%Lg%s %s",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        textHeightpx ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        !textHeightpx ? RADIO_TRUE : RADIO_FALSE,
        SS.UnitName());
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    Printf(false, "%Ba   %Ftangle %E%@ %D%f%Ll%Fl[change]%E",
        s-&gt;textAngle,
        s-&gt;h.v, &amp;ScreenChangeStyleTextAngle);

    Printf(false, "");
    Printf(false, "%Ft text comment alignment%E");
    bool neither;
    neither = !((uint32_t)s-&gt;textOrigin &amp; ((uint32_t)Style::TextOrigin::LEFT | (uint32_t)Style::TextOrigin::RIGHT));
    Printf(false, "%Ba   "
                  "%D%f%LL%s left%E    "
                  "%D%f%LH%s center%E  "
                  "%D%f%LR%s right%E  ",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::LEFT) ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        neither ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::RIGHT) ? RADIO_TRUE : RADIO_FALSE);

    neither = !((uint32_t)s-&gt;textOrigin &amp; ((uint32_t)Style::TextOrigin::BOT | (uint32_t)Style::TextOrigin::TOP));
    Printf(false, "%Bd   "
                  "%D%f%LB%s bottom%E  "
                  "%D%f%LV%s center%E  "
                  "%D%f%LT%s top%E  ",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::BOT) ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        neither ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::TOP) ? RADIO_TRUE : RADIO_FALSE);
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    Printf(false, "");

    Printf(false, "  %Fd%D%f%Lv%s  show these objects on screen%E",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            s-&gt;visible ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "  %Fd%D%f%Le%s  export these objects%E",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            s-&gt;exportable ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "To assign lines or curves to this style,");
    Printf(false, "right-click them on the drawing.");
}
</t>
<t tx="leo1.20171224221229.8">void PluralExpr::Reduce() {
    Token r;
    r.type = Token::Type::VALUE;

    Token a  = PopToken();
    ssassert(a.type == Token::Type::VALUE, "Expected 1st operand to be a value");

    Token op = PopToken();
    switch(op.type) {
        case Token::Type::BINARY_OP: {
            Token b = PopToken();
            ssassert(b.type == Token::Type::VALUE, "Expected 2nd operand to be a value");

            switch(op.op) {
                case Token::Op::EQ:
                    r.value = (a.value == b.value ? 1 : 0);
                    break;
                case Token::Op::NEQ:
                    r.value = (a.value != b.value ? 1 : 0);
                    break;
                case Token::Op::LT:
                    r.value = (b.value &lt;  a.value ? 1 : 0);
                    break;
                case Token::Op::GT:
                    r.value = (b.value &gt;  a.value ? 1 : 0);
                    break;
                case Token::Op::LE:
                    r.value = (b.value &lt;= a.value ? 1 : 0);
                    break;
                case Token::Op::GE:
                    r.value = (b.value &gt;= a.value ? 1 : 0);
                    break;
                case Token::Op::AND:
                    r.value = a.value &amp;&amp; b.value;
                    break;
                case Token::Op::OR:
                    r.value = a.value || b.value;
                    break;
                case Token::Op::MOD:
                    r.value = b.value %  a.value;
                    break;
                case Token::Op::NONE:
                    ssassert(false, "Unexpected operator");
            }
            break;
        }

        case Token::Type::COLON: {
            Token b = PopToken();
            ssassert(PopToken().type == Token::Type::QUERY, "Expected ?");
            Token c = PopToken();
            r.value = c.value ? b.value : a.value;
            break;
        }

        default:
            ssassert(false, "Unexpected operator type");
    }

    stack.push_back(r);
}

</t>
<t tx="leo1.20171224221229.80">void TextWindow::ScreenAssignSelectionToStyle(int link, uint32_t v) {
    Style::AssignSelectionToStyle(v);
}
</t>
<t tx="leo1.20171224221229.81">//-----------------------------------------------------------------------------
// Once we've written our constraint equations in the symbolic algebra system,
// these routines linearize them, and solve by a modified Newton's method.
// This also contains the routines to detect non-convergence or inconsistency,
// and report diagnostics to the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// This tolerance is used to determine whether two (linearized) constraints
// are linearly dependent. If this is too small, then we will attempt to
// solve truly inconsistent systems and fail. But if it's too large, then
// we will give up on legitimate systems like a skinny right angle triangle by
// its hypotenuse and long side.
const double System::RANK_MAG_TOLERANCE = 1e-4;

// The solver will converge all unknowns to within this tolerance. This must
// always be much less than LENGTH_EPS, and in practice should be much less.
const double System::CONVERGE_TOLERANCE = (LENGTH_EPS/(1e2));

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221229.82">bool System::WriteJacobian(int tag) {
    int a, i, j;

    j = 0;
    for(a = 0; a &lt; param.n; a++) {
        if(j &gt;= MAX_UNKNOWNS) return false;

        Param *p = &amp;(param.elem[a]);
        if(p-&gt;tag != tag) continue;
        mat.param[j] = p-&gt;h;
        j++;
    }
    mat.n = j;

    i = 0;
    for(a = 0; a &lt; eq.n; a++) {
        if(i &gt;= MAX_UNKNOWNS) return false;

        Equation *e = &amp;(eq.elem[a]);
        if(e-&gt;tag != tag) continue;

        mat.eq[i] = e-&gt;h;
        Expr *f = e-&gt;e-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
        f = f-&gt;FoldConstants();

        // Hash table (61 bits) to accelerate generation of zero partials.
        uint64_t scoreboard = f-&gt;ParamsUsed();
        for(j = 0; j &lt; mat.n; j++) {
            Expr *pd;
            if(scoreboard &amp; ((uint64_t)1 &lt;&lt; (mat.param[j].v % 61)) &amp;&amp;
                f-&gt;DependsOn(mat.param[j]))
            {
                pd = f-&gt;PartialWrt(mat.param[j]);
                pd = pd-&gt;FoldConstants();
                pd = pd-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
            } else {
                pd = Expr::From(0.0);
            }
            mat.A.sym[i][j] = pd;
        }
        mat.B.sym[i] = f;
        i++;
    }
    mat.m = i;

    return true;
}

</t>
<t tx="leo1.20171224221229.83">void System::EvalJacobian() {
    int i, j;
    for(i = 0; i &lt; mat.m; i++) {
        for(j = 0; j &lt; mat.n; j++) {
            mat.A.num[i][j] = (mat.A.sym[i][j])-&gt;Eval();
        }
    }
}

</t>
<t tx="leo1.20171224221229.84">bool System::IsDragged(hParam p) {
    hParam *pp;
    for(pp = dragged.First(); pp; pp = dragged.NextAfter(pp)) {
        if(p.v == pp-&gt;v) return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221229.85">void System::SolveBySubstitution() {
    int i;
    for(i = 0; i &lt; eq.n; i++) {
        Equation *teq = &amp;(eq.elem[i]);
        Expr *tex = teq-&gt;e;

        if(tex-&gt;op    == Expr::Op::MINUS &amp;&amp;
           tex-&gt;a-&gt;op == Expr::Op::PARAM &amp;&amp;
           tex-&gt;b-&gt;op == Expr::Op::PARAM)
        {
            hParam a = tex-&gt;a-&gt;parh;
            hParam b = tex-&gt;b-&gt;parh;
            if(!(param.FindByIdNoOops(a) &amp;&amp; param.FindByIdNoOops(b))) {
                // Don't substitute unless they're both solver params;
                // otherwise it's an equation that can be solved immediately,
                // or an error to flag later.
                continue;
            }

            if(IsDragged(a)) {
                // A is being dragged, so A should stay, and B should go
                hParam t = a;
                a = b;
                b = t;
            }

            int j;
            for(j = 0; j &lt; eq.n; j++) {
                Equation *req = &amp;(eq.elem[j]);
                (req-&gt;e)-&gt;Substitute(a, b); // A becomes B, B unchanged
            }
            for(j = 0; j &lt; param.n; j++) {
                Param *rp = &amp;(param.elem[j]);
                if(rp-&gt;substd.v == a.v) {
                    rp-&gt;substd = b;
                }
            }
            Param *ptr = param.FindById(a);
            ptr-&gt;tag = VAR_SUBSTITUTED;
            ptr-&gt;substd = b;

            teq-&gt;tag = EQ_SUBSTITUTED;
        }
    }
}

//-----------------------------------------------------------------------------
// Calculate the rank of the Jacobian matrix, by Gram-Schimdt orthogonalization
// in place. A row (~equation) is considered to be all zeros if its magnitude
// is less than the tolerance RANK_MAG_TOLERANCE.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221229.86">int System::CalculateRank() {
    // Actually work with magnitudes squared, not the magnitudes
    double rowMag[MAX_UNKNOWNS] = {};
    double tol = RANK_MAG_TOLERANCE*RANK_MAG_TOLERANCE;

    int i, iprev, j;
    int rank = 0;

    for(i = 0; i &lt; mat.m; i++) {
        // Subtract off this row's component in the direction of any
        // previous rows
        for(iprev = 0; iprev &lt; i; iprev++) {
            if(rowMag[iprev] &lt;= tol) continue; // ignore zero rows

            double dot = 0;
            for(j = 0; j &lt; mat.n; j++) {
                dot += (mat.A.num[iprev][j]) * (mat.A.num[i][j]);
            }
            for(j = 0; j &lt; mat.n; j++) {
                mat.A.num[i][j] -= (dot/rowMag[iprev])*mat.A.num[iprev][j];
            }
        }
        // Our row is now normal to all previous rows; calculate the
        // magnitude of what's left
        double mag = 0;
        for(j = 0; j &lt; mat.n; j++) {
            mag += (mat.A.num[i][j]) * (mat.A.num[i][j]);
        }
        if(mag &gt; tol) {
            rank++;
        }
        rowMag[i] = mag;
    }

    return rank;
}

</t>
<t tx="leo1.20171224221229.87">bool System::TestRank() {
    EvalJacobian();
    return CalculateRank() == mat.m;
}

</t>
<t tx="leo1.20171224221229.88">bool System::SolveLinearSystem(double X[], double A[][MAX_UNKNOWNS],
                               double B[], int n)
{
    // Gaussian elimination, with partial pivoting. It's an error if the
    // matrix is singular, because that means two constraints are
    // equivalent.
    int i, j, ip, jp, imax = 0;
    double max, temp;

    for(i = 0; i &lt; n; i++) {
        // We are trying eliminate the term in column i, for rows i+1 and
        // greater. First, find a pivot (between rows i and N-1).
        max = 0;
        for(ip = i; ip &lt; n; ip++) {
            if(ffabs(A[ip][i]) &gt; max) {
                imax = ip;
                max = ffabs(A[ip][i]);
            }
        }
        // Don't give up on a singular matrix unless it's really bad; the
        // assumption code is responsible for identifying that condition,
        // so we're not responsible for reporting that error.
        if(ffabs(max) &lt; 1e-20) continue;

        // Swap row imax with row i
        for(jp = 0; jp &lt; n; jp++) {
            swap(A[i][jp], A[imax][jp]);
        }
        swap(B[i], B[imax]);

        // For rows i+1 and greater, eliminate the term in column i.
        for(ip = i+1; ip &lt; n; ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; n; jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            B[ip] -= temp*B[i];
        }
    }

    // We've put the matrix in upper triangular form, so at this point we
    // can solve by back-substitution.
    for(i = n - 1; i &gt;= 0; i--) {
        if(ffabs(A[i][i]) &lt; 1e-20) continue;

        temp = B[i];
        for(j = n - 1; j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }

    return true;
}

</t>
<t tx="leo1.20171224221229.89">bool System::SolveLeastSquares() {
    int r, c, i;

    // Scale the columns; this scale weights the parameters for the least
    // squares solve, so that we can encourage the solver to make bigger
    // changes in some parameters, and smaller in others.
    for(c = 0; c &lt; mat.n; c++) {
        if(IsDragged(mat.param[c])) {
            // It's least squares, so this parameter doesn't need to be all
            // that big to get a large effect.
            mat.scale[c] = 1/20.0;
        } else {
            mat.scale[c] = 1;
        }
        for(r = 0; r &lt; mat.m; r++) {
            mat.A.num[r][c] *= mat.scale[c];
        }
    }

    // Write A*A'
    for(r = 0; r &lt; mat.m; r++) {
        for(c = 0; c &lt; mat.m; c++) {  // yes, AAt is square
            double sum = 0;
            for(i = 0; i &lt; mat.n; i++) {
                sum += mat.A.num[r][i]*mat.A.num[c][i];
            }
            mat.AAt[r][c] = sum;
        }
    }

    if(!SolveLinearSystem(mat.Z, mat.AAt, mat.B.num, mat.m)) return false;

    // And multiply that by A' to get our solution.
    for(c = 0; c &lt; mat.n; c++) {
        double sum = 0;
        for(i = 0; i &lt; mat.m; i++) {
            sum += mat.A.num[i][c]*mat.Z[i];
        }
        mat.X[c] = sum * mat.scale[c];
    }
    return true;
}

</t>
<t tx="leo1.20171224221229.9">void PluralExpr::Eval() {
    while(true) {
        Token t = Lex();
        switch(t.type) {
            case Token::Type::END:
            case Token::Type::PAREN_RIGHT:
                while(stack.size() &gt; 1 &amp;&amp;
                      stack.end()[-2].type != Token::Type::PAREN_LEFT) {
                    Reduce();
                }
                if(t.type == Token::Type::PAREN_RIGHT) {
                    ssassert(stack.size() &gt; 1, "Expected (");
                    stack.push_back(t);
                }
                return;

            case Token::Type::PAREN_LEFT:
                stack.push_back(t);
                Eval();
                if(stack.back().type != Token::Type::PAREN_RIGHT) {
                    ssassert(false, "Expected )");
                }
                stack.pop_back();
                stack.erase(stack.end() - 2);
                break;

            case Token::Type::VALUE:
                stack.push_back(t);
                break;

            case Token::Type::BINARY_OP:
            case Token::Type::QUERY:
            case Token::Type::COLON:
                while(stack.size() &gt; 1 &amp;&amp;
                      stack.end()[-2].type != Token::Type::PAREN_LEFT &amp;&amp;
                      t.Precedence() &lt; stack.end()[-2].Precedence()) {
                    Reduce();
                }
                stack.push_back(t);
                break;
        }
    }
}

</t>
<t tx="leo1.20171224221229.90">bool System::NewtonSolve(int tag) {

    int iter = 0;
    bool converged = false;
    int i;

    // Evaluate the functions at our operating point.
    for(i = 0; i &lt; mat.m; i++) {
        mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
    }
    do {
        // And evaluate the Jacobian at our initial operating point.
        EvalJacobian();

        if(!SolveLeastSquares()) break;

        // Take the Newton step;
        //      J(x_n) (x_{n+1} - x_n) = 0 - F(x_n)
        for(i = 0; i &lt; mat.n; i++) {
            Param *p = param.FindById(mat.param[i]);
            p-&gt;val -= mat.X[i];
            if(isnan(p-&gt;val)) {
                // Very bad, and clearly not convergent
                return false;
            }
        }

        // Re-evalute the functions, since the params have just changed.
        for(i = 0; i &lt; mat.m; i++) {
            mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
        }
        // Check for convergence
        converged = true;
        for(i = 0; i &lt; mat.m; i++) {
            if(isnan(mat.B.num[i])) {
                return false;
            }
            if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE) {
                converged = false;
                break;
            }
        }
    } while(iter++ &lt; 50 &amp;&amp; !converged);

    return converged;
}

</t>
<t tx="leo1.20171224221229.91">void System::WriteEquationsExceptFor(hConstraint hc, Group *g) {
    int i;
    // Generate all the equations from constraints in this group
    for(i = 0; i &lt; SK.constraint.n; i++) {
        ConstraintBase *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;group.v != g-&gt;h.v) continue;
        if(c-&gt;h.v == hc.v) continue;

        if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Constraint::Type::COMMENT &amp;&amp;
                g-&gt;allDimsReference)
        {
            // When all dimensions are reference, we adjust them to display
            // the correct value, and then don't generate any equations.
            c-&gt;ModifyToSatisfy();
            continue;
        }
        if(g-&gt;relaxConstraints &amp;&amp; c-&gt;type != Constraint::Type::POINTS_COINCIDENT) {
            // When the constraints are relaxed, we keep only the point-
            // coincident constraints, and the constraints generated by
            // the entities and groups.
            continue;
        }

        c-&gt;GenerateEquations(&amp;eq);
    }
    // And the equations from entities
    for(i = 0; i &lt; SK.entity.n; i++) {
        EntityBase *e = &amp;(SK.entity.elem[i]);
        if(e-&gt;group.v != g-&gt;h.v) continue;

        e-&gt;GenerateEquations(&amp;eq);
    }
    // And from the groups themselves
    g-&gt;GenerateEquations(&amp;eq);
}

</t>
<t tx="leo1.20171224221229.92">void System::FindWhichToRemoveToFixJacobian(Group *g, List&lt;hConstraint&gt; *bad, bool forceDofCheck) {
    int a, i;

    for(a = 0; a &lt; 2; a++) {
        for(i = 0; i &lt; SK.constraint.n; i++) {
            ConstraintBase *c = &amp;(SK.constraint.elem[i]);
            if(c-&gt;group.v != g-&gt;h.v) continue;
            if((c-&gt;type == Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 0) ||
               (c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 1))
            {
                // Do the constraints in two passes: first everything but
                // the point-coincident constraints, then only those
                // constraints (so they appear last in the list).
                continue;
            }

            param.ClearTags();
            eq.Clear();
            WriteEquationsExceptFor(c-&gt;h, g);
            eq.ClearTags();

            // It's a major speedup to solve the easy ones by substitution here,
            // and that doesn't break anything.
            if(!forceDofCheck) {
                SolveBySubstitution();
            }

            WriteJacobian(0);
            EvalJacobian();

            int rank = CalculateRank();
            if(rank == mat.m) {
                // We fixed it by removing this constraint
                bad-&gt;Add(&amp;(c-&gt;h));
            }
        }
    }
}

SolveResult System::Solve(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo1.20171224221229.93">                          bool andFindBad, bool andFindFree, bool forceDofCheck)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    int i;
    bool rankOk;

/*
    dbp("%d equations", eq.n);
    for(i = 0; i &lt; eq.n; i++) {
        dbp("  %.3f = %s = 0", eq.elem[i].e-&gt;Eval(), eq.elem[i].e-&gt;Print());
    }
    dbp("%d parameters", param.n);
    for(i = 0; i &lt; param.n; i++) {
        dbp("   param %08x at %.3f", param.elem[i].h.v, param.elem[i].val);
    } */

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    if(!forceDofCheck) {
        SolveBySubstitution();
    }

    // Before solving the big system, see if we can find any equations that
    // are soluble alone. This can be a huge speedup. We don't know whether
    // the system is consistent yet, but if it isn't then we'll catch that
    // later.
    int alone = 1;
    for(i = 0; i &lt; eq.n; i++) {
        Equation *e = &amp;(eq.elem[i]);
        if(e-&gt;tag != 0) continue;

        hParam hp = e-&gt;e-&gt;ReferencedParams(&amp;param);
        if(hp.v == Expr::NO_PARAMS.v) continue;
        if(hp.v == Expr::MULTIPLE_PARAMS.v) continue;

        Param *p = param.FindById(hp);
        if(p-&gt;tag != 0) continue; // let rank test catch inconsistency

        e-&gt;tag = alone;
        p-&gt;tag = alone;
        WriteJacobian(alone);
        if(!NewtonSolve(alone)) {
            // We don't do the rank test, so let's arbitrarily return
            // the DIDNT_CONVERGE result here.
            rankOk = true;
            // Failed to converge, bail out early
            goto didnt_converge;
        }
        alone++;
    }

    // Now write the Jacobian for what's left, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    rankOk = TestRank();

    // And do the leftovers as one big system
    if(!NewtonSolve(0)) {
        goto didnt_converge;
    }

    rankOk = TestRank();
    if(!rankOk) {
        if(!g-&gt;allowRedundant) {
            if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, forceDofCheck);
        }
    } else {
        // This is not the full Jacobian, but any substitutions or single-eq
        // solves removed one equation and one unknown, therefore no effect
        // on the number of DOF.
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    // System solved correctly, so write the new values back in to the
    // main parameter table.
    for(i = 0; i &lt; param.n; i++) {
        Param *p = &amp;(param.elem[i]);
        double val;
        if(p-&gt;tag == VAR_SUBSTITUTED) {
            val = param.FindById(p-&gt;substd)-&gt;val;
        } else {
            val = p-&gt;val;
        }
        Param *pp = SK.GetParam(p-&gt;h);
        pp-&gt;val = val;
        pp-&gt;known = true;
        pp-&gt;free = p-&gt;free;
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;

didnt_converge:
    SK.constraint.ClearTags();
    for(i = 0; i &lt; eq.n; i++) {
        if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE || isnan(mat.B.num[i])) {
            // This constraint is unsatisfied.
            if(!mat.eq[i].isFromConstraint()) continue;

            hConstraint hc = mat.eq[i].constraint();
            ConstraintBase *c = SK.constraint.FindByIdNoOops(hc);
            if(!c) continue;
            // Don't double-show constraints that generated multiple
            // unsatisfied equations
            if(!c-&gt;tag) {
                bad-&gt;Add(&amp;(c-&gt;h));
                c-&gt;tag = 1;
            }
        }
    }

    return rankOk ? SolveResult::DIDNT_CONVERGE : SolveResult::REDUNDANT_DIDNT_CONVERGE;
}

SolveResult System::SolveRank(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo1.20171224221229.94">                              bool andFindBad, bool andFindFree, bool forceDofCheck)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    if(!forceDofCheck) {
        SolveBySubstitution();
    }

    // Now write the Jacobian, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    bool rankOk = TestRank();
    if(!rankOk) {
        if(!g-&gt;allowRedundant) {
            if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, forceDofCheck);
        }
    } else {
        // This is not the full Jacobian, but any substitutions or single-eq
        // solves removed one equation and one unknown, therefore no effect
        // on the number of DOF.
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;
}

</t>
<t tx="leo1.20171224221229.95">void System::Clear() {
    entity.Clear();
    param.Clear();
    eq.Clear();
    dragged.Clear();
}

</t>
<t tx="leo1.20171224221229.96">void System::MarkParamsFree(bool find) {
    // If requested, find all the free (unbound) variables. This might be
    // more than the number of degrees of freedom. Don't always do this,
    // because the display would get annoying and it's slow.
    for(int i = 0; i &lt; param.n; i++) {
        Param *p = &amp;(param.elem[i]);
        p-&gt;free = false;

        if(find) {
            if(p-&gt;tag == 0) {
                p-&gt;tag = VAR_DOF_TEST;
                WriteJacobian(0);
                EvalJacobian();
                int rank = CalculateRank();
                if(rank == mat.m) {
                    p-&gt;free = true;
                }
                p-&gt;tag = 0;
            }
        }
    }
}

</t>
<t tx="leo1.20171224221229.97">int System::CalculateDof() {
    return mat.n - mat.m;
}

</t>
<t tx="leo1.20171224221229.98">//-----------------------------------------------------------------------------
// The text-based browser window, used to view the structure of the model by
// groups and for other similar purposes.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

//-----------------------------------------------------------------------------
// A navigation bar that always appears at the top of the window, with a
// link to bring us back home.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221229.99">void TextWindow::ScreenHome(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
}
</t>
<t tx="leo1.20171224221230.1">//-----------------------------------------------------------------------------
// The toolbar that appears at the top left of the graphics window, where the
// user can select icons with the mouse, to perform operations equivalent to
// selecting a menu item or using a keyboard shortcut.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

struct ToolIcon {
    std::string name;
    Command     command;
    const char *tooltip;
    std::shared_ptr&lt;Pixmap&gt; pixmap;
};
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221230.10">static const struct ft_error ft_errors[] = {
#include FT_ERRORS_H
};

</t>
<t tx="leo1.20171224221230.11">extern "C" const char *ft_error_string(int err) {
    const struct ft_error *e;
    for(e = ft_errors; e-&gt;str; e++)
        if(e-&gt;err == err)
            return e-&gt;str;
    return "Unknown error";
}

/* Okay, we're done with that. */
#undef FT_ERRORDEF
#undef FT_ERROR_START_LIST
#undef FT_ERROR_END_LIST

#include "solvespace.h"

//-----------------------------------------------------------------------------
// Get the list of available font filenames, and load the name for each of
// them. Only that, though, not the glyphs too.
//-----------------------------------------------------------------------------
TtfFontList::TtfFontList() {
    FT_Init_FreeType(&amp;fontLibrary);
}

TtfFontList::~TtfFontList() {
    FT_Done_FreeType(fontLibrary);
}

</t>
<t tx="leo1.20171224221230.12">void TtfFontList::LoadAll() {
    if(loaded) return;

    for(const Platform::Path &amp;font : GetFontFiles()) {
        TtfFont tf = {};
        tf.fontFile = font;
        if(tf.LoadFromFile(fontLibrary))
            l.Add(&amp;tf);
    }

    // Sort fonts according to their actual name, not filename.
    std::sort(&amp;l.elem[0], &amp;l.elem[l.n],
        [](const TtfFont &amp;a, const TtfFont &amp;b) { return a.name &lt; b.name; });

    // Filter out fonts with the same family and style name. This is not
    // strictly necessarily the exact same font, but it will almost always be.
    TtfFont *it = std::unique(&amp;l.elem[0], &amp;l.elem[l.n],
        [](const TtfFont &amp;a, const TtfFont &amp;b) { return a.name == b.name; });
    l.RemoveLast(&amp;l.elem[l.n] - it);

    // TODO: identify fonts by their name and not filename, which may change
    // between OSes.

    loaded = true;
}

TtfFont *TtfFontList::LoadFont(const std::string &amp;font)
{
    LoadAll();

    TtfFont *tf = std::find_if(l.begin(), l.end(),
        [&amp;](const TtfFont &amp;tf) { return tf.FontFileBaseName() == font; });

    if(tf != l.end()) {
        if(tf-&gt;fontFace == NULL) {
            tf-&gt;LoadFromFile(fontLibrary, /*nameOnly=*/false);
        }
        return tf;
    } else {
        return NULL;
    }
}

</t>
<t tx="leo1.20171224221230.13">void TtfFontList::PlotString(const std::string &amp;font, const std::string &amp;str,
                             SBezierList *sbl, Vector origin, Vector u, Vector v)
{
    TtfFont *tf = LoadFont(font);
    if(!str.empty() &amp;&amp; tf != NULL) {
        tf-&gt;PlotString(str, sbl, origin, u, v);
    } else {
        // No text or no font; so draw a big X for an error marker.
        SBezier sb;
        sb = SBezier::From(origin, origin.Plus(u).Plus(v));
        sbl-&gt;l.Add(&amp;sb);
        sb = SBezier::From(origin.Plus(v), origin.Plus(u));
        sbl-&gt;l.Add(&amp;sb);
    }
}

double TtfFontList::AspectRatio(const std::string &amp;font, const std::string &amp;str)
{
    TtfFont *tf = LoadFont(font);
    if(tf != NULL) {
        return tf-&gt;AspectRatio(str);
    }

    return 0.0;
}

//-----------------------------------------------------------------------------
// Return the basename of our font filename; that's how the requests and
// entities that reference us will store it.
//-----------------------------------------------------------------------------
std::string TtfFont::FontFileBaseName() const {
    return fontFile.FileName();
}

//-----------------------------------------------------------------------------
// Load a TrueType font into memory. We care about the curves that define
// the letter shapes, and about the mappings that determine which glyph goes
// with which character.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221230.14">bool TtfFont::LoadFromFile(FT_Library fontLibrary, bool nameOnly) {
    FT_Open_Args args = {};
    args.flags    = FT_OPEN_PATHNAME;
    args.pathname = &amp;fontFile.raw[0]; // FT_String is char* for historical reasons

    // We don't use OpenFile() here to let freetype do its own memory management.
    // This is OK because on Linux/OS X we just delegate to fopen and on Windows
    // we only look into C:\Windows\Fonts, which has a known short path.
    if(int fterr = FT_Open_Face(fontLibrary, &amp;args, 0, &amp;fontFace)) {
        dbp("freetype: loading font from file '%s' failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        return false;
    }

    if(int fterr = FT_Select_Charmap(fontFace, FT_ENCODING_UNICODE)) {
        dbp("freetype: loading unicode CMap for file '%s' failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return false;
    }

    name = std::string(fontFace-&gt;family_name) +
           " (" + std::string(fontFace-&gt;style_name) + ")";

    if(nameOnly) {
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return true;
    }

    // We always ask Freetype to give us a unit size character.
    // It uses fixed point; put the unit size somewhere in the middle of the dynamic
    // range of its 26.6 fixed point type, and adjust the factors so that the unit
    // matches cap height.
    FT_Size_RequestRec sizeRequest;
    sizeRequest.type           = FT_SIZE_REQUEST_TYPE_REAL_DIM;
    sizeRequest.width          = 1 &lt;&lt; 16;
    sizeRequest.height         = 1 &lt;&lt; 16;
    sizeRequest.horiResolution = 128;
    sizeRequest.vertResolution = 128;
    if(int fterr = FT_Request_Size(fontFace, &amp;sizeRequest)) {
        dbp("freetype: cannot set character size: %s",
            ft_error_string(fterr));
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return false;
    }

    char chr = 'A';
    uint32_t gid = FT_Get_Char_Index(fontFace, 'A');
    if (gid == 0) {
        dbp("freetype: CID-to-GID mapping for CID 0x%04x failed: %s; using CID as GID",
            chr, ft_error_string(gid));
        dbp("Assuming cap height is the same as requested height (this is likely wrong).");
        capHeight = (double)sizeRequest.height;
    }

    if(gid) {
        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph for GID 0x%04x: %s",
                gid, ft_error_string(fterr));
            FT_Done_Face(fontFace);
            fontFace = NULL;
            return false;
        }

        FT_BBox bbox;
        FT_Outline_Get_CBox(&amp;fontFace-&gt;glyph-&gt;outline, &amp;bbox);
        capHeight = (double)bbox.yMax;
    }

    return true;
}

</t>
<t tx="leo1.20171224221230.15">typedef struct OutlineData {
    Vector       origin, u, v; // input parameters
    SBezierList *beziers;      // output bezier list
    float        factor;       // ratio between freetype and solvespace coordinates
    FT_Pos       bx;           // x offset of the current glyph
    FT_Pos       px, py;       // current point
} OutlineData;

</t>
<t tx="leo1.20171224221230.16">static Vector Transform(OutlineData *data, FT_Pos x, FT_Pos y) {
    Vector r = data-&gt;origin;
    r = r.Plus(data-&gt;u.ScaledBy((float)(data-&gt;bx + x) * data-&gt;factor));
    r = r.Plus(data-&gt;v.ScaledBy((float)y * data-&gt;factor));
    return r;
}

</t>
<t tx="leo1.20171224221230.17">static int MoveTo(const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo1.20171224221230.18">static int LineTo(const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo1.20171224221230.19">static int ConicTo(const FT_Vector *c, const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, c-&gt;x,     c-&gt;y),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo1.20171224221230.2">static ToolIcon Toolbar[] = {
    { "line",            Command::LINE_SEGMENT,
      N_("Sketch line segment"),                              {} },
    { "rectangle",       Command::RECTANGLE,
      N_("Sketch rectangle"),                                 {} },
    { "circle",          Command::CIRCLE,
      N_("Sketch circle"),                                    {} },
    { "arc",             Command::ARC,
      N_("Sketch arc of a circle"),                           {} },
    { "text",            Command::TTF_TEXT,
      N_("Sketch curves from text in a TrueType font"),       {} },
    { "image",           Command::IMAGE,
      N_("Sketch image from a file"),                         {} },
    { "tangent-arc",     Command::TANGENT_ARC,
      N_("Create tangent arc at selected point"),             {} },
    { "bezier",          Command::CUBIC,
      N_("Sketch cubic Bezier spline"),                       {} },
    { "point",           Command::DATUM_POINT,
      N_("Sketch datum point"),                               {} },
    { "construction",    Command::CONSTRUCTION,
      N_("Toggle construction"),                              {} },
    { "trim",            Command::SPLIT_CURVES,
      N_("Split lines / curves where they intersect"),        {} },
    { "",                Command::NONE, "",                   {} },

    { "length",          Command::DISTANCE_DIA,
      N_("Constrain distance / diameter / length"),           {} },
    { "angle",           Command::ANGLE,
      N_("Constrain angle"),                                  {} },
    { "horiz",           Command::HORIZONTAL,
      N_("Constrain to be horizontal"),                       {} },
    { "vert",            Command::VERTICAL,
      N_("Constrain to be vertical"),                         {} },
    { "parallel",        Command::PARALLEL,
      N_("Constrain to be parallel or tangent"),              {} },
    { "perpendicular",   Command::PERPENDICULAR,
      N_("Constrain to be perpendicular"),                    {} },
    { "pointonx",        Command::ON_ENTITY,
      N_("Constrain point on line / curve / plane / point"),  {} },
    { "symmetric",       Command::SYMMETRIC,
      N_("Constrain symmetric"),                              {} },
    { "equal",           Command::EQUAL,
      N_("Constrain equal length / radius / angle"),          {} },
    { "same-orientation",Command::ORIENTED_SAME,
      N_("Constrain normals in same orientation"),            {} },
    { "other-supp",      Command::OTHER_ANGLE,
      N_("Other supplementary angle"),                        {} },
    { "ref",             Command::REFERENCE,
      N_("Toggle reference dimension"),                       {} },
    { "",                Command::NONE, "",                   {} },

    { "extrude",         Command::GROUP_EXTRUDE,
      N_("New group extruding active sketch"),                {} },
    { "lathe",           Command::GROUP_LATHE,
      N_("New group rotating active sketch"),                 {} },
    { "step-rotate",     Command::GROUP_ROT,
      N_("New group step and repeat rotating"),               {} },
    { "step-translate",  Command::GROUP_TRANS,
      N_("New group step and repeat translating"),            {} },
    { "sketch-in-plane", Command::GROUP_WRKPL,
      N_("New group in new workplane (thru given entities)"), {} },
    { "sketch-in-3d",    Command::GROUP_3D,
      N_("New group in 3d"),                                  {} },
    { "assemble",        Command::GROUP_LINK,
      N_("New group linking / assembling file"),              {} },
    { "",                Command::NONE, "",                   {} },

    { "in3d",            Command::NEAREST_ISO,
      N_("Nearest isometric view"),                           {} },
    { "ontoworkplane",   Command::ONTO_WORKPLANE,
      N_("Align view to active workplane"),                   {} },
};

</t>
<t tx="leo1.20171224221230.20">static int CubicTo(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, c1-&gt;x,    c1-&gt;y),
        Transform(data, c2-&gt;x,    c2-&gt;y),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo1.20171224221230.21">void TtfFont::PlotString(const std::string &amp;str,
                         SBezierList *sbl, Vector origin, Vector u, Vector v)
{
    ssassert(fontFace != NULL, "Expected font face to be loaded");

    FT_Outline_Funcs outlineFuncs;
    outlineFuncs.move_to  = MoveTo;
    outlineFuncs.line_to  = LineTo;
    outlineFuncs.conic_to = ConicTo;
    outlineFuncs.cubic_to = CubicTo;
    outlineFuncs.shift    = 0;
    outlineFuncs.delta    = 0;

    FT_Pos dx = 0;
    for(char32_t cid : ReadUTF8(str)) {
        uint32_t gid = FT_Get_Char_Index(fontFace, cid);
        if (gid == 0) {
            dbp("freetype: CID-to-GID mapping for CID 0x%04x failed: %s; using CID as GID",
                cid, ft_error_string(gid));
            gid = cid;
        }

        /*
         * Stupid hacks:
         *  - if we want fake-bold, use FT_Outline_Embolden(). This actually looks
         *    quite good.
         *  - if we want fake-italic, apply a shear transform [1 s s 1 0 0] here using
         *    FT_Set_Transform. This looks decent at small font sizes and bad at larger
         *    ones, antialiasing mitigates this considerably though.
         */
        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph for GID 0x%04x: %s",
                gid, ft_error_string(fterr));
            return;
        }

        /* A point that has x = xMin should be plotted at (dx0 + lsb); fix up
         * our x-position so that the curve-generating code will put stuff
         * at the right place.
         *
         * There's no point in getting the glyph BBox here - not only can it be
         * needlessly slow sometimes, but because we're about to render a single glyph,
         * what we want actually *is* the CBox.
         *
         * This is notwithstanding that this makes extremely little sense, this
         * looks like a workaround for either mishandling the start glyph on a line,
         * or as a really hacky pseudo-track-kerning (in which case it works better than
         * one would expect! especially since most fonts don't set track kerning).
         */
        FT_BBox cbox;
        FT_Outline_Get_CBox(&amp;fontFace-&gt;glyph-&gt;outline, &amp;cbox);
        FT_Pos bx = dx - cbox.xMin;
        // Yes, this is what FreeType calls left-side bearing.
        // Then interchangeably uses that with "left-side bearing". Sigh.
        bx += fontFace-&gt;glyph-&gt;metrics.horiBearingX;

        OutlineData data = {};
        data.origin  = origin;
        data.u       = u;
        data.v       = v;
        data.beziers = sbl;
        data.factor  = (float)(1.0 / capHeight);
        data.bx      = bx;
        if(int fterr = FT_Outline_Decompose(&amp;fontFace-&gt;glyph-&gt;outline, &amp;outlineFuncs, &amp;data)) {
            dbp("freetype: bezier decomposition failed (gid %d): %s",
                gid, ft_error_string(fterr));
        }

        // And we're done, so advance our position by the requested advance
        // width, plus the user-requested extra advance.
        dx += fontFace-&gt;glyph-&gt;advance.x;
    }
}

double TtfFont::AspectRatio(const std::string &amp;str) {
    ssassert(fontFace != NULL, "Expected font face to be loaded");

    // We always request a unit size character, so the aspect ratio is the same as advance length.
    double dx = 0;
    for(char32_t chr : ReadUTF8(str)) {
        uint32_t gid = FT_Get_Char_Index(fontFace, chr);
        if (gid == 0) {
            dbp("freetype: CID-to-GID mapping for CID 0x%04x failed: %s; using CID as GID",
                chr, ft_error_string(gid));
        }

        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph (GID 0x%04x): %s",
                gid, ft_error_string(fterr));
            break;
        }

        dx += (double)fontFace-&gt;glyph-&gt;advance.x / capHeight;
    }

    return dx;
}
</t>
<t tx="leo1.20171224221230.22">//-----------------------------------------------------------------------------
// The user-visible undo/redo operation; whenever they change something, we
// record our state and push it on a stack, and we pop the stack when they
// select undo.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221230.23">void SolveSpaceUI::UndoRemember() {
    unsaved = true;
    PushFromCurrentOnto(&amp;undo);
    UndoClearStack(&amp;redo);
    UndoEnableMenus();
}

</t>
<t tx="leo1.20171224221230.24">void SolveSpaceUI::UndoUndo() {
    if(undo.cnt &lt;= 0) return;

    PushFromCurrentOnto(&amp;redo);
    PopOntoCurrentFrom(&amp;undo);
    UndoEnableMenus();
}

</t>
<t tx="leo1.20171224221230.25">void SolveSpaceUI::UndoRedo() {
    if(redo.cnt &lt;= 0) return;

    PushFromCurrentOnto(&amp;undo);
    PopOntoCurrentFrom(&amp;redo);
    UndoEnableMenus();
}

</t>
<t tx="leo1.20171224221230.26">void SolveSpaceUI::UndoEnableMenus() {
    EnableMenuByCmd(Command::UNDO, undo.cnt &gt; 0);
    EnableMenuByCmd(Command::REDO, redo.cnt &gt; 0);
}

</t>
<t tx="leo1.20171224221230.27">void SolveSpaceUI::PushFromCurrentOnto(UndoStack *uk) {
    int i;

    if(uk-&gt;cnt == MAX_UNDO) {
        UndoClearState(&amp;(uk-&gt;d[uk-&gt;write]));
        // And then write in to this one again
    } else {
        (uk-&gt;cnt)++;
    }

    UndoState *ut = &amp;(uk-&gt;d[uk-&gt;write]);
    *ut = {};
    ut-&gt;group.ReserveMore(SK.group.n);
    for(i = 0; i &lt; SK.group.n; i++) {
        Group *src = &amp;(SK.group.elem[i]);
        Group dest = *src;
        // And then clean up all the stuff that needs to be a deep copy,
        // and zero out all the dynamic stuff that will get regenerated.
        dest.clean = false;
        dest.solved = {};
        dest.polyLoops = {};
        dest.bezierLoops = {};
        dest.bezierOpens = {};
        dest.polyError = {};
        dest.thisMesh = {};
        dest.runningMesh = {};
        dest.thisShell = {};
        dest.runningShell = {};
        dest.displayMesh = {};
        dest.displayOutlines = {};

        dest.remap = {};
        src-&gt;remap.DeepCopyInto(&amp;(dest.remap));

        dest.impMesh = {};
        dest.impShell = {};
        dest.impEntity = {};
        ut-&gt;group.Add(&amp;dest);
    }
    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        ut-&gt;groupOrder.Add(&amp;(SK.groupOrder.elem[i]));
    }
    ut-&gt;request.ReserveMore(SK.request.n);
    for(i = 0; i &lt; SK.request.n; i++) {
        ut-&gt;request.Add(&amp;(SK.request.elem[i]));
    }
    ut-&gt;constraint.ReserveMore(SK.constraint.n);
    for(i = 0; i &lt; SK.constraint.n; i++) {
        Constraint *src = &amp;(SK.constraint.elem[i]);
        Constraint dest = *src;
        ut-&gt;constraint.Add(&amp;dest);
    }
    ut-&gt;param.ReserveMore(SK.param.n);
    for(i = 0; i &lt; SK.param.n; i++) {
        ut-&gt;param.Add(&amp;(SK.param.elem[i]));
    }
    ut-&gt;style.ReserveMore(SK.style.n);
    for(i = 0; i &lt; SK.style.n; i++) {
        ut-&gt;style.Add(&amp;(SK.style.elem[i]));
    }
    ut-&gt;activeGroup = SS.GW.activeGroup;

    uk-&gt;write = WRAP(uk-&gt;write + 1, MAX_UNDO);
}

</t>
<t tx="leo1.20171224221230.28">void SolveSpaceUI::PopOntoCurrentFrom(UndoStack *uk) {
    int i;

    ssassert(uk-&gt;cnt &gt; 0, "Cannot pop from empty undo stack");
    (uk-&gt;cnt)--;
    uk-&gt;write = WRAP(uk-&gt;write - 1, MAX_UNDO);

    UndoState *ut = &amp;(uk-&gt;d[uk-&gt;write]);

    // Free everything in the main copy of the program before replacing it
    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder.elem[i]);
        g-&gt;Clear();
    }
    SK.group.Clear();
    SK.groupOrder.Clear();
    SK.request.Clear();
    SK.constraint.Clear();
    SK.param.Clear();
    SK.style.Clear();

    // And then do a shallow copy of the state from the undo list
    ut-&gt;group.MoveSelfInto(&amp;(SK.group));
    for(i = 0; i &lt; ut-&gt;groupOrder.n; i++)
        SK.groupOrder.Add(&amp;ut-&gt;groupOrder.elem[i]);
    ut-&gt;request.MoveSelfInto(&amp;(SK.request));
    ut-&gt;constraint.MoveSelfInto(&amp;(SK.constraint));
    ut-&gt;param.MoveSelfInto(&amp;(SK.param));
    ut-&gt;style.MoveSelfInto(&amp;(SK.style));
    SS.GW.activeGroup = ut-&gt;activeGroup;

    // No need to free it, since a shallow copy was made above
    *ut = {};

    // And reset the state everywhere else in the program, since the
    // sketch just changed a lot.
    SS.GW.ClearSuper();
    SS.TW.ClearSuper();
    SS.ReloadAllLinked(SS.saveFile);
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);
    SS.ScheduleShowTW();

    // Activate the group that was active before.
    Group *activeGroup = SK.GetGroup(SS.GW.activeGroup);
    activeGroup-&gt;Activate();
}

</t>
<t tx="leo1.20171224221230.29">void SolveSpaceUI::UndoClearStack(UndoStack *uk) {
    while(uk-&gt;cnt &gt; 0) {
        uk-&gt;write = WRAP(uk-&gt;write - 1, MAX_UNDO);
        (uk-&gt;cnt)--;
        UndoClearState(&amp;(uk-&gt;d[uk-&gt;write]));
    }
    *uk = {}; // for good measure
}

</t>
<t tx="leo1.20171224221230.3">void GraphicsWindow::ToolbarDraw(UiCanvas *canvas) {
    ToolbarDrawOrHitTest(0, 0, canvas, NULL);
}

</t>
<t tx="leo1.20171224221230.30">void SolveSpaceUI::UndoClearState(UndoState *ut) {
    int i;
    for(i = 0; i &lt; ut-&gt;group.n; i++) {
        Group *g = &amp;(ut-&gt;group.elem[i]);

        g-&gt;remap.Clear();
    }
    ut-&gt;group.Clear();
    ut-&gt;request.Clear();
    ut-&gt;constraint.Clear();
    ut-&gt;param.Clear();
    ut-&gt;style.Clear();
    *ut = {};
}

</t>
<t tx="leo1.20171224221230.31">//-----------------------------------------------------------------------------
// Utility functions, mostly various kinds of vector math (working on real
// numbers, not working on quantities in the symbolic algebra system).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string SolveSpace::ssprintf(const char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    int size = vsnprintf(NULL, 0, fmt, va);
    ssassert(size &gt;= 0, "vsnprintf could not encode string");
    va_end(va);

    std::string result;
    result.resize(size + 1);

    va_start(va, fmt);
    vsnprintf(&amp;result[0], size + 1, fmt, va);
    va_end(va);

    result.resize(size);
    return result;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221230.32">char32_t utf8_iterator::operator*()
{
    const uint8_t *it = (const uint8_t*) this-&gt;p;
    char32_t result = *it;

    if((result &amp; 0x80) != 0) {
      unsigned int mask = 0x40;

      do {
        result &lt;&lt;= 6;
        unsigned int c = (*++it);
        mask   &lt;&lt;= 5;
        result  += c - 0x80;
      } while((result &amp; mask) != 0);

      result &amp;= mask - 1;
    }

    this-&gt;n = (const char*) (it + 1);
    return result;
}

</t>
<t tx="leo1.20171224221230.33">int64_t SolveSpace::GetMilliseconds()
{
    auto timestamp = std::chrono::steady_clock::now().time_since_epoch();
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timestamp).count();
}

</t>
<t tx="leo1.20171224221230.34">void SolveSpace::MakeMatrix(double *mat,
                            double a11, double a12, double a13, double a14,
                            double a21, double a22, double a23, double a24,
                            double a31, double a32, double a33, double a34,
                            double a41, double a42, double a43, double a44)
{
    mat[ 0] = a11;
    mat[ 1] = a21;
    mat[ 2] = a31;
    mat[ 3] = a41;
    mat[ 4] = a12;
    mat[ 5] = a22;
    mat[ 6] = a32;
    mat[ 7] = a42;
    mat[ 8] = a13;
    mat[ 9] = a23;
    mat[10] = a33;
    mat[11] = a43;
    mat[12] = a14;
    mat[13] = a24;
    mat[14] = a34;
    mat[15] = a44;
}

</t>
<t tx="leo1.20171224221230.35">void SolveSpace::MultMatrix(double *mata, double *matb, double *matr) {
    for(int i = 0; i &lt; 4; i++) {
        for(int j = 0; j &lt; 4; j++) {
            double s = 0.0;
            for(int k = 0; k &lt; 4; k++) {
                s += mata[k * 4 + j] * matb[i * 4 + k];
            }
           matr[i * 4 + j] = s;
        }
    }
}

//-----------------------------------------------------------------------------
// Word-wrap the string for our message box appropriately, and then display
// that string.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221230.36">static void DoStringForMessageBox(const char *str, va_list f, bool error)
{
    char inBuf[1024*50];
    vsprintf(inBuf, str, f);

    char outBuf[1024*50];
    int i = 0, j = 0, len = 0, longestLen = 47;
    int rows = 0, cols = 0;

    // Count the width of the longest line that starts with spaces; those
    // are list items, that should not be split in the middle.
    bool listLine = false;
    while(inBuf[i]) {
        if(inBuf[i] == '\r') {
            // ignore these
        } else if(inBuf[i] == ' ' &amp;&amp; len == 0) {
            listLine = true;
        } else if(inBuf[i] == '\n') {
            if(listLine) longestLen = max(longestLen, len);
            len = 0;
        } else {
            len++;
        }
        i++;
    }
    if(listLine) longestLen = max(longestLen, len);

    // Word wrap according to our target line length longestLen.
    len = 0;
    i = 0;
    while(inBuf[i]) {
        if(inBuf[i] == '\r') {
            // ignore these
        } else if(inBuf[i] == '\n') {
            outBuf[j++] = '\n';
            if(len == 0) rows++;
            len = 0;
        } else if(inBuf[i] == ' ' &amp;&amp; len &gt; longestLen) {
            outBuf[j++] = '\n';
            len = 0;
        } else {
            outBuf[j++] = inBuf[i];
            // Count rows when we draw the first character; so an empty
            // row doesn't end up counting.
            if(len == 0) rows++;
            len++;
        }
        cols = max(cols, len);
        i++;
    }
    outBuf[j++] = '\0';

    // And then display the text with our actual longest line length.
    DoMessageBox(outBuf, rows, cols, error);
}
</t>
<t tx="leo1.20171224221230.37">void SolveSpace::Error(const char *str, ...)
{
    va_list f;
    va_start(f, str);
    DoStringForMessageBox(str, f, /*error=*/true);
    va_end(f);
}
</t>
<t tx="leo1.20171224221230.38">void SolveSpace::Message(const char *str, ...)
{
    va_list f;
    va_start(f, str);
    DoStringForMessageBox(str, f, /*error=*/false);
    va_end(f);
}

void SolveSpace::CnfFreezeBool(bool v, const std::string &amp;name)

//-----------------------------------------------------------------------------
// Solve a mostly banded matrix. In a given row, there are LEFT_OF_DIAG
// elements to the left of the diagonal element, and RIGHT_OF_DIAG elements to
// the right (so that the total band width is LEFT_OF_DIAG + RIGHT_OF_DIAG + 1).
// There also may be elements in the last two columns of any row. We solve
// without pivoting.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221230.39">void BandedMatrix::Solve() {
    int i, ip, j, jp;
    double temp;

    // Reduce the matrix to upper triangular form.
    for(i = 0; i &lt; n; i++) {
        for(ip = i+1; ip &lt; n &amp;&amp; ip &lt;= (i + LEFT_OF_DIAG); ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; (n - 2) &amp;&amp; jp &lt;= (i + RIGHT_OF_DIAG); jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            A[ip][n-2] -= temp*(A[i][n-2]);
            A[ip][n-1] -= temp*(A[i][n-1]);

            B[ip] -= temp*B[i];
        }
    }

    // And back-substitute.
    for(i = n - 1; i &gt;= 0; i--) {
        temp = B[i];

        if(i &lt; n-1) temp -= X[n-1]*A[i][n-1];
        if(i &lt; n-2) temp -= X[n-2]*A[i][n-2];

        for(j = min(n - 3, i + RIGHT_OF_DIAG); j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }
}

const Quaternion Quaternion::IDENTITY = { 1, 0, 0, 0 };

Quaternion Quaternion::From(double w, double vx, double vy, double vz) {
    Quaternion q;
    q.w  = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

Quaternion Quaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    Quaternion q;
    q.w  = SK.GetParam(w )-&gt;val;
    q.vx = SK.GetParam(vx)-&gt;val;
    q.vy = SK.GetParam(vy)-&gt;val;
    q.vz = SK.GetParam(vz)-&gt;val;
    return q;
}

Quaternion Quaternion::From(Vector axis, double dtheta) {
    Quaternion q;
    double c = cos(dtheta / 2), s = sin(dtheta / 2);
    axis = axis.WithMagnitude(s);
    q.w  = c;
    q.vx = axis.x;
    q.vy = axis.y;
    q.vz = axis.z;
    return q;
}

Quaternion Quaternion::From(Vector u, Vector v)
{
    Vector n = u.Cross(v);

    Quaternion q;
    double s, tr = 1 + u.x + v.y + n.z;
    if(tr &gt; 1e-4) {
        s = 2*sqrt(tr);
        q.w  = s/4;
        q.vx = (v.z - n.y)/s;
        q.vy = (n.x - u.z)/s;
        q.vz = (u.y - v.x)/s;
    } else {
        if(u.x &gt; v.y &amp;&amp; u.x &gt; n.z) {
            s = 2*sqrt(1 + u.x - v.y - n.z);
            q.w  = (v.z - n.y)/s;
            q.vx = s/4;
            q.vy = (u.y + v.x)/s;
            q.vz = (n.x + u.z)/s;
        } else if(v.y &gt; n.z) {
            s = 2*sqrt(1 - u.x + v.y - n.z);
            q.w  = (n.x - u.z)/s;
            q.vx = (u.y + v.x)/s;
            q.vy = s/4;
            q.vz = (v.z + n.y)/s;
        } else {
            s = 2*sqrt(1 - u.x - v.y + n.z);
            q.w  = (u.y - v.x)/s;
            q.vx = (n.x + u.z)/s;
            q.vy = (v.z + n.y)/s;
            q.vz = s/4;
        }
    }

    return q.WithMagnitude(1);
}

Quaternion Quaternion::Plus(Quaternion b) const {
    Quaternion q;
    q.w  = w  + b.w;
    q.vx = vx + b.vx;
    q.vy = vy + b.vy;
    q.vz = vz + b.vz;
    return q;
}

Quaternion Quaternion::Minus(Quaternion b) const {
    Quaternion q;
    q.w  = w  - b.w;
    q.vx = vx - b.vx;
    q.vy = vy - b.vy;
    q.vz = vz - b.vz;
    return q;
}

Quaternion Quaternion::ScaledBy(double s) const {
    Quaternion q;
    q.w  = w*s;
    q.vx = vx*s;
    q.vy = vy*s;
    q.vz = vz*s;
    return q;
}

double Quaternion::Magnitude() const {
    return sqrt(w*w + vx*vx + vy*vy + vz*vz);
}

Quaternion Quaternion::WithMagnitude(double s) const {
    return ScaledBy(s/Magnitude());
}

Vector Quaternion::RotationU() const {
    Vector v;
    v.x = w*w + vx*vx - vy*vy - vz*vz;
    v.y = 2*w *vz + 2*vx*vy;
    v.z = 2*vx*vz - 2*w *vy;
    return v;
}

Vector Quaternion::RotationV() const {
    Vector v;
    v.x = 2*vx*vy - 2*w*vz;
    v.y = w*w - vx*vx + vy*vy - vz*vz;
    v.z = 2*w*vx + 2*vy*vz;
    return v;
}

Vector Quaternion::RotationN() const {
    Vector v;
    v.x = 2*w*vy + 2*vx*vz;
    v.y = 2*vy*vz - 2*w*vx;
    v.z = w*w - vx*vx - vy*vy + vz*vz;
    return v;
}

Vector Quaternion::Rotate(Vector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

Quaternion Quaternion::Inverse() const {
    Quaternion r;
    r.w = w;
    r.vx = -vx;
    r.vy = -vy;
    r.vz = -vz;
    return r.WithMagnitude(1); // not that the normalize should be reqd
}

Quaternion Quaternion::ToThe(double p) const {
    // Avoid division by zero, or arccos of something not in its domain
    if(w &gt;= (1 - 1e-6)) {
        return From(1, 0, 0, 0);
    } else if(w &lt;= (-1 + 1e-6)) {
        return From(-1, 0, 0, 0);
    }

    Quaternion r;
    Vector axis = Vector::From(vx, vy, vz);
    double theta = acos(w); // okay, since magnitude is 1, so -1 &lt;= w &lt;= 1
    theta *= p;
    r.w = cos(theta);
    axis = axis.WithMagnitude(sin(theta));
    r.vx = axis.x;
    r.vy = axis.y;
    r.vz = axis.z;
    return r;
}

Quaternion Quaternion::Times(Quaternion b) const {
    double sa = w, sb = b.w;
    Vector va = { vx, vy, vz };
    Vector vb = { b.vx, b.vy, b.vz };

    Quaternion r;
    r.w = sa*sb - va.Dot(vb);
    Vector vr = vb.ScaledBy(sa).Plus(
                va.ScaledBy(sb).Plus(
                va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Quaternion Quaternion::Mirror() const {
    Vector u = RotationU(),
           v = RotationV();
    u = u.ScaledBy(-1);
    v = v.ScaledBy(-1);
    return Quaternion::From(u, v);
}


Vector Vector::From(double x, double y, double z) {
    Vector v;
    v.x = x; v.y = y; v.z = z;
    return v;
}

Vector Vector::From(hParam x, hParam y, hParam z) {
    Vector v;
    v.x = SK.GetParam(x)-&gt;val;
    v.y = SK.GetParam(y)-&gt;val;
    v.z = SK.GetParam(z)-&gt;val;
    return v;
}

double Vector::Element(int i) const {
    switch(i) {
        case 0: return x;
        case 1: return y;
        case 2: return z;
        default: ssassert(false, "Unexpected vector element index");
    }
}

</t>
<t tx="leo1.20171224221230.4">bool GraphicsWindow::ToolbarMouseMoved(int x, int y) {
    x += ((int)width/2);
    y += ((int)height/2);

    Command nh = Command::NONE;
    bool withinToolbar = ToolbarDrawOrHitTest(x, y, NULL, &amp;nh);
    if(!withinToolbar) nh = Command::NONE;

    if(nh != toolbarTooltipped) {
        // Don't let the tool tip move around if the mouse moves within the
        // same item.
        toolbarMouseX = x;
        toolbarMouseY = y;
        toolbarTooltipped = Command::NONE;
    }

    if(nh != toolbarHovered) {
        toolbarHovered = nh;
        SetTimerFor(1000);
        PaintGraphics();
    }
    // So if we moved off the toolbar, then toolbarHovered is now equal to
    // zero, so it doesn't matter if the tool tip timer expires. And if
    // we moved from one item to another, we reset the timer, so also okay.
    return withinToolbar;
}

</t>
<t tx="leo1.20171224221230.40">bool Vector::Equals(Vector v, double tol) const {
    // Quick axis-aligned tests before going further
    double dx = v.x - x; if(dx &lt; -tol || dx &gt; tol) return false;
    double dy = v.y - y; if(dy &lt; -tol || dy &gt; tol) return false;
    double dz = v.z - z; if(dz &lt; -tol || dz &gt; tol) return false;

    return (this-&gt;Minus(v)).MagSquared() &lt; tol*tol;
}

</t>
<t tx="leo1.20171224221230.41">bool Vector::EqualsExactly(Vector v) const {
    return EXACT(x == v.x &amp;&amp;
                 y == v.y &amp;&amp;
                 z == v.z);
}

Vector Vector::Plus(Vector b) const {
    Vector r;

    r.x = x + b.x;
    r.y = y + b.y;
    r.z = z + b.z;

    return r;
}

Vector Vector::Minus(Vector b) const {
    Vector r;

    r.x = x - b.x;
    r.y = y - b.y;
    r.z = z - b.z;

    return r;
}

Vector Vector::Negated() const {
    Vector r;

    r.x = -x;
    r.y = -y;
    r.z = -z;

    return r;
}

Vector Vector::Cross(Vector b) const {
    Vector r;

    r.x = -(z*b.y) + (y*b.z);
    r.y =  (z*b.x) - (x*b.z);
    r.z = -(y*b.x) + (x*b.y);

    return r;
}

double Vector::Dot(Vector b) const {
    return (x*b.x + y*b.y + z*b.z);
}

double Vector::DirectionCosineWith(Vector b) const {
    Vector a = this-&gt;WithMagnitude(1);
    b = b.WithMagnitude(1);
    return a.Dot(b);
}

Vector Vector::Normal(int which) const {
    Vector n;

    // Arbitrarily choose one vector that's normal to us, pivoting
    // appropriately.
    double xa = fabs(x), ya = fabs(y), za = fabs(z);
    if(this-&gt;Equals(Vector::From(0, 0, 1))) {
        // Make DXFs exported in the XY plane work nicely...
        n = Vector::From(1, 0, 0);
    } else if(xa &lt; ya &amp;&amp; xa &lt; za) {
        n.x = 0;
        n.y = z;
        n.z = -y;
    } else if(ya &lt; za) {
        n.x = -z;
        n.y = 0;
        n.z = x;
    } else {
        n.x = y;
        n.y = -x;
        n.z = 0;
    }

    if(which == 0) {
        // That's the vector we return.
    } else if(which == 1) {
        n = this-&gt;Cross(n);
    } else ssassert(false, "Unexpected vector normal index");

    n = n.WithMagnitude(1);

    return n;
}

Vector Vector::RotatedAbout(Vector orig, Vector axis, double theta) const {
    Vector r = this-&gt;Minus(orig);
    r = r.RotatedAbout(axis, theta);
    return r.Plus(orig);
}

Vector Vector::RotatedAbout(Vector axis, double theta) const {
    double c = cos(theta);
    double s = sin(theta);

    axis = axis.WithMagnitude(1);

    Vector r;

    r.x =   (x)*(c + (1 - c)*(axis.x)*(axis.x)) +
            (y)*((1 - c)*(axis.x)*(axis.y) - s*(axis.z)) +
            (z)*((1 - c)*(axis.x)*(axis.z) + s*(axis.y));

    r.y =   (x)*((1 - c)*(axis.y)*(axis.x) + s*(axis.z)) +
            (y)*(c + (1 - c)*(axis.y)*(axis.y)) +
            (z)*((1 - c)*(axis.y)*(axis.z) - s*(axis.x));

    r.z =   (x)*((1 - c)*(axis.z)*(axis.x) - s*(axis.y)) +
            (y)*((1 - c)*(axis.z)*(axis.y) + s*(axis.x)) +
            (z)*(c + (1 - c)*(axis.z)*(axis.z));

    return r;
}

Vector Vector::DotInToCsys(Vector u, Vector v, Vector n) const {
    Vector r = {
        this-&gt;Dot(u),
        this-&gt;Dot(v),
        this-&gt;Dot(n)
    };
    return r;
}

Vector Vector::ScaleOutOfCsys(Vector u, Vector v, Vector n) const {
    Vector r = u.ScaledBy(x).Plus(
               v.ScaledBy(y).Plus(
               n.ScaledBy(z)));
    return r;
}

Vector Vector::InPerspective(Vector u, Vector v, Vector n,
                             Vector origin, double cameraTan) const
{
    Vector r = this-&gt;Minus(origin);
    r = r.DotInToCsys(u, v, n);
    // yes, minus; we are assuming a csys where u cross v equals n, backwards
    // from the display stuff
    double w = (1 - r.z*cameraTan);
    r = r.ScaledBy(1/w);

    return r;
}

double Vector::DistanceToLine(Vector p0, Vector dp) const {
    double m = dp.Magnitude();
    return ((this-&gt;Minus(p0)).Cross(dp)).Magnitude() / m;
}

double Vector::DistanceToPlane(Vector normal, Vector origin) const {
    return this-&gt;Dot(normal) - origin.Dot(normal);
}

</t>
<t tx="leo1.20171224221230.42">bool Vector::OnLineSegment(Vector a, Vector b, double tol) const {
    if(this-&gt;Equals(a, tol) || this-&gt;Equals(b, tol)) return true;

    Vector d = b.Minus(a);

    double m = d.MagSquared();
    double distsq = ((this-&gt;Minus(a)).Cross(d)).MagSquared() / m;

    if(distsq &gt;= tol*tol) return false;

    double t = (this-&gt;Minus(a)).DivPivoting(d);
    // On-endpoint already tested
    if(t &lt; 0 || t &gt; 1) return false;
    return true;
}

Vector Vector::ClosestPointOnLine(Vector p0, Vector dp) const {
    dp = dp.WithMagnitude(1);
    // this, p0, and (p0+dp) define a plane; the min distance is in
    // that plane, so calculate its normal
    Vector pn = (this-&gt;Minus(p0)).Cross(dp);
    // The minimum distance line is in that plane, perpendicular
    // to the line
    Vector n = pn.Cross(dp);

    // Calculate the actual distance
    double d = (dp.Cross(p0.Minus(*this))).Magnitude();
    return this-&gt;Plus(n.WithMagnitude(d));
}

double Vector::MagSquared() const {
    return x*x + y*y + z*z;
}

double Vector::Magnitude() const {
    return sqrt(x*x + y*y + z*z);
}

Vector Vector::ScaledBy(double v) const {
    Vector r;

    r.x = x * v;
    r.y = y * v;
    r.z = z * v;

    return r;
}

Vector Vector::WithMagnitude(double v) const {
    double m = Magnitude();
    if(EXACT(m == 0)) {
        // We can do a zero vector with zero magnitude, but not any other cases.
        if(fabs(v) &gt; 1e-100) {
            dbp("Vector::WithMagnitude(%g) of zero vector!", v);
        }
        return From(0, 0, 0);
    } else {
        return ScaledBy(v/m);
    }
}

Vector Vector::ProjectVectorInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector u = w-&gt;Normal()-&gt;NormalU();
    Vector v = w-&gt;Normal()-&gt;NormalV();

    double up = this-&gt;Dot(u);
    double vp = this-&gt;Dot(v);

    return (u.ScaledBy(up)).Plus(v.ScaledBy(vp));
}

Vector Vector::ProjectInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector p0 = w-&gt;WorkplaneGetOffset();

    Vector f = this-&gt;Minus(p0);

    return p0.Plus(f.ProjectVectorInto(wrkpl));
}

Point2d Vector::Project2d(Vector u, Vector v) const {
    Point2d p;
    p.x = this-&gt;Dot(u);
    p.y = this-&gt;Dot(v);
    return p;
}

Point2d Vector::ProjectXy() const {
    Point2d p;
    p.x = x;
    p.y = y;
    return p;
}

Vector4 Vector::Project4d() const {
    return Vector4::From(1, x, y, z);
}

double Vector::DivPivoting(Vector delta) const {
    double mx = fabs(delta.x), my = fabs(delta.y), mz = fabs(delta.z);

    if(mx &gt; my &amp;&amp; mx &gt; mz) {
        return x/delta.x;
    } else if(my &gt; mz) {
        return y/delta.y;
    } else {
        return z/delta.z;
    }
}

Vector Vector::ClosestOrtho() const {
    double mx = fabs(x), my = fabs(y), mz = fabs(z);

    if(mx &gt; my &amp;&amp; mx &gt; mz) {
        return From((x &gt; 0) ? 1 : -1, 0, 0);
    } else if(my &gt; mz) {
        return From(0, (y &gt; 0) ? 1 : -1, 0);
    } else {
        return From(0, 0, (z &gt; 0) ? 1 : -1);
    }
}

Vector Vector::ClampWithin(double minv, double maxv) const {
    Vector ret = *this;

    if(ret.x &lt; minv) ret.x = minv;
    if(ret.y &lt; minv) ret.y = minv;
    if(ret.z &lt; minv) ret.z = minv;

    if(ret.x &gt; maxv) ret.x = maxv;
    if(ret.y &gt; maxv) ret.y = maxv;
    if(ret.z &gt; maxv) ret.z = maxv;

    return ret;
}

</t>
<t tx="leo1.20171224221230.43">void Vector::MakeMaxMin(Vector *maxv, Vector *minv) const {
    maxv-&gt;x = max(maxv-&gt;x, x);
    maxv-&gt;y = max(maxv-&gt;y, y);
    maxv-&gt;z = max(maxv-&gt;z, z);

    minv-&gt;x = min(minv-&gt;x, x);
    minv-&gt;y = min(minv-&gt;y, y);
    minv-&gt;z = min(minv-&gt;z, z);
}

</t>
<t tx="leo1.20171224221230.44">bool Vector::OutsideAndNotOn(Vector maxv, Vector minv) const {
    return (x &gt; maxv.x + LENGTH_EPS) || (x &lt; minv.x - LENGTH_EPS) ||
           (y &gt; maxv.y + LENGTH_EPS) || (y &lt; minv.y - LENGTH_EPS) ||
           (z &gt; maxv.z + LENGTH_EPS) || (z &lt; minv.z - LENGTH_EPS);
}

</t>
<t tx="leo1.20171224221230.45">bool Vector::BoundingBoxesDisjoint(Vector amax, Vector amin,
                                   Vector bmax, Vector bmin)
{
    int i;
    for(i = 0; i &lt; 3; i++) {
        if(amax.Element(i) &lt; bmin.Element(i) - LENGTH_EPS) return true;
        if(amin.Element(i) &gt; bmax.Element(i) + LENGTH_EPS) return true;
    }
    return false;
}

</t>
<t tx="leo1.20171224221230.46">bool Vector::BoundingBoxIntersectsLine(Vector amax, Vector amin,
                                       Vector p0, Vector p1, bool asSegment)
{
    Vector dp = p1.Minus(p0);
    double lp = dp.Magnitude();
    dp = dp.ScaledBy(1.0/lp);

    int i, a;
    for(i = 0; i &lt; 3; i++) {
        int j = WRAP(i+1, 3), k = WRAP(i+2, 3);
        if(lp*fabs(dp.Element(i)) &lt; LENGTH_EPS) continue; // parallel to plane

        for(a = 0; a &lt; 2; a++) {
            double d = (a == 0) ? amax.Element(i) : amin.Element(i);
            // n dot (p0 + t*dp) = d
            // (n dot p0) + t * (n dot dp) = d
            double t = (d - p0.Element(i)) / dp.Element(i);
            Vector p = p0.Plus(dp.ScaledBy(t));

            if(asSegment &amp;&amp; (t &lt; -LENGTH_EPS || t &gt; (lp+LENGTH_EPS))) continue;

            if(p.Element(j) &gt; amax.Element(j) + LENGTH_EPS) continue;
            if(p.Element(k) &gt; amax.Element(k) + LENGTH_EPS) continue;

            if(p.Element(j) &lt; amin.Element(j) - LENGTH_EPS) continue;
            if(p.Element(k) &lt; amin.Element(k) - LENGTH_EPS) continue;

            return true;
        }
    }

    return false;
}

Vector Vector::AtIntersectionOfPlanes(Vector n1, double d1,
                                      Vector n2, double d2)
{
    double det = (n1.Dot(n1))*(n2.Dot(n2)) -
{
    // Make a semi-orthogonal coordinate system from those directions;
    // note that dna and dnb need not be perpendicular.
    Vector dn = da.Cross(db); // normal to both
    Vector dna = dn.Cross(da); // normal to da
    Vector dnb = dn.Cross(db); // normal to db

    // At the intersection of the lines
    //    a0 + pa*da = b0 + pb*db (where pa, pb are scalar params)
    // So dot this equation against dna and dnb to get two equations
    // to solve for da and db
    *tb =  ((a0.Minus(b0)).Dot(dna))/(db.Dot(dna));
    *ta = -((a0.Minus(b0)).Dot(dnb))/(da.Dot(dnb));
}

Vector Vector::AtIntersectionOfLines(Vector a0, Vector a1,
                                     Vector b0, Vector b1,
                                     bool *skew,
                                     double *parama, double *paramb)
{
    Vector da = a1.Minus(a0), db = b1.Minus(b0);

    double pa, pb;
    Vector::ClosestPointBetweenLines(a0, da, b0, db, &amp;pa, &amp;pb);

    if(parama) *parama = pa;
    if(paramb) *paramb = pb;

    // And from either of those, we get the intersection point.
    Vector pi = a0.Plus(da.ScaledBy(pa));

    if(skew) {
        // Check if the intersection points on each line are actually
        // coincident...
        if(pi.Equals(b0.Plus(db.ScaledBy(pb)))) {
            *skew = false;
        } else {
            *skew = true;
        }
    }
    return pi;
}

Vector Vector::AtIntersectionOfPlaneAndLine(Vector n, double d,
                                            Vector p0, Vector p1,
                                            bool *parallel)
{
    Vector dp = p1.Minus(p0);

    if(fabs(n.Dot(dp)) &lt; LENGTH_EPS) {
        if(parallel) *parallel = true;
        return Vector::From(0, 0, 0);
    }

    if(parallel) *parallel = false;

    // n dot (p0 + t*dp) = d
    // (n dot p0) + t * (n dot dp) = d
    double t = (d - n.Dot(p0)) / (n.Dot(dp));

    return p0.Plus(dp.ScaledBy(t));
}

</t>
<t tx="leo1.20171224221230.47">static double det2(double a1, double b1,
                   double a2, double b2)
{
    return (a1*b2) - (b1*a2);
}
</t>
<t tx="leo1.20171224221230.48">static double det3(double a1, double b1, double c1,
                   double a2, double b2, double c2,
                   double a3, double b3, double c3)
{
    return a1*det2(b2, c2, b3, c3) -
           b1*det2(a2, c2, a3, c3) +
           c1*det2(a2, b2, a3, b3);
}
Vector Vector::AtIntersectionOfPlanes(Vector na, double da,
                                      Vector nb, double db,
                                      Vector nc, double dc,
                                      bool *parallel)
{
</t>
<t tx="leo1.20171224221230.49">    double det  = det3(na.x, na.y, na.z,
                       nb.x, nb.y, nb.z,
                       nc.x, nc.y, nc.z);
    if(fabs(det) &lt; 1e-10) { // arbitrary tolerance, not so good
        *parallel = true;
        return Vector::From(0, 0, 0);
    }
    *parallel = false;

    double detx = det3(da,   na.y, na.z,

    return Vector::From(detx/det, dety/det, detz/det);
}

size_t VectorHash::operator()(const Vector &amp;v) const {
    const size_t size = (size_t)pow(std::numeric_limits&lt;size_t&gt;::max(), 1.0 / 3.0) - 1;
    const double eps = 4.0 * LENGTH_EPS;

    double x = fabs(v.x) / eps;
    double y = fabs(v.y) / eps;
    double z = fabs(v.y) / eps;

    size_t xs = size_t(fmod(x, (double)size));
    size_t ys = size_t(fmod(y, (double)size));
    size_t zs = size_t(fmod(z, (double)size));

    return (zs * size + ys) * size + xs;
}

</t>
<t tx="leo1.20171224221230.5">bool GraphicsWindow::ToolbarMouseDown(int x, int y) {
    x += ((int)width/2);
    y += ((int)height/2);

    Command nh = Command::NONE;
    bool withinToolbar = ToolbarDrawOrHitTest(x, y, NULL, &amp;nh);
    // They might have clicked within the toolbar, but not on a button.
    if(withinToolbar &amp;&amp; nh != Command::NONE) {
        for(int i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
            if(nh == SS.GW.menu[i].id) {
                (SS.GW.menu[i].fn)((Command)SS.GW.menu[i].id);
                break;
            }
        }
    }
    return withinToolbar;
}

</t>
<t tx="leo1.20171224221230.50">bool VectorPred::operator()(Vector a, Vector b) const {
    return a.Equals(b, LENGTH_EPS);
}

Vector4 Vector4::From(double w, double x, double y, double z) {
    Vector4 ret;
    ret.w = w;
    ret.x = x;
    ret.y = y;
    ret.z = z;
    return ret;
}

Vector4 Vector4::From(double w, Vector v) {
    return Vector4::From(w, w*v.x, w*v.y, w*v.z);
}

Vector4 Vector4::Blend(Vector4 a, Vector4 b, double t) {
    return (a.ScaledBy(1 - t)).Plus(b.ScaledBy(t));
}

Vector4 Vector4::Plus(Vector4 b) const {
    return Vector4::From(w + b.w, x + b.x, y + b.y, z + b.z);
}

Vector4 Vector4::Minus(Vector4 b) const {
    return Vector4::From(w - b.w, x - b.x, y - b.y, z - b.z);
}

Vector4 Vector4::ScaledBy(double s) const {
    return Vector4::From(w*s, x*s, y*s, z*s);
}

Vector Vector4::PerspectiveProject() const {
    return Vector::From(x / w, y / w, z / w);
}

Point2d Point2d::From(double x, double y) {
    return { x, y };
}

Point2d Point2d::FromPolar(double r, double a) {
    return { r * cos(a), r * sin(a) };
}

double Point2d::Angle() const {
    double a = atan2(y, x);
    return M_PI + remainder(a - M_PI, 2 * M_PI);
}

double Point2d::AngleTo(const Point2d &amp;p) const {
    return p.Minus(*this).Angle();
}

Point2d Point2d::Plus(const Point2d &amp;b) const {
    return { x + b.x, y + b.y };
}

Point2d Point2d::Minus(const Point2d &amp;b) const {
    return { x - b.x, y - b.y };
}

Point2d Point2d::ScaledBy(double s) const {
    return { x * s, y * s };
}

double Point2d::DivPivoting(Point2d delta) const {
    if(fabs(delta.x) &gt; fabs(delta.y)) {
        return x/delta.x;
    } else {
        return y/delta.y;
    }
}

double Point2d::MagSquared() const {
    return x*x + y*y;
}

double Point2d::Magnitude() const {
    return sqrt(x*x + y*y);
}

Point2d Point2d::WithMagnitude(double v) const {
    double m = Magnitude();
    if(m &lt; 1e-20) {
        dbp("!!! WithMagnitude() of zero vector");
        return { v, 0 };
    }
    return { x * v / m, y * v / m };
}

double Point2d::DistanceTo(const Point2d &amp;p) const {
    double dx = x - p.x;
    double dy = y - p.y;
    return sqrt(dx*dx + dy*dy);
}

double Point2d::Dot(Point2d p) const {
    return x*p.x + y*p.y;
}

double Point2d::DistanceToLine(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
    double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;

    if(asSegment) {
        if(t &lt; 0.0) return DistanceTo(p0);
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp));
    }
    Point2d closest = p0.Plus(dp.ScaledBy(t));
    return DistanceTo(closest);
}

double Point2d::DistanceToLineSigned(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    Point2d n = dp.Normal().WithMagnitude(1.0);
    double dist = n.Dot(*this) - n.Dot(p0);
    if(asSegment) {
        // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
        double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;
        double sign = (dist &gt; 0.0) ? 1.0 : -1.0;
        if(t &lt; 0.0) return DistanceTo(p0) * sign;
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp)) * sign;
    }

    return dist;
}

Point2d Point2d::Normal() const {
    return { y, -x };
}

</t>
<t tx="leo1.20171224221230.51">bool Point2d::Equals(Point2d v, double tol) const {
    double dx = v.x - x; if(dx &lt; -tol || dx &gt; tol) return false;
    double dy = v.y - y; if(dy &lt; -tol || dy &gt; tol) return false;

    return (this-&gt;Minus(v)).MagSquared() &lt; tol*tol;
}

BBox BBox::From(const Vector &amp;p0, const Vector &amp;p1) {
    BBox bbox;
    bbox.minp.x = min(p0.x, p1.x);
    bbox.minp.y = min(p0.y, p1.y);
    bbox.minp.z = min(p0.z, p1.z);

    bbox.maxp.x = max(p0.x, p1.x);
    bbox.maxp.y = max(p0.y, p1.y);
    bbox.maxp.z = max(p0.z, p1.z);
    return bbox;
}

Vector BBox::GetOrigin() const { return minp.Plus(maxp.Minus(minp).ScaledBy(0.5)); }
Vector BBox::GetExtents() const { return maxp.Minus(minp).ScaledBy(0.5); }

</t>
<t tx="leo1.20171224221230.52">void BBox::Include(const Vector &amp;v, double r) {
    minp.x = min(minp.x, v.x - r);
    minp.y = min(minp.y, v.y - r);
    minp.z = min(minp.z, v.z - r);

    maxp.x = max(maxp.x, v.x + r);
    maxp.y = max(maxp.y, v.y + r);
    maxp.z = max(maxp.z, v.z + r);
}

</t>
<t tx="leo1.20171224221230.53">bool BBox::Overlaps(const BBox &amp;b1) const {
    Vector t = b1.GetOrigin().Minus(GetOrigin());
    Vector e = b1.GetExtents().Plus(GetExtents());

    return fabs(t.x) &lt; e.x &amp;&amp; fabs(t.y) &lt; e.y &amp;&amp; fabs(t.z) &lt; e.z;
}

</t>
<t tx="leo1.20171224221230.54">bool BBox::Contains(const Point2d &amp;p, double r) const {
    return p.x &gt;= (minp.x - r) &amp;&amp;
           p.y &gt;= (minp.y - r) &amp;&amp;
           p.x &lt;= (maxp.x + r) &amp;&amp;
           p.y &lt;= (maxp.y + r);
}

</t>
<t tx="leo1.20171224221230.55">const std::vector&lt;double&gt;&amp; SolveSpace::StipplePatternDashes(StipplePattern pattern) {
    static bool initialized;
    static std::vector&lt;double&gt; dashes[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        // Inkscape ignores all elements that are exactly zero instead of drawing
        // them as dots, so set those to 1e-6.
        dashes[(size_t)StipplePattern::CONTINUOUS] =
            {};
        dashes[(size_t)StipplePattern::SHORT_DASH] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::DASH] =
            { 1.0, 1.0 };
        dashes[(size_t)StipplePattern::DASH_DOT] =
            { 1.0, 0.5, 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::DASH_DOT_DOT] =
            { 1.0, 0.5, 1e-6, 0.5, 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::DOT] =
            { 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::LONG_DASH] =
            { 2.0, 0.5 };
        dashes[(size_t)StipplePattern::FREEHAND] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::ZIGZAG] =
            { 1.0, 2.0 };
    }

    return dashes[(size_t)pattern];
}

double SolveSpace::StipplePatternLength(StipplePattern pattern) {
    static bool initialized;
    static double lengths[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        for(size_t i = 0; i &lt; (size_t)StipplePattern::LAST; i++) {
            const std::vector&lt;double&gt; &amp;dashes = StipplePatternDashes((StipplePattern)i);
            double length = 0.0;
            for(double dash : dashes) {
                length += dash;
            }
            lengths[i] = length;
        }
    }

    return lengths[(size_t)pattern];
}
</t>
<t tx="leo1.20171224221230.56">//-----------------------------------------------------------------------------
// The View menu, stuff to snap to certain special vews of the model, and to
// display our current view of the model to the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221230.57">void TextWindow::ShowEditView() {
    Printf(true, "%Ft3D VIEW PARAMETERS%E");

    Printf(true,  "%Bd %Ftoverall scale factor%E");
    Printf(false, "%Ba   %# px/%s %Fl%Ll%f[edit]%E",
        SS.GW.scale * SS.MmPerUnit(),
        SS.UnitName(),
        &amp;ScreenChangeViewScale);
    Printf(false, "%Bd   %Fl%Ll%fset to full scale%E",
        &amp;ScreenChangeViewToFullScale);
    Printf(false, "");

    Printf(false, "%Bd %Ftorigin (maps to center of screen)%E");
    Printf(false, "%Ba   (%s, %s, %s) %Fl%Ll%f[edit]%E",
        SS.MmToString(-SS.GW.offset.x).c_str(),
        SS.MmToString(-SS.GW.offset.y).c_str(),
        SS.MmToString(-SS.GW.offset.z).c_str(),
        &amp;ScreenChangeViewOrigin);
    Printf(false, "");

    Vector n = (SS.GW.projRight).Cross(SS.GW.projUp);
    Printf(false, "%Bd %Ftprojection onto screen%E");
    Printf(false, "%Ba   %Ftright%E (%3, %3, %3) %Fl%Ll%f[edit]%E",
        CO(SS.GW.projRight),
        &amp;ScreenChangeViewProjection);
    Printf(false, "%Bd   %Ftup%E    (%3, %3, %3)", CO(SS.GW.projUp));
    Printf(false, "%Ba   %Ftout%E   (%3, %3, %3)", CO(n));
    Printf(false, "");

    Printf(false, "The perspective may be changed in the");
    Printf(false, "configuration screen.");
}

</t>
<t tx="leo1.20171224221230.58">void TextWindow::ScreenChangeViewScale(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::VIEW_SCALE;
    SS.TW.ShowEditControl(3, ssprintf("%.3f", SS.GW.scale * SS.MmPerUnit()));
}

</t>
<t tx="leo1.20171224221230.59">void TextWindow::ScreenChangeViewToFullScale(int link, uint32_t v) {
    SS.GW.scale = GetScreenDpi() / 25.4;
}

</t>
<t tx="leo1.20171224221230.6">bool GraphicsWindow::ToolbarDrawOrHitTest(int mx, int my,
                                          UiCanvas *canvas, Command *menuHit)
{
    int i;
    int x = 17, y = (int)(height - 52);

    int fudge = 8;
    int h = 34*16 + 3*16 + fudge;
    int aleft = 0, aright = 66, atop = y+16+fudge/2, abot = y+16-h;

    @others
}

</t>
<t tx="leo1.20171224221230.60">void TextWindow::ScreenChangeViewOrigin(int link, uint32_t v) {
    std::string edit_value =
        ssprintf("%s, %s, %s",
            SS.MmToString(-SS.GW.offset.x).c_str(),
            SS.MmToString(-SS.GW.offset.y).c_str(),
            SS.MmToString(-SS.GW.offset.z).c_str());

    SS.TW.edit.meaning = Edit::VIEW_ORIGIN;
    SS.TW.ShowEditControl(3, edit_value);
}

</t>
<t tx="leo1.20171224221230.61">void TextWindow::ScreenChangeViewProjection(int link, uint32_t v) {
    std::string edit_value =
        ssprintf("%.3f, %.3f, %.3f", CO(SS.GW.projRight));
    SS.TW.edit.meaning = Edit::VIEW_PROJ_RIGHT;
    SS.TW.ShowEditControl(10, edit_value);
}

</t>
<t tx="leo1.20171224221230.62">bool TextWindow::EditControlDoneForView(const char *s) {
    switch(edit.meaning) {
        case Edit::VIEW_SCALE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double v =  e-&gt;Eval() / SS.MmPerUnit();
                if(v &gt; LENGTH_EPS) {
                    SS.GW.scale = v;
                } else {
                    Error(_("Scale cannot be zero or negative."));
                }
            }
            break;
        }

        case Edit::VIEW_ORIGIN: {
            Vector pt;
            if(sscanf(s, "%lf, %lf, %lf", &amp;pt.x, &amp;pt.y, &amp;pt.z) == 3) {
                pt = pt.ScaledBy(SS.MmPerUnit());
                SS.GW.offset = pt.ScaledBy(-1);
            } else {
                Error(_("Bad format: specify x, y, z"));
            }
            break;
        }

        case Edit::VIEW_PROJ_RIGHT:
        case Edit::VIEW_PROJ_UP: {
            Vector pt;
            if(sscanf(s, "%lf, %lf, %lf", &amp;pt.x, &amp;pt.y, &amp;pt.z) != 3) {
                Error(_("Bad format: specify x, y, z"));
                break;
            }
            if(edit.meaning == Edit::VIEW_PROJ_RIGHT) {
                SS.GW.projRight = pt;
                SS.GW.NormalizeProjectionVectors();
                edit.meaning = Edit::VIEW_PROJ_UP;
                HideEditControl();
                ShowEditControl(10, ssprintf("%.3f, %.3f, %.3f", CO(SS.GW.projUp)),
                                editControl.halfRow + 2);
                edit.showAgain = true;
            } else {
                SS.GW.projUp = pt;
                SS.GW.NormalizeProjectionVectors();
            }
            break;
        }

        default:
            return false;
    }
    return true;
}

</t>
<t tx="leo1.20171224221230.63"></t>
<t tx="leo1.20171224221230.64">//-----------------------------------------------------------------------------
// Our main() function for the command-line interface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {
    // These are defined in headless.cpp, and aren't exposed in solvespace.h.
    extern std::shared_ptr&lt;Pixmap&gt; framebuffer;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221230.65">static void ShowUsage(const std::string &amp;cmd) {
    fprintf(stderr, "Usage: %s &lt;command&gt; &lt;options&gt; &lt;filename&gt; [filename...]", cmd.c_str());
//-----------------------------------------------------------------------------&gt; 80 col */
    fprintf(stderr, R"(
    When run, performs an action specified by &lt;command&gt; on every &lt;filename&gt;.

Common options:
    -o, --output &lt;pattern&gt;
        For an input file &lt;name&gt;.slvs, replaces the '%%' symbol in &lt;pattern&gt;
        with &lt;name&gt; and uses it as output file. For example, when using
        --output %%-2d.png for input files f/a.slvs and f/b.slvs, output files
        f/a-2d.png and f/b-2d.png will be written.
    -v, --view &lt;direction&gt;
        Selects the camera direction. &lt;direction&gt; can be one of "top", "bottom",
        "left", "right", "front", "back", or "isometric".
    -t, --chord-tol &lt;tolerance&gt;
        Selects the chord tolerance, used for converting exact curves to
        piecewise linear, and exact surfaces into triangle meshes.
        For export commands, the unit is mm, and the default is 1.0 mm.
        For non-export commands, the unit is %%, and the default is 1.0 %%.

Commands:
    thumbnail --output &lt;pattern&gt; --size &lt;size&gt; --view &lt;direction&gt;
              [--chord-tol &lt;tolerance&gt;]
        Outputs a rendered view of the sketch, like the SolveSpace GUI would.
        &lt;size&gt; is &lt;width&gt;x&lt;height&gt;, in pixels. Graphics acceleration is
        not used, and the output may look slightly different from the GUI.
    export-view --output &lt;pattern&gt; --view &lt;direction&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a view of the sketch, in a 2d vector format.
    export-wireframe --output &lt;pattern&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a wireframe of the sketch, in a 3d vector format.
    export-mesh --output &lt;pattern&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a triangle mesh of solids in the sketch, with exact surfaces
        being triangulated first.
    export-surfaces --output &lt;pattern&gt;
        Exports exact surfaces of solids in the sketch, if any.
    regenerate
        Reloads all imported files, regenerates the sketch, and saves it.
)");

    @others
}

</t>
<t tx="leo1.20171224221230.66">    auto FormatListFromFileFilter = [](const FileFilter *filter) {
        std::string descr;
        while(filter-&gt;name) {
            descr += "\n        ";
            descr += filter-&gt;name;
            descr += " (";
            const char *const *patterns = filter-&gt;patterns;
            while(*patterns) {
                descr += *patterns;
                if(*++patterns) {
                    descr += ", ";
                }
            }
            descr += ")";
            filter++;
        }
        return descr;
    };

    fprintf(stderr, R"(
File formats:
    thumbnail:%s
    export-view:%s
    export-wireframe:%s
    export-mesh:%s
    export-surfaces:%s
)", FormatListFromFileFilter(RasterFileFilter).c_str(),
    FormatListFromFileFilter(VectorFileFilter).c_str(),
    FormatListFromFileFilter(Vector3dFileFilter).c_str(),
    FormatListFromFileFilter(MeshFileFilter).c_str(),
    FormatListFromFileFilter(SurfaceFileFilter).c_str());
</t>
<t tx="leo1.20171224221230.67">static bool RunCommand(const std::vector&lt;std::string&gt; args) {
    if(args.size() &lt; 2) return false;

    for(const std::string &amp;arg : args) {
        if(arg == "--help" || arg == "-h") {
            ShowUsage(args[0]);
            return true;
        }
    }

    std::function&lt;void(const Platform::Path &amp;)&gt; runner;

    std::vector&lt;Platform::Path&gt; inputFiles;
    @others
}

</t>
<t tx="leo1.20171224221230.68">auto ParseInputFile = [&amp;](size_t &amp;argn) {
    std::string arg = args[argn];
    if(arg[0] != '-') {
        inputFiles.push_back(Platform::Path::From(arg));
        return true;
    } else return false;
};

std::string outputPattern;
</t>
<t tx="leo1.20171224221230.69">auto ParseOutputPattern = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--output" ||
                                  args[argn] == "-o")) {
        argn++;
        outputPattern = args[argn];
        return true;
    } else return false;
};

Vector projUp = {}, projRight = {};
</t>
<t tx="leo1.20171224221230.7">bool withinToolbar =
    (mx &gt;= aleft &amp;&amp; mx &lt;= aright &amp;&amp; my &lt;= atop &amp;&amp; my &gt;= abot);

if(!canvas &amp;&amp; !withinToolbar) {
    // This gets called every MouseMove event, so return quickly.
    return false;
}

if(canvas) {
    canvas-&gt;DrawRect(aleft, aright, atop, abot,
                    /*fillColor=*/{ 30, 30, 30, 255 },
                    /*outlineColor=*/{});
}

bool showTooltip = false;
std::string tooltip;

bool leftpos = true;
for(ToolIcon &amp;icon : Toolbar) {
    if(icon.name == "") { // spacer
        if(!leftpos) {
            leftpos = true;
            y -= 32;
            x -= 32;
        }
        y -= 16;

        if(canvas) {
            // Draw a separator bar in a slightly different color.
            int divw = 30, divh = 2;
            canvas-&gt;DrawRect(x+16+divw, x+16-divw, y+24+divh, y+24-divh,
                             /*fillColor=*/{ 45, 45, 45, 255 },
                             /*outlineColor=*/{});
        }

        continue;
    }

    if(icon.pixmap == nullptr) {
        icon.pixmap = LoadPng("icons/graphics-window/" + icon.name + ".png");
    }

    if(canvas) {
        canvas-&gt;DrawPixmap(icon.pixmap,
                           x - (int)icon.pixmap-&gt;width  / 2,
                           y - (int)icon.pixmap-&gt;height / 2);

        if(toolbarHovered == icon.command ||
           (pending.operation == Pending::COMMAND &amp;&amp;
            pending.command == icon.command)) {
            // Highlight the hovered or pending item.
            int boxhw = 15;
            canvas-&gt;DrawRect(x+boxhw, x-boxhw, y+boxhw, y-boxhw,
                             /*fillColor=*/{ 255, 255, 0, 75 },
                             /*outlineColor=*/{});
        }

        if(toolbarTooltipped == icon.command) {
            // Display the tool tip for this item; postpone till later
            // so that no one draws over us. Don't need position since
            // that's just wherever the mouse is.
            showTooltip = true;
            tooltip     = Translate(icon.tooltip);
        }
    } else {
        int boxhw = 16;
        if(mx &lt; (x+boxhw) &amp;&amp; mx &gt; (x - boxhw) &amp;&amp;
           my &lt; (y+boxhw) &amp;&amp; my &gt; (y - boxhw))
        {
            if(menuHit) *menuHit = icon.command;
        }
    }

    if(leftpos) {
        x += 32;
        leftpos = false;
    } else {
        x -= 32;
        y -= 32;
        leftpos = true;
    }
}

if(canvas) {
    // Do this last so that nothing can draw over it.
    if(showTooltip) {
        for(i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
            if(toolbarTooltipped == SS.GW.menu[i].id) {
                std::string accel = MakeAcceleratorLabel(SS.GW.menu[i].accel);
                if(!accel.empty()) {
                    tooltip += ssprintf(" (%s)", accel.c_str());
                }
                break;
            }
        }

        int tw = (int)canvas-&gt;canvas-&gt;GetBitmapFont()-&gt;GetWidth(tooltip) * 8 + 10,
return withinToolbar;
</t>
<t tx="leo1.20171224221230.70">auto ParseViewDirection = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--view" ||
                                  args[argn] == "-v")) {
        argn++;
        if(args[argn] == "top") {
            projRight = Vector::From(1, 0, 0);
            projUp    = Vector::From(0, 1, 0);
        } else if(args[argn] == "bottom") {
            projRight = Vector::From(-1, 0, 0);
            projUp    = Vector::From(0, 1, 0);
        } else if(args[argn] == "left") {
            projRight = Vector::From(0, 1, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "right") {
            projRight = Vector::From(0, -1, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "front") {
            projRight = Vector::From(-1, 0, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "back") {
            projRight = Vector::From(1, 0, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "isometric") {
            projRight = Vector::From(0.707,  0.000, -0.707);
            projUp    = Vector::From(-0.408, 0.816, -0.408);
        } else {
            fprintf(stderr, "Unrecognized view direction '%s'\n", args[argn].c_str());
        }
        return true;
    } else return false;
};

double chordTol = 1.0;
</t>
<t tx="leo1.20171224221230.71">auto ParseChordTolerance = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--chord-ol" ||
                                  args[argn] == "-t")) {
        argn++;
        if(sscanf(args[argn].c_str(), "%lf", &amp;chordTol) == 1) {
            return true;
        } else return false;
    } else return false;
};

unsigned width = 0, height = 0;
if(args[1] == "thumbnail") {
</t>
<t tx="leo1.20171224221230.72">    auto ParseSize = [&amp;](size_t &amp;argn) {
        if(argn + 1 &lt; args.size() &amp;&amp; args[argn] == "--size") {
            argn++;
            if(sscanf(args[argn].c_str(), "%ux%u", &amp;width, &amp;height) == 2) {
                return true;
            } else return false;
        } else return false;
    };

    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseViewDirection(argn) ||
             ParseChordTolerance(argn) ||
             ParseSize(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    if(width == 0 || height == 0) {
        fprintf(stderr, "Non-zero viewport size must be specified.\n");
        return false;
    }

    if(EXACT(projUp.Magnitude() == 0 || projRight.Magnitude() == 0)) {
        fprintf(stderr, "View direction must be specified.\n");
        return false;
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.GW.width     = width;
        SS.GW.height    = height;
        SS.GW.projRight = projRight;
        SS.GW.projUp    = projUp;
        SS.chordTol     = chordTol;

        SS.GW.ZoomToFit(/*includingInvisibles=*/false);
        SS.GenerateAll();
        PaintGraphics();
        framebuffer-&gt;WritePng(output, /*flip=*/true);
    };
} else if(args[1] == "export-view") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseViewDirection(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    if(EXACT(projUp.Magnitude() == 0 || projRight.Magnitude() == 0)) {
        fprintf(stderr, "View direction must be specified.\n");
        return false;
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.GW.projRight   = projRight;
        SS.GW.projUp      = projUp;
        SS.exportChordTol = chordTol;

        SS.ExportViewOrWireframeTo(output, /*exportWireframe=*/false);
    };
} else if(args[1] == "export-wireframe") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.exportChordTol = chordTol;

        SS.ExportViewOrWireframeTo(output, /*exportWireframe=*/true);
    };
} else if(args[1] == "export-mesh") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.exportChordTol = chordTol;

        SS.ExportMeshTo(output);
    };
} else if(args[1] == "export-surfaces") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        StepFileWriter sfw = {};
        sfw.ExportSurfacesTo(output);
    };
} else if(args[1] == "regenerate") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    outputPattern = "%.slvs";

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.SaveToFile(output);
    };
} else {
    fprintf(stderr, "Unrecognized command '%s'.\n", args[1].c_str());
    return false;
}

if(outputPattern.empty()) {
    fprintf(stderr, "An output pattern must be specified.\n");
    return false;
} else if(outputPattern.find('%') == std::string::npos &amp;&amp; inputFiles.size() &gt; 1) {
    fprintf(stderr,
            "Output pattern must include a %% symbol when using multiple inputs!\n");
    return false;
}

if(inputFiles.size() == 0) {
    fprintf(stderr, "At least one input file must be specified.\n");
    return false;
}

for(const Platform::Path &amp;inputFile : inputFiles) {
    Platform::Path absInputFile = inputFile.Expand(/*fromCurrentDirectory=*/true);

    Platform::Path outputFile = Platform::Path::From(outputPattern);
    size_t replaceAt = outputFile.raw.find('%');
    if(replaceAt != std::string::npos) {
        Platform::Path outputSubst = inputFile.Parent();
        outputSubst = outputSubst.Join(inputFile.FileStem());
        outputFile.raw.replace(replaceAt, 1, outputSubst.raw);
    }
    Platform::Path absOutputFile = outputFile.Expand(/*fromCurrentDirectory=*/true);

    SS.Init();
    if(!SS.LoadFromFile(absInputFile)) {
        fprintf(stderr, "Cannot load '%s'!\n", inputFile.raw.c_str());
        return false;
    }
    SS.AfterNewFile();
    runner(absOutputFile);
    SK.Clear();
    SS.Clear();

    fprintf(stderr, "Written '%s'.\n", outputFile.raw.c_str());
}

return true;
</t>
<t tx="leo1.20171224221230.73">int main(int argc, char **argv) {
    std::vector&lt;std::string&gt; args = InitPlatform(argc, argv);

    if(args.size() == 1) {
        ShowUsage(args[0]);
        return 0;
    }

    if(!RunCommand(args)) {
        return 1;
    } else {
        return 0;
    }
}
</t>
<t tx="leo1.20171224221230.74">//-----------------------------------------------------------------------------
// Our main() function, and GTK2/3-specific stuff to set up our windows and
// otherwise handle our interface to the operating system. Everything
// outside platform/... should be standard C++ and OpenGL.
//
// Copyright 2015 &lt;whitequark@whitequark.org&gt;
//-----------------------------------------------------------------------------
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#include &lt;json-c/json_object.h&gt;
#include &lt;json-c/json_util.h&gt;

#include &lt;glibmm/main.h&gt;
#include &lt;glibmm/convert.h&gt;
#include &lt;giomm/file.h&gt;
#include &lt;gdkmm/cursor.h&gt;
#include &lt;gtkmm/cssprovider.h&gt;
#include &lt;gtkmm/drawingarea.h&gt;
#include &lt;gtkmm/glarea.h&gt;
#include &lt;gtkmm/scrollbar.h&gt;
#include &lt;gtkmm/entry.h&gt;
#include &lt;gtkmm/eventbox.h&gt;
#include &lt;gtkmm/hvbox.h&gt;
#include &lt;gtkmm/fixed.h&gt;
#include &lt;gtkmm/adjustment.h&gt;
#include &lt;gtkmm/separatormenuitem.h&gt;
#include &lt;gtkmm/menuitem.h&gt;
#include &lt;gtkmm/checkmenuitem.h&gt;
#include &lt;gtkmm/radiomenuitem.h&gt;
#include &lt;gtkmm/radiobuttongroup.h&gt;
#include &lt;gtkmm/menu.h&gt;
#include &lt;gtkmm/menubar.h&gt;
#include &lt;gtkmm/filechooserdialog.h&gt;
#include &lt;gtkmm/messagedialog.h&gt;
#include &lt;gtkmm/main.h&gt;

#include &lt;cairomm/xlib_surface.h&gt;
#include &lt;pangomm/fontdescription.h&gt;
#include &lt;gdk/gdkx.h&gt;
#include &lt;fontconfig/fontconfig.h&gt;

#include &lt;GL/glx.h&gt;

#include "solvespace.h"
#include "config.h"

#ifdef HAVE_SPACEWARE
#include &lt;spnav.h&gt;
#endif

namespace SolveSpace {
/* Utility functions */
std::string Title(const std::string &amp;s) {
    return "SolveSpace - " + s;
}

/* Settings */

/* Why not just use GSettings? Two reasons. It doesn't allow to easily see
   whether the setting had the default value, and it requires to install
   a schema globally. */
static json_object *settings = NULL;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221230.8">void GraphicsWindow::TimerCallback() {
    SS.GW.toolbarTooltipped = SS.GW.toolbarHovered;
    PaintGraphics();
}

</t>
<t tx="leo1.20171224221230.9">//-----------------------------------------------------------------------------
// Routines to read a TrueType font as vector outlines, and generate them
// as entities, since they're always representable as either lines or
// quadratic Bezier curves.
//
// Copyright 2016 whitequark, Peter Barfuss.
//-----------------------------------------------------------------------------
#include &lt;ft2build.h&gt;
#include FT_FREETYPE_H
#include FT_OUTLINE_H
#include FT_ADVANCES_H

/* Yecch. Irritatingly, you need to do this nonsense to get the error string table,
   since nobody thought to put this exact function into FreeType itsself. */
#undef __FTERRORS_H__
#define FT_ERRORDEF(e, v, s) { (e), (s) },
#define FT_ERROR_START_LIST
#define FT_ERROR_END_LIST { 0, NULL }

struct ft_error {
    int err;
    const char *str;
};

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221232.1">static std::string CnfPrepare() {
    // Refer to http://standards.freedesktop.org/basedir-spec/latest/

    std::string dir;
    if(getenv("XDG_CONFIG_HOME")) {
        dir = std::string(getenv("XDG_CONFIG_HOME")) + "/solvespace";
    } else if(getenv("HOME")) {
        dir = std::string(getenv("HOME")) + "/.config/solvespace";
    } else {
        dbp("neither XDG_CONFIG_HOME nor HOME are set");
        return "";
    }

    struct stat st;
    if(stat(dir.c_str(), &amp;st)) {
        if(errno == ENOENT) {
            if(mkdir(dir.c_str(), 0777)) {
                dbp("cannot mkdir %s: %s", dir.c_str(), strerror(errno));
                return "";
            }
        } else {
            dbp("cannot stat %s: %s", dir.c_str(), strerror(errno));
            return "";
        }
    } else if(!S_ISDIR(st.st_mode)) {
        dbp("%s is not a directory", dir.c_str());
        return "";
    }

    return dir + "/settings.json";
}

</t>
<t tx="leo1.20171224221232.10">static bool TimerCallback() {
    SS.GW.TimerCallback();
    SS.TW.TimerCallback();
    return false;
}

</t>
<t tx="leo1.20171224221232.11">void SetTimerFor(int milliseconds) {
    Glib::signal_timeout().connect(&amp;TimerCallback, milliseconds);
}

</t>
<t tx="leo1.20171224221232.12">static bool AutosaveTimerCallback() {
    SS.Autosave();
    return false;
}

</t>
<t tx="leo1.20171224221232.13">void SetAutosaveTimerFor(int minutes) {
    Glib::signal_timeout().connect(&amp;AutosaveTimerCallback, minutes * 60 * 1000);
}

</t>
<t tx="leo1.20171224221232.14">static bool LaterCallback() {
    SS.DoLater();
    return false;
}

</t>
<t tx="leo1.20171224221232.15">void ScheduleLater() {
    Glib::signal_timeout().connect(&amp;LaterCallback, 0);
}

/* Editor overlay */

</t>
<t tx="leo1.20171224221232.16">class EditorOverlay : public Gtk::Fixed {
public:
    EditorOverlay(Gtk::Widget &amp;underlay) : _underlay(underlay) {
        set_size_request(0, 0);

        add(_underlay);

        _entry.set_no_show_all(true);
        _entry.set_has_frame(false);
        add(_entry);

        _entry.signal_activate().
            connect(sigc::mem_fun(this, &amp;EditorOverlay::on_activate));
    }

    @others
};

/* Graphics window */

double DeltaYOfScrollEvent(GdkEventScroll *event) {
    double delta_y = event-&gt;delta_y;
    if(delta_y == 0) {
        switch(event-&gt;direction) {
            case GDK_SCROLL_UP:
            delta_y = -1;
            break;

            case GDK_SCROLL_DOWN:
            delta_y = 1;
            break;

            default:
            /* do nothing */
            return false;
        }
    }

    return delta_y;
}

</t>
<t tx="leo1.20171224221232.17">void start_editing(int x, int y, int font_height, bool is_monospace, int minWidthChars,
                   const std::string &amp;val) {
    x /= get_scale_factor();
    y /= get_scale_factor();
    font_height /= get_scale_factor();

    Pango::FontDescription font_desc;
    font_desc.set_family(is_monospace ? "monospace" : "normal");
    font_desc.set_absolute_size(font_height * Pango::SCALE);
    _entry.override_font(font_desc);

    /* y coordinate denotes baseline */
    Pango::FontMetrics font_metrics = get_pango_context()-&gt;get_metrics(font_desc);
    y -= font_metrics.get_ascent() / Pango::SCALE;

    Glib::RefPtr&lt;Pango::Layout&gt; layout = Pango::Layout::create(get_pango_context());
    layout-&gt;set_font_description(font_desc);
    layout-&gt;set_text(val + " "); /* avoid scrolling */
    int width = layout-&gt;get_logical_extents().get_width();

    Gtk::Border margin  = _entry.get_style_context()-&gt;get_margin();
    Gtk::Border border  = _entry.get_style_context()-&gt;get_border();
    Gtk::Border padding = _entry.get_style_context()-&gt;get_padding();
    move(_entry,
         x - margin.get_left() - border.get_left() - padding.get_left(),
         y - margin.get_top()  - border.get_top()  - padding.get_top());
    _entry.set_width_chars(minWidthChars);
    _entry.set_size_request(
        width / Pango::SCALE + padding.get_left() + padding.get_right(),
        -1);

    _entry.set_text(val);
    if(!_entry.is_visible()) {
        _entry.show();
        _entry.grab_focus();
        add_modal_grab();
    }
}

</t>
<t tx="leo1.20171224221232.18">void stop_editing() {
    if(_entry.is_visible()) {
        remove_modal_grab();
    }
    _entry.hide();
}

</t>
<t tx="leo1.20171224221232.19">    bool is_editing() const {
        return _entry.is_visible();
    }

    sigc::signal&lt;void, Glib::ustring&gt; signal_editing_done() {
        return _signal_editing_done;
    }

    Gtk::Entry &amp;get_entry() {
        return _entry;
    }

protected:
</t>
<t tx="leo1.20171224221232.2">static void CnfLoad() {
    std::string path = CnfPrepare();
    if(path.empty())
        return;

    if(settings)
        json_object_put(settings); // deallocate

    settings = json_object_from_file(path.c_str());
    if(!settings) {
        if(errno != ENOENT)
            dbp("cannot load settings: %s", strerror(errno));

        settings = json_object_new_object();
    }
}

</t>
<t tx="leo1.20171224221232.20">bool on_key_press_event(GdkEventKey *event) override {
    if(is_editing()) {
        if(event-&gt;keyval == GDK_KEY_Escape) {
            stop_editing();
        } else {
            _entry.event((GdkEvent *)event);
        }
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221232.21">bool on_key_release_event(GdkEventKey *event) override {
    if(is_editing()) {
        _entry.event((GdkEvent *)event);
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221232.22">void on_size_allocate(Gtk::Allocation&amp; allocation) override {
    Gtk::Fixed::on_size_allocate(allocation);

    _underlay.size_allocate(allocation);
}

</t>
<t tx="leo1.20171224221232.23">    void on_activate() {
        _signal_editing_done(_entry.get_text());
    }

private:
    Gtk::Widget &amp;_underlay;
    Gtk::Entry _entry;
    sigc::signal&lt;void, Glib::ustring&gt; _signal_editing_done;
</t>
<t tx="leo1.20171224221232.24">class GraphicsWidget : public Gtk::GLArea {
public:
    GraphicsWidget() {
        set_events(Gdk::POINTER_MOTION_MASK |
                   Gdk::BUTTON_PRESS_MASK | Gdk::BUTTON_RELEASE_MASK | Gdk::BUTTON_MOTION_MASK |
                   Gdk::SCROLL_MASK |
                   Gdk::LEAVE_NOTIFY_MASK);
        set_has_depth_buffer(true);
    }

protected:
    // Work around a bug fixed in GTKMM 3.22:
    // https://mail.gnome.org/archives/gtkmm-list/2016-April/msg00020.html
    Glib::RefPtr&lt;Gdk::GLContext&gt; on_create_context() override {
        return get_window()-&gt;create_gl_context();
    }

    @others
};

</t>
<t tx="leo1.20171224221232.25">void on_resize(int width, int height) override {
    _w = width;
    _h = height;
}

</t>
<t tx="leo1.20171224221232.26">bool on_render(const Glib::RefPtr&lt;Gdk::GLContext&gt; &amp;context) override {
    SS.GW.Paint();
    return true;
}

</t>
<t tx="leo1.20171224221232.27">bool on_motion_notify_event(GdkEventMotion *event) override {
    int x, y;
    ij_to_xy(event-&gt;x, event-&gt;y, x, y);

    SS.GW.MouseMoved(x, y,
        event-&gt;state &amp; GDK_BUTTON1_MASK,
        event-&gt;state &amp; GDK_BUTTON2_MASK,
        event-&gt;state &amp; GDK_BUTTON3_MASK,
        event-&gt;state &amp; GDK_SHIFT_MASK,
        event-&gt;state &amp; GDK_CONTROL_MASK);

    return true;
}

</t>
<t tx="leo1.20171224221232.28">bool on_button_press_event(GdkEventButton *event) override {
    int x, y;
    ij_to_xy(event-&gt;x, event-&gt;y, x, y);

    switch(event-&gt;button) {
        case 1:
        if(event-&gt;type == GDK_BUTTON_PRESS)
            SS.GW.MouseLeftDown(x, y);
        else if(event-&gt;type == GDK_2BUTTON_PRESS)
            SS.GW.MouseLeftDoubleClick(x, y);
        break;

        case 2:
        case 3:
        SS.GW.MouseMiddleOrRightDown(x, y);
        break;
    }

    return true;
}

</t>
<t tx="leo1.20171224221232.29">bool on_button_release_event(GdkEventButton *event) override {
    int x, y;
    ij_to_xy(event-&gt;x, event-&gt;y, x, y);

    switch(event-&gt;button) {
        case 1:
        SS.GW.MouseLeftUp(x, y);
        break;

        case 3:
        SS.GW.MouseRightUp(x, y);
        break;
    }

    return true;
}

</t>
<t tx="leo1.20171224221232.3">static void CnfSave() {
    std::string path = CnfPrepare();
    if(path.empty())
        return;

    /* json-c &lt;0.12 has the first argument non-const here */
    if(json_object_to_file_ext((char*) path.c_str(), settings, JSON_C_TO_STRING_PRETTY))
        dbp("cannot save settings: %s", strerror(errno));
}

</t>
<t tx="leo1.20171224221232.30">bool on_scroll_event(GdkEventScroll *event) override {
    int x, y;
    ij_to_xy(event-&gt;x, event-&gt;y, x, y);

    SS.GW.MouseScroll(x, y, (int)-DeltaYOfScrollEvent(event));

    return true;
}

</t>
<t tx="leo1.20171224221232.31">    bool on_leave_notify_event (GdkEventCrossing *) override {
        SS.GW.MouseLeave();

        return true;
    }

private:
    int _w, _h;
</t>
<t tx="leo1.20171224221232.32">void ij_to_xy(double i, double j, int &amp;x, int &amp;y) {
    // Convert to xy (vs. ij) style coordinates,
    // with (0, 0) at center
    x = (int)(i * get_scale_factor()) - _w / 2;
    y = _h / 2 - (int)(j * get_scale_factor());
}
</t>
<t tx="leo1.20171224221232.33">class GraphicsWindowGtk : public Gtk::Window {
public:
    GraphicsWindowGtk() : _overlay(_widget), _is_fullscreen(false) {
        set_default_size(900, 600);

        _box.pack_start(_menubar, false, true);
        _box.pack_start(_overlay, true, true);

        add(_box);

        _overlay.signal_editing_done().
            connect(sigc::mem_fun(this, &amp;GraphicsWindowGtk::on_editing_done));
    }

    GraphicsWidget &amp;get_widget() {
        return _widget;
    }

    EditorOverlay &amp;get_overlay() {
        return _overlay;
    }

    Gtk::MenuBar &amp;get_menubar() {
        return _menubar;
    }

    @others
};

std::unique_ptr&lt;GraphicsWindowGtk&gt; GW;

</t>
<t tx="leo1.20171224221232.34">    bool is_fullscreen() const {
        return _is_fullscreen;
    }

protected:
</t>
<t tx="leo1.20171224221232.35">void on_show() override {
    Gtk::Window::on_show();

    CnfThawWindowPos(this, "GraphicsWindow");
}

</t>
<t tx="leo1.20171224221232.36">void on_hide() override {
    CnfFreezeWindowPos(this, "GraphicsWindow");

    Gtk::Window::on_hide();
}

</t>
<t tx="leo1.20171224221232.37">bool on_delete_event(GdkEventAny *) override {
    if(!SS.OkayToStartNewFile()) return true;
    SS.Exit();

    return true;
}

</t>
<t tx="leo1.20171224221232.38">bool on_window_state_event(GdkEventWindowState *event) override {
    _is_fullscreen = event-&gt;new_window_state &amp; GDK_WINDOW_STATE_FULLSCREEN;

    /* The event arrives too late for the caller of ToggleFullScreen
       to notice state change; and it's possible that the WM will
       refuse our request, so we can't just toggle the saved state */
    SS.GW.EnsureValidActives();

    return Gtk::Window::on_window_state_event(event);
}

</t>
<t tx="leo1.20171224221232.39">bool on_key_press_event(GdkEventKey *event) override {
    int chr;

    switch(event-&gt;keyval) {
        case GDK_KEY_Escape:
        chr = GraphicsWindow::ESCAPE_KEY;
        break;

        case GDK_KEY_Delete:
        chr = GraphicsWindow::DELETE_KEY;
        break;

        case GDK_KEY_Tab:
        chr = '\t';
        break;

        case GDK_KEY_BackSpace:
        case GDK_KEY_Back:
        chr = '\b';
        break;

        case GDK_KEY_KP_Decimal:
        chr = '.';
        break;

        default:
        if(event-&gt;keyval &gt;= GDK_KEY_F1 &amp;&amp; event-&gt;keyval &lt;= GDK_KEY_F12) {
            chr = GraphicsWindow::FUNCTION_KEY_BASE + (event-&gt;keyval - GDK_KEY_F1);
        } else {
            chr = gdk_keyval_to_unicode(event-&gt;keyval);
        }
    }

    if(event-&gt;state &amp; GDK_SHIFT_MASK){
        chr |= GraphicsWindow::SHIFT_MASK;
    }
    if(event-&gt;state &amp; GDK_CONTROL_MASK) {
        chr |= GraphicsWindow::CTRL_MASK;
    }

    if(chr &amp;&amp; SS.GW.KeyDown(chr)) {
        return true;
    }

    if(chr == '\t') {
        // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=123994.
        GraphicsWindow::MenuView(Command::SHOW_TEXT_WND);
        return true;
    }

    return Gtk::Window::on_key_press_event(event);
}

</t>
<t tx="leo1.20171224221232.4">void CnfFreezeInt(uint32_t val, const std::string &amp;key) {
    struct json_object *jval = json_object_new_int(val);
    json_object_object_add(settings, key.c_str(), jval);
    CnfSave();
}

uint32_t CnfThawInt(uint32_t val, const std::string &amp;key) {
    struct json_object *jval;
    if(json_object_object_get_ex(settings, key.c_str(), &amp;jval))
        return json_object_get_int(jval);
    else return val;
}

</t>
<t tx="leo1.20171224221232.40">    void on_editing_done(Glib::ustring value) {
        SS.GW.EditControlDone(value.c_str());
    }

private:
    GraphicsWidget _widget;
    EditorOverlay _overlay;
    Gtk::MenuBar _menubar;
    Gtk::VBox _box;

    bool _is_fullscreen;
</t>
<t tx="leo1.20171224221232.41">void GetGraphicsWindowSize(int *w, int *h) {
    Gdk::Rectangle allocation = GW-&gt;get_widget().get_allocation();
    *w = allocation.get_width() * GW-&gt;get_scale_factor();
    *h = allocation.get_height() * GW-&gt;get_scale_factor();
}

</t>
<t tx="leo1.20171224221232.42">void InvalidateGraphics(void) {
    GW-&gt;get_widget().queue_draw();
}

</t>
<t tx="leo1.20171224221232.43">void PaintGraphics(void) {
    GW-&gt;get_widget().queue_draw();
    /* Process animation */
    Glib::MainContext::get_default()-&gt;iteration(false);
}

</t>
<t tx="leo1.20171224221232.44">void SetCurrentFilename(const Platform::Path &amp;filename) {
    GW-&gt;set_title(Title(filename.IsEmpty() ? C_("title", "(new sketch)") : filename.raw.c_str()));
}

</t>
<t tx="leo1.20171224221232.45">void ToggleFullScreen(void) {
    if(GW-&gt;is_fullscreen())
        GW-&gt;unfullscreen();
    else
        GW-&gt;fullscreen();
}

</t>
<t tx="leo1.20171224221232.46">bool FullScreenIsActive(void) {
    return GW-&gt;is_fullscreen();
}

</t>
<t tx="leo1.20171224221232.47">void ShowGraphicsEditControl(int x, int y, int fontHeight, int minWidthChars,
                             const std::string &amp;val) {
    Gdk::Rectangle rect = GW-&gt;get_widget().get_allocation();

    // Convert to ij (vs. xy) style coordinates,
    // and compensate for the input widget height due to inverse coord
    int i, j;
    i = x + rect.get_width() / 2 * GW-&gt;get_widget().get_scale_factor();
    j = -y + rect.get_height() / 2 * GW-&gt;get_widget().get_scale_factor();

    GW-&gt;get_overlay().start_editing(i, j, fontHeight, /*is_monospace=*/false, minWidthChars, val);
}

</t>
<t tx="leo1.20171224221232.48">void HideGraphicsEditControl(void) {
    GW-&gt;get_overlay().stop_editing();
}

</t>
<t tx="leo1.20171224221232.49">bool GraphicsEditControlIsVisible(void) {
    return GW-&gt;get_overlay().is_editing();
}

/* Context menus */

</t>
<t tx="leo1.20171224221232.5">void CnfFreezeFloat(float val, const std::string &amp;key) {
    struct json_object *jval = json_object_new_double(val);
    json_object_object_add(settings, key.c_str(), jval);
    CnfSave();
}

</t>
<t tx="leo1.20171224221232.50">class ContextMenuItem : public Gtk::MenuItem {
public:
    static ContextCommand choice;

    ContextMenuItem(const Glib::ustring &amp;label, ContextCommand cmd, bool mnemonic=false) :
            Gtk::MenuItem(label, mnemonic), _cmd(cmd) {
    }

protected:
    @others
};

ContextCommand ContextMenuItem::choice = ContextCommand::CANCELLED;

static Gtk::Menu *context_menu = NULL, *context_submenu = NULL;

</t>
<t tx="leo1.20171224221232.51">void on_activate() override {
    Gtk::MenuItem::on_activate();

    if(has_submenu())
        return;

    choice = _cmd;
}

/* Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=695488.
   This is used in addition to on_activate() to catch mouse events.
   Without on_activate(), it would be impossible to select a menu item
   via keyboard.
   This selects the item twice in some cases, but we are idempotent.
 */
</t>
<t tx="leo1.20171224221232.52">    bool on_button_press_event(GdkEventButton *event) override {
        if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS) {
            on_activate();
            return true;
        }

        return Gtk::MenuItem::on_button_press_event(event);
    }

private:
    ContextCommand _cmd;
</t>
<t tx="leo1.20171224221232.53">void AddContextMenuItem(const char *label, ContextCommand cmd) {
    Gtk::MenuItem *menu_item;
    if(label)
        menu_item = new ContextMenuItem(label, cmd);
    else
        menu_item = new Gtk::SeparatorMenuItem();

    if(cmd == ContextCommand::SUBMENU) {
        menu_item-&gt;set_submenu(*context_submenu);
        context_submenu = NULL;
    }

    if(context_submenu) {
        context_submenu-&gt;append(*menu_item);
    } else {
        if(!context_menu)
            context_menu = new Gtk::Menu;

        context_menu-&gt;append(*menu_item);
    }
}

</t>
<t tx="leo1.20171224221232.54">void CreateContextSubmenu(void) {
    ssassert(!context_submenu, "Unexpected nested submenu");

    context_submenu = new Gtk::Menu;
}

ContextCommand ShowContextMenu(void) {
    if(!context_menu)
        return ContextCommand::CANCELLED;

    Glib::RefPtr&lt;Glib::MainLoop&gt; loop = Glib::MainLoop::create();
    context_menu-&gt;signal_deactivate().
        connect(sigc::mem_fun(loop.operator-&gt;(), &amp;Glib::MainLoop::quit));

    ContextMenuItem::choice = ContextCommand::CANCELLED;

    context_menu-&gt;show_all();
    context_menu-&gt;popup(3, GDK_CURRENT_TIME);

    loop-&gt;run();

    delete context_menu;
    context_menu = NULL;

    return ContextMenuItem::choice;
}

/* Main menu */

template&lt;class MenuItem&gt; class MainMenuItem : public MenuItem {
public:
    MainMenuItem(const GraphicsWindow::MenuEntry &amp;entry) :
            MenuItem(), _entry(entry), _synthetic(false) {
        Glib::ustring label(_entry.label);
        for(size_t i = 0; i &lt; label.length(); i++) {
            if(label[i] == '&amp;')
                label.replace(i, 1, "_");
        }

        guint accel_key = 0;
        Gdk::ModifierType accel_mods = Gdk::ModifierType();
        switch(_entry.accel) {
            case GraphicsWindow::DELETE_KEY:
            accel_key = GDK_KEY_Delete;
            break;

            case GraphicsWindow::ESCAPE_KEY:
            accel_key = GDK_KEY_Escape;
            break;

            case '\t':
            accel_key = GDK_KEY_Tab;
            break;

            default:
            accel_key = _entry.accel &amp; ~(GraphicsWindow::SHIFT_MASK | GraphicsWindow::CTRL_MASK);
            if(accel_key &gt; GraphicsWindow::FUNCTION_KEY_BASE &amp;&amp;
                    accel_key &lt;= GraphicsWindow::FUNCTION_KEY_BASE + 12)
                accel_key = GDK_KEY_F1 + (accel_key - GraphicsWindow::FUNCTION_KEY_BASE - 1);
            else
                accel_key = gdk_unicode_to_keyval(accel_key);

            if(_entry.accel &amp; GraphicsWindow::SHIFT_MASK)
                accel_mods |= Gdk::SHIFT_MASK;
            if(_entry.accel &amp; GraphicsWindow::CTRL_MASK)
                accel_mods |= Gdk::CONTROL_MASK;
        }

        MenuItem::set_label(label);
        MenuItem::set_use_underline(true);
        if(!(accel_key &amp; 0x01000000))
            MenuItem::set_accel_key(Gtk::AccelKey(accel_key, accel_mods));
    }

</t>
<t tx="leo1.20171224221232.55">    void set_active(bool checked) {
        if(MenuItem::get_active() == checked)
            return;

       _synthetic = true;
        MenuItem::set_active(checked);
    }

protected:
</t>
<t tx="leo1.20171224221232.56">    void on_activate() override {
        MenuItem::on_activate();

        if(_synthetic)
            _synthetic = false;
        else if(!MenuItem::has_submenu() &amp;&amp; _entry.fn)
            _entry.fn(_entry.id);
    }

private:
    const GraphicsWindow::MenuEntry _entry;
    bool _synthetic;
};

static std::map&lt;uint32_t, Gtk::MenuItem *&gt; main_menu_items;

</t>
<t tx="leo1.20171224221232.57">static void InitMainMenu(Gtk::MenuShell *menu_shell) {
    Gtk::MenuItem *menu_item = NULL;
    Gtk::MenuShell *levels[5] = {menu_shell, 0};

    const GraphicsWindow::MenuEntry *entry = &amp;GraphicsWindow::menu[0];
    int current_level = 0;
    while(entry-&gt;level &gt;= 0) {
        if(entry-&gt;level &gt; current_level) {
            Gtk::Menu *menu = new Gtk::Menu;
            menu_item-&gt;set_submenu(*menu);

            ssassert((unsigned)entry-&gt;level &lt; sizeof(levels) / sizeof(levels[0]),
                     "Unexpected depth of menu nesting");

            levels[entry-&gt;level] = menu;
        }

        current_level = entry-&gt;level;

        if(entry-&gt;label) {
            GraphicsWindow::MenuEntry localizedEntry = *entry;
            localizedEntry.label = Translate(entry-&gt;label).c_str();

            switch(entry-&gt;kind) {
                case GraphicsWindow::MenuKind::NORMAL:
                menu_item = new MainMenuItem&lt;Gtk::MenuItem&gt;(localizedEntry);
                break;

                case GraphicsWindow::MenuKind::CHECK:
                menu_item = new MainMenuItem&lt;Gtk::CheckMenuItem&gt;(localizedEntry);
                break;

                case GraphicsWindow::MenuKind::RADIO:
                MainMenuItem&lt;Gtk::CheckMenuItem&gt; *radio_item =
                        new MainMenuItem&lt;Gtk::CheckMenuItem&gt;(localizedEntry);
                radio_item-&gt;set_draw_as_radio(true);
                menu_item = radio_item;
                break;
            }
        } else {
            menu_item = new Gtk::SeparatorMenuItem();
        }

        if(entry-&gt;id == Command::LOCALE) {
            Gtk::Menu *menu = new Gtk::Menu;
            menu_item-&gt;set_submenu(*menu);

            size_t i = 0;
            for(auto locale : Locales()) {
                GraphicsWindow::MenuEntry localeEntry = {};
                localeEntry.label = locale.displayName.c_str();
                localeEntry.id    = (Command)((uint32_t)Command::LOCALE + i++);
                localeEntry.fn    = entry-&gt;fn;
                menu-&gt;append(*new MainMenuItem&lt;Gtk::MenuItem&gt;(localeEntry));
            }
        }

        levels[entry-&gt;level]-&gt;append(*menu_item);

        main_menu_items[(uint32_t)entry-&gt;id] = menu_item;

        ++entry;
    }
}

</t>
<t tx="leo1.20171224221232.58">void EnableMenuByCmd(Command cmd, bool enabled) {
    main_menu_items[(uint32_t)cmd]-&gt;set_sensitive(enabled);
}

</t>
<t tx="leo1.20171224221232.59">void CheckMenuByCmd(Command cmd, bool checked) {
    ((MainMenuItem&lt;Gtk::CheckMenuItem&gt;*)main_menu_items[(uint32_t)cmd])-&gt;set_active(checked);
}

</t>
<t tx="leo1.20171224221232.6">float CnfThawFloat(float val, const std::string &amp;key) {
    struct json_object *jval;
    if(json_object_object_get_ex(settings, key.c_str(), &amp;jval))
        return json_object_get_double(jval);
    else return val;
}

</t>
<t tx="leo1.20171224221232.60">void RadioMenuByCmd(Command cmd, bool selected) {
    SolveSpace::CheckMenuByCmd(cmd, selected);
}

</t>
<t tx="leo1.20171224221232.61">class RecentMenuItem : public Gtk::MenuItem {
public:
    RecentMenuItem(const Glib::ustring&amp; label, uint32_t cmd) :
            MenuItem(label), _cmd(cmd) {
    }

protected:
    @others
};

</t>
<t tx="leo1.20171224221232.62">    void on_activate() override {
        if(_cmd &gt;= (uint32_t)Command::RECENT_OPEN &amp;&amp;
           _cmd &lt; ((uint32_t)Command::RECENT_OPEN + MAX_RECENT)) {
            SolveSpaceUI::MenuFile((Command)_cmd);
        } else if(_cmd &gt;= (uint32_t)Command::RECENT_LINK &amp;&amp;
                  _cmd &lt; ((uint32_t)Command::RECENT_LINK + MAX_RECENT)) {
            Group::MenuGroup((Command)_cmd);
        }
    }

private:
    uint32_t _cmd;
</t>
<t tx="leo1.20171224221232.63">static void RefreshRecentMenu(Command cmd, Command base) {
    Gtk::MenuItem *recent = static_cast&lt;Gtk::MenuItem*&gt;(main_menu_items[(uint32_t)cmd]);
    recent-&gt;unset_submenu();

    Gtk::Menu *menu = new Gtk::Menu;
    recent-&gt;set_submenu(*menu);

    if(RecentFile[0].IsEmpty()) {
        Gtk::MenuItem *placeholder = new Gtk::MenuItem(_("(no recent files)"));
        placeholder-&gt;set_sensitive(false);
        menu-&gt;append(*placeholder);
    } else {
        for(size_t i = 0; i &lt; MAX_RECENT; i++) {
            if(RecentFile[i].IsEmpty())
                break;

            RecentMenuItem *item = new RecentMenuItem(RecentFile[i].raw, (uint32_t)base + i);
            menu-&gt;append(*item);
        }
    }

    menu-&gt;show_all();
}

</t>
<t tx="leo1.20171224221232.64">void RefreshRecentMenus(void) {
    RefreshRecentMenu(Command::OPEN_RECENT, Command::RECENT_OPEN);
    RefreshRecentMenu(Command::GROUP_RECENT, Command::RECENT_LINK);
}

/* Save/load */

</t>
<t tx="leo1.20171224221232.65">static std::string ConvertFilters(std::string active, const FileFilter ssFilters[],
                                  Gtk::FileChooser *chooser) {
    for(const FileFilter *ssFilter = ssFilters; ssFilter-&gt;name; ssFilter++) {
        Glib::RefPtr&lt;Gtk::FileFilter&gt; filter = Gtk::FileFilter::create();
        filter-&gt;set_name(Translate(ssFilter-&gt;name));

        bool is_active = false;
        std::string desc = "";
        for(const char *const *ssPattern = ssFilter-&gt;patterns; *ssPattern; ssPattern++) {
            std::string pattern = "*." + std::string(*ssPattern);
            filter-&gt;add_pattern(pattern);
            filter-&gt;add_pattern(Glib::ustring(pattern).uppercase());
            if(active == "")
                active = pattern.substr(2);
            if("*." + active == pattern)
                is_active = true;
            if(desc == "")
                desc = pattern;
            else
                desc += ", " + pattern;
        }
        filter-&gt;set_name(filter-&gt;get_name() + " (" + desc + ")");

        chooser-&gt;add_filter(filter);
        if(is_active)
            chooser-&gt;set_filter(filter);
    }

    return active;
}

</t>
<t tx="leo1.20171224221232.66">bool GetOpenFile(Platform::Path *filename, const std::string &amp;activeOrEmpty,
                 const FileFilter filters[]) {
    Gtk::FileChooserDialog chooser(*GW, Title(C_("title", "Open File")));
    chooser.set_filename(filename-&gt;raw);
    chooser.add_button(_("_Cancel"), Gtk::RESPONSE_CANCEL);
    chooser.add_button(_("_Open"), Gtk::RESPONSE_OK);
    chooser.set_current_folder(CnfThawString("", "FileChooserPath"));

    ConvertFilters(activeOrEmpty, filters, &amp;chooser);

    if(chooser.run() == Gtk::RESPONSE_OK) {
        CnfFreezeString(chooser.get_current_folder(), "FileChooserPath");
        *filename = Platform::Path::From(chooser.get_filename());
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo1.20171224221232.67">static void ChooserFilterChanged(Gtk::FileChooserDialog *chooser)
{
    /* Extract the pattern from the filter. GtkFileFilter doesn't provide
       any way to list the patterns, so we extract it from the filter name.
       Gross. */
    std::string filter_name = chooser-&gt;get_filter()-&gt;get_name();
    int lparen = filter_name.rfind('(') + 1;
    int rdelim = filter_name.find(',', lparen);
    if(rdelim &lt; 0)
        rdelim = filter_name.find(')', lparen);
    ssassert(lparen &gt; 0 &amp;&amp; rdelim &gt; 0, "Expected to find a parenthesized extension");

    std::string extension = filter_name.substr(lparen, rdelim - lparen);
    if(extension == "*")
        return;

    if(extension.length() &gt; 2 &amp;&amp; extension.substr(0, 2) == "*.")
        extension = extension.substr(2, extension.length() - 2);

    Platform::Path path = Platform::Path::From(chooser-&gt;get_filename());
    chooser-&gt;set_current_name(path.WithExtension(extension).FileName());
}

</t>
<t tx="leo1.20171224221232.68">bool GetSaveFile(Platform::Path *filename, const std::string &amp;defExtension,
                 const FileFilter filters[]) {
    Gtk::FileChooserDialog chooser(*GW, Title(C_("title", "Save File")),
                                   Gtk::FILE_CHOOSER_ACTION_SAVE);
    chooser.set_do_overwrite_confirmation(true);
    chooser.add_button(C_("button", "_Cancel"), Gtk::RESPONSE_CANCEL);
    chooser.add_button(C_("button", "_Save"), Gtk::RESPONSE_OK);

    std::string activeExtension = ConvertFilters(defExtension, filters, &amp;chooser);

    if(filename-&gt;IsEmpty()) {
        chooser.set_current_folder(CnfThawString("", "FileChooserPath"));
        chooser.set_current_name(std::string(_("untitled")) + "." + activeExtension);
    } else {
        chooser.set_current_folder(filename-&gt;Parent().raw);
        chooser.set_current_name(filename-&gt;WithExtension(activeExtension).FileName());
    }

    /* Gtk's dialog doesn't change the extension when you change the filter,
       and makes it extremely hard to do so. Gtk is garbage. */
    chooser.property_filter().signal_changed().
       connect(sigc::bind(sigc::ptr_fun(&amp;ChooserFilterChanged), &amp;chooser));

    if(chooser.run() == Gtk::RESPONSE_OK) {
        CnfFreezeString(chooser.get_current_folder(), "FileChooserPath");
        *filename = Platform::Path::From(chooser.get_filename());
        return true;
    } else {
        return false;
    }
}

DialogChoice SaveFileYesNoCancel(void) {
    Glib::ustring message =
        _("The file has changed since it was last saved.\n\n"
          "Do you want to save the changes?");
    Gtk::MessageDialog dialog(*GW, message, /*use_markup*/ true, Gtk::MESSAGE_QUESTION,
                              Gtk::BUTTONS_NONE, /*is_modal*/ true);
    dialog.set_title(Title(C_("title", "Modified File")));
    dialog.add_button(C_("button", "_Save"), Gtk::RESPONSE_YES);
    dialog.add_button(C_("button", "Do_n't Save"), Gtk::RESPONSE_NO);
    dialog.add_button(C_("button", "_Cancel"), Gtk::RESPONSE_CANCEL);

    switch(dialog.run()) {
        case Gtk::RESPONSE_YES:
        return DIALOG_YES;

        case Gtk::RESPONSE_NO:
        return DIALOG_NO;

        case Gtk::RESPONSE_CANCEL:
        default:
        return DIALOG_CANCEL;
    }
}

DialogChoice LoadAutosaveYesNo(void) {
    Glib::ustring message =
        _("An autosave file is availible for this project.\n\n"
          "Do you want to load the autosave file instead?");
    Gtk::MessageDialog dialog(*GW, message, /*use_markup*/ true, Gtk::MESSAGE_QUESTION,
                              Gtk::BUTTONS_NONE, /*is_modal*/ true);
    dialog.set_title(Title(C_("title", "Autosave Available")));
    dialog.add_button(C_("button", "_Load autosave"), Gtk::RESPONSE_YES);
    dialog.add_button(C_("button", "Do_n't Load"), Gtk::RESPONSE_NO);

    switch(dialog.run()) {
        case Gtk::RESPONSE_YES:
        return DIALOG_YES;

        case Gtk::RESPONSE_NO:
        default:
        return DIALOG_NO;
    }
}

DialogChoice LocateImportedFileYesNoCancel(const Platform::Path &amp;filename,
</t>
<t tx="leo1.20171224221232.69">                                           bool canCancel) {
    Glib::ustring message =
        "The linked file " + filename.raw + " is not present.\n\n"
        "Do you want to locate it manually?\n\n"
        "If you select \"No\", any geometry that depends on "
        "the missing file will be removed.";
    Gtk::MessageDialog dialog(*GW, message, /*use_markup*/ true, Gtk::MESSAGE_QUESTION,
                              Gtk::BUTTONS_NONE, /*is_modal*/ true);
    dialog.set_title(Title(C_("title", "Missing File")));
    dialog.add_button(C_("button", "_Yes"), Gtk::RESPONSE_YES);
    dialog.add_button(C_("button", "_No"), Gtk::RESPONSE_NO);
    if(canCancel)
        dialog.add_button(C_("button", "_Cancel"), Gtk::RESPONSE_CANCEL);

    switch(dialog.run()) {
        case Gtk::RESPONSE_YES:
        return DIALOG_YES;

        case Gtk::RESPONSE_NO:
        return DIALOG_NO;

        case Gtk::RESPONSE_CANCEL:
        default:
        return DIALOG_CANCEL;
    }
}

/* Text window */

</t>
<t tx="leo1.20171224221232.7">void CnfFreezeString(const std::string &amp;val, const std::string &amp;key) {
    struct json_object *jval = json_object_new_string(val.c_str());
    json_object_object_add(settings, key.c_str(), jval);
    CnfSave();
}

std::string CnfThawString(const std::string &amp;val, const std::string &amp;key) {
    struct json_object *jval;
    if(json_object_object_get_ex(settings, key.c_str(), &amp;jval))
        return json_object_get_string(jval);
    return val;
}

</t>
<t tx="leo1.20171224221232.70">class TextWidget : public Gtk::GLArea {
public:
    TextWidget(Glib::RefPtr&lt;Gtk::Adjustment&gt; adjustment) : _adjustment(adjustment) {
        set_events(Gdk::POINTER_MOTION_MASK | Gdk::BUTTON_PRESS_MASK | Gdk::SCROLL_MASK |
                   Gdk::LEAVE_NOTIFY_MASK);
        set_has_depth_buffer(true);
    }

    @others
};

</t>
<t tx="leo1.20171224221232.71">    void set_cursor_hand(bool is_hand) {
        Glib::RefPtr&lt;Gdk::Window&gt; gdkwin = get_window();
        if(gdkwin) { // returns NULL if not realized
            Gdk::CursorType type = is_hand ? Gdk::HAND1 : Gdk::ARROW;
            gdkwin-&gt;set_cursor(Gdk::Cursor::create(type));
        }
    }

protected:
    // See GraphicsWidget::on_create_context.
    Glib::RefPtr&lt;Gdk::GLContext&gt; on_create_context() override {
        return get_window()-&gt;create_gl_context();
    }

</t>
<t tx="leo1.20171224221232.72">bool on_render(const Glib::RefPtr&lt;Gdk::GLContext&gt; &amp;context) override {
    SS.TW.Paint();
    return true;
}

</t>
<t tx="leo1.20171224221232.73">bool on_motion_notify_event(GdkEventMotion *event) override {
    SS.TW.MouseEvent(/*leftClick*/ false,
                     /*leftDown*/ event-&gt;state &amp; GDK_BUTTON1_MASK,
                     event-&gt;x * get_scale_factor(),
                     event-&gt;y * get_scale_factor());

    return true;
}

</t>
<t tx="leo1.20171224221232.74">bool on_button_press_event(GdkEventButton *event) override {
    SS.TW.MouseEvent(/*leftClick*/ event-&gt;type == GDK_BUTTON_PRESS,
                     /*leftDown*/ event-&gt;state &amp; GDK_BUTTON1_MASK,
                     event-&gt;x * get_scale_factor(),
                     event-&gt;y * get_scale_factor());

    return true;
}

</t>
<t tx="leo1.20171224221232.75">bool on_scroll_event(GdkEventScroll *event) override {
    _adjustment-&gt;set_value(_adjustment-&gt;get_value() +
            DeltaYOfScrollEvent(event) * _adjustment-&gt;get_page_increment());

    return true;
}

</t>
<t tx="leo1.20171224221232.76">    bool on_leave_notify_event (GdkEventCrossing *) override {
        SS.TW.MouseLeave();

        return true;
    }

private:
    Glib::RefPtr&lt;Gtk::Adjustment&gt; _adjustment;
</t>
<t tx="leo1.20171224221232.77">class TextWindowGtk : public Gtk::Window {
public:
    TextWindowGtk() : _scrollbar(), _widget(_scrollbar.get_adjustment()),
                      _overlay(_widget), _box() {
        set_type_hint(Gdk::WINDOW_TYPE_HINT_UTILITY);
        set_skip_taskbar_hint(true);
        set_skip_pager_hint(true);
        set_default_size(420, 300);

        _box.pack_start(_overlay, true, true);
        _box.pack_start(_scrollbar, false, true);
        add(_box);

        _scrollbar.get_adjustment()-&gt;signal_value_changed().
            connect(sigc::mem_fun(this, &amp;TextWindowGtk::on_scrollbar_value_changed));

        _overlay.signal_editing_done().
            connect(sigc::mem_fun(this, &amp;TextWindowGtk::on_editing_done));

        _overlay.get_entry().signal_motion_notify_event().
            connect(sigc::mem_fun(this, &amp;TextWindowGtk::on_editor_motion_notify_event));
        _overlay.get_entry().signal_button_press_event().
            connect(sigc::mem_fun(this, &amp;TextWindowGtk::on_editor_button_press_event));
    }

    Gtk::VScrollbar &amp;get_scrollbar() {
        return _scrollbar;
    }

    TextWidget &amp;get_widget() {
        return _widget;
    }

    EditorOverlay &amp;get_overlay() {
        return _overlay;
    }

protected:
    @others
};

std::unique_ptr&lt;TextWindowGtk&gt; TW;

</t>
<t tx="leo1.20171224221232.78">void on_show() override {
    Gtk::Window::on_show();

    CnfThawWindowPos(this, "TextWindow");
}

</t>
<t tx="leo1.20171224221232.79">void on_hide() override {
    CnfFreezeWindowPos(this, "TextWindow");

    Gtk::Window::on_hide();
}

</t>
<t tx="leo1.20171224221232.8">static void CnfFreezeWindowPos(Gtk::Window *win, const std::string &amp;key) {
    int x, y, w, h;
    win-&gt;get_position(x, y);
    win-&gt;get_size(w, h);

    CnfFreezeInt(x, key + "_left");
    CnfFreezeInt(y, key + "_top");
    CnfFreezeInt(w, key + "_width");
    CnfFreezeInt(h, key + "_height");
}

</t>
<t tx="leo1.20171224221232.80">bool on_delete_event(GdkEventAny *) override {
    /* trigger the action and ignore the request */
    GraphicsWindow::MenuView(Command::SHOW_TEXT_WND);

    return false;
}

</t>
<t tx="leo1.20171224221232.81">void on_scrollbar_value_changed() {
    SS.TW.ScrollbarEvent((int)_scrollbar.get_adjustment()-&gt;get_value());
}

</t>
<t tx="leo1.20171224221232.82">void on_editing_done(Glib::ustring value) {
    SS.TW.EditControlDone(value.c_str());
}

</t>
<t tx="leo1.20171224221232.83">bool on_editor_motion_notify_event(GdkEventMotion *event) {
    return _widget.event((GdkEvent*) event);
}

</t>
<t tx="leo1.20171224221232.84">    bool on_editor_button_press_event(GdkEventButton *event) {
        return _widget.event((GdkEvent*) event);
    }

private:
    Gtk::VScrollbar _scrollbar;
    TextWidget _widget;
    EditorOverlay _overlay;
    Gtk::HBox _box;
</t>
<t tx="leo1.20171224221232.85">void ShowTextWindow(bool visible) {
    if(visible)
        TW-&gt;show();
    else
        TW-&gt;hide();
}

</t>
<t tx="leo1.20171224221232.86">void GetTextWindowSize(int *w, int *h) {
    Gdk::Rectangle allocation = TW-&gt;get_widget().get_allocation();
    *w = allocation.get_width() * TW-&gt;get_scale_factor();
    *h = allocation.get_height() * TW-&gt;get_scale_factor();
}

double GetScreenDpi() {
    return Gdk::Screen::get_default()-&gt;get_resolution();
}

</t>
<t tx="leo1.20171224221232.87">void InvalidateText(void) {
    TW-&gt;get_widget().queue_draw();
}

</t>
<t tx="leo1.20171224221232.88">void MoveTextScrollbarTo(int pos, int maxPos, int page) {
    TW-&gt;get_scrollbar().get_adjustment()-&gt;configure(pos, 0, maxPos, 1, 10, page);
}

</t>
<t tx="leo1.20171224221232.89">void SetMousePointerToHand(bool is_hand) {
    TW-&gt;get_widget().set_cursor_hand(is_hand);
}

</t>
<t tx="leo1.20171224221232.9">static void CnfThawWindowPos(Gtk::Window *win, const std::string &amp;key) {
    int x, y, w, h;
    win-&gt;get_position(x, y);
    win-&gt;get_size(w, h);

    x = CnfThawInt(x, key + "_left");
    y = CnfThawInt(y, key + "_top");
    w = CnfThawInt(w, key + "_width");
    h = CnfThawInt(h, key + "_height");

    win-&gt;move(x, y);
    win-&gt;resize(w, h);
}

/* Timers */

</t>
<t tx="leo1.20171224221232.90">void ShowTextEditControl(int x, int y, const std::string &amp;val) {
    TW-&gt;get_overlay().start_editing(x, y, TextWindow::CHAR_HEIGHT, /*is_monospace=*/true, 30, val);
}

</t>
<t tx="leo1.20171224221232.91">void HideTextEditControl(void) {
    TW-&gt;get_overlay().stop_editing();
}

</t>
<t tx="leo1.20171224221232.92">bool TextEditControlIsVisible(void) {
    return TW-&gt;get_overlay().is_editing();
}

/* Miscellanea */

</t>
<t tx="leo1.20171224221232.93">void DoMessageBox(const char *message, int rows, int cols, bool error) {
    Gtk::MessageDialog dialog(*GW, message, /*use_markup*/ true,
                              error ? Gtk::MESSAGE_ERROR : Gtk::MESSAGE_INFO, Gtk::BUTTONS_OK,
                              /*is_modal*/ true);
    dialog.set_title(error ?
        Title(C_("title", "Error")) : Title(C_("title", "Message")));
    dialog.run();
}

</t>
<t tx="leo1.20171224221232.94">void OpenWebsite(const char *url) {
    gtk_show_uri(Gdk::Screen::get_default()-&gt;gobj(), url, GDK_CURRENT_TIME, NULL);
}

/* fontconfig is already initialized by GTK */
std::vector&lt;Platform::Path&gt; GetFontFiles() {
    std::vector&lt;Platform::Path&gt; fonts;

    FcPattern   *pat = FcPatternCreate();
    FcObjectSet *os  = FcObjectSetBuild(FC_FILE, (char *)0);
    FcFontSet   *fs  = FcFontList(0, pat, os);

    for(int i = 0; i &lt; fs-&gt;nfont; i++) {
        FcChar8 *filenameFC = FcPatternFormat(fs-&gt;fonts[i], (const FcChar8*) "%{file}");
        fonts.push_back(Platform::Path::From((const char *)filenameFC));
        FcStrFree(filenameFC);
    }

    FcFontSetDestroy(fs);
    FcObjectSetDestroy(os);
    FcPatternDestroy(pat);

    return fonts;
}


/* Space Navigator support */

#ifdef HAVE_SPACEWARE
</t>
<t tx="leo1.20171224221232.95">static GdkFilterReturn GdkSpnavFilter(GdkXEvent *gxevent, GdkEvent *, gpointer) {
    XEvent *xevent = (XEvent*) gxevent;

    spnav_event sev;
    if(!spnav_x11_event(xevent, &amp;sev))
        return GDK_FILTER_CONTINUE;

    switch(sev.type) {
        case SPNAV_EVENT_MOTION:
            SS.GW.SpaceNavigatorMoved(
                (double)sev.motion.x,
                (double)sev.motion.y,
                (double)sev.motion.z  * -1.0,
                (double)sev.motion.rx *  0.001,
                (double)sev.motion.ry *  0.001,
                (double)sev.motion.rz * -0.001,
                xevent-&gt;xmotion.state &amp; ShiftMask);
            break;

        case SPNAV_EVENT_BUTTON:
            if(!sev.button.press &amp;&amp; sev.button.bnum == 0) {
                SS.GW.SpaceNavigatorButtonUp();
            }
            break;
    }

    return GDK_FILTER_REMOVE;
}
#endif

/* Application lifecycle */

</t>
<t tx="leo1.20171224221232.96">void RefreshLocale() {
    SS.UpdateWindowTitle();
    for(auto menu : GW-&gt;get_menubar().get_children()) {
        GW-&gt;get_menubar().remove(*menu);
    }
    InitMainMenu(&amp;GW-&gt;get_menubar());
    RefreshRecentMenus();
    GW-&gt;get_menubar().show_all();
    GW-&gt;get_menubar().accelerate(*GW);
    GW-&gt;get_menubar().accelerate(*TW);

    TW-&gt;set_title(Title(C_("title", "Property Browser")));
}

</t>
<t tx="leo1.20171224221232.97">void ExitNow() {
    GW-&gt;hide();
    TW-&gt;hide();
}
};

</t>
<t tx="leo1.20171224221232.98">int main(int argc, char** argv) {
    /* It would in principle be possible to judiciously use
       Glib::filename_{from,to}_utf8, but it's not really worth
       the effort.
       The setlocale() call is necessary for Glib::get_charset()
       to detect the system character set; otherwise it thinks
       it is always ANSI_X3.4-1968.
       We set it back to C after all.  */
    setlocale(LC_ALL, "");
    if(!Glib::get_charset()) {
        dbp("Sorry, only UTF-8 locales are supported.");
        return 1;
    }
    setlocale(LC_ALL, "C");

    /* If we don't do this, gtk_init will set the C standard library
       locale, and printf will format floats using ",". We will then
       fail to parse these. Also, many text window lines will become
       ambiguous. */
    gtk_disable_setlocale();

    Gtk::Main main(argc, argv);

    // Add our application-specific styles, to override GTK defaults.
    Glib::RefPtr&lt;Gtk::CssProvider&gt; style_provider = Gtk::CssProvider::create();
    style_provider-&gt;load_from_data(R"(
    entry {
        background: white;
        color: black;
    }
    )");
    Gtk::StyleContext::add_provider_for_screen(Gdk::Screen::get_default(),
                                               style_provider,
                                               600 /*Gtk::STYLE_PROVIDER_PRIORITY_APPLICATION*/);

#ifdef HAVE_SPACEWARE
    gdk_window_add_filter(NULL, GdkSpnavFilter, NULL);
#endif

    CnfLoad();

    auto icon = LoadPng("freedesktop/solvespace-48x48.png");
    auto icon_gdk =
    TW-&gt;show_all();
    GW-&gt;show_all();

    const char* const* langNames = g_get_language_names();
    while(*langNames) {
        if(SetLocale(*langNames++)) break;
    }
    if(!*langNames) {
        SetLocale("en_US");
    }

#if defined(HAVE_SPACEWARE) &amp;&amp; defined(GDK_WINDOWING_X11)
    if(GDK_IS_X11_DISPLAY(Gdk::Display::get_default()-&gt;gobj())) {
        // We don't care if it can't be opened; just continue without.
        spnav_x11_open(gdk_x11_get_default_xdisplay(),
                       gdk_x11_window_get_xid(GW-&gt;get_window()-&gt;gobj()));
    }
#endif

    SS.Init();

    if(argc &gt;= 2) {
        if(argc &gt; 2) {
            dbp("Only the first file passed on command line will be opened.");
        }

        /* Make sure the argument is valid UTF-8. */
        Glib::ustring arg(argv[1]);
        SS.Load(Platform::Path::From(arg).Expand(/*fromCurrentDirectory=*/true));
    }

    main.run(*GW);

    TW.reset();
    GW.reset();

    SK.Clear();
    SS.Clear();

    return 0;
}
</t>
<t tx="leo1.20171224221232.99">//-----------------------------------------------------------------------------
// Our platform support functions for the headless (no OpenGL) test runner.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include &lt;cairo.h&gt;

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221233.1">class Setting {
public:
    enum class Type {
        Undefined,
        Int,
        Float,
        String
    };

    Type        type;
    int         valueInt;
    float       valueFloat;
    std::string valueString;

    @others
};

std::map&lt;std::string, Setting&gt; settings;

</t>
<t tx="leo1.20171224221233.10">void GetGraphicsWindowSize(int *w, int *h) {
    *w = *h = 600;
}
double GetScreenDpi() {
    return 72;
}

</t>
<t tx="leo1.20171224221233.100">void SolveSpace::PaintGraphics()
{
    SS.GW.Paint();
#if HAVE_OPENGL == 3
    eglSwapBuffers(GraphicsGlDisplay, GraphicsGlSurface);
#else
    SwapBuffers(GetDC(GraphicsWnd));
#endif
}
</t>
<t tx="leo1.20171224221233.101">void SolveSpace::InvalidateGraphics()
{
    InvalidateRect(GraphicsWnd, NULL, false);
}

</t>
<t tx="leo1.20171224221233.102">void SolveSpace::ToggleFullScreen()
{
    static WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);

    DWORD dwStyle = GetWindowLong(GraphicsWnd, GWL_STYLE);
    if(dwStyle &amp; WS_OVERLAPPEDWINDOW) {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);

        if(GetWindowPlacement(GraphicsWnd, &amp;wp) &amp;&amp;
                GetMonitorInfo(MonitorFromWindow(GraphicsWnd, MONITOR_DEFAULTTOPRIMARY), &amp;mi)) {
            SetWindowLong(GraphicsWnd, GWL_STYLE, dwStyle &amp; ~WS_OVERLAPPEDWINDOW);
            SetWindowPos(GraphicsWnd, HWND_TOP,
                         mi.rcMonitor.left, mi.rcMonitor.top,
                         mi.rcMonitor.right - mi.rcMonitor.left,
                         mi.rcMonitor.bottom - mi.rcMonitor.top,
                         SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
        }
    } else {
        SetWindowLong(GraphicsWnd, GWL_STYLE, dwStyle | WS_OVERLAPPEDWINDOW);
        SetWindowPlacement(GraphicsWnd, &amp;wp);
        SetWindowPos(GraphicsWnd, NULL, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER |
                     SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
    }
}
</t>
<t tx="leo1.20171224221233.103">bool SolveSpace::FullScreenIsActive()
{
    return (GetWindowLong(GraphicsWnd, GWL_STYLE) &amp; WS_OVERLAPPEDWINDOW) != 0;
}

</t>
<t tx="leo1.20171224221233.104">void SolveSpace::InvalidateText()
{
    InvalidateRect(TextWnd, NULL, false);
}

</t>
<t tx="leo1.20171224221233.105">static void ShowEditControl(HWND h, int x, int y, int fontHeight, int minWidthChars,
                            bool isMonospace, const std::wstring &amp;s) {
    static HFONT hf;
    if(hf) DeleteObject(hf);
    hf = CreateFontW(-fontHeight, 0, 0, 0,
        FW_REGULAR, false, false, false, ANSI_CHARSET,
        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, FF_DONTCARE, isMonospace ? L"Lucida Console" : L"Arial");
    if(hf) SendMessage(h, WM_SETFONT, (WPARAM)hf, false);
    else   SendMessage(h, WM_SETFONT, (WPARAM)(HFONT)GetStockObject(SYSTEM_FONT), false);
    SendMessage(h, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, 0);

    HDC hdc = GetDC(h);
    TEXTMETRICW tm;
    SIZE ts;
    SelectObject(hdc, hf);
    GetTextMetrics(hdc, &amp;tm);
    GetTextExtentPoint32W(hdc, s.c_str(), s.length(), &amp;ts);
    ReleaseDC(h, hdc);

    RECT rc;
    rc.left   = x;
    rc.top    = y - tm.tmAscent;
    // Add one extra char width to avoid scrolling.
    rc.right  = x + std::max(tm.tmAveCharWidth * minWidthChars,
                             ts.cx + tm.tmAveCharWidth);
    rc.bottom = y + tm.tmDescent;

    AdjustWindowRectEx(&amp;rc, 0, false, WS_EX_CLIENTEDGE);
    MoveWindow(h, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, true);
    ShowWindow(h, SW_SHOW);
    if(!s.empty()) {
        SendMessage(h, WM_SETTEXT, 0, (LPARAM)s.c_str());
        SendMessage(h, EM_SETSEL, 0, s.length());
        SetFocus(h);
    }
}
</t>
<t tx="leo1.20171224221233.106">void SolveSpace::ShowTextEditControl(int x, int y, const std::string &amp;str)
{
    if(GraphicsEditControlIsVisible()) return;

    ShowEditControl(TextEditControl, x, y, TextWindow::CHAR_HEIGHT, 30,
                    /*isMonospace=*/true, Widen(str));
}
</t>
<t tx="leo1.20171224221233.107">void SolveSpace::HideTextEditControl()
{
    ShowWindow(TextEditControl, SW_HIDE);
}
</t>
<t tx="leo1.20171224221233.108">bool SolveSpace::TextEditControlIsVisible()
{
    return IsWindowVisible(TextEditControl) ? true : false;
}
</t>
<t tx="leo1.20171224221233.109">void SolveSpace::ShowGraphicsEditControl(int x, int y, int fontHeight, int minWidthChars,
                                         const std::string &amp;str)
{
    if(GraphicsEditControlIsVisible()) return;

    RECT r;
    GetClientRect(GraphicsWnd, &amp;r);
    x = x + (r.right - r.left)/2;
    y = (r.bottom - r.top)/2 - y;

    ShowEditControl(GraphicsEditControl, x, y, fontHeight, minWidthChars,
                    /*isMonospace=*/false, Widen(str));
}
</t>
<t tx="leo1.20171224221233.11">void InvalidateGraphics() {
}

std::shared_ptr&lt;Pixmap&gt; framebuffer;
bool antialias = true;
</t>
<t tx="leo1.20171224221233.110">void SolveSpace::HideGraphicsEditControl()
{
    ShowWindow(GraphicsEditControl, SW_HIDE);
}
</t>
<t tx="leo1.20171224221233.111">bool SolveSpace::GraphicsEditControlIsVisible()
{
    return IsWindowVisible(GraphicsEditControl) ? true : false;
}

LRESULT CALLBACK GraphicsWndProc(HWND hwnd, UINT msg, WPARAM wParam,
                                                            LPARAM lParam)
{
    switch (msg) {
        case WM_ERASEBKGND:
            break;

        case WM_SIZE:
            InvalidateRect(GraphicsWnd, NULL, false);
            break;

        case WM_PAINT: {
            // Actually paint the window, with gl.
            PaintGraphics();
            // And make Windows happy.
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &amp;ps);
            EndPaint(hwnd, &amp;ps);
            break;
        }

        case WM_MOUSELEAVE:
            SS.GW.MouseLeave();
            break;

        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_MBUTTONDOWN: {
            int x = LOWORD(lParam);
            int y = HIWORD(lParam);

            // We need this in order to get the WM_MOUSELEAVE
            TRACKMOUSEEVENT tme = {};
            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = GraphicsWnd;
            TrackMouseEvent(&amp;tme);

            // Convert to xy (vs. ij) style coordinates, with (0, 0) at center
            RECT r;
            GetClientRect(GraphicsWnd, &amp;r);
            x = x - (r.right - r.left)/2;
            y = (r.bottom - r.top)/2 - y;

            LastMousePos.x = x;
            LastMousePos.y = y;

            if(msg == WM_LBUTTONDOWN) {
                SS.GW.MouseLeftDown(x, y);
            } else if(msg == WM_LBUTTONUP) {
                SS.GW.MouseLeftUp(x, y);
            } else if(msg == WM_LBUTTONDBLCLK) {
                SS.GW.MouseLeftDoubleClick(x, y);
            } else if(msg == WM_MBUTTONDOWN || msg == WM_RBUTTONDOWN) {
                SS.GW.MouseMiddleOrRightDown(x, y);
            } else if(msg == WM_RBUTTONUP) {
                SS.GW.MouseRightUp(x, y);
            } else if(msg == WM_MOUSEMOVE) {
                SS.GW.MouseMoved(x, y,
                    !!(wParam &amp; MK_LBUTTON),
                    !!(wParam &amp; MK_MBUTTON),
                    !!(wParam &amp; MK_RBUTTON),
                    !!(wParam &amp; MK_SHIFT),
                    !!(wParam &amp; MK_CONTROL));
            }
            break;
        }
        case WM_MOUSEWHEEL:
            MouseWheel(GET_WHEEL_DELTA_WPARAM(wParam));
            break;

        case WM_COMMAND: {
            if(HIWORD(wParam) == 0) {
                Command id = (Command)LOWORD(wParam);
                if(((uint32_t)id &gt;= (uint32_t)Command::RECENT_OPEN &amp;&amp;
                    (uint32_t)id &lt; ((uint32_t)Command::RECENT_OPEN + MAX_RECENT))) {
                    SolveSpaceUI::MenuFile(id);
                    break;
                }
                if(((uint32_t)id &gt;= (uint32_t)Command::RECENT_LINK &amp;&amp;
                    (uint32_t)id &lt; ((uint32_t)Command::RECENT_LINK + MAX_RECENT))) {
                    Group::MenuGroup(id);
                    break;
                }
                if((uint32_t)id &gt;= (uint32_t)Command::LOCALE &amp;&amp;
                   (uint32_t)id &lt; ((uint32_t)Command::LOCALE + Locales().size())) {
                    SolveSpaceUI::MenuHelp(id);
                    break;
                }
                int i;
                for(i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
                    if(id == SS.GW.menu[i].id) {
                        (SS.GW.menu[i].fn)((Command)id);
                        break;
                    }
                }
                ssassert(SS.GW.menu[i].level &gt;= 0, "Cannot find command in the menu");
            }
            break;
        }

        case WM_CLOSE:
        case WM_DESTROY:
            SolveSpaceUI::MenuFile(Command::EXIT);
            return 1;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 1;
}

//-----------------------------------------------------------------------------
// Common dialog routines, to open or save a file.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221233.112">static std::string ConvertFilters(const FileFilter ssFilters[]) {
    std::string filter;
    for(const FileFilter *ssFilter = ssFilters; ssFilter-&gt;name; ssFilter++) {
        std::string desc, patterns;
        for(const char *const *ssPattern = ssFilter-&gt;patterns; *ssPattern; ssPattern++) {
            std::string pattern = "*." + std::string(*ssPattern);
            if(desc == "")
                desc = pattern;
            else
                desc += ", " + pattern;
            if(patterns == "")
                patterns = pattern;
            else
                patterns += ";" + pattern;
        }
        filter += std::string(ssFilter-&gt;name) + " (" + desc + ")" + '\0';
        filter += patterns + '\0';
    }
    filter += '\0';
    return filter;
}

</t>
<t tx="leo1.20171224221233.113">static bool OpenSaveFile(bool isOpen, Platform::Path *filename, const std::string &amp;defExtension,
                         const FileFilter filters[]) {
    std::string activeExtension = defExtension;
    if(activeExtension == "") {
        activeExtension = filters[0].patterns[0];
    }

    std::wstring initialFilenameW;
    if(filename-&gt;IsEmpty()) {
        initialFilenameW = Widen("untitled");
    } else {
        initialFilenameW = Widen(filename-&gt;Parent().Join(filename-&gt;FileStem()).raw);
    }
    std::wstring selPatternW = Widen(ConvertFilters(filters));
    std::wstring defExtensionW = Widen(defExtension);

    // UNC paths may be as long as 32767 characters.
    // Unfortunately, the Get*FileName API does not provide any way to use it
    // except with a preallocated buffer of fixed size, so we use something
    // reasonably large.
    const int len = 32768;
    wchar_t filenameC[len] = {};
    wcsncpy(filenameC, initialFilenameW.c_str(), len - 1);

    OPENFILENAME ofn = {};
    ofn.lStructSize = sizeof(ofn);
    ofn.hInstance = Instance;
    ofn.hwndOwner = GraphicsWnd;
    ofn.lpstrFilter = selPatternW.c_str();
    ofn.lpstrDefExt = defExtensionW.c_str();
    ofn.lpstrFile = filenameC;
    ofn.nMaxFile = len;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    EnableWindow(GraphicsWnd, false);
    EnableWindow(TextWnd, false);

    BOOL r;
    if(isOpen) {
        r = GetOpenFileNameW(&amp;ofn);
    } else {
        r = GetSaveFileNameW(&amp;ofn);
    }

    EnableWindow(TextWnd, true);
    EnableWindow(GraphicsWnd, true);
    SetForegroundWindow(GraphicsWnd);

    if(r) *filename = Platform::Path::From(Narrow(filenameC));
    return r ? true : false;
}

</t>
<t tx="leo1.20171224221233.114">bool SolveSpace::GetOpenFile(Platform::Path *filename, const std::string &amp;defExtension,
                             const FileFilter filters[])
{
    return OpenSaveFile(/*isOpen=*/true, filename, defExtension, filters);
}

</t>
<t tx="leo1.20171224221233.115">bool SolveSpace::GetSaveFile(Platform::Path *filename, const std::string &amp;defExtension,
                             const FileFilter filters[])
{
    return OpenSaveFile(/*isOpen=*/false, filename, defExtension, filters);
}

DialogChoice SolveSpace::SaveFileYesNoCancel()
{
    EnableWindow(GraphicsWnd, false);
    EnableWindow(TextWnd, false);

    int r = MessageBoxW(GraphicsWnd,
        case IDYES:
        return DIALOG_YES;
        case IDNO:
        return DIALOG_NO;
        case IDCANCEL:
        default:
        return DIALOG_CANCEL;
    }
}

DialogChoice SolveSpace::LoadAutosaveYesNo()
{
    EnableWindow(GraphicsWnd, false);
    EnableWindow(TextWnd, false);

    int r = MessageBoxW(GraphicsWnd,
        case IDYES:
        return DIALOG_YES;
        case IDNO:
        default:
        return DIALOG_NO;
    }
}

DialogChoice SolveSpace::LocateImportedFileYesNoCancel(const Platform::Path &amp;filename,
</t>
<t tx="leo1.20171224221233.116">                                                       bool canCancel) {
    EnableWindow(GraphicsWnd, false);
    EnableWindow(TextWnd, false);

    std::string message =
        "The linked file " + filename.raw + " is not present.\n\n"
        "Do you want to locate it manually?\n\n"
        "If you select \"No\", any geometry that depends on "
        "the missing file will be removed.";

    @others
}

std::vector&lt;Platform::Path&gt; SolveSpace::GetFontFiles() {
    std::vector&lt;Platform::Path&gt; fonts;

    std::wstring fontsDirW(MAX_PATH, '\0');
    fontsDirW.resize(GetWindowsDirectoryW(&amp;fontsDirW[0], fontsDirW.length()));
    fontsDirW += L"\\fonts\\";
    Platform::Path fontsDir = Platform::Path::From(Narrow(fontsDirW));

    WIN32_FIND_DATA wfd;
    HANDLE h = FindFirstFileW((fontsDirW + L"*").c_str(), &amp;wfd);
    while(h != INVALID_HANDLE_VALUE) {
        fonts.push_back(fontsDir.Join(Narrow(wfd.cFileName)));
        if(!FindNextFileW(h, &amp;wfd)) break;
    }

    return fonts;
}

</t>
<t tx="leo1.20171224221233.117">int r = MessageBoxW(GraphicsWnd, Widen(message).c_str(),
    Title(C_("title", "Missing File")).c_str(),
    (canCancel ? MB_YESNOCANCEL : MB_YESNO) | MB_ICONWARNING);

EnableWindow(TextWnd, true);
EnableWindow(GraphicsWnd, true);
SetForegroundWindow(GraphicsWnd);

switch(r) {
    case IDYES:
    return DIALOG_YES;
    case IDNO:
    return DIALOG_NO;
    case IDCANCEL:
    default:
    return DIALOG_CANCEL;
}
</t>
<t tx="leo1.20171224221233.118">static void MenuByCmd(Command id, bool yes, bool check)
{
    int i;
    int subMenu = -1;

    for(i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
        if(SS.GW.menu[i].level == 0) subMenu++;

        if(SS.GW.menu[i].id == id) {
            ssassert(subMenu &gt;= 0 &amp;&amp; subMenu &lt; (int)arraylen(SubMenus),
                     "Submenu out of range");

            if(check) {
                CheckMenuItem(SubMenus[subMenu], (uint32_t)id,
                            yes ? MF_CHECKED : MF_UNCHECKED);
            } else {
                EnableMenuItem(SubMenus[subMenu], (uint32_t)id,
                            yes ? MF_ENABLED : MF_GRAYED);
            }
            return;
        }
    }
    ssassert(false, "Cannot find submenu");
}
</t>
<t tx="leo1.20171224221233.119">void SolveSpace::CheckMenuByCmd(Command cmd, bool checked)
{
    MenuByCmd(cmd, checked, true);
}
</t>
<t tx="leo1.20171224221233.12">void PaintGraphics() {
    const Camera &amp;camera = SS.GW.GetCamera();

    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;format = Pixmap::Format::BGRA;
    pixmap-&gt;width  = camera.width;
    pixmap-&gt;height = camera.height;
    pixmap-&gt;stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, (int)camera.width);
    pixmap-&gt;data   = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    cairo_surface_t *surface =
        cairo_image_surface_create_for_data(&amp;pixmap-&gt;data[0], CAIRO_FORMAT_RGB24,
                                            (int)pixmap-&gt;width, (int)pixmap-&gt;height,
                                            (int)pixmap-&gt;stride);
    cairo_t *context = cairo_create(surface);

    CairoRenderer canvas;
    canvas.camera = camera;
    canvas.lighting = SS.GW.GetLighting();
    canvas.chordTolerance = SS.chordTol;
    canvas.context = context;
    canvas.antialias = antialias;

    SS.GW.Draw(&amp;canvas);
    canvas.CullOccludedStrokes();
    canvas.OutputInPaintOrder();

    pixmap-&gt;ConvertTo(Pixmap::Format::RGBA);
    framebuffer = pixmap;

    canvas.Clear();

    cairo_surface_destroy(surface);
    cairo_destroy(context);
}

</t>
<t tx="leo1.20171224221233.120">void SolveSpace::RadioMenuByCmd(Command cmd, bool selected)
{
    // Windows does not natively support radio-button menu items
    MenuByCmd(cmd, selected, true);
}
</t>
<t tx="leo1.20171224221233.121">void SolveSpace::EnableMenuByCmd(Command cmd, bool enabled)
{
    MenuByCmd(cmd, enabled, false);
}
</t>
<t tx="leo1.20171224221233.122">static void DoRecent(HMENU m, Command base)
{
    while(DeleteMenu(m, 0, MF_BYPOSITION))
        ;
    int c = 0;
    for(size_t i = 0; i &lt; MAX_RECENT; i++) {
        if(!RecentFile[i].IsEmpty()) {
            AppendMenuW(m, MF_STRING, (uint32_t)base + i, Widen(RecentFile[i].raw).c_str());
            c++;
        }
    }
    if(c == 0) AppendMenuW(m, MF_STRING | MF_GRAYED, 0, Widen(_("(no recent files)")).c_str());
}
</t>
<t tx="leo1.20171224221233.123">void SolveSpace::RefreshRecentMenus()
{
    DoRecent(RecentOpenMenu,   Command::RECENT_OPEN);
    DoRecent(RecentImportMenu, Command::RECENT_LINK);
}

HMENU CreateGraphicsWindowMenus()
{
    HMENU top = CreateMenu();
    HMENU m = 0;

    int i;
    int subMenu = 0;

    for(i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
        std::string label;
        if(SS.GW.menu[i].label) {
            std::string accel = MakeAcceleratorLabel(SS.GW.menu[i].accel);
            const char *sep = accel.empty() ? "" : "\t";
            label = ssprintf("%s%s%s", Translate(SS.GW.menu[i].label).c_str(), sep, accel.c_str());
        }

        if(SS.GW.menu[i].level == 0) {
            m = CreateMenu();
            AppendMenuW(top, MF_STRING | MF_POPUP, (UINT_PTR)m, Widen(label).c_str());
            ssassert(subMenu &lt; (int)arraylen(SubMenus), "Too many submenus");
            SubMenus[subMenu] = m;
            subMenu++;
        } else if(SS.GW.menu[i].level == 1) {
            if(SS.GW.menu[i].id == Command::OPEN_RECENT) {
                RecentOpenMenu = CreateMenu();
                AppendMenuW(m, MF_STRING | MF_POPUP,
                    (UINT_PTR)RecentOpenMenu, Widen(label).c_str());
            } else if(SS.GW.menu[i].id == Command::GROUP_RECENT) {
                RecentImportMenu = CreateMenu();
                AppendMenuW(m, MF_STRING | MF_POPUP,
                    (UINT_PTR)RecentImportMenu, Widen(label).c_str());
            } else if(SS.GW.menu[i].id == Command::LOCALE) {
                HMENU LocaleMenu = CreateMenu();
                size_t i = 0;
                for(auto locale : Locales()) {
                    AppendMenuW(LocaleMenu, MF_STRING,
                        (uint32_t)Command::LOCALE + i++, Widen(locale.displayName).c_str());
                }
                AppendMenuW(m, MF_STRING | MF_POPUP,
                    (UINT_PTR)LocaleMenu, Widen(label).c_str());
            } else if(SS.GW.menu[i].label) {
                AppendMenuW(m, MF_STRING, (uint32_t)SS.GW.menu[i].id, Widen(label).c_str());
            } else {
                AppendMenuW(m, MF_SEPARATOR, (uint32_t)SS.GW.menu[i].id, L"");
            }
        } else ssassert(false, "Submenus nested too deeply");
    }
    RefreshRecentMenus();

    return top;
}

</t>
<t tx="leo1.20171224221233.124">static void CreateMainWindows()
{
    WNDCLASSEX wc = {};

    wc.cbSize = sizeof(wc);

    // The graphics window, where the sketch is drawn and shown.
    wc.style            = CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW | CS_OWNDC |
                          CS_DBLCLKS;
    wc.lpfnWndProc      = (WNDPROC)GraphicsWndProc;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszClassName    = L"GraphicsWnd";
    wc.lpszMenuName     = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 32, 32, 0);
    wc.hIconSm          = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 16, 16, 0);
    ssassert(RegisterClassEx(&amp;wc), "Cannot register window class");

    GraphicsWnd = CreateWindowExW(0, L"GraphicsWnd",
        Title(C_("title", "(new sketch)")).c_str(),
        WS_OVERLAPPED | WS_THICKFRAME | WS_CLIPCHILDREN | WS_MAXIMIZEBOX |
        WS_MINIMIZEBOX | WS_SYSMENU | WS_SIZEBOX | WS_CLIPSIBLINGS,
        50, 50, 900, 600, NULL, NULL, Instance, NULL);
    ssassert(GraphicsWnd != NULL, "Cannot create window");

    GraphicsEditControl = CreateWindowExW(WS_EX_CLIENTEDGE, WC_EDIT, L"",
        WS_CHILD | ES_AUTOHSCROLL | WS_TABSTOP | WS_CLIPSIBLINGS,
        50, 50, 100, 21, GraphicsWnd, NULL, Instance, NULL);

    // The text window, with a comand line and some textual information
    // about the sketch.
    wc.style           &amp;= ~CS_DBLCLKS;
    wc.lpfnWndProc      = (WNDPROC)TextWndProc;
    wc.hbrBackground    = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszClassName    = L"TextWnd";
    wc.hCursor          = NULL;
    ssassert(RegisterClassEx(&amp;wc), "Cannot register window class");

    // We get the desired Alt+Tab behaviour by specifying that the text
    // window is a child of the graphics window.
    TextWnd = CreateWindowExW(0, L"TextWnd",
        Title(C_("title", "Property Browser")).c_str(),
        WS_THICKFRAME | WS_CLIPCHILDREN,
        650, 500, 420, 300, GraphicsWnd, (HMENU)NULL, Instance, NULL);
    ssassert(TextWnd != NULL, "Cannot create window");

    TextWndScrollBar = CreateWindowExW(0, WC_SCROLLBAR, L"", WS_CHILD |
        SBS_VERT | SBS_LEFTALIGN | WS_VISIBLE | WS_CLIPSIBLINGS,
        200, 100, 100, 100, TextWnd, NULL, Instance, NULL);
    // Force the scrollbar to get resized to the window,
    TextWndProc(TextWnd, WM_SIZE, 0, 0);

    TextEditControl = CreateWindowExW(WS_EX_CLIENTEDGE, WC_EDIT, L"",
        WS_CHILD | ES_AUTOHSCROLL | WS_TABSTOP | WS_CLIPSIBLINGS,
        50, 50, 100, 21, TextWnd, NULL, Instance, NULL);

#if HAVE_OPENGL == 3
    // Now that all our windows exist, set up gl contexts.
    CreateGlContext(TextWnd, &amp;TextGlDisplay, &amp;TextGlSurface, &amp;TextGlContext);
    CreateGlContext(GraphicsWnd, &amp;GraphicsGlDisplay, &amp;GraphicsGlSurface, &amp;GraphicsGlContext);
#else
    CreateGlContext(TextWnd, &amp;TextGl);
    CreateGlContext(GraphicsWnd, &amp;GraphicsGl);
#endif

    RECT r, rc;
    GetWindowRect(TextWnd, &amp;r);
    GetClientRect(TextWnd, &amp;rc);
    ClientIsSmallerBy = (r.bottom - r.top) - (rc.bottom - rc.top);
}

</t>
<t tx="leo1.20171224221233.125">void SolveSpace::RefreshLocale() {
    SS.UpdateWindowTitle();

    HMENU oldMenu = GetMenu(GraphicsWnd);
    SetMenu(GraphicsWnd, CreateGraphicsWindowMenus());
    if(oldMenu != NULL) {
        DestroyMenu(oldMenu);
    }
    RefreshRecentMenus();

    SetWindowTextW(TextWnd, Title(C_("title", "Property Browser")).c_str());
}

#ifdef HAVE_SPACEWARE
//-----------------------------------------------------------------------------
// Test if a message comes from the SpaceNavigator device. If yes, dispatch
// it appropriately and return true. Otherwise, do nothing and return false.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221233.126">static bool ProcessSpaceNavigatorMsg(MSG *msg) {
    if(SpaceNavigator == SI_NO_HANDLE) return false;

    SiGetEventData sged;
    SiSpwEvent sse;

    SiGetEventWinInit(&amp;sged, msg-&gt;message, msg-&gt;wParam, msg-&gt;lParam);
    int ret = SiGetEvent(SpaceNavigator, 0, &amp;sged, &amp;sse);
    if(ret == SI_NOT_EVENT) return false;
    // So the device is a SpaceNavigator event, or a SpaceNavigator error.

    if(ret == SI_IS_EVENT) {
        if(sse.type == SI_MOTION_EVENT) {
            // The Z axis translation and rotation are both
            // backwards in the default mapping.
            double tx =  sse.u.spwData.mData[SI_TX]*1.0,
            if(button == SI_APP_FIT_BUTTON) SS.GW.SpaceNavigatorButtonUp();
        }
    }
    return true;
}
#endif // HAVE_SPACEWARE

//-----------------------------------------------------------------------------
// Entry point into the program.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221233.127">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, INT nCmdShow)
{
    Instance = hInstance;

    InitCommonControls();

    // A monospaced font
    FixedFont = CreateFontW(SS.TW.CHAR_HEIGHT, SS.TW.CHAR_WIDTH_, 0, 0,
        FW_REGULAR, false,
        false, false, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, FF_DONTCARE, L"Lucida Console");
    if(!FixedFont)
        FixedFont = (HFONT)GetStockObject(SYSTEM_FONT);

    // Create the root windows: one for control, with text, and one for
    // the graphics
    CreateMainWindows();

    ThawWindowPos(TextWnd, "TextWnd");
    ThawWindowPos(GraphicsWnd, "GraphicsWnd");

    ShowWindow(TextWnd, SW_SHOWNOACTIVATE);
    ShowWindow(GraphicsWnd, SW_SHOW);

    std::vector&lt;std::string&gt; args = InitPlatform(0, NULL);

#ifdef HAVE_SPACEWARE
    // Initialize the SpaceBall, if present. Test if the driver is running
    // first, to avoid a long timeout if it's not.
    HWND swdc = FindWindowW(L"SpaceWare Driver Class", NULL);
    if(swdc != NULL) {
        SiOpenData sod;
        SiInitialize();
        SiOpenWinInit(&amp;sod, GraphicsWnd);
        SpaceNavigator =
            SiOpen("GraphicsWnd", SI_ANY_DEVICE, SI_NO_MASK, SI_EVENT, &amp;sod);
        SiSetUiMode(SpaceNavigator, SI_UI_NO_CONTROLS);
    }
#endif

    // Use the user default locale, then fall back to English.
    if(!SetLocale((uint16_t)GetUserDefaultLCID())) {
        SetLocale("en_US");
    }

    // Call in to the platform-independent code, and let them do their init
    SS.Init();

    // A filename may have been specified on the command line; if so, then
    // strip any quotation marks, and make it absolute.
    if(args.size() &gt;= 2) {
        SS.Load(Platform::Path::From(args[1]).Expand(/*fromCurrentDirectory=*/true));
    }

    // Repaint one more time, after we've set everything up.
    PaintGraphics();
    PaintTextWnd();

    // And now it's the message loop. All calls in to the rest of the code
    // will be from the wndprocs.
    MSG msg;
    DWORD ret;
    while((ret = GetMessage(&amp;msg, NULL, 0, 0)) != 0) {
#ifdef HAVE_SPACEWARE
        // Is it a message from the six degree of freedom input device?
        if(ProcessSpaceNavigatorMsg(&amp;msg)) goto done;
#endif

        // A message from the keyboard, which should be processed as a keyboard
        // accelerator?
        if(msg.message == WM_KEYDOWN) {
            if(ProcessKeyDown(msg.wParam)) goto done;
        }
        if(msg.message == WM_SYSKEYDOWN &amp;&amp; msg.hwnd == TextWnd) {
            // If the user presses the Alt key when the text window has focus,
            // then that should probably go to the graphics window instead.
            SetForegroundWindow(GraphicsWnd);
        }

        // None of the above; so just a normal message to process.
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
done:
        SS.DoLater();
    }

#ifdef HAVE_SPACEWARE
    if(swdc != NULL) {
        if(SpaceNavigator != SI_NO_HANDLE) SiClose(SpaceNavigator);
        SiTerminate();
    }
#endif

    // Write everything back to the registry
    FreezeWindowPos(TextWnd, "TextWnd");
    FreezeWindowPos(GraphicsWnd, "GraphicsWnd");

    // Free the memory we've used; anything that remains is a leak.
    SK.Clear();
    SS.Clear();

    return 0;
}
</t>
<t tx="leo1.20171224221233.128">//-----------------------------------------------------------------------------
// Utility functions that depend on Win32. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// Include after solvespace.h to avoid identifier clashes.
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;

namespace SolveSpace {
static HANDLE PermHeap, TempHeap;

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221233.129">void dbp(const char *str, ...)
{
    va_list f;
    static char buf[1024*50];
    va_start(f, str);
    _vsnprintf(buf, sizeof(buf), str, f);
    va_end(f);

    // The native version of OutputDebugString, unlike most others,
    // is OutputDebugStringA.
    OutputDebugStringA(buf);
    OutputDebugStringA("\n");

#ifndef NDEBUG
    // Duplicate to stderr in debug builds, but not in release; this is slow.
    fputs(buf, stderr);
    fputc('\n', stderr);
#endif
}

</t>
<t tx="leo1.20171224221233.13">void SetCurrentFilename(const Platform::Path &amp;filename) {
}
</t>
<t tx="leo1.20171224221233.130">void assert_failure(const char *file, unsigned line, const char *function,
                    const char *condition, const char *message) {
    dbp("File %s, line %u, function %s:", file, line, function);
    dbp("Assertion '%s' failed: ((%s) == false).", message, condition);
#ifdef NDEBUG
    _exit(1);
#else
    abort();
#endif
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since no fragmentation issues whatsoever, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221233.131">void *AllocTemporary(size_t n)
{
    void *v = HeapAlloc(TempHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(v != NULL, "Cannot allocate memory");
    return v;
}
</t>
<t tx="leo1.20171224221233.132">void FreeTemporary(void *p) {
    HeapFree(TempHeap, HEAP_NO_SERIALIZE, p);
}
</t>
<t tx="leo1.20171224221233.133">void FreeAllTemporary()
{
    if(TempHeap) HeapDestroy(TempHeap);
    TempHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // This is a good place to validate, because it gets called fairly
    // often.
    vl();
}

</t>
<t tx="leo1.20171224221233.134">void *MemAlloc(size_t n) {
    void *p = HeapAlloc(PermHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}
</t>
<t tx="leo1.20171224221233.135">void MemFree(void *p) {
    HeapFree(PermHeap, HEAP_NO_SERIALIZE, p);
}

</t>
<t tx="leo1.20171224221233.136">void vl() {
    ssassert(HeapValidate(TempHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
    ssassert(HeapValidate(PermHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
    // Create the heap used for long-lived stuff (that gets freed piecewise).
    PermHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // Create the heap that we use to store Exprs and other temp stuff.
    FreeAllTemporary();

#if !defined(LIBRARY) &amp;&amp; defined(_MSC_VER)
    // Don't display the abort message; it is aggravating in CLI binaries
    // and results in infinite WndProc recursion in GUI binaries.
    _set_abort_behavior(0, _WRITE_ABORT_MSG);
    int crtReportTypes[] = {_CRT_WARN, _CRT_ERROR, _CRT_ASSERT};
    for(int crtReportType : crtReportTypes) {
        _CrtSetReportMode(crtReportType, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(crtReportType, _CRTDBG_FILE_STDERR);
    }
#endif

    // Extract the command-line arguments; the ones from main() are ignored,
    // since they are in the OEM encoding.
    int argcW;
    LPWSTR *argvW = CommandLineToArgvW(GetCommandLineW(), &amp;argcW);
    std::vector&lt;std::string&gt; args;
    for(int i = 0; i &lt; argcW; i++) {
        args.push_back(Platform::Narrow(argvW[i]));
    }
    LocalFree(argvW);
    return args;
}

}
</t>
<t tx="leo1.20171224221233.137"></t>
<t tx="leo1.20171224221233.138">//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 shader interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "gl3shader.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Floating point data sturctures
//-----------------------------------------------------------------------------

Vector2f Vector2f::From(float x, float y) {
    return { x, y };
}

Vector2f Vector2f::From(double x, double y) {
    return { (float)x, (float)y };
}

Vector2f Vector2f::FromInt(uint32_t x, uint32_t y) {
    return { (float)x, (float)y };
}

Vector3f Vector3f::From(float x, float y, float z) {
    return { x, y, z };
}

Vector3f Vector3f::From(const Vector &amp;v) {
    return { (float)v.x, (float)v.y, (float)v.z };
}

Vector3f Vector3f::From(const RgbaColor &amp;c) {
    return { c.redF(), c.greenF(), c.blueF() };
}

Vector4f Vector4f::From(float x, float y, float z, float w) {
    return { x, y, z, w };
}

Vector4f Vector4f::From(const Vector &amp;v, float w) {
    return { (float)v.x, (float)v.y, (float)v.z, w };
}

Vector4f Vector4f::FromInt(uint32_t x, uint32_t y, uint32_t z, uint32_t w) {
    return { (float)x, (float)y, (float)z, (float)w };
}

Vector4f Vector4f::From(const RgbaColor &amp;c) {
    return { c.redF(), c.greenF(), c.blueF(), c.alphaF() };
}

//-----------------------------------------------------------------------------
// Shader manipulation
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221233.139">static GLuint CompileShader(const std::string &amp;res, GLenum type) {
    size_t size;
    const char *resData = (const char *)Platform::LoadResource(res, &amp;size);

    // Sigh, here we go... We want to deploy to four platforms: Linux, Windows, OS X, mobile+web.
    // These platforms are basically disjunctive in the OpenGL versions and profiles that they
    // support: mobile+web support GLES2, Windows can only be guaranteed to support GL1 without
    // vendor's drivers installed but supports D3D9+ natively, Linux supports GL3.2+ and/or
    // GLES2+ depending on whether we run on X11 or Wayland, and OS X supports either a legacy
    // profile or a GL3.2 core profile or (on 10.9+) a GL4.1 core profile.
    // The platforms barely have a common subset of features:
    //  * mobile+web and Windows (D3D9 through ANGLE) are strictly GLES2/GLSL1.0;
    //  * OS X legacy compatibility profile has GLSL1.2 only shaders, and GL3.2 core profile
    //    that has GLSL1.0 shaders compatible with GLES2 makes mandatory the use of vertex array
    //    objects, which cannot be used in GLES2 at all; similarly GL3.2 core has GL_RED but not
    //    GL_ALPHA whereas GLES2 has GL_ALPHA but not GL_RED.
    //  * GTK does not work on anything prior to GL3.0/GLES2.0; it does not permit explicitly
    //    asking for a compatibility profile, i.e. you can only ask for 3.2+; and it does not
    //    permit asking for a GLES profile prior to GTK 3.22, which will get into Ubuntu
    //    no earlier than late 2017. This is despite the fact that if only GTK defaulted
    //    to the compatibility profile, everything would have just worked as Mesa is
    //    very permissive.
    // While we're at it, let's remember that GLES2 has *only* glDepthRangef, GL3.2 has *only*
    // glDepthRange, and GL4.1+ has both glDepthRangef and glDepthRange. Also, that GLSL1.0
    // makes `precision highp float;` mandatory in fragment shaders, and GLSL1.2 removes
    // the `precision` keyword entirely, because that's clearly how minor versions work.
    // Christ, what a trash fire.

    const char *prelude;
#if defined(HAVE_GLES)
    prelude = R"(
#version 100
#define TEX_ALPHA a
precision highp float;
)";
#else
    prelude = R"(
#version 120
#define TEX_ALPHA r
)";
#endif
    std::string src(resData, size);
    src = prelude + src;

    GLuint shader = glCreateShader(type);
    ssassert(shader != 0, "glCreateShader failed");

    const GLint   glSize[]   = { (int)src.length() };
    const GLchar* glSource[] = { src.c_str() };
    glShaderSource(shader, 1, glSource, glSize);
    glCompileShader(shader);

    GLint infoLen;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);
    if(infoLen &gt; 1) {
        std::string infoStr(infoLen, '\0');
        glGetShaderInfoLog(shader, infoLen, NULL, &amp;infoStr[0]);
        dbp(infoStr.c_str());
    }

    GLint compiled;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);
    ssassert(compiled, "Cannot compile shader");

    return shader;
}

</t>
<t tx="leo1.20171224221233.14">void ToggleFullScreen() {
}
</t>
<t tx="leo1.20171224221233.140">void Shader::Init(const std::string &amp;vertexRes, const std::string &amp;fragmentRes,
                  const std::vector&lt;std::pair&lt;GLuint, std::string&gt; &gt; &amp;locations) {
    GLuint vert = CompileShader(vertexRes, GL_VERTEX_SHADER);
    GLuint frag = CompileShader(fragmentRes, GL_FRAGMENT_SHADER);

    program = glCreateProgram();
    ssassert(program != 0, "glCreateProgram failed");

    glAttachShader(program, vert);
    glAttachShader(program, frag);
    for(const auto &amp;l : locations) {
        glBindAttribLocation(program, l.first, l.second.c_str());
    }
    glLinkProgram(program);

    GLint infoLen;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);
    if(infoLen &gt; 1) {
        std::string infoStr(infoLen, '\0');
        glGetProgramInfoLog(program, infoLen, NULL, &amp;infoStr[0]);
        dbp(infoStr.c_str());
    }

    GLint linked;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;linked);
    ssassert(linked, "Cannot link shader");
}

</t>
<t tx="leo1.20171224221233.141">void Shader::Clear() {
    glDeleteProgram(program);
}

</t>
<t tx="leo1.20171224221233.142">void Shader::SetUniformMatrix(const char *name, double *md) {
    Enable();
    float mf[16];
    for(int i = 0; i &lt; 16; i++) mf[i] = (float)md[i];
    glUniformMatrix4fv(glGetUniformLocation(program, name), 1, false, mf);
}

</t>
<t tx="leo1.20171224221233.143">void Shader::SetUniformVector(const char *name, const Vector &amp;v) {
    Enable();
    glUniform3f(glGetUniformLocation(program, name), (float)v.x, (float)v.y, (float)v.z);
}

</t>
<t tx="leo1.20171224221233.144">void Shader::SetUniformVector(const char *name, const Vector4f &amp;v) {
    Enable();
    glUniform4f(glGetUniformLocation(program, name), v.x, v.y, v.z, v.w);
}

</t>
<t tx="leo1.20171224221233.145">void Shader::SetUniformColor(const char *name, RgbaColor c) {
    Enable();
    glUniform4f(glGetUniformLocation(program, name), c.redF(), c.greenF(), c.blueF(), c.alphaF());
}

</t>
<t tx="leo1.20171224221233.146">void Shader::SetUniformFloat(const char *name, float v) {
    Enable();
    glUniform1f(glGetUniformLocation(program, name), v);
}

</t>
<t tx="leo1.20171224221233.147">void Shader::SetUniformInt(const char *name, GLint v) {
    Enable();
    glUniform1i(glGetUniformLocation(program, name), v);
}

</t>
<t tx="leo1.20171224221233.148">void Shader::SetUniformTextureUnit(const char *name, GLint index) {
    Enable();
    glUniform1i(glGetUniformLocation(program, name), index);
}

</t>
<t tx="leo1.20171224221233.149">void Shader::Enable() const {
    glUseProgram(program);
}

</t>
<t tx="leo1.20171224221233.15">bool FullScreenIsActive() {
    return false;
}
</t>
<t tx="leo1.20171224221233.150">void Shader::Disable() const {
    glUseProgram(0);
}

//-----------------------------------------------------------------------------
// Mesh rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.151">void MeshRenderer::Init() {
    lightShader.Init(
        "shaders/mesh.vert", "shaders/mesh.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_NOR, "nor" },
            { ATTRIB_COL, "col" },
        }
    );

    fillShader.Init(
        "shaders/mesh_fill.vert", "shaders/mesh_fill.frag",
        {
            { ATTRIB_POS, "pos" },
        }
    );
    fillShader.SetUniformTextureUnit("texture", 0);

    selectedShader = &amp;lightShader;
}

</t>
<t tx="leo1.20171224221233.152">void MeshRenderer::Clear() {
    lightShader.Clear();
    fillShader.Clear();
}

MeshRenderer::Handle MeshRenderer::Add(const SMesh &amp;m, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);

    MeshVertex *vertices = new MeshVertex[m.l.n * 3];
    for(int i = 0; i &lt; m.l.n; i++) {
        const STriangle &amp;t = m.l.elem[i];
        vertices[i * 3 + 0].pos = Vector3f::From(t.a);
        vertices[i * 3 + 1].pos = Vector3f::From(t.b);
        vertices[i * 3 + 2].pos = Vector3f::From(t.c);

        if(t.an.EqualsExactly(Vector::From(0, 0, 0))) {
            Vector3f normal = Vector3f::From(t.Normal());
            vertices[i * 3 + 0].nor = normal;
            vertices[i * 3 + 1].nor = normal;
            vertices[i * 3 + 2].nor = normal;
        } else {
            vertices[i * 3 + 0].nor = Vector3f::From(t.an);
            vertices[i * 3 + 1].nor = Vector3f::From(t.bn);
            vertices[i * 3 + 2].nor = Vector3f::From(t.cn);
        }

        for(int j = 0; j &lt; 3; j++) {
            vertices[i * 3 + j].col = Vector4f::From(t.meta.color);
        }

    }
    glBufferData(GL_ARRAY_BUFFER, m.l.n * 3 * sizeof(MeshVertex),
                 vertices, dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW);
    handle.size = m.l.n * 3;
    delete []vertices;

    return handle;
}

</t>
<t tx="leo1.20171224221233.153">void MeshRenderer::Remove(const MeshRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
}

</t>
<t tx="leo1.20171224221233.154">void MeshRenderer::Draw(const MeshRenderer::Handle &amp;handle,
                        bool useColors, RgbaColor overrideColor) {
    selectedShader-&gt;Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                          (void *)offsetof(MeshVertex, pos));

    if(selectedShader == &amp;lightShader) {
        glEnableVertexAttribArray(ATTRIB_NOR);
        glVertexAttribPointer(ATTRIB_NOR, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                              (void *)offsetof(MeshVertex, nor));
        if(useColors) {
            glEnableVertexAttribArray(ATTRIB_COL);
            glVertexAttribPointer(ATTRIB_COL, 4, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                                  (void *)offsetof(MeshVertex, col));
        } else {
            glVertexAttrib4f(ATTRIB_COL, overrideColor.redF(), overrideColor.greenF(), overrideColor.blueF(), overrideColor.alphaF());
        }
    }

    glDrawArrays(GL_TRIANGLES, 0, handle.size);

    glDisableVertexAttribArray(ATTRIB_POS);
    if(selectedShader == &amp;lightShader) {
        glDisableVertexAttribArray(ATTRIB_NOR);
        if(useColors) glDisableVertexAttribArray(ATTRIB_COL);
    }

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    selectedShader-&gt;Disable();
}

</t>
<t tx="leo1.20171224221233.155">void MeshRenderer::Draw(const SMesh &amp;mesh, bool useColors, RgbaColor overrideColor) {
    Handle handle = Add(mesh, /*dynamic=*/true);
    Draw(handle, useColors, overrideColor);
    Remove(handle);
}

</t>
<t tx="leo1.20171224221233.156">void MeshRenderer::SetModelview(double *matrix) {
    lightShader.SetUniformMatrix("modelview", matrix);
    fillShader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo1.20171224221233.157">void MeshRenderer::SetProjection(double *matrix) {
    lightShader.SetUniformMatrix("projection", matrix);
    fillShader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo1.20171224221233.158">void MeshRenderer::UseShaded(const Lighting &amp;lighting) {
    Vector dir0 = lighting.lightDirection[0];
    Vector dir1 = lighting.lightDirection[1];
    dir0.z = -dir0.z;
    dir1.z = -dir1.z;

    lightShader.SetUniformVector("lightDir0", dir0);
    lightShader.SetUniformFloat("lightInt0", (float)lighting.lightIntensity[0]);
    lightShader.SetUniformVector("lightDir1", dir1);
    lightShader.SetUniformFloat("lightInt1", (float)lighting.lightIntensity[1]);
    lightShader.SetUniformFloat("ambient", (float)lighting.ambientIntensity);
    selectedShader = &amp;lightShader;
}

</t>
<t tx="leo1.20171224221233.159">void MeshRenderer::UseFilled(const Canvas::Fill &amp;fill) {
    fillShader.SetUniformColor("color", fill.color);
    selectedShader = &amp;fillShader;
}

//-----------------------------------------------------------------------------
// Arrangement of stipple patterns into textures
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.16">void ShowGraphicsEditControl(int x, int y, int fontHeight, int minWidthChars,
                             const std::string &amp;val) {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.160">static double Frac(double x) {
    return x - floor(x);
}

</t>
<t tx="leo1.20171224221233.161">static RgbaColor EncodeLengthAsFloat(double v) {
    v = max(0.0, min(1.0, v));
    double er = v;
    double eg = Frac(255.0 * v);
    double eb = Frac(65025.0 * v);
    double ea = Frac(160581375.0 * v);

    double r = er - eg / 255.0;
    double g = eg - eb / 255.0;
    double b = eb - ea / 255.0;
    return RgbaColor::From((int)floor( r * 255.0 + 0.5),
                           (int)floor( g * 255.0 + 0.5),
                           (int)floor( b * 255.0 + 0.5),
                           (int)floor(ea * 255.0 + 0.5));
}

GLuint Generate(const std::vector&lt;double&gt; &amp;pattern) {
    double patternLen = 0.0;
    for(double s : pattern) {
        patternLen += s;
    }

    GLuint texture;
    glGenTextures(1, &amp;texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

    GLint size;
    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;size);
    RgbaColor *textureData = new RgbaColor[size];

    int mipCount = (int)log2(size) + 1;
    for(int mip = 0; mip &lt; mipCount; mip++) {
        int dashI = 0;
        double dashT = 0.0;
        for(int i = 0; i &lt; size; i++) {
            if(pattern.size() == 0) {
                textureData[i] = EncodeLengthAsFloat(0.0);
                continue;
            }

            double t = (double)i / (double)(size - 1);
            while(t - LENGTH_EPS &gt; dashT + pattern[dashI] / patternLen) {
                dashT += pattern[dashI] / patternLen;
                dashI++;
            }
            double dashW = pattern[dashI] / patternLen;
            if(dashI % 2 == 0) {
                textureData[i] = EncodeLengthAsFloat(0.0);
            } else {
                double value;
                if(t - dashT &lt; pattern[dashI] / patternLen / 2.0) {
                    value = t - dashT;
                } else {
                    value = dashT + dashW - t;
                }
                value = value * patternLen;
                textureData[i] = EncodeLengthAsFloat(value);
            }
        }
        glTexImage2D(GL_TEXTURE_2D, mip, GL_RGBA, size, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,
                     textureData);
        size /= 2;
    }

    delete []textureData;
    return texture;
}

</t>
<t tx="leo1.20171224221233.162">void StippleAtlas::Init() {
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        patterns.push_back(Generate(StipplePatternDashes((StipplePattern)i)));
    }
}

</t>
<t tx="leo1.20171224221233.163">void StippleAtlas::Clear() {
    for(GLuint p : patterns) {
        glDeleteTextures(1, &amp;p);
    }
}

GLint StippleAtlas::GetTexture(StipplePattern pattern) const {
    return patterns[(uint32_t)pattern];
}

double StippleAtlas::GetLength(StipplePattern pattern) const {
    if(pattern == StipplePattern::CONTINUOUS) {
        return 1.0;
    }
    return StipplePatternLength(pattern);
}

//-----------------------------------------------------------------------------
// Edge rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.164">void EdgeRenderer::Init(const StippleAtlas *a) {
    atlas = a;
    shader.Init(
        "shaders/edge.vert", "shaders/edge.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_LOC, "loc" },
            { ATTRIB_TAN, "tan" }
        }
    );
}

</t>
<t tx="leo1.20171224221233.165">void EdgeRenderer::Clear() {
    shader.Clear();
}

EdgeRenderer::Handle EdgeRenderer::Add(const SEdgeList &amp;edges, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    EdgeVertex *vertices = new EdgeVertex[edges.l.n * 8];
    uint32_t *indices = new uint32_t[edges.l.n * 6 * 3];
    double phase = 0.0;
    uint32_t curVertex = 0;
    uint32_t curIndex = 0;
    for(int i = 0; i &lt; edges.l.n; i++) {
        const SEdge &amp;curr = edges.l.elem[i];
        const SEdge &amp;next = edges.l.elem[(i + 1) % edges.l.n];

        // 3d positions
        Vector3f a = Vector3f::From(curr.a);
        Vector3f b = Vector3f::From(curr.b);

        // tangent
        Vector3f tan = Vector3f::From(curr.b.Minus(curr.a));

        // length
        double len = curr.b.Minus(curr.a).Magnitude();

        // make line start cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = a;
            vertices[curVertex + j].tan = tan;
        }
        vertices[curVertex + 0].loc = Vector3f::From(-1.0f, -1.0f, float(phase));
        vertices[curVertex + 1].loc = Vector3f::From(-1.0f, +1.0f, float(phase));

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 2;

        // make line body
        vertices[curVertex +  0].pos = a;
        vertices[curVertex +  1].pos = a;
        vertices[curVertex +  2].pos = b;
        vertices[curVertex +  3].pos = b;

        for(int j = 0; j &lt; 4; j++) {
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex +  0].loc = Vector3f::From( 0.0f, -1.0f, float(phase));
        vertices[curVertex +  1].loc = Vector3f::From( 0.0f, +1.0f, float(phase));
        vertices[curVertex +  2].loc = Vector3f::From( 0.0f, +1.0f, float(phase + len));
        vertices[curVertex +  3].loc = Vector3f::From( 0.0f, -1.0f, float(phase + len));

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 4;

        // make line end cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = b;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector3f::From(+1.0, +1.0, float(phase + len));
        vertices[curVertex + 1].loc = Vector3f::From(+1.0, -1.0, float(phase + len));

        indices[curIndex++] = curVertex - 2;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;

        curVertex += 2;

        // phase stitching
        if(curr.a.EqualsExactly(next.a) ||
           curr.a.EqualsExactly(next.b) ||
           curr.b.EqualsExactly(next.a) ||
           curr.b.EqualsExactly(next.b))
        {
            phase += len;
        } else {
            phase = 0.0;
        }
    }
    handle.size = curIndex;
    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBufferData(GL_ARRAY_BUFFER, curVertex * sizeof(EdgeVertex), vertices, mode);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, curIndex * sizeof(uint32_t), indices, mode);
    delete []vertices;
    delete []indices;

    return handle;
}

</t>
<t tx="leo1.20171224221233.166">void EdgeRenderer::Remove(const EdgeRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
    glDeleteBuffers(1, &amp;handle.indexBuffer);
}

</t>
<t tx="leo1.20171224221233.167">void EdgeRenderer::Draw(const EdgeRenderer::Handle &amp;handle) {
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, atlas-&gt;GetTexture(pattern));
    shader.SetUniformTextureUnit("pattern", 1);
    shader.SetUniformFloat("patternLen", (float)atlas-&gt;GetLength(pattern));

    shader.Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glEnableVertexAttribArray(ATTRIB_LOC);
    glEnableVertexAttribArray(ATTRIB_TAN);

    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, pos));
    glVertexAttribPointer(ATTRIB_LOC, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, loc));
    glVertexAttribPointer(ATTRIB_TAN, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, tan));
    glDrawElements(GL_TRIANGLES, handle.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    glDisableVertexAttribArray(ATTRIB_LOC);
    glDisableVertexAttribArray(ATTRIB_TAN);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    shader.Disable();
}

</t>
<t tx="leo1.20171224221233.168">void EdgeRenderer::Draw(const SEdgeList &amp;edges) {
    Handle handle = Add(edges, /*dynamic=*/true);
    Draw(handle);
    Remove(handle);
}

</t>
<t tx="leo1.20171224221233.169">void EdgeRenderer::SetModelview(double *matrix) {
    shader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo1.20171224221233.17">void HideGraphicsEditControl() {
}
</t>
<t tx="leo1.20171224221233.170">void EdgeRenderer::SetProjection(double *matrix) {
    shader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo1.20171224221233.171">void EdgeRenderer::SetStroke(const Canvas::Stroke &amp;stroke, double pixel) {
    double unitScale = stroke.unit == Canvas::Unit::PX ? pixel : 1.0;
    shader.SetUniformFloat("width", float(stroke.width * unitScale / 2.0));
    shader.SetUniformColor("color", stroke.color);
    shader.SetUniformFloat("patternScale", float(stroke.stippleScale * unitScale * 2.0));
    shader.SetUniformFloat("pixel", (float)pixel);
    pattern = stroke.stipplePattern;
}

//-----------------------------------------------------------------------------
// Outline rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.172">void OutlineRenderer::Init(const StippleAtlas *a) {
    atlas = a;
    shader.Init(
        "shaders/outline.vert", "shaders/edge.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_LOC, "loc" },
            { ATTRIB_TAN, "tan" },
            { ATTRIB_NOL, "nol" },
            { ATTRIB_NOR, "nor" }
        }
    );
}

</t>
<t tx="leo1.20171224221233.173">void OutlineRenderer::Clear() {
    shader.Clear();
}

OutlineRenderer::Handle OutlineRenderer::Add(const SOutlineList &amp;outlines, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    OutlineVertex *vertices = new OutlineVertex[outlines.l.n * 8];
    uint32_t *indices = new uint32_t[outlines.l.n * 6 * 3];
    double phase = 0.0;
    uint32_t curVertex = 0;
    uint32_t curIndex = 0;

    for(int i = 0; i &lt; outlines.l.n; i++) {
        const SOutline &amp;curr = outlines.l.elem[i];
        const SOutline &amp;next = outlines.l.elem[(i + 1) % outlines.l.n];

        // 3d positions
        Vector3f a = Vector3f::From(curr.a);
        Vector3f b = Vector3f::From(curr.b);
        Vector3f nl = Vector3f::From(curr.nl);
        Vector3f nr = Vector3f::From(curr.nr);

        // tangent
        Vector3f tan = Vector3f::From(curr.b.Minus(curr.a));

        // length
        double len = curr.b.Minus(curr.a).Magnitude();
        float tag = (float)curr.tag;

        // make line start cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = a;
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector4f::From(-1.0f, -1.0f, float(phase), (float)tag);
        vertices[curVertex + 1].loc = Vector4f::From(-1.0f, +1.0f, float(phase), (float)tag);

        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 2;

        // make line body
        vertices[curVertex +  0].pos = a;
        vertices[curVertex +  1].pos = a;
        vertices[curVertex +  2].pos = b;
        vertices[curVertex +  3].pos = b;

        for(int j = 0; j &lt; 4; j++) {
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex +  0].loc = Vector4f::From( 0.0f, -1.0f, float(phase), (float)tag);
        vertices[curVertex +  1].loc = Vector4f::From( 0.0f, +1.0f, float(phase), (float)tag);
        vertices[curVertex +  2].loc = Vector4f::From( 0.0f, +1.0f,
                                                      float(phase + len), (float)tag);
        vertices[curVertex +  3].loc = Vector4f::From( 0.0f, -1.0f,
                                                      float(phase + len), (float)tag);

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 4;

        // make line end cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = b;
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector4f::From(+1.0f, +1.0f, float(phase + len), (float)tag);
        vertices[curVertex + 1].loc = Vector4f::From(+1.0f, -1.0f, float(phase + len), (float)tag);

        indices[curIndex++] = curVertex - 2;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;

        curVertex += 2;

        // phase stitching
        if(curr.a.EqualsExactly(next.a) ||
           curr.a.EqualsExactly(next.b) ||
           curr.b.EqualsExactly(next.a) ||
           curr.b.EqualsExactly(next.b))
        {
            phase += len;
        } else {
            phase = 0.0;
        }
    }
    handle.size = curIndex;
    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBufferData(GL_ARRAY_BUFFER, curVertex * sizeof(OutlineVertex), vertices, mode);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, curIndex * sizeof(uint32_t), indices, mode);

    delete []vertices;
    delete []indices;
    return handle;
}

</t>
<t tx="leo1.20171224221233.174">void OutlineRenderer::Remove(const OutlineRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
    glDeleteBuffers(1, &amp;handle.indexBuffer);
}

</t>
<t tx="leo1.20171224221233.175">void OutlineRenderer::Draw(const OutlineRenderer::Handle &amp;handle, Canvas::DrawOutlinesAs mode) {
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, atlas-&gt;GetTexture(pattern));
    shader.SetUniformTextureUnit("pattern", 1);
    shader.SetUniformFloat("patternLen", (float)atlas-&gt;GetLength(pattern));
    shader.SetUniformInt("mode", (GLint)mode);

    shader.Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glEnableVertexAttribArray(ATTRIB_LOC);
    glEnableVertexAttribArray(ATTRIB_TAN);
    glEnableVertexAttribArray(ATTRIB_NOL);
    glEnableVertexAttribArray(ATTRIB_NOR);

    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, pos));
    glVertexAttribPointer(ATTRIB_LOC, 4, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, loc));
    glVertexAttribPointer(ATTRIB_TAN, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, tan));
    glVertexAttribPointer(ATTRIB_NOL, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, nol));
    glVertexAttribPointer(ATTRIB_NOR, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, nor));
    glDrawElements(GL_TRIANGLES, handle.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    glDisableVertexAttribArray(ATTRIB_LOC);
    glDisableVertexAttribArray(ATTRIB_TAN);
    glDisableVertexAttribArray(ATTRIB_NOL);
    glDisableVertexAttribArray(ATTRIB_NOR);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    shader.Disable();
}

</t>
<t tx="leo1.20171224221233.176">void OutlineRenderer::Draw(const SOutlineList &amp;outlines, Canvas::DrawOutlinesAs drawAs) {
    Handle handle = Add(outlines, /*dynamic=*/true);
    Draw(handle, drawAs);
    Remove(handle);
}

</t>
<t tx="leo1.20171224221233.177">void OutlineRenderer::SetModelview(double *matrix) {
    shader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo1.20171224221233.178">void OutlineRenderer::SetProjection(double *matrix) {
    shader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo1.20171224221233.179">void OutlineRenderer::SetStroke(const Canvas::Stroke &amp;stroke, double pixel) {
    double unitScale = (stroke.unit == Canvas::Unit::PX) ? pixel : 1.0;
    shader.SetUniformFloat("width", (float)(stroke.width * unitScale / 2.0));
    shader.SetUniformColor("color", stroke.color);
    shader.SetUniformFloat("patternScale", (float)(stroke.stippleScale * unitScale * 2.0));
    shader.SetUniformFloat("pixel", (float)pixel);
    pattern = stroke.stipplePattern;
}

//-----------------------------------------------------------------------------
// Indexed mesh storage
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.18">bool GraphicsEditControlIsVisible() {
    return false;
}
</t>
<t tx="leo1.20171224221233.180">void SIndexedMesh::AddPoint(const Vector &amp;p) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(p);
    vertices[vstart + 0].tex = Vector2f::From(-1.0f, -1.0f);
    vertices[vstart + 1].pos = Vector3f::From(p);
    vertices[vstart + 1].tex = Vector2f::From(+1.0f, -1.0f);
    vertices[vstart + 2].pos = Vector3f::From(p);
    vertices[vstart + 2].tex = Vector2f::From(+1.0f, +1.0f);
    vertices[vstart + 3].pos = Vector3f::From(p);
    vertices[vstart + 3].tex = Vector2f::From(-1.0f, +1.0f);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo1.20171224221233.181">void SIndexedMesh::AddQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(a);
    vertices[vstart + 1].pos = Vector3f::From(b);
    vertices[vstart + 2].pos = Vector3f::From(c);
    vertices[vstart + 3].pos = Vector3f::From(d);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo1.20171224221233.182">void SIndexedMesh::AddPixmap(const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                             const Point2d &amp;ta, const Point2d &amp;tb) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(o);
    vertices[vstart + 0].tex = Vector2f::From(ta.x, ta.y);

    vertices[vstart + 1].pos = Vector3f::From(o.Plus(v));
    vertices[vstart + 1].tex = Vector2f::From(ta.x, tb.y);

    vertices[vstart + 2].pos = Vector3f::From(o.Plus(u).Plus(v));
    vertices[vstart + 2].tex = Vector2f::From(tb.x, tb.y);

    vertices[vstart + 3].pos = Vector3f::From(o.Plus(u));
    vertices[vstart + 3].tex = Vector2f::From(tb.x, ta.y);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo1.20171224221233.183">void SIndexedMesh::Clear() {
    vertices.clear();
    indices.clear();
}

//-----------------------------------------------------------------------------
// Indexed mesh rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.184">void IndexedMeshRenderer::Init() {
    colShader.Init(
        "shaders/imesh.vert", "shaders/imesh.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "tex" }
        }
    );
    texShader.Init(
        "shaders/imesh_tex.vert", "shaders/imesh_tex.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "tex" }
        }
    );
    texaShader.Init(
        "shaders/imesh_tex.vert", "shaders/imesh_texa.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "tex" }
        }
    );
    pointShader.Init(
        "shaders/imesh_point.vert", "shaders/imesh_point.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "loc" }
        }
    );

    texShader.SetUniformTextureUnit("texture", 0);
    texaShader.SetUniformTextureUnit("texture", 0);
    selectedShader = &amp;colShader;
}

</t>
<t tx="leo1.20171224221233.185">void IndexedMeshRenderer::Clear() {
    texShader.Clear();
    texaShader.Clear();
    colShader.Clear();
    pointShader.Clear();
}

IndexedMeshRenderer::Handle IndexedMeshRenderer::Add(const SIndexedMesh &amp;m, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);

    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, m.vertices.size() * sizeof(SIndexedMesh::Vertex),
                 m.vertices.data(), mode);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, m.indices.size() * sizeof(uint32_t),
                 m.indices.data(), mode);
    handle.size = m.indices.size();
    return handle;
}

</t>
<t tx="leo1.20171224221233.186">void IndexedMeshRenderer::Remove(const IndexedMeshRenderer::Handle &amp;m) {
    glDeleteBuffers(1, &amp;m.vertexBuffer);
    glDeleteBuffers(1, &amp;m.indexBuffer);
}

</t>
<t tx="leo1.20171224221233.187">void IndexedMeshRenderer::Draw(const IndexedMeshRenderer::Handle &amp;m) {
    selectedShader-&gt;Enable();

    glBindBuffer(GL_ARRAY_BUFFER, m.vertexBuffer);
    glEnableVertexAttribArray(ATTRIB_POS);
    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(SIndexedMesh::Vertex),
                          (void *)offsetof(SIndexedMesh::Vertex, pos));
    if(NeedsTexture()) {
        glEnableVertexAttribArray(ATTRIB_TEX);
        glVertexAttribPointer(ATTRIB_TEX, 2, GL_FLOAT, GL_FALSE, sizeof(SIndexedMesh::Vertex),
                              (void *)offsetof(SIndexedMesh::Vertex, tex));
    }

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m.indexBuffer);
    glDrawElements(GL_TRIANGLES, m.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    if(NeedsTexture()) glDisableVertexAttribArray(ATTRIB_TEX);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    selectedShader-&gt;Disable();
}

</t>
<t tx="leo1.20171224221233.188">void IndexedMeshRenderer::Draw(const SIndexedMesh &amp;mesh) {
    Handle handle = Add(mesh, /*dynamic=*/true) ;
    Draw(handle);
    Remove(handle);
}

</t>
<t tx="leo1.20171224221233.189">bool IndexedMeshRenderer::NeedsTexture() const {
    return selectedShader == &amp;texShader ||
        selectedShader == &amp;texaShader ||
        selectedShader == &amp;pointShader;
}

</t>
<t tx="leo1.20171224221233.19">void AddContextMenuItem(const char *label, ContextCommand cmd) {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.190">void IndexedMeshRenderer::SetModelview(double *matrix) {
    colShader.SetUniformMatrix("modelview", matrix);
    texShader.SetUniformMatrix("modelview", matrix);
    texaShader.SetUniformMatrix("modelview", matrix);
    pointShader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo1.20171224221233.191">void IndexedMeshRenderer::SetProjection(double *matrix) {
    colShader.SetUniformMatrix("projection", matrix);
    texShader.SetUniformMatrix("projection", matrix);
    texaShader.SetUniformMatrix("projection", matrix);
    pointShader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo1.20171224221233.192">void IndexedMeshRenderer::UseFilled(const Canvas::Fill &amp;fill) {
    if(fill.texture) {
        selectedShader = (fill.texture-&gt;format == Pixmap::Format::A) ? &amp;texaShader : &amp;texShader;
    } else {
        selectedShader = &amp;colShader;
    }
    selectedShader-&gt;SetUniformColor("color", fill.color);
}

</t>
<t tx="leo1.20171224221233.193">void IndexedMeshRenderer::UsePoint(const Canvas::Stroke &amp;stroke, double pixel) {
    pointShader.SetUniformColor("color", stroke.color);
    pointShader.SetUniformFloat("width", (float)(stroke.width * pixel / 2.0));
    pointShader.SetUniformFloat("pixel", (float)pixel);
    selectedShader = &amp;pointShader;
}

}
</t>
<t tx="leo1.20171224221233.194">//-----------------------------------------------------------------------------
// Backend-agnostic rendering interface, and various backends we use.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Camera transformations.
//-----------------------------------------------------------------------------

Point2d Camera::ProjectPoint(Vector p) const {
    Vector p3 = ProjectPoint3(p);
    Point2d p2 = { p3.x, p3.y };
    return p2;
}

Vector Camera::ProjectPoint3(Vector p) const {
    double w;
    Vector r = ProjectPoint4(p, &amp;w);
    return r.ScaledBy(scale/w);
}

Vector Camera::ProjectPoint4(Vector p, double *w) const {
    p = p.Plus(offset);

    Vector r;
    r.x = p.Dot(projRight);
    r.y = p.Dot(projUp);
    r.z = p.Dot(projUp.Cross(projRight));

    *w = 1 + r.z*tangent*scale;
    return r;
}

Vector Camera::UnProjectPoint(Point2d p) const {
    Vector orig = offset.ScaledBy(-1);

    // Note that we're ignoring the effects of perspective. Since our returned
    // point has the same component normal to the screen as the offset, it
    // will have z = 0 after the rotation is applied, thus w = 1. So this is
    // correct.
    orig = orig.Plus(projRight.ScaledBy(p.x / scale)).Plus(
                     projUp.   ScaledBy(p.y / scale));
    return orig;
}

Vector Camera::UnProjectPoint3(Vector p) const {
    p.z = p.z / (scale - p.z * tangent * scale);
    double w = 1 + p.z * tangent * scale;
    p.x *= w / scale;
    p.y *= w / scale;

    Vector orig = offset.ScaledBy(-1);
    orig = orig.Plus(projRight.ScaledBy(p.x)).Plus(
                     projUp.   ScaledBy(p.y).Plus(
                     projUp.Cross(projRight). ScaledBy(p.z)));
    return orig;
}

Vector Camera::VectorFromProjs(Vector rightUpForward) const {
    Vector n = projRight.Cross(projUp);

    Vector r = (projRight.ScaledBy(rightUpForward.x));
    r =  r.Plus(projUp.ScaledBy(rightUpForward.y));
    r =  r.Plus(n.ScaledBy(rightUpForward.z));
    return r;
}

Vector Camera::AlignToPixelGrid(Vector v) const {
    if(!hasPixels) return v;

    v = ProjectPoint3(v);
    v.x = floor(v.x) + 0.5;
    v.y = floor(v.y) + 0.5;
    return UnProjectPoint3(v);
}

SBezier Camera::ProjectBezier(SBezier b) const {
    Quaternion q = Quaternion::From(projRight, projUp);
    q = q.Inverse();
    // we want Q*(p - o) = Q*p - Q*o
    b = b.TransformedBy(q.Rotate(offset).ScaledBy(scale), q, scale);
    for(int i = 0; i &lt;= b.deg; i++) {
        Vector4 ct = Vector4::From(b.weight[i], b.ctrl[i]);
        // so the desired curve, before perspective, is
        //    (x/w, y/w, z/w)
        // and after perspective is
        //    ((x/w)/(1 - (z/w)*tangent, ...
        //  = (x/(w - z*tangent), ...
        // so we want to let w' = w - z*tangent
        ct.w = ct.w - ct.z*tangent;

        b.ctrl[i] = ct.PerspectiveProject();
        b.weight[i] = ct.w;
    }
    return b;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221233.2">void CheckType(Type expectedType) {
    ssassert(type == Setting::Type::Undefined ||
             type == expectedType, "Wrong setting type");
    type = expectedType;
}
</t>
<t tx="leo1.20171224221233.20">void CreateContextSubmenu() {
    ssassert(false, "Not implemented");
}
ContextCommand ShowContextMenu() {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.21">void EnableMenuByCmd(Command cmd, bool enabled) {
}
</t>
<t tx="leo1.20171224221233.22">void CheckMenuByCmd(Command cmd, bool checked) {
}
</t>
<t tx="leo1.20171224221233.23">void RadioMenuByCmd(Command cmd, bool selected) {
}
</t>
<t tx="leo1.20171224221233.24">void RefreshRecentMenus() {
}

//-----------------------------------------------------------------------------
// Text window
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.25">void ShowTextWindow(bool visible) {
}
</t>
<t tx="leo1.20171224221233.26">void GetTextWindowSize(int *w, int *h) {
    *w = *h = 100;
}
</t>
<t tx="leo1.20171224221233.27">void InvalidateText() {
}
</t>
<t tx="leo1.20171224221233.28">void MoveTextScrollbarTo(int pos, int maxPos, int page) {
}
</t>
<t tx="leo1.20171224221233.29">void SetMousePointerToHand(bool is_hand) {
}
</t>
<t tx="leo1.20171224221233.3">void CnfFreezeInt(uint32_t val, const std::string &amp;key) {
    Setting &amp;setting = settings[key];
    setting.CheckType(Setting::Type::Int);
    setting.valueInt = val;
}
uint32_t CnfThawInt(uint32_t val, const std::string &amp;key) {
    if(settings.find(key) != settings.end()) {
        Setting &amp;setting = settings[key];
        setting.CheckType(Setting::Type::Int);
        val = setting.valueInt;
    }
    return val;
}

</t>
<t tx="leo1.20171224221233.30">void ShowTextEditControl(int x, int y, const std::string &amp;val) {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.31">void HideTextEditControl() {
}
</t>
<t tx="leo1.20171224221233.32">bool TextEditControlIsVisible() {
    return false;
}

//-----------------------------------------------------------------------------
// Dialogs
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.33">bool GetOpenFile(Platform::Path *filename, const std::string &amp;activeOrEmpty,
                 const FileFilter filters[]) {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.34">bool GetSaveFile(Platform::Path *filename, const std::string &amp;activeOrEmpty,
                 const FileFilter filters[]) {
    ssassert(false, "Not implemented");
}
DialogChoice SaveFileYesNoCancel() {
    ssassert(false, "Not implemented");
}
DialogChoice LoadAutosaveYesNo() {
    ssassert(false, "Not implemented");
}
DialogChoice LocateImportedFileYesNoCancel(const Platform::Path &amp;filename,
</t>
<t tx="leo1.20171224221233.35">                                           bool canCancel) {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.36">void DoMessageBox(const char *message, int rows, int cols, bool error) {
    dbp("%s box: %s", error ? "error" : "message", message);
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo1.20171224221233.37">void OpenWebsite(const char *url) {
    ssassert(false, "Not implemented");
}

//-----------------------------------------------------------------------------
// Resources
//-----------------------------------------------------------------------------

std::vector&lt;Platform::Path&gt; fontFiles;
std::vector&lt;Platform::Path&gt; GetFontFiles() {
    return fontFiles;
}

//-----------------------------------------------------------------------------
// Application lifecycle
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.38">void RefreshLocale() {
}

</t>
<t tx="leo1.20171224221233.39">void ExitNow() {
    ssassert(false, "Not implemented");
}

}
</t>
<t tx="leo1.20171224221233.4">void CnfFreezeFloat(float val, const std::string &amp;key) {
    Setting &amp;setting = settings[key];
    setting.CheckType(Setting::Type::Float);
    setting.valueFloat = val;
}
</t>
<t tx="leo1.20171224221233.40">//-----------------------------------------------------------------------------
// Platform-dependent functionality.
//
// Copyright 2017 whitequark
//-----------------------------------------------------------------------------
#if defined(__APPLE__)
// Include Apple headers before solvespace.h to avoid identifier clashes.
#   include &lt;CoreFoundation/CFString.h&gt;
#   include &lt;CoreFoundation/CFURL.h&gt;
#   include &lt;CoreFoundation/CFBundle.h&gt;
#endif
#include "solvespace.h"
#include "config.h"
#if defined(WIN32)
// Conversely, include Microsoft headers after solvespace.h to avoid clashes.
#   include &lt;windows.h&gt;
#else
#   include &lt;unistd.h&gt;
#   include &lt;sys/stat.h&gt;
#endif

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// UTF-8  UTF-16 conversion, on Windows.
//-----------------------------------------------------------------------------

#if defined(WIN32)

std::string Narrow(const wchar_t *in)
{
    std::string out;
    DWORD len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);
    out.resize(len - 1);
    ssassert(WideCharToMultiByte(CP_UTF8, 0, in, -1, &amp;out[0], len, NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::string Narrow(const std::wstring &amp;in)
{
    if(in == L"") return "";

    std::string out;
    out.resize(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                   NULL, 0, NULL, NULL));
    ssassert(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length(), NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::wstring Widen(const char *in)
{
    std::wstring out;
    DWORD len = MultiByteToWideChar(CP_UTF8, 0, in, -1, NULL, 0);
    out.resize(len - 1);
    ssassert(MultiByteToWideChar(CP_UTF8, 0, in, -1, &amp;out[0], len),
             "Invalid UTF-8");
    return out;
}

std::wstring Widen(const std::string &amp;in)
{
    if(in == "") return L"";

    std::wstring out;
    out.resize(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(), NULL, 0));
    ssassert(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length()),
             "Invalid UTF-8");
    return out;
}

#endif

//-----------------------------------------------------------------------------
// Path utility functions.
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221233.41">static std::vector&lt;std::string&gt; Split(const std::string &amp;joined, char separator) {
    std::vector&lt;std::string&gt; parts;

    size_t oldpos = 0, pos = 0;
    while(true) {
        oldpos = pos;
        pos = joined.find(separator, pos);
        if(pos == std::string::npos) break;
        parts.push_back(joined.substr(oldpos, pos - oldpos));
        pos += 1;
    }

    if(oldpos != joined.length() - 1) {
        parts.push_back(joined.substr(oldpos));
    }

    return parts;
}

</t>
<t tx="leo1.20171224221233.42">static std::string Concat(const std::vector&lt;std::string&gt; &amp;parts, char separator) {
    std::string joined;

    bool first = true;
    for(auto &amp;part : parts) {
        if(!first) joined += separator;
        joined += part;
        first = false;
    }

    return joined;
}

//-----------------------------------------------------------------------------
// Path manipulation.
//-----------------------------------------------------------------------------

#if defined(WIN32)
const char SEPARATOR = '\\';
#else
const char SEPARATOR = '/';
#endif

Path Path::From(std::string raw) {
    Path path = { raw };
    return path;
}

Path Path::CurrentDirectory() {
#if defined(WIN32)
    // On Windows, OpenFile needs an absolute UNC path proper, so get that.
    std::wstring rawW;
    rawW.resize(GetCurrentDirectoryW(0, NULL));
    DWORD length = GetCurrentDirectoryW((int)rawW.length(), &amp;rawW[0]);
    ssassert(length &gt; 0 &amp;&amp; length == rawW.length() - 1, "Cannot get current directory");
    rawW.resize(length);
    return From(Narrow(rawW));
#else
    char *raw = getcwd(NULL, 0);
    ssassert(raw != NULL, "Cannot get current directory");
    Path path = From(raw);
    free(raw);
    return path;
#endif
}

std::string Path::FileName() const {
    std::string fileName = raw;
    size_t slash = fileName.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        fileName = fileName.substr(slash + 1);
    }
    return fileName;
}

std::string Path::FileStem() const {
    std::string baseName = FileName();
    size_t dot = baseName.rfind('.');
    if(dot != std::string::npos) {
        baseName = baseName.substr(0, dot);
    }
    return baseName;
}

std::string Path::Extension() const {
    size_t dot = raw.rfind('.');
    if(dot != std::string::npos) {
        return raw.substr(dot + 1);
    }
    return "";
}

</t>
<t tx="leo1.20171224221233.43">bool Path::HasExtension(std::string theirExt) const {
    std::string ourExt = Extension();
    std::transform(ourExt.begin(),   ourExt.end(),   ourExt.begin(),   ::tolower);
    std::transform(theirExt.begin(), theirExt.end(), theirExt.begin(), ::tolower);
    return ourExt == theirExt;
}

Path Path::WithExtension(std::string ext) const {
    Path withExt = *this;
    size_t dot = withExt.raw.rfind('.');
    if(dot != std::string::npos) {
        withExt.raw.erase(dot);
    }
    withExt.raw += ".";
    withExt.raw += ext;
    return withExt;
}

</t>
<t tx="leo1.20171224221233.44">static void FindPrefix(const std::string &amp;raw, size_t *pos) {
    *pos = std::string::npos;
#if defined(WIN32)
    if(raw.size() &gt;= 7 &amp;&amp; raw[2] == '?' &amp;&amp; raw[3] == '\\' &amp;&amp;
            isalpha(raw[4]) &amp;&amp; raw[5] == ':' &amp;&amp; raw[6] == '\\') {
        *pos = 7;
    } else if(raw.size() &gt;= 3 &amp;&amp; isalpha(raw[0]) &amp;&amp; raw[1] == ':' &amp;&amp; raw[2] == '\\') {
        *pos = 3;
    } else if(raw.size() &gt;= 2 &amp;&amp; raw[0] == '\\' &amp;&amp; raw[1] == '\\') {
        size_t slashAt = raw.find('\\', 2);
        if(slashAt != std::string::npos) {
            *pos = raw.find('\\', slashAt + 1);
        }
    }
#else
    if(raw.size() &gt;= 1 &amp;&amp; raw[0] == '/') {
        *pos = 1;
    }
#endif
}

</t>
<t tx="leo1.20171224221233.45">bool Path::IsAbsolute() const {
    size_t pos;
    FindPrefix(raw, &amp;pos);
    return pos != std::string::npos;
}

// Removes one component from the end of the path.
// Returns an empty path if the path consists only of a root.
Path Path::Parent() const {
    Path parent = { raw };
    if(!parent.raw.empty() &amp;&amp; parent.raw.back() == SEPARATOR) {
        parent.raw.pop_back();
    }
    size_t slash = parent.raw.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        parent.raw = parent.raw.substr(0, slash + 1);
    } else {
        parent.raw.clear();
    }
    if(IsAbsolute() &amp;&amp; !parent.IsAbsolute()) {
        return From("");
    }
    return parent;
}

// Concatenates a component to this path.
// Returns an empty path if this path or the component is empty.
Path Path::Join(const std::string &amp;component) const {
    ssassert(component.find(SEPARATOR) == std::string::npos,
             "Use the Path::Join(const Path &amp;) overload to append an entire path");
    return Join(Path::From(component));
}

// Concatenates a relative path to this path.
// Returns an empty path if either path is empty, or the other path is absolute.
Path Path::Join(const Path &amp;other) const {
    if(IsEmpty() || other.IsEmpty() || other.IsAbsolute()) {
        return From("");
    }

    Path joined = { raw };
    if(joined.raw.back() != SEPARATOR) {
        joined.raw += SEPARATOR;
    }
    joined.raw += other.raw;
    return joined;
}

// Expands the "." and ".." components in this path.
// On Windows, additionally prepends the UNC prefix to absolute paths without one.
// Returns an empty path if a ".." component would escape from the root.
Path Path::Expand(bool fromCurrentDirectory) const {
    Path source;
    Path expanded;

    if(fromCurrentDirectory &amp;&amp; !IsAbsolute()) {
        source = CurrentDirectory().Join(*this);
    } else {
        source = *this;
    }

    size_t splitAt;
    FindPrefix(source.raw, &amp;splitAt);
    if(splitAt != std::string::npos) {
        expanded.raw = source.raw.substr(0, splitAt);
    } else {
        splitAt = 0;
    }

    std::vector&lt;std::string&gt; expandedComponents;
    for(std::string component : Split(source.raw.substr(splitAt), SEPARATOR)) {
        if(component == ".") {
            // skip
        } else if(component == "..") {
            if(!expandedComponents.empty()) {
                expandedComponents.pop_back();
            } else {
                return From("");
            }
        } else if(!component.empty()) {
            expandedComponents.push_back(component);
        }
    }

    if(expanded.IsEmpty()) {
        if(expandedComponents.empty()) {
            expandedComponents.push_back(".");
        }
        expanded = From(Concat(expandedComponents, SEPARATOR));
    } else if(!expandedComponents.empty()) {
        expanded = expanded.Join(From(Concat(expandedComponents, SEPARATOR)));
    }

#if defined(WIN32)
    if(expanded.IsAbsolute() &amp;&amp; expanded.raw.substr(0, 2) != "\\\\") {
        expanded.raw = "\\\\?\\" + expanded.raw;
    }
#endif

    return expanded;
}

</t>
<t tx="leo1.20171224221233.46">static std::string FilesystemNormalize(const std::string &amp;str) {
#if defined(WIN32)
    std::wstring strW = Widen(str);
    std::transform(strW.begin(), strW.end(), strW.begin(), towlower);
    return Narrow(strW);
#elif defined(__APPLE__)
    CFMutableStringRef cfStr =
        CFStringCreateMutableCopy(NULL, 0,
            CFStringCreateWithBytesNoCopy(NULL, (const UInt8*)str.data(), str.size(),
                kCFStringEncodingUTF8, /*isExternalRepresentation=*/false, kCFAllocatorNull));
    CFStringLowercase(cfStr, NULL);
    std::string normalizedStr;
    normalizedStr.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfStr));
    CFStringGetFileSystemRepresentation(cfStr, &amp;normalizedStr[0], normalizedStr.size());
    normalizedStr.erase(normalizedStr.find('\0'));
    return normalizedStr;
#else
    return str;
#endif
}

</t>
<t tx="leo1.20171224221233.47">bool Path::Equals(const Path &amp;other) const {
    return FilesystemNormalize(raw) == FilesystemNormalize(other.raw);
}

// Returns a relative path from a given base path.
// Returns an empty path if any of the paths is not absolute, or
// if they belong to different roots, or
// if they cannot be expanded.
Path Path::RelativeTo(const Path &amp;base) const {
    Path expanded = Expand();
    Path baseExpanded = base.Expand();
    if(!(expanded.IsAbsolute() &amp;&amp; baseExpanded.IsAbsolute())){
        return From("");
    }

    size_t splitAt;
    FindPrefix(expanded.raw, &amp;splitAt);
    size_t baseSplitAt;
    FindPrefix(baseExpanded.raw, &amp;baseSplitAt);
    if(FilesystemNormalize(expanded.raw.substr(0, splitAt)) !=
            FilesystemNormalize(baseExpanded.raw.substr(0, splitAt))) {
        return From("");
    }

    std::vector&lt;std::string&gt; components =
        Split(expanded.raw.substr(splitAt), SEPARATOR);
    std::vector&lt;std::string&gt; baseComponents =
        Split(baseExpanded.raw.substr(baseSplitAt), SEPARATOR);
    size_t common;
    for(common = 0; common &lt; baseComponents.size() &amp;&amp;
                    common &lt; components.size(); common++) {
        if(FilesystemNormalize(baseComponents[common]) !=
                FilesystemNormalize(components[common])) {
            break;
        }
    }

    std::vector&lt;std::string&gt; resultComponents;
    for(size_t i = common; i &lt; baseComponents.size(); i++) {
        resultComponents.push_back("..");
    }
    resultComponents.insert(resultComponents.end(),
                            components.begin() + common, components.end());
    if(resultComponents.empty()) {
        resultComponents.push_back(".");
    }
    return From(Concat(resultComponents, SEPARATOR));
}

Path Path::FromPortable(const std::string &amp;repr) {
    return From(Concat(Split(repr, '/'), SEPARATOR));
}

std::string Path::ToPortable() const {
    ssassert(!IsAbsolute(), "absolute paths cannot be made portable");

    return Concat(Split(raw, SEPARATOR), '/');
}

//-----------------------------------------------------------------------------
// File manipulation.
//-----------------------------------------------------------------------------

FILE *OpenFile(const Platform::Path &amp;filename, const char *mode) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    return _wfopen(Widen(filename.Expand().raw).c_str(), Widen(mode).c_str());
#else
    return fopen(filename.raw.c_str(), mode);
#endif
}

</t>
<t tx="leo1.20171224221233.48">void RemoveFile(const Platform::Path &amp;filename) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    _wremove(Widen(filename.Expand().raw).c_str());
#else
    remove(filename.raw.c_str());
#endif
}

</t>
<t tx="leo1.20171224221233.49">bool ReadFile(const Platform::Path &amp;filename, std::string *data) {
    FILE *f = OpenFile(filename, "rb");
    if(f == NULL) return false;

    fseek(f, 0, SEEK_END);
    data-&gt;resize(ftell(f));
    fseek(f, 0, SEEK_SET);
    fread(&amp;(*data)[0], 1, data-&gt;size(), f);
    fclose(f);

    return true;
}

</t>
<t tx="leo1.20171224221233.5">float CnfThawFloat(float val, const std::string &amp;key) {
    if(settings.find(key) != settings.end()) {
        Setting &amp;setting = settings[key];
        setting.CheckType(Setting::Type::Float);
        val = setting.valueFloat;
    }
    return val;
}

</t>
<t tx="leo1.20171224221233.50">bool WriteFile(const Platform::Path &amp;filename, const std::string &amp;data) {
    FILE *f = OpenFile(filename, "wb");
    if(f == NULL) return false;

    fwrite(&amp;data[0], 1, data.size(), f);
    fclose(f);

    return true;
}

//-----------------------------------------------------------------------------
// Loading resources, on Windows.
//-----------------------------------------------------------------------------

#if defined(WIN32)

</t>
<t tx="leo1.20171224221233.51">const void *LoadResource(const std::string &amp;name, size_t *size) {
    HRSRC hres = FindResourceW(NULL, Widen(name).c_str(), RT_RCDATA);
    ssassert(hres != NULL, "Cannot find resource");
    HGLOBAL res = ::LoadResource(NULL, hres);
    ssassert(res != NULL, "Cannot load resource");

    *size = SizeofResource(NULL, hres);
    return LockResource(res);
}

#endif

//-----------------------------------------------------------------------------
// Loading resources, on *nix.
//-----------------------------------------------------------------------------

#if defined(__APPLE__)

</t>
<t tx="leo1.20171224221233.52">static Platform::Path PathFromCFURL(CFURLRef cfUrl) {
    Path path;
    CFStringRef cfPath = CFURLCopyFileSystemPath(cfUrl, kCFURLPOSIXPathStyle);
    path.raw.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfPath));
    CFStringGetFileSystemRepresentation(cfPath, &amp;path.raw[0], path.raw.size());
    path.raw.erase(path.raw.find('\0'));
    CFRelease(cfPath);
    return path;
}

</t>
<t tx="leo1.20171224221233.53">static Platform::Path ResourcePath(const std::string &amp;name) {
    Path path;

    // First, try to get the URL from the bundle.
    CFStringRef cfName = CFStringCreateWithCString(kCFAllocatorDefault, name.c_str(),
                                                   kCFStringEncodingUTF8);
    CFURLRef cfUrl = CFBundleCopyResourceURL(CFBundleGetMainBundle(), cfName, NULL, NULL);
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl);
        CFRelease(cfUrl);
    }
    CFRelease(cfName);

    if(!path.IsEmpty()) return path;

    // If that failed, it means we aren't running from the bundle.
    // Reference off the executable path, then.
    cfUrl = CFBundleCopyExecutableURL(CFBundleGetMainBundle());
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl).Parent().Parent().Join("res");
        path = path.Join(Path::FromPortable(name));
        CFRelease(cfUrl);
    }

    return path;
}

#elif !defined(WIN32)

#    if defined(__linux__)
static const char *selfSymlink = "/proc/self/exe";
#    elif defined(__NetBSD__)
static const char *selfSymlink = "/proc/curproc/exe";
#    elif defined(__OpenBSD__) || defined(__FreeBSD__)
static const char *selfSymlink = "/proc/curproc/file";
#    else
static const char *selfSymlink = "";
#    endif

</t>
<t tx="leo1.20171224221233.54">static Platform::Path FindLocalResourceDir() {
    // Find out the path to the running binary.
    Platform::Path selfPath;
    char *expandedSelfPath = realpath(selfSymlink, NULL);
    if(expandedSelfPath != NULL) {
        selfPath = Path::From(expandedSelfPath);
    }
    free(expandedSelfPath);

    Platform::Path resourceDir;
    if(selfPath.IsEmpty()) {
        // We don't know how to find the local resource directory on this platform,
        // so use the global one (by returning an empty string).
        return Path::From(UNIX_DATADIR);
    } else {
        resourceDir = selfPath.Parent().Parent().Join("res");
    }

    struct stat st;
    if(stat(resourceDir.raw.c_str(), &amp;st) != -1) {
        // An executable-adjacent resource directory exists, good.
        return resourceDir;
    }

    // No executable-adjacent resource directory; use the one from compile-time prefix.
    return Path::From(UNIX_DATADIR);
}

</t>
<t tx="leo1.20171224221233.55">static Platform::Path ResourcePath(const std::string &amp;name) {
    static Platform::Path resourceDir;
    if(resourceDir.IsEmpty()) {
        resourceDir = FindLocalResourceDir();
    }

    return resourceDir.Join(Path::FromPortable(name));
}

#endif

#if !defined(WIN32)

</t>
<t tx="leo1.20171224221233.56">const void *LoadResource(const std::string &amp;name, size_t *size) {
    static std::map&lt;std::string, std::string&gt; cache;

    auto it = cache.find(name);
    if(it == cache.end()) {
        ssassert(ReadFile(ResourcePath(name), &amp;cache[name]), "Cannot read resource");
        it = cache.find(name);
    }

    const std::string &amp;content = (*it).second;
    *size = content.size();
    return (const void*)content.data();
}

#endif

}
}
</t>
<t tx="leo1.20171224221233.57">//-----------------------------------------------------------------------------
// Utility functions used by the Unix port. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
// Copyright 2013 Daniel Richard G. &lt;skunk@iSKUNK.ORG&gt;
//-----------------------------------------------------------------------------
#include &lt;execinfo.h&gt;
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221233.58">void dbp(const char *str, ...)
{
    va_list f;
    static char buf[1024*50];
    va_start(f, str);
    vsnprintf(buf, sizeof(buf), str, f);
    va_end(f);

    fputs(buf, stderr);
    fputc('\n', stderr);
}

</t>
<t tx="leo1.20171224221233.59">void assert_failure(const char *file, unsigned line, const char *function,
                    const char *condition, const char *message) {
    fprintf(stderr, "File %s, line %u, function %s:\n", file, line, function);
    fprintf(stderr, "Assertion '%s' failed: ((%s) == false).\n", message, condition);

#ifndef LIBRARY
    static void *ptrs[1024] = {};
    size_t nptrs = backtrace(ptrs, sizeof(ptrs) / sizeof(ptrs[0]));
    char **syms = backtrace_symbols(ptrs, nptrs);

    fprintf(stderr, "Backtrace:\n");
    if(syms != NULL) {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %s\n", i, syms[i]);
        }
    } else {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %p\n", i, ptrs[i]);
        }
    }
#endif

    abort();
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since fragmentation is less of a concern, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------

typedef struct _AllocTempHeader AllocTempHeader;

</t>
<t tx="leo1.20171224221233.6">void CnfFreezeString(const std::string &amp;val, const std::string &amp;key) {
    Setting &amp;setting = settings[key];
    setting.CheckType(Setting::Type::String);
    setting.valueString = val;
}
std::string CnfThawString(const std::string &amp;val, const std::string &amp;key) {
    std::string ret = val;
    if(settings.find(key) != settings.end()) {
        Setting &amp;setting = settings[key];
        setting.CheckType(Setting::Type::String);
        ret = setting.valueString;
    }
    return ret;
}

//-----------------------------------------------------------------------------
// Timers
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.60">typedef struct _AllocTempHeader {
    AllocTempHeader *prev;
    AllocTempHeader *next;
} AllocTempHeader;

static AllocTempHeader *Head = NULL;

</t>
<t tx="leo1.20171224221233.61">void *AllocTemporary(size_t n)
{
    AllocTempHeader *h =
        (AllocTempHeader *)malloc(n + sizeof(AllocTempHeader));
    h-&gt;prev = NULL;
    h-&gt;next = Head;
    if(Head) Head-&gt;prev = h;
    Head = h;
    memset(&amp;h[1], 0, n);
    return (void *)&amp;h[1];
}

</t>
<t tx="leo1.20171224221233.62">void FreeTemporary(void *p)
{
    AllocTempHeader *h = (AllocTempHeader *)p - 1;
    if(h-&gt;prev) {
        h-&gt;prev-&gt;next = h-&gt;next;
    } else {
        Head = h-&gt;next;
    }
    if(h-&gt;next) h-&gt;next-&gt;prev = h-&gt;prev;
    free(h);
}

</t>
<t tx="leo1.20171224221233.63">void FreeAllTemporary(void)
{
    AllocTempHeader *h = Head;
    while(h) {
        AllocTempHeader *f = h;
        h = h-&gt;next;
        free(f);
    }
    Head = NULL;
}

</t>
<t tx="leo1.20171224221233.64">void *MemAlloc(size_t n) {
    void *p = malloc(n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}

</t>
<t tx="leo1.20171224221233.65">void MemFree(void *p) {
    free(p);
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
    std::vector&lt;std::string&gt; args;
    for(int i = 0; i &lt; argc; i++) {
        args.push_back(argv[i]);
    }
    return args;
}

};
</t>
<t tx="leo1.20171224221233.66">//-----------------------------------------------------------------------------
// Our WinMain() functions, and Win32-specific stuff to set up our windows
// and otherwise handle our interface to the operating system. Everything
// outside platform/... should be standard C++ and gl.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include &lt;time.h&gt;

#include "config.h"
#include "solvespace.h"

// Include after solvespace.h to avoid identifier clashes.
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;
#include &lt;commctrl.h&gt;
#include &lt;commdlg.h&gt;

#ifdef MenuHelp
// This is defined to IsolationAwareMenuHelp on Windows 6.0 and later.
#undef MenuHelp
#endif

#ifdef HAVE_SPACEWARE
#   include &lt;si.h&gt;
#   include &lt;siapp.h&gt;
#   undef uint32_t  // thanks but no thanks
#endif

#if HAVE_OPENGL == 3
#define EGLAPI /*static linkage*/
#include &lt;EGL/egl.h&gt;
#endif

using Platform::Narrow;
using Platform::Widen;

HINSTANCE Instance;

HWND TextWnd;
HWND TextWndScrollBar;
HWND TextEditControl;
#if HAVE_OPENGL == 3
EGLDisplay TextGlDisplay;
EGLSurface TextGlSurface;
EGLContext TextGlContext;
#else
HGLRC TextGl;
#endif

HWND GraphicsWnd;
HWND GraphicsEditControl;
#if HAVE_OPENGL == 3
EGLDisplay GraphicsGlDisplay;
EGLSurface GraphicsGlSurface;
EGLContext GraphicsGlContext;
#else
HGLRC GraphicsGl;
#endif
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221233.67">static struct {
    int x, y;
} LastMousePos;

HMENU SubMenus[100];
HMENU RecentOpenMenu, RecentImportMenu;

HMENU ContextMenu, ContextSubmenu;

int ClientIsSmallerBy;

HFONT FixedFont;

#ifdef HAVE_SPACEWARE
// The 6-DOF input device.
SiHdl SpaceNavigator = SI_NO_HANDLE;
#endif

//-----------------------------------------------------------------------------
// Utility routines
//-----------------------------------------------------------------------------
std::wstring Title(const std::string &amp;s) {
    return Widen("SolveSpace - " + s);
}

//-----------------------------------------------------------------------------
// Routines to display message boxes on screen. Do our own, instead of using
// MessageBox, because that is not consistent from version to version and
// there's word wrap problems.
//-----------------------------------------------------------------------------

HWND MessageWnd, OkButton;
bool MessageDone;
int MessageWidth, MessageHeight;
const char *MessageString;

</t>
<t tx="leo1.20171224221233.68">static LRESULT CALLBACK MessageProc(HWND hwnd, UINT msg, WPARAM wParam,
    LPARAM lParam)
{
    switch (msg) {
        case WM_COMMAND:
            if((HWND)lParam == OkButton &amp;&amp; wParam == BN_CLICKED) {
                MessageDone = true;
            }
            break;

        case WM_CLOSE:
        case WM_DESTROY:
            MessageDone = true;
            break;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &amp;ps);
            SelectObject(hdc, FixedFont);
            SetTextColor(hdc, 0x000000);
            SetBkMode(hdc, TRANSPARENT);
            RECT rc;
            SetRect(&amp;rc, 10, 10, MessageWidth, MessageHeight);
            std::wstring text = Widen(MessageString);
            DrawText(hdc, text.c_str(), text.length(), &amp;rc, DT_LEFT | DT_WORDBREAK);
            EndPaint(hwnd, &amp;ps);
            break;
        }

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 1;
}

HWND CreateWindowClient(DWORD exStyle, const wchar_t *className, const wchar_t *windowName,
    DWORD style, int x, int y, int width, int height, HWND parent,
    HMENU menu, HINSTANCE instance, void *param)
{
    HWND h = CreateWindowExW(exStyle, className, windowName, style, x, y,
        width, height, parent, menu, instance, param);

    RECT r;
    GetClientRect(h, &amp;r);
    width = width - (r.right - width);
    height = height - (r.bottom - height);

    SetWindowPos(h, HWND_TOP, x, y, width, height, 0);

    return h;
}

</t>
<t tx="leo1.20171224221233.69">void SolveSpace::DoMessageBox(const char *str, int rows, int cols, bool error)
{
    EnableWindow(GraphicsWnd, false);
    EnableWindow(TextWnd, false);

    // Register the window class for our dialog.
    WNDCLASSEX wc = {};
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW | CS_OWNDC;
    wc.lpfnWndProc      = (WNDPROC)MessageProc;
    wc.hInstance        = Instance;
    wc.hbrBackground    = (HBRUSH)COLOR_BTNSHADOW;
    wc.lpszClassName    = L"MessageWnd";
    wc.lpszMenuName     = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 32, 32, 0);
    wc.hIconSm          = (HICON)LoadImage(Instance, MAKEINTRESOURCE(4000),
                            IMAGE_ICON, 16, 16, 0);
    RegisterClassEx(&amp;wc);

    // Create the window.
    MessageString = str;
    RECT r;
    GetWindowRect(GraphicsWnd, &amp;r);
    int width  = cols*SS.TW.CHAR_WIDTH_ + 20,
        (width - 70)/2, rows*SS.TW.LINE_HEIGHT + 20,
        70, 25, MessageWnd, NULL, Instance, NULL);
    SendMessage(OkButton, WM_SETFONT, (WPARAM)FixedFont, true);

    ShowWindow(MessageWnd, true);
    SetFocus(OkButton);

    MSG msg;
    DWORD ret;
    MessageDone = false;
    while((ret = GetMessage(&amp;msg, NULL, 0, 0)) != 0 &amp;&amp; !MessageDone) {
        if((msg.message == WM_KEYDOWN &amp;&amp;
               (msg.wParam == VK_RETURN ||
                msg.wParam == VK_ESCAPE)) ||
            (msg.message == WM_KEYUP &amp;&amp;
               (msg.wParam == VK_SPACE)))
        {
            MessageDone = true;
            break;
        }

        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }

    MessageString = NULL;
    EnableWindow(TextWnd, true);
    EnableWindow(GraphicsWnd, true);
    SetForegroundWindow(GraphicsWnd);
    DestroyWindow(MessageWnd);
}

</t>
<t tx="leo1.20171224221233.7">void SetTimerFor(int milliseconds) {
}
</t>
<t tx="leo1.20171224221233.70">void SolveSpace::AddContextMenuItem(const char *label, ContextCommand cmd)
{
    if(!ContextMenu) ContextMenu = CreatePopupMenu();

    if(cmd == ContextCommand::SUBMENU) {
        AppendMenuW(ContextMenu, MF_STRING | MF_POPUP,
            (UINT_PTR)ContextSubmenu, Widen(label).c_str());
        ContextSubmenu = NULL;
    } else {
        HMENU m = ContextSubmenu ? ContextSubmenu : ContextMenu;
        if(cmd == ContextCommand::SEPARATOR) {
            AppendMenuW(m, MF_SEPARATOR, 0, L"");
        } else {
            AppendMenuW(m, MF_STRING, (uint32_t)cmd, Widen(label).c_str());
        }
    }
}

</t>
<t tx="leo1.20171224221233.71">void SolveSpace::CreateContextSubmenu()
{
    ContextSubmenu = CreatePopupMenu();
}

ContextCommand SolveSpace::ShowContextMenu()
{
    POINT p;
    GetCursorPos(&amp;p);
    int r = TrackPopupMenu(ContextMenu,
    // The timer is periodic, so needs to be killed explicitly.
    KillTimer(GraphicsWnd, 1);
    SS.GW.TimerCallback();
    SS.TW.TimerCallback();
}
</t>
<t tx="leo1.20171224221233.72">void SolveSpace::SetTimerFor(int milliseconds)
{
    SetTimer(GraphicsWnd, 1, milliseconds, TimerCallback);
}

</t>
<t tx="leo1.20171224221233.73">void SolveSpace::ScheduleLater()
{
}

</t>
<t tx="leo1.20171224221233.74">static void CALLBACK AutosaveCallback(HWND hwnd, UINT msg, UINT_PTR id, DWORD time)
{
    KillTimer(GraphicsWnd, 1);
    SS.Autosave();
}

</t>
<t tx="leo1.20171224221233.75">void SolveSpace::SetAutosaveTimerFor(int minutes)
{
    SetTimer(GraphicsWnd, 2, minutes * 60 * 1000, AutosaveCallback);
}

</t>
<t tx="leo1.20171224221233.76">static void GetWindowSize(HWND hwnd, int *w, int *h)
{
    RECT r;
    GetClientRect(hwnd, &amp;r);
    *w = r.right - r.left;
    *h = r.bottom - r.top;
}
</t>
<t tx="leo1.20171224221233.77">void SolveSpace::GetGraphicsWindowSize(int *w, int *h)
{
    GetWindowSize(GraphicsWnd, w, h);
}
</t>
<t tx="leo1.20171224221233.78">void SolveSpace::GetTextWindowSize(int *w, int *h)
{
    GetWindowSize(TextWnd, w, h);
}

double SolveSpace::GetScreenDpi() {
    HDC hdc = GetDC(NULL);
    double dpi = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);
    return dpi;
}

</t>
<t tx="leo1.20171224221233.79">void SolveSpace::OpenWebsite(const char *url) {
    ShellExecuteW(GraphicsWnd, L"open", Widen(url).c_str(), NULL, NULL, SW_SHOWNORMAL);
}

</t>
<t tx="leo1.20171224221233.8">void SetAutosaveTimerFor(int minutes) {
}
</t>
<t tx="leo1.20171224221233.80">void SolveSpace::ExitNow() {
    PostQuitMessage(0);
}

//-----------------------------------------------------------------------------
// Helpers so that we can read/write registry keys from the platform-
// independent code.
//-----------------------------------------------------------------------------
inline int CLAMP(int v, int a, int b) {
    // Clamp it to the range [a, b]
    if(v &lt;= a) return a;
    if(v &gt;= b) return b;
    return v;
}

</t>
<t tx="leo1.20171224221233.81">static HKEY GetRegistryKey()
{
    HKEY Software;
    if(RegOpenKeyExW(HKEY_CURRENT_USER, L"Software", 0,
                     KEY_ALL_ACCESS, &amp;Software) != ERROR_SUCCESS)
        return NULL;

    HKEY SolveSpace;
    if(RegCreateKeyExW(Software, L"SolveSpace", 0, NULL, 0,
                       KEY_ALL_ACCESS, NULL, &amp;SolveSpace, NULL) != ERROR_SUCCESS)
        return NULL;

    RegCloseKey(Software);

    return SolveSpace;
}

</t>
<t tx="leo1.20171224221233.82">void SolveSpace::CnfFreezeInt(uint32_t val, const std::string &amp;name)
{
    HKEY SolveSpace = GetRegistryKey();
    RegSetValueExW(SolveSpace, &amp;Widen(name)[0], 0,
                   REG_DWORD, (const BYTE*) &amp;val, sizeof(DWORD));
    RegCloseKey(SolveSpace);
}
</t>
<t tx="leo1.20171224221233.83">void SolveSpace::CnfFreezeFloat(float val, const std::string &amp;name)
{
    @others
}
</t>
<t tx="leo1.20171224221233.84">    static_assert(sizeof(float) == sizeof(DWORD),
                  "sizes of float and DWORD must match");
    HKEY SolveSpace = GetRegistryKey();
    RegSetValueExW(SolveSpace, &amp;Widen(name)[0], 0,
                   REG_DWORD, (const BYTE*) &amp;val, sizeof(DWORD));
    RegCloseKey(SolveSpace);
}
void SolveSpace::CnfFreezeString(const std::string &amp;str, const std::string &amp;name)
{
    HKEY SolveSpace = GetRegistryKey();
    std::wstring strW = Widen(str);
    RegSetValueExW(SolveSpace, &amp;Widen(name)[0], 0,
                   REG_SZ, (const BYTE*) &amp;strW[0], (strW.length() + 1) * 2);
    RegCloseKey(SolveSpace);
</t>
<t tx="leo1.20171224221233.85">static void FreezeWindowPos(HWND hwnd, const std::string &amp;name)
{
    RECT r;
    GetWindowRect(hwnd, &amp;r);
    CnfFreezeInt(r.left,   name + "_left");
    CnfFreezeInt(r.right,  name + "_right");
    CnfFreezeInt(r.top,    name + "_top");
    CnfFreezeInt(r.bottom, name + "_bottom");

    CnfFreezeInt(IsZoomed(hwnd), name + "_maximized");
}

uint32_t SolveSpace::CnfThawInt(uint32_t val, const std::string &amp;name)
{
    HKEY SolveSpace = GetRegistryKey();
    DWORD type, newval, len = sizeof(DWORD);
    LONG result = RegQueryValueEx(SolveSpace, &amp;Widen(name)[0], NULL,
                                  &amp;type, (BYTE*) &amp;newval, &amp;len);
    RegCloseKey(SolveSpace);

    if(result == ERROR_SUCCESS &amp;&amp; type == REG_DWORD)
        return newval;
    else
        return val;
}
</t>
<t tx="leo1.20171224221233.86">float SolveSpace::CnfThawFloat(float val, const std::string &amp;name)
{
    HKEY SolveSpace = GetRegistryKey();
    DWORD type, len = sizeof(DWORD);
    float newval;
    LONG result = RegQueryValueExW(SolveSpace, &amp;Widen(name)[0], NULL,
                                   &amp;type, (BYTE*) &amp;newval, &amp;len);
    RegCloseKey(SolveSpace);

    if(result == ERROR_SUCCESS &amp;&amp; type == REG_DWORD)
        return newval;
    else
        return val;
}
std::string SolveSpace::CnfThawString(const std::string &amp;val, const std::string &amp;name)
{
    HKEY SolveSpace = GetRegistryKey();
    DWORD type, len;
    if(RegQueryValueExW(SolveSpace, &amp;Widen(name)[0], NULL,
                        &amp;type, NULL, &amp;len) != ERROR_SUCCESS || type != REG_SZ) {
        RegCloseKey(SolveSpace);
        return val;
    }

    std::wstring newval;
    newval.resize(len / 2 - 1);
    if(RegQueryValueExW(SolveSpace, &amp;Widen(name)[0], NULL,
                        NULL, (BYTE*) &amp;newval[0], &amp;len) != ERROR_SUCCESS) {
        RegCloseKey(SolveSpace);
        return val;
    }

    RegCloseKey(SolveSpace);
    return Narrow(newval);
}
</t>
<t tx="leo1.20171224221233.87">static void ThawWindowPos(HWND hwnd, const std::string &amp;name)
{
    RECT r;
    GetWindowRect(hwnd, &amp;r);
    r.left   = CnfThawInt(r.left,   name + "_left");
    r.right  = CnfThawInt(r.right,  name + "_right");
    r.top    = CnfThawInt(r.top,    name + "_top");
    r.bottom = CnfThawInt(r.bottom, name + "_bottom");

    HMONITOR hMonitor = MonitorFromRect(&amp;r, MONITOR_DEFAULTTONEAREST);;
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &amp;mi);

    // If it somehow ended up off-screen, then put it back.
    RECT dr = mi.rcMonitor;
    r.left   = CLAMP(r.left,   dr.left, dr.right);
    r.right  = CLAMP(r.right,  dr.left, dr.right);
    r.top    = CLAMP(r.top,    dr.top,  dr.bottom);
    r.bottom = CLAMP(r.bottom, dr.top,  dr.bottom);
    MoveWindow(hwnd, r.left, r.top, r.right - r.left, r.bottom - r.top, TRUE);

    if(CnfThawInt(FALSE, name + "_maximized"))
        ShowWindow(hwnd, SW_MAXIMIZE);
}

</t>
<t tx="leo1.20171224221233.88">void SolveSpace::SetCurrentFilename(const Platform::Path &amp;filename) {
    SetWindowTextW(GraphicsWnd,
        Title(filename.IsEmpty() ? C_("title", "(new sketch)") : filename.raw).c_str());
}

</t>
<t tx="leo1.20171224221233.89">void SolveSpace::SetMousePointerToHand(bool yes) {
    SetCursor(LoadCursor(NULL, yes ? IDC_HAND : IDC_ARROW));
}

</t>
<t tx="leo1.20171224221233.9">void ScheduleLater() {
}

//-----------------------------------------------------------------------------
// Rendering
//-----------------------------------------------------------------------------

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return NULL;
}

//-----------------------------------------------------------------------------
// Graphics window
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221233.90">static void PaintTextWnd()
{
#if HAVE_OPENGL == 3
    eglMakeCurrent(TextGlDisplay, TextGlSurface, TextGlSurface, TextGlContext);

    SS.TW.Paint();
    eglSwapBuffers(TextGlDisplay, TextGlSurface);

    // Leave the graphics window context active, except when we're painting
    // this text window.
    eglMakeCurrent(GraphicsGlDisplay, GraphicsGlSurface, GraphicsGlSurface, GraphicsGlContext);
#else
    wglMakeCurrent(GetDC(TextWnd), TextGl);

    SS.TW.Paint();
    SwapBuffers(GetDC(TextWnd));

    // Leave the graphics window context active, except when we're painting
    // this text window.
    wglMakeCurrent(GetDC(GraphicsWnd), GraphicsGl);
#endif
}

</t>
<t tx="leo1.20171224221233.91">void SolveSpace::MoveTextScrollbarTo(int pos, int maxPos, int page)
{
    SCROLLINFO si = {};
    si.cbSize = sizeof(si);
    si.fMask = SIF_DISABLENOSCROLL | SIF_ALL;
    si.nMin = 0;
    si.nMax = maxPos;
    si.nPos = pos;
    si.nPage = page;
    SetScrollInfo(TextWndScrollBar, SB_CTL, &amp;si, true);
}

</t>
<t tx="leo1.20171224221233.92">void HandleTextWindowScrollBar(WPARAM wParam, LPARAM lParam)
{
    int maxPos, minPos, pos;
    GetScrollRange(TextWndScrollBar, SB_CTL, &amp;minPos, &amp;maxPos);
    pos = GetScrollPos(TextWndScrollBar, SB_CTL);

    switch(LOWORD(wParam)) {
        case SB_LINEUP:         pos--; break;
        case SB_PAGEUP:         pos -= 4; break;

        case SB_LINEDOWN:       pos++; break;
        case SB_PAGEDOWN:       pos += 4; break;

        case SB_TOP:            pos = 0; break;

        case SB_BOTTOM:         pos = maxPos; break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:  pos = HIWORD(wParam); break;
    }

    SS.TW.ScrollbarEvent(pos);
}

</t>
<t tx="leo1.20171224221233.93">static void MouseWheel(int thisDelta) {
    static int DeltaAccum;
    int delta = 0;
    // Handle mouse deltas of less than 120 (like from an un-detented mouse
    // wheel) correctly, even though no one ever uses those.
    DeltaAccum += thisDelta;
    while(DeltaAccum &gt;= 120) {
        DeltaAccum -= 120;
        delta += 120;
    }
    while(DeltaAccum &lt;= -120) {
        DeltaAccum += 120;
        delta -= 120;
    }
    if(delta == 0) return;

    POINT pt;
    GetCursorPos(&amp;pt);
    HWND hw = WindowFromPoint(pt);

    // Make the mousewheel work according to which window the mouse is
    // over, not according to which window is active.
    bool inTextWindow;
    if(hw == TextWnd) {
        inTextWindow = true;
    } else if(hw == GraphicsWnd) {
        inTextWindow = false;
    } else if(GetForegroundWindow() == TextWnd) {
        inTextWindow = true;
    } else {
        inTextWindow = false;
    }

    if(inTextWindow) {
        int i;
        for(i = 0; i &lt; abs(delta/40); i++) {
            HandleTextWindowScrollBar(delta &gt; 0 ? SB_LINEUP : SB_LINEDOWN, 0);
        }
    } else {
        SS.GW.MouseScroll(LastMousePos.x, LastMousePos.y, delta);
    }
}

LRESULT CALLBACK TextWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
        case WM_ERASEBKGND:
            break;

        case WM_CLOSE:
        case WM_DESTROY:
            SolveSpaceUI::MenuFile(Command::EXIT);
            break;

        case WM_PAINT: {
            // Actually paint the text window, with gl.
            PaintTextWnd();
            // And then just make Windows happy.
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &amp;ps);
            EndPaint(hwnd, &amp;ps);
            break;
        }

        case WM_SIZING: {
            RECT *r = (RECT *)lParam;
            int hc = (r-&gt;bottom - r-&gt;top) - ClientIsSmallerBy;
            int extra = hc % (SS.TW.LINE_HEIGHT/2);
            switch(wParam) {
                case WMSZ_BOTTOM:
                case WMSZ_BOTTOMLEFT:
                case WMSZ_BOTTOMRIGHT:
                    r-&gt;bottom -= extra;
                    break;

                case WMSZ_TOP:
                case WMSZ_TOPLEFT:
                case WMSZ_TOPRIGHT:
                    r-&gt;top += extra;
                    break;
            }
</t>
<t tx="leo1.20171224221233.94">            int tooNarrow = (SS.TW.MIN_COLS*SS.TW.CHAR_WIDTH_) -
                                                (r-&gt;right - r-&gt;left);
            if(tooNarrow &gt;= 0) {
                switch(wParam) {
                    case WMSZ_RIGHT:
                    case WMSZ_BOTTOMRIGHT:
                    case WMSZ_TOPRIGHT:
                        r-&gt;right += tooNarrow;
                        break;

                    case WMSZ_LEFT:
                    case WMSZ_BOTTOMLEFT:
                    case WMSZ_TOPLEFT:
                        r-&gt;left -= tooNarrow;
                        break;
                }
            }
            break;
        }

        case WM_MOUSELEAVE:
            SS.TW.MouseLeave();
            break;

        case WM_LBUTTONDOWN:
        case WM_MOUSEMOVE: {
            // We need this in order to get the WM_MOUSELEAVE
            TRACKMOUSEEVENT tme = {};
            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = TextWnd;
            TrackMouseEvent(&amp;tme);

            // And process the actual message
            int x = LOWORD(lParam);
            int y = HIWORD(lParam);
            SS.TW.MouseEvent(msg == WM_LBUTTONDOWN, wParam &amp; MK_LBUTTON, x, y);
            break;
        }

        case WM_SIZE: {
            RECT r;
            GetWindowRect(TextWndScrollBar, &amp;r);
            int sw = r.right - r.left;
            GetClientRect(hwnd, &amp;r);
            MoveWindow(TextWndScrollBar, r.right - sw, r.top, sw,
                (r.bottom - r.top), true);
            // If the window is growing, then the scrollbar position may
            // be moving, so it's as if we're dragging the scrollbar.
            HandleTextWindowScrollBar((WPARAM)-1, -1);
            InvalidateRect(TextWnd, NULL, false);
            break;
        }

        case WM_MOUSEWHEEL:
            MouseWheel(GET_WHEEL_DELTA_WPARAM(wParam));
            break;

        case WM_VSCROLL:
            HandleTextWindowScrollBar(wParam, lParam);
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 1;
}

</t>
<t tx="leo1.20171224221233.95">static std::string EditControlText(HWND hwnd)
{
    std::wstring result;
    result.resize(GetWindowTextLength(hwnd));
    GetWindowTextW(hwnd, &amp;result[0], result.length() + 1);
    return Narrow(result);
}

</t>
<t tx="leo1.20171224221233.96">static bool ProcessKeyDown(WPARAM wParam)
{
    if(GraphicsEditControlIsVisible() &amp;&amp; wParam != VK_ESCAPE) {
        if(wParam == VK_RETURN) {
            SS.GW.EditControlDone(EditControlText(GraphicsEditControl).c_str());
            return true;
        } else {
            return false;
        }
    }
    if(TextEditControlIsVisible() &amp;&amp; wParam != VK_ESCAPE) {
        if(wParam == VK_RETURN) {
            SS.TW.EditControlDone(EditControlText(TextEditControl).c_str());
        } else {
            return false;
        }
    }

    int c;
    switch(wParam) {
        case VK_OEM_PLUS:       c = '+';            break;
        case VK_OEM_MINUS:      c = '-';            break;
        case VK_ESCAPE:         c = 27;             break;
        case VK_OEM_1:          c = ';';            break;
        case VK_OEM_3:          c = '`';            break;
        case VK_OEM_4:          c = '[';            break;
        case VK_OEM_6:          c = ']';            break;
        case VK_OEM_5:          c = '\\';           break;
        case VK_OEM_PERIOD:     c = '.';            break;
        case VK_DECIMAL:        c = '.';            break;
        case VK_SPACE:          c = ' ';            break;
        case VK_DELETE:         c = 127;            break;
        case VK_TAB:            c = '\t';           break;

        case VK_BROWSER_BACK:
        case VK_BACK:           c = '\b';           break;

        case VK_F1:
        case VK_F2:
        case VK_F3:
        case VK_F4:
        case VK_F5:
        case VK_F6:
        case VK_F7:
        case VK_F8:
        case VK_F9:
        case VK_F10:
        case VK_F11:
        case VK_F12:            c = ((int)wParam - VK_F1) + 0xf1; break;

        // These overlap with some character codes that I'm using, so
        // don't let them trigger by accident.
        case VK_F16:
        case VK_INSERT:
        case VK_EXECUTE:
        case VK_APPS:
        case VK_LWIN:
        case VK_RWIN:           return false;

        default:
            c = (int)wParam;
            break;
    }
    if(GetAsyncKeyState(VK_SHIFT)   &amp; 0x8000) c |= GraphicsWindow::SHIFT_MASK;
    if(GetAsyncKeyState(VK_CONTROL) &amp; 0x8000) c |= GraphicsWindow::CTRL_MASK;

    switch(c) {
        case GraphicsWindow::SHIFT_MASK | '.': c = '&gt;'; break;
    }

    for(int i = 0; SS.GW.menu[i].level &gt;= 0; i++) {
        if(c == SS.GW.menu[i].accel) {
            (SS.GW.menu[i].fn)((Command)SS.GW.menu[i].id);
            break;
        }
    }

    if(SS.GW.KeyDown(c)) return true;

    // No accelerator; process the key as normal.
    return false;
}

</t>
<t tx="leo1.20171224221233.97">void SolveSpace::ShowTextWindow(bool visible)
{
    ShowWindow(TextWnd, visible ? SW_SHOWNOACTIVATE : SW_HIDE);
}

#if HAVE_OPENGL == 3
</t>
<t tx="leo1.20171224221233.98">static void CreateGlContext(HWND hwnd, EGLDisplay *eglDisplay, EGLSurface *eglSurface,
                            EGLContext *eglContext) {
    ssassert(eglBindAPI(EGL_OPENGL_ES_API), "Cannot bind EGL API");

    *eglDisplay = eglGetDisplay(GetDC(hwnd));
    ssassert(eglInitialize(*eglDisplay, NULL, NULL), "Cannot initialize EGL");

    EGLint configAttributes[] = {
        EGL_COLOR_BUFFER_TYPE,  EGL_RGB_BUFFER,
        EGL_RED_SIZE,           8,
        EGL_GREEN_SIZE,         8,
        EGL_BLUE_SIZE,          8,
        EGL_DEPTH_SIZE,         24,
        EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,
        EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
        EGL_NONE
    };
    EGLint numConfigs;
    EGLConfig windowConfig;
    ssassert(eglChooseConfig(*eglDisplay, configAttributes, &amp;windowConfig, 1, &amp;numConfigs),
             "Cannot choose EGL configuration");

    EGLint surfaceAttributes[] = {
        EGL_NONE
    };
    *eglSurface = eglCreateWindowSurface(*eglDisplay, windowConfig, hwnd, surfaceAttributes);
    ssassert(eglSurface != EGL_NO_SURFACE, "Cannot create EGL window surface");

    EGLint contextAttributes[] = {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };
    *eglContext = eglCreateContext(*eglDisplay, windowConfig, NULL, contextAttributes);
    ssassert(eglContext != EGL_NO_CONTEXT, "Cannot create EGL context");

    eglMakeCurrent(*eglDisplay, *eglSurface, *eglSurface, *eglContext);
}
#else
</t>
<t tx="leo1.20171224221233.99">static void CreateGlContext(HWND hwnd, HGLRC *glrc)
{
    HDC hdc = GetDC(hwnd);

    PIXELFORMATDESCRIPTOR pfd = {};
    int pixelFormat;

    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL |
                        PFD_DOUBLEBUFFER;
    pfd.dwLayerMask = PFD_MAIN_PLANE;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 32;
    pfd.cDepthBits = 24;
    pfd.cAccumBits = 0;
    pfd.cStencilBits = 0;

    pixelFormat = ChoosePixelFormat(hdc, &amp;pfd);
    ssassert(pixelFormat != 0, "Expected a valid pixel format to be chosen");

    ssassert(SetPixelFormat(hdc, pixelFormat, &amp;pfd), "Cannot set pixel format");

    *glrc = wglCreateContext(hdc);
    wglMakeCurrent(hdc, *glrc);
}
#endif

</t>
<t tx="leo1.20171224221234.1">void Camera::LoadIdentity() {
    offset    = { 0.0, 0.0, 0.0 };
    projRight = { 1.0, 0.0, 0.0 };
    projUp    = { 0.0, 1.0, 0.0 };
    scale     = 1.0;
    tangent   = 0.0;
}

</t>
<t tx="leo1.20171224221234.10">void UiCanvas::DrawBitmapChar(char32_t codepoint, int x, int y, RgbaColor color, int zIndex) {
    BitmapFont *font = canvas-&gt;GetBitmapFont();

    Canvas::Fill fill = {};
    fill.layer  = Canvas::Layer::NORMAL;
    fill.zIndex = zIndex;
    fill.color  = color;
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    if(codepoint &gt;= 0xe000 &amp;&amp; codepoint &lt;= 0xefff) {
        // Special character, like a checkbox or a radio button
        x -= 3;
    }

    double s0, t0, s1, t1;
    size_t w, h;
    font-&gt;LocateGlyph(codepoint, &amp;s0, &amp;t0, &amp;s1, &amp;t1, &amp;w, &amp;h);
    if(font-&gt;textureUpdated) {
        // LocateGlyph modified the texture, reload it.
        canvas-&gt;InvalidatePixmap(font-&gt;texture);
        font-&gt;textureUpdated = false;
    }

    canvas-&gt;DrawPixmap(font-&gt;texture,
                       { (double)x, (double)Flip(y), 0.0 },
                       { (double)w,  0.0, 0.0 },
                       { 0.0, (double) h, 0.0 },
                       { s0, t1 },
                       { s1, t0 },
                       hcf);
}

</t>
<t tx="leo1.20171224221234.11">void UiCanvas::DrawBitmapText(const std::string &amp;str, int x, int y, RgbaColor color, int zIndex) {
    BitmapFont *font = canvas-&gt;GetBitmapFont();

    for(char32_t codepoint : ReadUTF8(str)) {
        DrawBitmapChar(codepoint, x, y, color, zIndex);
        x += (int)font-&gt;GetWidth(codepoint) * 8;
    }
}

//-----------------------------------------------------------------------------
// A canvas that performs picking against drawn geometry.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221234.12">void ObjectPicker::DoCompare(double distance, int zIndex, int comparePosition) {
    if(distance &gt; selRadius) return;
    if((zIndex == maxZIndex &amp;&amp; distance &lt; minDistance) || (zIndex &gt; maxZIndex)) {
        minDistance = distance;
        maxZIndex   = zIndex;
        position    = comparePosition;
    }
}

</t>
<t tx="leo1.20171224221234.13">void ObjectPicker::DoQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                          int zIndex, int comparePosition) {
    Point2d corners[4] = {
        camera.ProjectPoint(a),
        camera.ProjectPoint(b),
        camera.ProjectPoint(c),
        camera.ProjectPoint(d)
    };
    @others
}

</t>
<t tx="leo1.20171224221234.14">double minNegative = VERY_NEGATIVE,
       maxPositive = VERY_POSITIVE;
for(int i = 0; i &lt; 4; i++) {
    Point2d ap = corners[i],
            bp = corners[(i + 1) % 4];
    double distance = point.DistanceToLineSigned(ap, bp.Minus(ap), /*asSegment=*/true);
    if(distance &lt; 0) minNegative = std::max(minNegative, distance);
    if(distance &gt; 0) maxPositive = std::min(maxPositive, distance);
}

bool insideQuad = (minNegative == VERY_NEGATIVE || maxPositive == VERY_POSITIVE);
if(insideQuad) {
    DoCompare(0.0, zIndex, comparePosition);
} else {
    double distance = std::min(fabs(minNegative), fabs(maxPositive));
    DoCompare(distance, zIndex, comparePosition);
}
</t>
<t tx="leo1.20171224221234.15">void ObjectPicker::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    Point2d ap = camera.ProjectPoint(a);
    Point2d bp = camera.ProjectPoint(b);
    double distance = point.DistanceToLine(ap, bp.Minus(ap), /*asSegment=*/true);
    DoCompare(distance - stroke-&gt;width / 2.0, stroke-&gt;zIndex);
}

</t>
<t tx="leo1.20171224221234.16">void ObjectPicker::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    for(const SEdge &amp;e : el.l) {
        Point2d ap = camera.ProjectPoint(e.a);
        Point2d bp = camera.ProjectPoint(e.b);
        double distance = point.DistanceToLine(ap, bp.Minus(ap), /*asSegment=*/true);
        DoCompare(distance - stroke-&gt;width / 2.0, stroke-&gt;zIndex, e.auxB);
    }
}

</t>
<t tx="leo1.20171224221234.17">void ObjectPicker::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221234.18">void ObjectPicker::DrawVectorText(const std::string &amp;text, double height,
                                  const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                  hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    double w = VectorFont::Builtin()-&gt; GetWidth(height, text),
    Fill *fill = fills.FindById(hcf);
    DoQuad(a, b, c, d, fill-&gt;zIndex);
}

</t>
<t tx="leo1.20171224221234.19">void ObjectPicker::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    double distance = point.DistanceTo(camera.ProjectPoint(o)) - stroke-&gt;width / 2;
    DoCompare(distance, stroke-&gt;zIndex);
}

</t>
<t tx="leo1.20171224221234.2">void Camera::NormalizeProjectionVectors() {
    if(projRight.Magnitude() &lt; LENGTH_EPS) {
        projRight = Vector::From(1, 0, 0);
    }

    Vector norm = projRight.Cross(projUp);
    // If projRight and projUp somehow ended up parallel, then pick an
    // arbitrary projUp normal to projRight.
    if(norm.Magnitude() &lt; LENGTH_EPS) {
        norm = projRight.Normal(0);
    }
    projUp = norm.Cross(projRight);

    projUp = projUp.WithMagnitude(1);
    projRight = projRight.WithMagnitude(1);
}

//-----------------------------------------------------------------------------
// Stroke and fill caching.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221234.20">void ObjectPicker::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221234.21">void ObjectPicker::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221234.22">void ObjectPicker::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221234.23">void ObjectPicker::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                              const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                              const Point2d &amp;ta, const Point2d &amp;tb, Canvas::hFill hcf) {
    DrawQuad(o, o.Plus(u), o.Plus(u).Plus(v), o.Plus(v), hcf);
}

</t>
<t tx="leo1.20171224221234.24">bool ObjectPicker::Pick(std::function&lt;void()&gt; drawFn) {
    minDistance = VERY_POSITIVE;
    maxZIndex = INT_MIN;

    drawFn();
    return minDistance &lt; selRadius;
}

}
</t>
<t tx="leo1.20171224221234.25">//-----------------------------------------------------------------------------
// Rendering projections to 2d surfaces: z-sorting, occlusion testing, etc.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

// FIXME: The export coordinate system has a different handedness than display
// coordinate system; lighting and occlusion calculations are right-handed.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221234.3">bool Canvas::Stroke::Equals(const Stroke &amp;other) const {
    return (layer  == other.layer &amp;&amp;
            zIndex == other.zIndex &amp;&amp;
            color.Equals(other.color) &amp;&amp;
            width == other.width &amp;&amp;
            unit == other.unit &amp;&amp;
            stipplePattern == other.stipplePattern &amp;&amp;
            stippleScale == other.stippleScale);
}

double Canvas::Stroke::WidthMm(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return width;
        case Canvas::Unit::PX:
            return width / camera.scale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::WidthPx(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return width * camera.scale;
        case Canvas::Unit::PX:
            return width;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::StippleScaleMm(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return stippleScale;
        case Canvas::Unit::PX:
            return stippleScale / camera.scale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::StippleScalePx(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return stippleScale * camera.scale;
        case Canvas::Unit::PX:
            return stippleScale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

</t>
<t tx="leo1.20171224221234.4">bool Canvas::Fill::Equals(const Fill &amp;other) const {
    return (layer  == other.layer &amp;&amp;
            zIndex == other.zIndex &amp;&amp;
            color.Equals(other.color) &amp;&amp;
            pattern == other.pattern &amp;&amp;
            texture == other.texture);
}

</t>
<t tx="leo1.20171224221234.5">void Canvas::Clear() {
    strokes.Clear();
    fills.Clear();
}

Canvas::hStroke Canvas::GetStroke(const Stroke &amp;stroke) {
    for(const Stroke &amp;s : strokes) {
        if(s.Equals(stroke)) return s.h;
    }
    Stroke strokeCopy = stroke;
    return strokes.AddAndAssignId(&amp;strokeCopy);
}

Canvas::hFill Canvas::GetFill(const Fill &amp;fill) {
    for(const Fill &amp;f : fills) {
        if(f.Equals(fill)) return f.h;
    }
    Fill fillCopy = fill;
    return fills.AddAndAssignId(&amp;fillCopy);
}

BitmapFont *Canvas::GetBitmapFont() {
    if(bitmapFont.IsEmpty()) {
        bitmapFont = BitmapFont::Create();
    }
    return &amp;bitmapFont;
}

std::shared_ptr&lt;BatchCanvas&gt; Canvas::CreateBatch() {
    return std::shared_ptr&lt;BatchCanvas&gt;();
}

//-----------------------------------------------------------------------------
// An interface for view-independent visualization
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221234.6">const Camera &amp;BatchCanvas::GetCamera() const {
    ssassert(false, "Geometry drawn on BatchCanvas must be independent from camera");
}

//-----------------------------------------------------------------------------
// A wrapper around Canvas that simplifies drawing UI in screen coordinates
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221234.7">void UiCanvas::DrawLine(int x1, int y1, int x2, int y2, RgbaColor color, int width, int zIndex) {
    Vector va = { (double)x1 + 0.5, (double)Flip(y1) + 0.5, 0.0 },
           vb = { (double)x2 + 0.5, (double)Flip(y2) + 0.5, 0.0 };

    Canvas::Stroke stroke = {};
    stroke.layer  = Canvas::Layer::NORMAL;
    stroke.zIndex = zIndex;
    stroke.width  = (double)width;
    stroke.color  = color;
    stroke.unit   = Canvas::Unit::PX;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    canvas-&gt;DrawLine(va, vb, hcs);
}

</t>
<t tx="leo1.20171224221234.8">void UiCanvas::DrawRect(int l, int r, int t, int b, RgbaColor fillColor, RgbaColor outlineColor,
                        int zIndex) {
    Vector va = { (double)l + 0.5, (double)Flip(b) + 0.5, 0.0 },
           vb = { (double)l + 0.5, (double)Flip(t) + 0.5, 0.0 },
           vc = { (double)r + 0.5, (double)Flip(t) + 0.5, 0.0 },
           vd = { (double)r + 0.5, (double)Flip(b) + 0.5, 0.0 };

    if(!fillColor.IsEmpty()) {
        Canvas::Fill fill = {};
        fill.layer  = Canvas::Layer::NORMAL;
        fill.zIndex = zIndex;
        fill.color  = fillColor;
        Canvas::hFill hcf = canvas-&gt;GetFill(fill);

        canvas-&gt;DrawQuad(va, vb, vc, vd, hcf);
    }

    if(!outlineColor.IsEmpty()) {
        Canvas::Stroke stroke = {};
        stroke.layer  = Canvas::Layer::NORMAL;
        stroke.zIndex = zIndex;
        stroke.width  = 1.0;
        stroke.color  = outlineColor;
        stroke.unit   = Canvas::Unit::PX;
        Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

        canvas-&gt;DrawLine(va, vb, hcs);
        canvas-&gt;DrawLine(vb, vc, hcs);
        canvas-&gt;DrawLine(vc, vd, hcs);
        canvas-&gt;DrawLine(vd, va, hcs);
    }
}

</t>
<t tx="leo1.20171224221234.9">void UiCanvas::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm, int x, int y, int zIndex) {
    Canvas::Fill fill = {};
    fill.layer  = Canvas::Layer::NORMAL;
    fill.zIndex = zIndex;
    fill.color  = { 255, 255, 255, 255 };
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    canvas-&gt;DrawPixmap(pm,
                       { (double)x, (double)(flip ? Flip(y) - pm-&gt;height : y), 0.0 },
                       { (double)pm-&gt;width,  0.0, 0.0 },
                       { 0.0, (double)pm-&gt;height, 0.0 },
                       { 0.0, 1.0 },
                       { 1.0, 0.0 },
                       hcf);
}

</t>
<t tx="leo1.20171224221235.1">static Vector ProjectPoint3RH(const Camera &amp;camera, Vector p) {
    p = p.Plus(camera.offset);

    Vector r;
    r.x = p.Dot(camera.projRight);
    r.y = p.Dot(camera.projUp);
    r.z = p.Dot(camera.projRight.Cross(camera.projUp));

    double w = 1 + r.z*camera.tangent*camera.scale;
    return r.ScaledBy(camera.scale/w);
}

//-----------------------------------------------------------------------------
// Accumulation of geometry
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.10">void SurfaceRenderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    SMesh m = {};
    p.TriangulateInto(&amp;m);
    DrawMesh(m, hcf, {});
    m.Clear();
}

</t>
<t tx="leo1.20171224221235.11">void SurfaceRenderer::DrawMesh(const SMesh &amp;m,
                               hFill hcfFront, hFill hcfBack) {
    Fill *fill = fills.FindById(hcfFront);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY, "Unexpected mesh layer");

    Vector l0 = (lighting.lightDirection[0]).WithMagnitude(1),
           l1 = (lighting.lightDirection[1]).WithMagnitude(1);
    for(STriangle tr : m.l) {
        tr.a = ProjectPoint3RH(camera, tr.a);
        tr.b = ProjectPoint3RH(camera, tr.b);
        tr.c = ProjectPoint3RH(camera, tr.c);

        if(CanOutputTriangles() &amp;&amp; fill-&gt;layer == Layer::NORMAL) {
            if(fill-&gt;color.IsEmpty()) {
                // Compute lighting, since we're going to draw the shaded triangles.
                Vector n = tr.Normal().WithMagnitude(1);
                double intensity = lighting.ambientIntensity +
        } else {
            // This triangle is just for occlusion testing.
            tr.meta.color = {};
        }
        mesh.AddTriangle(&amp;tr);
    }
}

</t>
<t tx="leo1.20171224221235.12">void SurfaceRenderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    Fill *fill = fills.FindById(hcf);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY, "Unexpected mesh layer");

    Vector zOffset = {};
    zOffset.z += camera.scale * fill-&gt;zIndex;

    size_t facesSize = faces.size();
    for(STriangle tr : m.l) {
        uint32_t face = tr.meta.face;
        for(size_t j = 0; j &lt; facesSize; j++) {
            if(faces[j] != face) continue;
            if(!fill-&gt;color.IsEmpty()) {
                tr.meta.color = fill-&gt;color;
            }
            mesh.AddTriangle(tr.meta,
                ProjectPoint3RH(camera, tr.a).Plus(zOffset),
                ProjectPoint3RH(camera, tr.b).Plus(zOffset),
                ProjectPoint3RH(camera, tr.c).Plus(zOffset));
            break;
        }
    }
}

</t>
<t tx="leo1.20171224221235.13">void SurfaceRenderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221235.14">void SurfaceRenderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    ssassert(false, "Not implemented");
}

//-----------------------------------------------------------------------------
// Processing of geometry
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.15">void SurfaceRenderer::CalculateBBox() {
    bbox.minp = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
    bbox.maxp = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);

    for(auto &amp;it : edges) {
        SEdgeList &amp;el = it.second;
        for(SEdge &amp;e : el.l) {
            bbox.Include(e.a);
            bbox.Include(e.b);
        }
    }

    for(auto &amp;it : beziers) {
        SBezierList &amp;bl = it.second;
        for(SBezier &amp;b : bl.l) {
            for(int i = 0; i &lt;= b.deg; i++) {
                bbox.Include(b.ctrl[i]);
            }
        }
    }

    for(STriangle &amp;tr : mesh.l) {
        for(int i = 0; i &lt; 3; i++) {
            bbox.Include(tr.vertices[i]);
        }
    }
}


</t>
<t tx="leo1.20171224221235.16">void SurfaceRenderer::ConvertBeziersToEdges() {
    for(auto &amp;it : beziers) {
        hStroke hcs = it.first;
        SBezierList &amp;bl = it.second;

        SEdgeList &amp;el = edges[hcs];
        for(const SBezier &amp;b : bl.l) {
            if(b.deg == 1) {
                el.AddEdge(b.ctrl[0], b.ctrl[1]);
            } else {
                List&lt;Vector&gt; lv = {};
                b.MakePwlInto(&amp;lv, chordTolerance);
                for(int i = 1; i &lt; lv.n; i++) {
                    el.AddEdge(lv.elem[i-1], lv.elem[i]);
                }
                lv.Clear();
            }
        }
        bl.l.Clear();
    }
    beziers.clear();
}

</t>
<t tx="leo1.20171224221235.17">void SurfaceRenderer::CullOccludedStrokes() {
    // Perform occlusion testing, if necessary.
    if(mesh.l.n == 0) return;

    // We can't perform hidden line removal on exact curves.
    ConvertBeziersToEdges();

    // Remove hidden lines (on NORMAL layers), or remove visible lines (on OCCLUDED layers).
    SKdNode *root = SKdNode::From(&amp;mesh);
    root-&gt;ClearTags();

    int cnt = 1234;
    for(auto &amp;eit : edges) {
        hStroke hcs = eit.first;
        SEdgeList &amp;el = eit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != Layer::NORMAL &amp;&amp;
           stroke-&gt;layer != Layer::OCCLUDED) continue;

        SEdgeList nel = {};
        for(const SEdge &amp;e : el.l) {
            SEdgeList oel = {};
            oel.AddEdge(e.a, e.b);
            root-&gt;OcclusionTestLine(e, &amp;oel, cnt);

            if(stroke-&gt;layer == Layer::OCCLUDED) {
                for(SEdge &amp;oe : oel.l) {
                    oe.tag = !oe.tag;
                }
            }
            oel.l.RemoveTagged();

            oel.MergeCollinearSegments(e.a, e.b);
            for(const SEdge &amp;oe : oel.l) {
                nel.AddEdge(oe.a, oe.b);
            }

            oel.Clear();
            cnt++;
        }

        el.l.Clear();
        el.l = nel.l;
    }
}

</t>
<t tx="leo1.20171224221235.18">void SurfaceRenderer::OutputInPaintOrder() {
    // Sort our strokes in paint order.
    std::vector&lt;std::pair&lt;Layer, int&gt;&gt; paintOrder;
    paintOrder.emplace_back(Layer::NORMAL, 0); // mesh
    for(const Stroke &amp;cs : strokes) {
        paintOrder.emplace_back(cs.layer, cs.zIndex);
    }

    @others
}

</t>
<t tx="leo1.20171224221235.19">const Layer stackup[] = {
    Layer::BACK, Layer::NORMAL, Layer::DEPTH_ONLY, Layer::OCCLUDED, Layer::FRONT
};
std::sort(paintOrder.begin(), paintOrder.end(),
          [&amp;](std::pair&lt;Layer, int&gt; a, std::pair&lt;Layer, int&gt; b) {
    Layer aLayer  = a.first,
          bLayer  = b.first;
</t>
<t tx="leo1.20171224221235.2">void SurfaceRenderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    edges[hcs].AddEdge(ProjectPoint3RH(camera, a),
                       ProjectPoint3RH(camera, b));
}

</t>
<t tx="leo1.20171224221235.20">    int   aZIndex = a.second,
          bZIndex = b.second;

    size_t aLayerIndex =
        std::find(std::begin(stackup), std::end(stackup), aLayer) - std::begin(stackup);
    size_t bLayerIndex =
        std::find(std::begin(stackup), std::end(stackup), bLayer) - std::begin(stackup);
    if(aLayerIndex == bLayerIndex) {
        return aZIndex &lt; bZIndex;
    } else {
        return aLayerIndex &lt; bLayerIndex;
    }
});

auto last = std::unique(paintOrder.begin(), paintOrder.end());
paintOrder.erase(last, paintOrder.end());

// Output geometry in paint order.
OutputStart();
for(auto &amp;it : paintOrder) {
    Layer layer  = it.first;
    int   zIndex = it.second;

    if(layer == Layer::NORMAL &amp;&amp; zIndex == 0) {
        SMesh mp = {};
        SBsp3 *bsp = SBsp3::FromMesh(&amp;mesh);
        if(bsp) bsp-&gt;GenerateInPaintOrder(&amp;mp);

        for(const STriangle &amp;tr : mp.l) {
            // Cull back-facing and invisible triangles.
            if(tr.Normal().z &lt; 0) continue;
            if(tr.meta.color.IsEmpty()) continue;
            OutputTriangle(tr);
        }

        mp.Clear();
    }

    for(auto eit : edges) {
        hStroke hcs = eit.first;
        const SEdgeList &amp;el = eit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != layer || stroke-&gt;zIndex != zIndex) continue;

        for(const SEdge &amp;e : el.l) {
            OutputBezier(SBezier::From(e.a, e.b), hcs);
        }
    }

    for(auto &amp;bit : beziers) {
        hStroke hcs = bit.first;
        const SBezierList &amp;bl = bit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != layer || stroke-&gt;zIndex != zIndex) continue;

        for(const SBezier &amp;b : bl.l) {
            OutputBezier(b, hcs);
        }
    }
}
OutputEnd();
</t>
<t tx="leo1.20171224221235.21">void SurfaceRenderer::Clear() {
    Canvas::Clear();

    for(auto &amp;eit : edges) {
        SEdgeList &amp;el = eit.second;
        el.l.Clear();
    }
    edges.clear();

    for(auto &amp;bit : beziers) {
        SBezierList &amp;bl = bit.second;
        bl.l.Clear();
    }
    beziers.clear();

    mesh.Clear();
}

</t>
<t tx="leo1.20171224221235.22">void SurfaceRenderer::OutputBezierAsNonrationalCubic(const SBezier &amp;b, hStroke hcs) {
    // Arbitrary choice of tolerance; make it a little finer than pwl tolerance since
    // it should be easier to achieve that with the smooth curves.
    SBezierList bl;
    b.MakeNonrationalCubicInto(&amp;bl, chordTolerance / 2);
    for(const SBezier &amp;cb : bl.l) {
        OutputBezier(cb, hcs);
    }
    bl.Clear();
}

}
</t>
<t tx="leo1.20171224221235.23">//-----------------------------------------------------------------------------
// A rendering backend that draws on a Cairo surface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include &lt;cairo.h&gt;
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221235.24">void CairoRenderer::OutputStart() {
    cairo_save(context);

    RgbaColor bgColor = lighting.backgroundColor;
    cairo_rectangle(context, 0.0, 0.0, (double)camera.width, (double)camera.height);
    cairo_set_source_rgba(context, bgColor.redF(), bgColor.greenF(), bgColor.blueF(),
                          bgColor.alphaF());
    cairo_fill(context);

    cairo_translate(context, camera.width / 2.0, camera.height / 2.0);

    // Avoid pixel boundaries; when not using antialiasing, we would otherwise
    // get numerically unstable output.
    cairo_translate(context, 0.1, 0.1);

    cairo_set_line_join(context, CAIRO_LINE_JOIN_ROUND);
    cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
}

</t>
<t tx="leo1.20171224221235.25">void CairoRenderer::OutputEnd() {
    FinishPath();

    cairo_restore(context);
    cairo_surface_flush(cairo_get_target(context));
}

</t>
<t tx="leo1.20171224221235.26">void CairoRenderer::SelectStroke(hStroke hcs) {
    if(current.hcs.v == hcs.v) return;
    FinishPath();

    Stroke *stroke = strokes.FindById(hcs);
    current.hcs = hcs;

    RgbaColor color = stroke-&gt;color;
    std::vector&lt;double&gt; dashes = StipplePatternDashes(stroke-&gt;stipplePattern);
    for(double &amp;dash : dashes) {
        dash *= stroke-&gt;StippleScalePx(camera);
    }
    cairo_set_line_width(context, stroke-&gt;WidthPx(camera));
    cairo_set_dash(context, dashes.data(), (int)dashes.size(), 0);
    cairo_set_source_rgba(context, color.redF(), color.greenF(), color.blueF(),
                          color.alphaF());
    if(antialias) {
        cairo_set_antialias(context, CAIRO_ANTIALIAS_GRAY);
    } else {
        cairo_set_antialias(context, CAIRO_ANTIALIAS_NONE);
    }
}

</t>
<t tx="leo1.20171224221235.27">void CairoRenderer::MoveTo(Vector p) {
    Point2d pos;
    cairo_get_current_point(context, &amp;pos.x, &amp;pos.y);
    if(cairo_has_current_point(context) &amp;&amp; pos.Equals(p.ProjectXy())) return;
    FinishPath();

    cairo_move_to(context, p.x, p.y);
}

</t>
<t tx="leo1.20171224221235.28">void CairoRenderer::FinishPath() {
    if(!cairo_has_current_point(context)) return;

    cairo_stroke(context);
}

</t>
<t tx="leo1.20171224221235.29">void CairoRenderer::OutputBezier(const SBezier &amp;b, hStroke hcs) {
    SelectStroke(hcs);

    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(b.deg == 1) {
        MoveTo(b.ctrl[0]);
        cairo_line_to(context,
            b.ctrl[1].x, b.ctrl[1].y);
    } else if(b.IsCircle(n, &amp;c, &amp;r)) {
        MoveTo(b.ctrl[0]);
        @others
}

</t>
<t tx="leo1.20171224221235.3">void SurfaceRenderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    for(const SEdge &amp;e : el.l) {
        edges[hcs].AddEdge(ProjectPoint3RH(camera, e.a),
                           ProjectPoint3RH(camera, e.b));
    }
}

</t>
<t tx="leo1.20171224221235.30">    double theta0 = atan2(b.ctrl[0].y - c.y, b.ctrl[0].x - c.x),
           theta1 = atan2(b.ctrl[2].y - c.y, b.ctrl[2].x - c.x),
           dtheta = WRAP_SYMMETRIC(theta1 - theta0, 2*PI);
    if(dtheta &gt; 0) {
        cairo_arc(context,
            c.x, c.y, r, theta0, theta1);
    } else {
        cairo_arc_negative(context,
            c.x, c.y, r, theta0, theta1);
    }
} else if(b.deg == 3 &amp;&amp; !b.IsRational()) {
    MoveTo(b.ctrl[0]);
    cairo_curve_to(context,
        b.ctrl[1].x, b.ctrl[1].y,
        b.ctrl[2].x, b.ctrl[2].y,
        b.ctrl[3].x, b.ctrl[3].y);
} else {
    OutputBezierAsNonrationalCubic(b, hcs);
}
</t>
<t tx="leo1.20171224221235.31">void CairoRenderer::OutputTriangle(const STriangle &amp;tr) {
    FinishPath();
    current.hcs = {};

    RgbaColor color = tr.meta.color;
    cairo_set_source_rgba(context, color.redF(), color.greenF(), color.blueF(),
                          color.alphaF());
    cairo_set_antialias(context, CAIRO_ANTIALIAS_NONE);
    cairo_move_to(context, tr.a.x, tr.a.y);
    cairo_line_to(context, tr.b.x, tr.b.y);
    cairo_line_to(context, tr.c.x, tr.c.y);
    cairo_fill(context);
}

}
</t>
<t tx="leo1.20171224221235.32">//-----------------------------------------------------------------------------
// Offscreen rendering in OpenGL using EGL and framebuffer objects.
//
// Copyright 2015-2016 whitequark
//-----------------------------------------------------------------------------
#ifdef __APPLE__
#include &lt;OpenGL/GL.h&gt;
#else
#define GL_GLEXT_PROTOTYPES
#include &lt;GL/gl.h&gt;
#endif

#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221235.33">void GlOffscreen::Clear() {
    glDeleteRenderbuffersEXT(1, &amp;depthRenderbuffer);
    glDeleteRenderbuffersEXT(1, &amp;colorRenderbuffer);
    glDeleteFramebuffersEXT(1, &amp;framebuffer);
    *this = {};
}

</t>
<t tx="leo1.20171224221235.34">bool GlOffscreen::Render(int width, int height, std::function&lt;void()&gt; renderFn) {
    data.resize(width * height * 4);

    if(framebuffer == 0)
        glGenFramebuffersEXT(1, &amp;framebuffer);
    if(colorRenderbuffer == 0)
        glGenRenderbuffersEXT(1, &amp;colorRenderbuffer);
    if(depthRenderbuffer == 0)
        glGenRenderbuffersEXT(1, &amp;depthRenderbuffer);

    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffer);

    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, colorRenderbuffer);
    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_RGBA8, width, height);
    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
                                 GL_RENDERBUFFER_EXT, colorRenderbuffer);

    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depthRenderbuffer);
    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, width, height);
    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
                                 GL_RENDERBUFFER_EXT, depthRenderbuffer);

    @others
}
</t>
<t tx="leo1.20171224221235.35">    bool framebufferComplete =
        glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) == GL_FRAMEBUFFER_COMPLETE_EXT;
    if(framebufferComplete) {
        renderFn();
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        glReadPixels(0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, &amp;data[0]);
#else
        glReadPixels(0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8, &amp;data[0]);
#endif
    }

    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);

    return framebufferComplete;
</t>
<t tx="leo1.20171224221235.36">//-----------------------------------------------------------------------------
// OpenGL 1 based rendering interface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

#ifdef WIN32
// Include after solvespace.h to avoid identifier clashes.
#   include &lt;windows.h&gt; // required by GL headers
#endif
#ifdef __APPLE__
#   include &lt;OpenGL/gl.h&gt;
#   include &lt;OpenGL/glu.h&gt;
#else
#   include &lt;GL/gl.h&gt;
#   include &lt;GL/glu.h&gt;
#endif

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Checks for buggy OpenGL renderers
//-----------------------------------------------------------------------------

// Intel GPUs with Mesa on *nix render thin lines poorly.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221235.37">static bool HasIntelThinLineQuirk()
{
    static bool quirkChecked, quirkEnabled;
    if(!quirkChecked) {
        const char *ident = (const char*)glGetString(GL_VENDOR);
        if(ident != NULL) {
            quirkChecked = true;
            quirkEnabled = !strcmp(ident, "Intel Open Source Technology Center");
        }
    }
    return quirkEnabled;
}

// The default Windows GL renderer really does implement GL 1.1,
// and cannot handle non-power-of-2 textures, which is legal.
</t>
<t tx="leo1.20171224221235.38">static bool HasGl1V1Quirk()
{
    static bool quirkChecked, quirkEnabled;
    if(!quirkChecked) {
        const char *ident = (const char*)glGetString(GL_VERSION);
        if(ident != NULL) {
            quirkChecked = true;
            quirkEnabled = !strcmp(ident, "1.1.0");
        }
    }
    return quirkEnabled;
}

//-----------------------------------------------------------------------------
// Thin wrappers around OpenGL functions to fix bugs, adapt them to our
// data structures, etc.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.39">static inline void ssglNormal3v(Vector n) {
    glNormal3d(n.x, n.y, n.z);
}

</t>
<t tx="leo1.20171224221235.4">bool SurfaceRenderer::DrawBeziers(const SBezierList &amp;bl, hStroke hcs) {
    if(!CanOutputCurves())
        return false;

    for(const SBezier &amp;b : bl.l) {
        SBezier pb = camera.ProjectBezier(b);
        beziers[hcs].l.Add(&amp;pb);
    }
    return true;
}

</t>
<t tx="leo1.20171224221235.40">static inline void ssglVertex3v(Vector v) {
    glVertex3d(v.x, v.y, v.z);
}

</t>
<t tx="leo1.20171224221235.41">void ssglLineWidth(double width) {
    if(HasIntelThinLineQuirk() &amp;&amp; width &lt; 1.6)
        width = 1.6;

    glLineWidth((GLfloat)width);
}

</t>
<t tx="leo1.20171224221235.42">static inline void ssglColorRGBA(RgbaColor color) {
    glColor4d(color.redF(), color.greenF(), color.blueF(), color.alphaF());
}

</t>
<t tx="leo1.20171224221235.43">static inline void ssglMaterialRGBA(GLenum side, RgbaColor color) {
    GLfloat mpb[] = { color.redF(), color.greenF(), color.blueF(), color.alphaF() };
    glMaterialfv(side, GL_AMBIENT_AND_DIFFUSE, mpb);
}

</t>
<t tx="leo1.20171224221235.44">static void ssglDepthRange(Canvas::Layer layer, int zIndex) {
    switch(layer) {
        case Canvas::Layer::NORMAL:
        case Canvas::Layer::FRONT:
        case Canvas::Layer::BACK:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;

        case Canvas::Layer::DEPTH_ONLY:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
            break;

        case Canvas::Layer::OCCLUDED:
            glDepthFunc(GL_GREATER);
            glDepthMask(GL_FALSE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;
    }

    switch(layer) {
        case Canvas::Layer::FRONT:
            glDepthRange(0.0, 0.0);
            break;

        case Canvas::Layer::BACK:
            glDepthRange(1.0, 1.0);
            break;

        case Canvas::Layer::NORMAL:
        case Canvas::Layer::DEPTH_ONLY:
        case Canvas::Layer::OCCLUDED:
            // The size of this step depends on the resolution of the Z buffer; for
            // a 16-bit buffer, this should be fine.
            double offset = 1.0 / (65535 * 0.8) * zIndex;
            glDepthRange(0.1 - offset, 1.0 - offset);
            break;
    }
}

</t>
<t tx="leo1.20171224221235.45">static void ssglFillPattern(Canvas::FillPattern pattern) {
    static bool Init;
    static GLubyte MaskA[(32*32)/8];
    static GLubyte MaskB[(32*32)/8];
    if(!Init) {
        int x, y;
        for(x = 0; x &lt; 32; x++) {
            for(y = 0; y &lt; 32; y++) {
                int i = y*4 + x/8, b = x % 8;
                int ym = y % 4, xm = x % 4;
                for(int k = 0; k &lt; 2; k++) {
                    if(xm &gt;= 1 &amp;&amp; xm &lt;= 2 &amp;&amp; ym &gt;= 1 &amp;&amp; ym &lt;= 2) {
                        (k == 0 ? MaskB : MaskA)[i] |= (0x80 &gt;&gt; b);
                    }
                    ym = (ym + 2) % 4; xm = (xm + 2) % 4;
                }
            }
        }
        Init = true;
    }

    switch(pattern) {
        case Canvas::FillPattern::SOLID:
            glDisable(GL_POLYGON_STIPPLE);
            break;

        case Canvas::FillPattern::CHECKERED_A:
            glEnable(GL_POLYGON_STIPPLE);
            glPolygonStipple(MaskA);
            break;

        case Canvas::FillPattern::CHECKERED_B:
            glEnable(GL_POLYGON_STIPPLE);
            glPolygonStipple(MaskB);
            break;
    }
}

//-----------------------------------------------------------------------------
// OpenGL 1 / compatibility profile based renderer
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.46">class OpenGl1Renderer : public ViewportCanvas {
public:
    Camera      camera;
    Lighting    lighting;
    // Cached OpenGL state.
    struct {
        bool        drawing;
        GLenum      mode;
        hStroke     hcs;
        Stroke     *stroke;
        hFill       hcf;
        Fill       *fill;
        std::weak_ptr&lt;const Pixmap&gt; texture;
    } current;

    OpenGl1Renderer() : camera(), lighting(), current() {}

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
    void DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);
    void DoPoint(Vector p, double radius);
    void DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs, double phase = 0.0);

    void UpdateProjection();
    void SetCamera(const Camera &amp;camera) override;
    void SetLighting(const Lighting &amp;lighting) override;

    void NewFrame() override;
    void FlushFrame() override;
    std::shared_ptr&lt;Pixmap&gt; ReadFrame() override;

    void GetIdent(const char **vendor, const char **renderer, const char **version) override;
};

//-----------------------------------------------------------------------------
// A simple OpenGL state tracker to group consecutive draw calls.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.47">void OpenGl1Renderer::SelectPrimitive(GLenum mode) {
    if(current.drawing &amp;&amp; current.mode == mode) {
        return;
    } else if(current.drawing) {
        glEnd();
    }
    glBegin(mode);
    current.drawing = true;
    current.mode    = mode;
}

</t>
<t tx="leo1.20171224221235.48">void OpenGl1Renderer::UnSelectPrimitive() {
    if(!current.drawing) return;
    glEnd();
    current.drawing = false;
}

Canvas::Stroke *OpenGl1Renderer::SelectStroke(hStroke hcs) {
    if(current.hcs.v == hcs.v) return current.stroke;

    Stroke *stroke = strokes.FindById(hcs);
    UnSelectPrimitive();
    ssglColorRGBA(stroke-&gt;color);
    ssglDepthRange(stroke-&gt;layer, stroke-&gt;zIndex);
    ssglLineWidth(stroke-&gt;WidthPx(camera));
    // Fat lines and points are quads affected by glPolygonStipple, so make sure
    // they are displayed correctly.
    ssglFillPattern(FillPattern::SOLID);
    glDisable(GL_TEXTURE_2D);

    current.hcs    = hcs;
    current.stroke = stroke;
    current.hcf    = {};
    current.fill   = NULL;
    current.texture.reset();
    return stroke;
}

Canvas::Fill *OpenGl1Renderer::SelectFill(hFill hcf) {
    if(current.hcf.v == hcf.v) return current.fill;

    Fill *fill = fills.FindById(hcf);
    UnSelectPrimitive();
    ssglColorRGBA(fill-&gt;color);
    ssglDepthRange(fill-&gt;layer, fill-&gt;zIndex);
    ssglFillPattern(fill-&gt;pattern);
    glDisable(GL_TEXTURE_2D);

    current.hcs    = {};
    current.stroke = NULL;
    current.hcf    = hcf;
    current.fill   = fill;
    current.texture.reset();
    return fill;
}

</t>
<t tx="leo1.20171224221235.49">static int RoundUpToPowerOfTwo(int v)
{
    for(int i = 0; i &lt; 31; i++) {
        int vt = (1 &lt;&lt; i);
        if(vt &gt;= v) {
            return vt;
        }
    }
    return 0;
}

</t>
<t tx="leo1.20171224221235.5">void SurfaceRenderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    Vector projDir = camera.projRight.Cross(camera.projUp);
    for(const SOutline &amp;o : ol.l) {
        if(drawAs == DrawOutlinesAs::EMPHASIZED_AND_CONTOUR &amp;&amp;
                !(o.IsVisible(projDir) || o.tag != 0))
            continue;
        if(drawAs == DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR &amp;&amp;
                !(!o.IsVisible(projDir) &amp;&amp; o.tag != 0))
            continue;
        if(drawAs == DrawOutlinesAs::CONTOUR_ONLY &amp;&amp;
                !(o.IsVisible(projDir)))
            continue;

        edges[hcs].AddEdge(ProjectPoint3RH(camera, o.a),
                           ProjectPoint3RH(camera, o.b));
    }
}

</t>
<t tx="leo1.20171224221235.50">void OpenGl1Renderer::SelectTexture(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) return;

    glBindTexture(GL_TEXTURE_2D, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_CLAMP);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    GLenum format = 0;
    switch(pm-&gt;format) {
        case Pixmap::Format::RGBA: format = GL_RGBA;  break;
        case Pixmap::Format::RGB:  format = GL_RGB;   break;
        case Pixmap::Format::A:    format = GL_ALPHA; break;
        case Pixmap::Format::BGRA:
        case Pixmap::Format::BGR:
            ssassert(false, "Unexpected pixmap format");
    }

    if(!HasGl1V1Quirk()) {
        glTexImage2D(GL_TEXTURE_2D, 0, format, pm-&gt;width, pm-&gt;height, 0,
                     format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
    } else {
        GLsizei width = RoundUpToPowerOfTwo(pm-&gt;width);
        GLsizei height = RoundUpToPowerOfTwo(pm-&gt;height);
        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0,
                     format, GL_UNSIGNED_BYTE, 0);
        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, pm-&gt;width, pm-&gt;height,
                        format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
    }

    glEnable(GL_TEXTURE_2D);

    current.texture = pm;
}

//-----------------------------------------------------------------------------
// OpenGL's GL_LINES mode does not work on lines thicker than about 3 px,
// so we have to draw thicker lines using triangles.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.51">void OpenGl1Renderer::DoFatLineEndcap(const Vector &amp;p, const Vector &amp;u, const Vector &amp;v) {
    // A table of cos and sin of (pi*i/10 + pi/2), as i goes from 0 to 10
    @others
}

</t>
<t tx="leo1.20171224221235.52">static const double Circle[11][2] = {
    {  0.0000,   1.0000 },
    { -0.3090,   0.9511 },
    { -0.5878,   0.8090 },
    { -0.8090,   0.5878 },
    { -0.9511,   0.3090 },
    { -1.0000,   0.0000 },
    { -0.9511,  -0.3090 },
    { -0.8090,  -0.5878 },
    { -0.5878,  -0.8090 },
    { -0.3090,  -0.9511 },
    {  0.0000,  -1.0000 },
};

SelectPrimitive(GL_TRIANGLE_FAN);
for(auto pc : Circle) {
    double c = pc[0], s = pc[1];
    ssglVertex3v(p.Plus(u.ScaledBy(c)).Plus(v.ScaledBy(s)));
}
UnSelectPrimitive();
</t>
<t tx="leo1.20171224221235.53">void OpenGl1Renderer::DoFatLine(const Vector &amp;a, const Vector &amp;b, double width) {
    // The half-width of the line we're drawing.
    double hw = width / 2;
    Vector ab  = b.Minus(a);
    Vector gn = (camera.projRight).Cross(camera.projUp);
    Vector abn = (ab.Cross(gn)).WithMagnitude(1);
    abn = abn.Minus(gn.ScaledBy(gn.Dot(abn)));
    // So now abn is normal to the projection of ab into the screen, so the
    // line will always have constant thickness as the view is rotated.

    abn = abn.WithMagnitude(hw);
    ab  = gn.Cross(abn);
    ab  = ab. WithMagnitude(hw);

    // The body of a line is a quad
    SelectPrimitive(GL_QUADS);
    ssglVertex3v(a.Plus (abn));
    ssglVertex3v(b.Plus (abn));
    ssglVertex3v(b.Minus(abn));
    ssglVertex3v(a.Minus(abn));
    // And the line has two semi-circular end caps.
    DoFatLineEndcap(a, ab,              abn);
    DoFatLineEndcap(b, ab.ScaledBy(-1), abn);
}

</t>
<t tx="leo1.20171224221235.54">void OpenGl1Renderer::DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    if(a.Equals(b)) return;

    Stroke *stroke = SelectStroke(hcs);
    if(stroke-&gt;WidthPx(camera) &lt;= 3.0) {
        SelectPrimitive(GL_LINES);
        ssglVertex3v(a);
        ssglVertex3v(b);
    } else {
        DoFatLine(a, b, stroke-&gt;WidthPx(camera) / camera.scale);
    }
}

</t>
<t tx="leo1.20171224221235.55">void OpenGl1Renderer::DoPoint(Vector p, double d) {
    if(d &lt;= 3.0) {
        Vector u = camera.projRight.WithMagnitude(d / 2.0 / camera.scale);

        SelectPrimitive(GL_LINES);
        ssglVertex3v(p.Minus(u));
        ssglVertex3v(p.Plus(u));
    } else {
        Vector u = camera.projRight.WithMagnitude(d / 2.0 / camera.scale);
        Vector v = camera.projUp.WithMagnitude(d / 2.0 / camera.scale);

        DoFatLineEndcap(p, u, v);
        DoFatLineEndcap(p, u.ScaledBy(-1.0), v);
    }
}

</t>
<t tx="leo1.20171224221235.56">void OpenGl1Renderer::DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs, double phase) {
    Stroke *stroke = SelectStroke(hcs);

    if(stroke-&gt;stipplePattern == StipplePattern::CONTINUOUS) {
        DoLine(a, b, hcs);
        return;
    }

    double scale = stroke-&gt;StippleScaleMm(camera);
    const std::vector&lt;double&gt; &amp;dashes = StipplePatternDashes(stroke-&gt;stipplePattern);
    double length = StipplePatternLength(stroke-&gt;stipplePattern) * scale;

    phase -= floor(phase / length) * length;

    double curPhase = 0.0;
    size_t curDash;
    for(curDash = 0; curDash &lt; dashes.size(); curDash++) {
        curPhase += dashes[curDash] * scale;
        if(phase &lt; curPhase) break;
    }

    Vector dir = b.Minus(a);
    double len = dir.Magnitude();
    dir = dir.WithMagnitude(1.0);

    double cur = 0.0;
    Vector curPos = a;
    double width = stroke-&gt;WidthMm(camera);

    double curDashLen = (curPhase - phase) / scale;
    while(cur &lt; len) {
        double next = std::min(len, cur + curDashLen * scale);
        Vector nextPos = curPos.Plus(dir.ScaledBy(next - cur));
        if(curDash % 2 == 0) {
            if(curDashLen &lt;= LENGTH_EPS) {
                DoPoint(curPos, width);
            } else {
                DoLine(curPos, nextPos, hcs);
            }
        }
        cur = next;
        curPos = nextPos;
        curDash++;
        curDashLen = dashes[curDash % dashes.size()];
    }
}

//-----------------------------------------------------------------------------
// A canvas implemented using OpenGL 3 immediate mode.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221235.57">void OpenGl1Renderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    DoStippledLine(a, b, hcs);
}

</t>
<t tx="leo1.20171224221235.58">void OpenGl1Renderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    double phase = 0.0;
    for(const SEdge *e = el.l.First(); e; e = el.l.NextAfter(e)) {
        DoStippledLine(e-&gt;a, e-&gt;b, hcs, phase);
        phase += e-&gt;a.Minus(e-&gt;b).Magnitude();
    }
}

</t>
<t tx="leo1.20171224221235.59">void OpenGl1Renderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    Vector projDir = camera.projRight.Cross(camera.projUp);
    double phase = 0.0;
    switch(drawAs) {
        case DrawOutlinesAs::EMPHASIZED_AND_CONTOUR:
            for(const SOutline &amp;o : ol.l) {
                if(o.IsVisible(projDir) || o.tag != 0) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;

        case DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR:
            for(const SOutline &amp;o : ol.l) {
                if(!o.IsVisible(projDir) &amp;&amp; o.tag != 0) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;

        case DrawOutlinesAs::CONTOUR_ONLY:
            for(const SOutline &amp;o : ol.l) {
                if(o.IsVisible(projDir)) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;
    }
}

</t>
<t tx="leo1.20171224221235.6">void SurfaceRenderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    @others
}

</t>
<t tx="leo1.20171224221235.60">void OpenGl1Renderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    auto traceEdge = [&amp;](Vector a, Vector b) { DoStippledLine(a, b, hcs); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo1.20171224221235.61">void OpenGl1Renderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    SelectFill(hcf);
    SelectPrimitive(GL_QUADS);
    ssglVertex3v(a);
    ssglVertex3v(b);
    ssglVertex3v(c);
    ssglVertex3v(d);
}

</t>
<t tx="leo1.20171224221235.62">void OpenGl1Renderer::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = SelectStroke(hcs);

    Canvas::Fill fill = {};
    fill.layer  = stroke-&gt;layer;
    fill.zIndex = stroke-&gt;zIndex;
    fill.color  = stroke-&gt;color;
    hFill hcf = GetFill(fill);

    Vector r = camera.projRight.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    Vector u = camera.projUp.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    Vector a = o.Plus (r).Plus (u),
           b = o.Plus (r).Minus(u),
           c = o.Minus(r).Minus(u),
           d = o.Minus(r).Plus (u);
    DrawQuad(a, b, c, d, hcf);
}

#ifdef WIN32
#define SSGL_CALLBACK CALLBACK
#else
#define SSGL_CALLBACK
#endif
typedef void(SSGL_CALLBACK *GLUCallback)();

</t>
<t tx="leo1.20171224221235.63">static void SSGL_CALLBACK Vertex(Vector *p) {
    ssglVertex3v(*p);
}
</t>
<t tx="leo1.20171224221235.64">static void SSGL_CALLBACK Combine(double coords[3], void *vertexData[4],
                                  float weight[4], void **outData) {
    Vector *n = (Vector *)AllocTemporary(sizeof(Vector));
    n-&gt;x = coords[0];
    n-&gt;y = coords[1];
    n-&gt;z = coords[2];

    *outData = n;
}
</t>
<t tx="leo1.20171224221235.65">void OpenGl1Renderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    UnSelectPrimitive();
    SelectFill(hcf);

    GLUtesselator *gt = gluNewTess();
    gluTessCallback(gt, GLU_TESS_BEGIN,   (GLUCallback) glBegin);
    gluTessCallback(gt, GLU_TESS_VERTEX,  (GLUCallback) Vertex);
    gluTessCallback(gt, GLU_TESS_END,     (GLUCallback) glEnd);
    gluTessCallback(gt, GLU_TESS_COMBINE, (GLUCallback) Combine);

    gluTessProperty(gt, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_ODD);

    ssglNormal3v(p.normal);
    gluTessNormal(gt, p.normal.x, p.normal.y, p.normal.z);

    gluTessBeginPolygon(gt, NULL);
    for(const SContour &amp;sc : p.l) {
        gluTessBeginContour(gt);
        for(const SPoint &amp;sp : sc.l) {
            double ap[3] = { sp.p.x, sp.p.y, sp.p.z };
            gluTessVertex(gt, ap, (GLvoid *) &amp;sp.p);
        }
        gluTessEndContour(gt);
    }
    gluTessEndPolygon(gt);

    gluDeleteTess(gt);
}

</t>
<t tx="leo1.20171224221235.66">void OpenGl1Renderer::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    UnSelectPrimitive();

    RgbaColor frontColor = {},
              backColor  = {};

    Fill *frontFill = SelectFill(hcfFront);
    frontColor = frontFill-&gt;color;

    ssglMaterialRGBA(GL_FRONT, frontFill-&gt;color);
    if(hcfBack.v != 0) {
        Fill *backFill = fills.FindById(hcfBack);
        backColor = backFill-&gt;color;
        ssassert(frontFill-&gt;layer  == backFill-&gt;layer &amp;&amp;
                 frontFill-&gt;zIndex == backFill-&gt;zIndex,
                 "frontFill and backFill should belong to the same depth range");
        ssassert(frontFill-&gt;pattern == backFill-&gt;pattern,
                 "frontFill and backFill should have the same pattern");
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1);
        ssglMaterialRGBA(GL_BACK, backFill-&gt;color);
    } else {
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
    }

    RgbaColor triangleColor = {};
    glEnable(GL_LIGHTING);
    glBegin(GL_TRIANGLES);
    for(const STriangle &amp;tr : m.l) {
        if(frontColor.IsEmpty() || backColor.IsEmpty()) {
            if(triangleColor.IsEmpty() || !triangleColor.Equals(tr.meta.color)) {
                triangleColor = tr.meta.color;
                if(frontColor.IsEmpty()) {
                    ssglMaterialRGBA(GL_FRONT, triangleColor);
                }
                if(backColor.IsEmpty()) {
                    ssglMaterialRGBA(GL_BACK, triangleColor);
                }
            }
        }

        if(tr.an.EqualsExactly(Vector::From(0, 0, 0))) {
            // Compute the normal from the vertices
            ssglNormal3v(tr.Normal());
            ssglVertex3v(tr.a);
            ssglVertex3v(tr.b);
            ssglVertex3v(tr.c);
        } else {
            // Use the exact normals that are specified
            ssglNormal3v(tr.an);
            ssglVertex3v(tr.a);
            ssglNormal3v(tr.bn);
            ssglVertex3v(tr.b);
            ssglNormal3v(tr.cn);
            ssglVertex3v(tr.c);
        }
    }
    glEnd();
    glDisable(GL_LIGHTING);
}

</t>
<t tx="leo1.20171224221235.67">void OpenGl1Renderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    SelectFill(hcf);
    SelectPrimitive(GL_TRIANGLES);
    size_t facesSize = faces.size();
    for(const STriangle &amp;tr : m.l) {
        uint32_t face = tr.meta.face;
        for(size_t j = 0; j &lt; facesSize; j++) {
            if(faces[j] != face) continue;
            ssglVertex3v(tr.a);
            ssglVertex3v(tr.b);
            ssglVertex3v(tr.c);
            break;
        }
    }
}

</t>
<t tx="leo1.20171224221235.68">void OpenGl1Renderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                                 const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                 const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    @others
}

</t>
<t tx="leo1.20171224221235.69">double xfactor = 1.0,
       yfactor = 1.0;
if(HasGl1V1Quirk()) {
    xfactor = (double)pm-&gt;width / RoundUpToPowerOfTwo(pm-&gt;width);
    yfactor = (double)pm-&gt;height / RoundUpToPowerOfTwo(pm-&gt;height);
}

UnSelectPrimitive();
SelectFill(hcf);
SelectTexture(pm);
SelectPrimitive(GL_QUADS);
glTexCoord2d(ta.x * xfactor, ta.y * yfactor);
ssglVertex3v(o);
glTexCoord2d(ta.x * xfactor, tb.y * yfactor);
ssglVertex3v(o.Plus(v));
glTexCoord2d(tb.x * xfactor, tb.y * yfactor);
ssglVertex3v(o.Plus(u).Plus(v));
glTexCoord2d(tb.x * xfactor, ta.y * yfactor);
ssglVertex3v(o.Plus(u));
</t>
<t tx="leo1.20171224221235.7">auto traceEdge = [&amp;](Vector a, Vector b) {
    edges[hcs].AddEdge(ProjectPoint3RH(camera, a),
                       ProjectPoint3RH(camera, b));
};
VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
</t>
<t tx="leo1.20171224221235.70">void OpenGl1Renderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) {
        current.texture.reset();
    }
}

</t>
<t tx="leo1.20171224221235.71">void OpenGl1Renderer::UpdateProjection() {
    UnSelectPrimitive();

    glViewport(0, 0, camera.width, camera.height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glScaled(camera.scale * 2.0 / camera.width,
             camera.scale * 2.0 / camera.height,
             camera.scale * 1.0 / 30000);

    double mat[16];
    // Last thing before display is to apply the perspective
    double clp = camera.tangent * camera.scale;
    MakeMatrix(mat, 1,              0,              0,              0,
                    0,              1,              0,              0,
                    0,              0,              1,              0,
                    0,              0,              clp,            1);
    glMultMatrixd(mat);

    // Before that, we apply the rotation
    Vector projRight = camera.projRight,
           projUp    = camera.projUp,
           n         = camera.projUp.Cross(camera.projRight);
    MakeMatrix(mat, projRight.x,    projRight.y,    projRight.z,    0,
                    projUp.x,       projUp.y,       projUp.z,       0,
                    n.x,            n.y,            n.z,            0,
                    0,              0,              0,              1);
    glMultMatrixd(mat);

    // And before that, the translation
    Vector offset = camera.offset;
    MakeMatrix(mat, 1,              0,              0,              offset.x,
                    0,              1,              0,              offset.y,
                    0,              0,              1,              offset.z,
                    0,              0,              0,              1);
    glMultMatrixd(mat);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo1.20171224221235.72">void OpenGl1Renderer::NewFrame() {
    glEnable(GL_NORMALIZE);

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);

    glEnable(GL_LINE_SMOOTH);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
    // don't enable GL_POLYGON_SMOOTH; that looks ugly on some graphics cards,
    // drawn with leaks in the mesh

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    if(EXACT(lighting.lightIntensity[0] != 0.0)) {
        glEnable(GL_LIGHT0);
        GLfloat f = (GLfloat)lighting.lightIntensity[0];
        GLfloat li0[] = { f, f, f, 1.0f };
        glLightfv(GL_LIGHT0, GL_DIFFUSE, li0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, li0);

        Vector ld = camera.VectorFromProjs(lighting.lightDirection[0]);
        GLfloat ld0[4] = { (GLfloat)ld.x, (GLfloat)ld.y, (GLfloat)ld.z, 0 };
        glLightfv(GL_LIGHT0, GL_POSITION, ld0);
    }

    if(EXACT(lighting.lightIntensity[1] != 0.0)) {
        glEnable(GL_LIGHT1);
        GLfloat f = (GLfloat)lighting.lightIntensity[1];
        GLfloat li0[] = { f, f, f, 1.0f };
        glLightfv(GL_LIGHT1, GL_DIFFUSE, li0);
        glLightfv(GL_LIGHT1, GL_SPECULAR, li0);

        Vector ld = camera.VectorFromProjs(lighting.lightDirection[1]);
        GLfloat ld0[4] = { (GLfloat)ld.x, (GLfloat)ld.y, (GLfloat)ld.z, 0 };
        glLightfv(GL_LIGHT1, GL_POSITION, ld0);
    }

    if(EXACT(lighting.ambientIntensity != 0.0)) {
        GLfloat ambient[4] = { (float)lighting.ambientIntensity,
                               (float)lighting.ambientIntensity,
                               (float)lighting.ambientIntensity, 1 };
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient);
    }

    glClearColor(lighting.backgroundColor.redF(),  lighting.backgroundColor.greenF(),
                 lighting.backgroundColor.blueF(), lighting.backgroundColor.alphaF());
    glClear(GL_COLOR_BUFFER_BIT);

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo1.20171224221235.73">void OpenGl1Renderer::FlushFrame() {
    UnSelectPrimitive();
    glFlush();

    GLenum error = glGetError();
    if(error != GL_NO_ERROR) {
        dbp("glGetError() == 0x%X %s", error, gluErrorString(error));
    }
}

std::shared_ptr&lt;Pixmap&gt; OpenGl1Renderer::ReadFrame() {
    std::shared_ptr&lt;Pixmap&gt; pixmap =
        Pixmap::Create(Pixmap::Format::RGB, (size_t)camera.width, (size_t)camera.height);
    glReadPixels(0, 0, camera.width, camera.height, GL_RGB, GL_UNSIGNED_BYTE, &amp;pixmap-&gt;data[0]);
    return pixmap;
}

</t>
<t tx="leo1.20171224221235.74">void OpenGl1Renderer::GetIdent(const char **vendor, const char **renderer, const char **version) {
    *vendor   = (const char *)glGetString(GL_VENDOR);
    *renderer = (const char *)glGetString(GL_RENDERER);
    *version  = (const char *)glGetString(GL_VERSION);
}

</t>
<t tx="leo1.20171224221235.75">void OpenGl1Renderer::SetCamera(const Camera &amp;c) {
    camera = c;
    UpdateProjection();
}

</t>
<t tx="leo1.20171224221235.76">void OpenGl1Renderer::SetLighting(const Lighting &amp;l) {
    lighting = l;
}

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return std::shared_ptr&lt;ViewportCanvas&gt;(new OpenGl1Renderer());
}

}
</t>
<t tx="leo1.20171224221235.77">//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 based rendering interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "gl3shader.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221235.8">void SurfaceRenderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    Fill *fill = fills.FindById(hcf);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY ||
             fill-&gt;layer == Layer::FRONT ||
             fill-&gt;layer == Layer::BACK, "Unexpected mesh layer");

    Vector zOffset = {};
    if(fill-&gt;layer == Layer::BACK) {
        zOffset.z -= 1e6;
    } else if(fill-&gt;layer == Layer::FRONT) {
        zOffset.z += 1e6;
    }
    zOffset.z += camera.scale * fill-&gt;zIndex;

    STriMeta meta = {};
    if(fill-&gt;layer != Layer::DEPTH_ONLY) {
        meta.color = fill-&gt;color;
    }
    Vector ta = ProjectPoint3RH(camera, a).Plus(zOffset),
           tb = ProjectPoint3RH(camera, b).Plus(zOffset),
           tc = ProjectPoint3RH(camera, c).Plus(zOffset),
           td = ProjectPoint3RH(camera, d).Plus(zOffset);
    mesh.AddTriangle(meta, tc, tb, ta);
    mesh.AddTriangle(meta, ta, td, tc);
}

</t>
<t tx="leo1.20171224221235.9">void SurfaceRenderer::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);

    Fill fill = {};
    fill.layer  = stroke-&gt;layer;
    fill.zIndex = stroke-&gt;zIndex;
    fill.color  = stroke-&gt;color;
    hFill hcf = GetFill(fill);

    Vector u = camera.projRight.ScaledBy(stroke-&gt;width/2.0/camera.scale),
           v = camera.projUp.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    DrawQuad(o.Minus(u).Minus(v), o.Minus(u).Plus(v),
             o.Plus(u).Plus(v),   o.Plus(u).Minus(v), hcf);
}

</t>
<t tx="leo1.20171224221236.1">class TextureCache {
public:
    std::map&lt;std::weak_ptr&lt;const Pixmap&gt;, GLuint,
             std::owner_less&lt;std::weak_ptr&lt;const Pixmap&gt;&gt;&gt; items;

    @others
};

// A canvas that uses the core OpenGL 3 profile, for desktop systems.
</t>
<t tx="leo1.20171224221236.10">void OpenGl2Renderer::DoPoint(Vector p, hStroke hs) {
    SPointListItem *pli = points.FindByIdNoOops(hs);
    if(pli == NULL) {
        SPointListItem item = {};
        item.h = hs;
        points.Add(&amp;item);
        pli = points.FindByIdNoOops(hs);
    }

    pli-&gt;points.AddPoint(p);
}

</t>
<t tx="leo1.20171224221236.100">//-----------------------------------------------------------------------------
// Anything involving curves and sets of curves (except for the real math,
// which is in ratpoly.cpp).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

SBezier SBezier::From(Vector4 p0, Vector4 p1) {
    SBezier ret = {};
    ret.deg = 1;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector4 p0, Vector4 p1, Vector4 p2) {
    SBezier ret = {};
    ret.deg = 2;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    ret.weight[2] = p2.w;
    ret.ctrl  [2] = p2.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector4 p0, Vector4 p1, Vector4 p2, Vector4 p3) {
    SBezier ret = {};
    ret.deg = 3;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    ret.weight[2] = p2.w;
    ret.ctrl  [2] = p2.PerspectiveProject();
    ret.weight[3] = p3.w;
    ret.ctrl  [3] = p3.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector p0, Vector p1) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d());
}

SBezier SBezier::From(Vector p0, Vector p1, Vector p2) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d(),
                         p2.Project4d());
}

SBezier SBezier::From(Vector p0, Vector p1, Vector p2, Vector p3) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d(),
                         p2.Project4d(),
                         p3.Project4d());
}

Vector SBezier::Start() const {
    return ctrl[0];
}

Vector SBezier::Finish() const {
    return ctrl[deg];
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221236.101">void SBezier::Reverse() {
    int i;
    for(i = 0; i &lt; (deg+1)/2; i++) {
        swap(ctrl[i], ctrl[deg-i]);
        swap(weight[i], weight[deg-i]);
    }
}

</t>
<t tx="leo1.20171224221236.102">void SBezier::ScaleSelfBy(double s) {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ctrl[i] = ctrl[i].ScaledBy(s);
    }
}

</t>
<t tx="leo1.20171224221236.103">void SBezier::GetBoundingProjd(Vector u, Vector orig,
                               double *umin, double *umax) const
{
    int i;
    for(i = 0; i &lt;= deg; i++) {
        double ut = ((ctrl[i]).Minus(orig)).Dot(u);
        if(ut &lt; *umin) *umin = ut;
        if(ut &gt; *umax) *umax = ut;
    }
}

SBezier SBezier::TransformedBy(Vector t, Quaternion q, double scale) const {
    SBezier ret = *this;
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ret.ctrl[i] = (ret.ctrl[i]).ScaledBy(scale);
        ret.ctrl[i] = (q.Rotate(ret.ctrl[i])).Plus(t);
    }
    return ret;
}

//-----------------------------------------------------------------------------
// Does this curve lie entirely within the specified plane? It does if all
// the control points lie in that plane.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.104">bool SBezier::IsInPlane(Vector n, double d) const {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(fabs((ctrl[i]).Dot(n) - d) &gt; LENGTH_EPS) {
            return false;
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Is this Bezier exactly the arc of a circle, projected along the specified
// axis? If yes, return that circle's center and radius.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.105">bool SBezier::IsCircle(Vector axis, Vector *center, double *r) const {
    if(deg != 2) return false;

    if(ctrl[1].DistanceToLine(ctrl[0], ctrl[2].Minus(ctrl[0])) &lt; LENGTH_EPS) {
        // This is almost a line segment. So it's a circle with very large
        // radius, which is likely to make code that tries to handle circles
        // blow up. So return false.
        return false;
    }

    Vector t0 = (ctrl[0]).Minus(ctrl[1]),
           t2 = (ctrl[2]).Minus(ctrl[1]),
           r0 = axis.Cross(t0),
           r2 = axis.Cross(t2);

    *center = Vector::AtIntersectionOfLines(ctrl[0], (ctrl[0]).Plus(r0),
                                            ctrl[2], (ctrl[2]).Plus(r2),
                                            NULL, NULL, NULL);

    @others
}

</t>
<t tx="leo1.20171224221236.106">double rd0 = center-&gt;Minus(ctrl[0]).Magnitude(),
       rd2 = center-&gt;Minus(ctrl[2]).Magnitude();
if(fabs(rd0 - rd2) &gt; LENGTH_EPS) {
    return false;
}
*r = rd0;

Vector u = r0.WithMagnitude(1),
       v = (axis.Cross(u)).WithMagnitude(1);
Point2d c2  = center-&gt;Project2d(u, v),
        pa2 = (ctrl[0]).Project2d(u, v).Minus(c2),
        pb2 = (ctrl[2]).Project2d(u, v).Minus(c2);

</t>
<t tx="leo1.20171224221236.107">double thetaa = atan2(pa2.y, pa2.x), // in fact always zero due to csys
       thetab = atan2(pb2.y, pb2.x),
       dtheta = WRAP_NOT_0(thetab - thetaa, 2*PI);
if(dtheta &gt; PI) {
    // Not possible with a second order Bezier arc; so we must have
    // the points backwards.
    dtheta = 2*PI - dtheta;
}

if(fabs(weight[1] - cos(dtheta/2)) &gt; LENGTH_EPS) {
    return false;
}

return true;
</t>
<t tx="leo1.20171224221236.108">bool SBezier::IsRational() const {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(fabs(weight[i] - 1) &gt; LENGTH_EPS) return true;
    }
    return false;
}

//-----------------------------------------------------------------------------
// Apply a perspective transformation to a rational Bezier curve, calculating
// the new weights as required.
//-----------------------------------------------------------------------------
SBezier SBezier::InPerspective(Vector u, Vector v, Vector n,
                               Vector origin, double cameraTan) const
{
    Quaternion q = Quaternion::From(u, v);
    q = q.Inverse();
    // we want Q*(p - o) = Q*p - Q*o
    SBezier ret = this-&gt;TransformedBy(q.Rotate(origin).ScaledBy(-1), q, 1.0);
    int i;
    for(i = 0; i &lt;= deg; i++) {
        Vector4 ct = Vector4::From(ret.weight[i], ret.ctrl[i]);
        // so the desired curve, before perspective, is
        //    (x/w, y/w, z/w)
        // and after perspective is
        //    ((x/w)/(1 - (z/w)*cameraTan, ...
        //  = (x/(w - z*cameraTan), ...
        // so we want to let w' = w - z*cameraTan
        ct.w = ct.w - ct.z*cameraTan;

        ret.ctrl[i] = ct.PerspectiveProject();
        ret.weight[i] = ct.w;
    }
    return ret;
}

</t>
<t tx="leo1.20171224221236.109">bool SBezier::Equals(SBezier *b) const {
    // We just test of identical degree and control points, even though two
    // curves could still be coincident (even sharing endpoints).
    if(deg != b-&gt;deg) return false;
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(!(ctrl[i]).Equals(b-&gt;ctrl[i])) return false;
        if(fabs(weight[i] - b-&gt;weight[i]) &gt; LENGTH_EPS) return false;
    }
    return true;
}

</t>
<t tx="leo1.20171224221236.11">void OpenGl2Renderer::DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    if(stroke-&gt;stipplePattern != StipplePattern::FREEHAND &amp;&amp;
       stroke-&gt;stipplePattern != StipplePattern::ZIGZAG)
    {
        DoLine(a, b, hcs);
        return;
    }

    const char *patternSeq;
    Stroke s = *stroke;
    s.stipplePattern = StipplePattern::CONTINUOUS;
    hcs = GetStroke(s);
    switch(stroke-&gt;stipplePattern) {
        case StipplePattern::CONTINUOUS:    DoLine(a, b, hcs);  return;
        case StipplePattern::SHORT_DASH:    patternSeq = "-  "; break;
        case StipplePattern::DASH:          patternSeq = "- ";  break;
        case StipplePattern::LONG_DASH:     patternSeq = "_ ";  break;
        case StipplePattern::DASH_DOT:      patternSeq = "-.";  break;
        case StipplePattern::DASH_DOT_DOT:  patternSeq = "-.."; break;
        case StipplePattern::DOT:           patternSeq = ".";   break;
        case StipplePattern::FREEHAND:      patternSeq = "~";   break;
        case StipplePattern::ZIGZAG:        patternSeq = "~__"; break;
    }

    Vector dir = b.Minus(a);
    double len = dir.Magnitude();
    dir = dir.WithMagnitude(1.0);

    const char *si = patternSeq;
    double end = len;
    double ss = stroke-&gt;stippleScale / 2.0;
    do {
        double start = end;
        switch(*si) {
            case ' ':
                end -= 1.0 * ss;
                break;

            case '-':
                start = max(start - 0.5 * ss, 0.0);
                end = max(start - 2.0 * ss, 0.0);
                if(start == end) break;
                DoLine(a.Plus(dir.ScaledBy(start)), a.Plus(dir.ScaledBy(end)), hcs);
                end = max(end - 0.5 * ss, 0.0);
                break;

            case '_':
                end = max(end - 4.0 * ss, 0.0);
                DoLine(a.Plus(dir.ScaledBy(start)), a.Plus(dir.ScaledBy(end)), hcs);
                break;

            case '.':
                end = max(end - 0.5 * ss, 0.0);
                if(end == 0.0) break;
                DoPoint(a.Plus(dir.ScaledBy(end)), hcs);
                end = max(end - 0.5 * ss, 0.0);
                break;

            case '~': {
                Vector ab  = b.Minus(a);
                Vector gn = (camera.projRight).Cross(camera.projUp);
                Vector abn = (ab.Cross(gn)).WithMagnitude(1);
                abn = abn.Minus(gn.ScaledBy(gn.Dot(abn)));
                double pws = 2.0 * stroke-&gt;width / camera.scale;

                end = max(end - 0.5 * ss, 0.0);
                Vector aa = a.Plus(dir.ScaledBy(start));
                Vector bb = a.Plus(dir.ScaledBy(end))
                             .Plus(abn.ScaledBy(pws * (start - end) / (0.5 * ss)));
                DoLine(aa, bb, hcs);
                if(end == 0.0) break;

                start = end;
                end = max(end - 1.0 * ss, 0.0);
                aa = a.Plus(dir.ScaledBy(end))
                      .Plus(abn.ScaledBy(pws))
                      .Minus(abn.ScaledBy(2.0 * pws * (start - end) / ss));
                DoLine(bb, aa, hcs);
                if(end == 0.0) break;

                start = end;
                end = max(end - 0.5 * ss, 0.0);
                bb = a.Plus(dir.ScaledBy(end))
                      .Minus(abn.ScaledBy(pws))
                      .Plus(abn.ScaledBy(pws * (start - end) / (0.5 * ss)));
                DoLine(aa, bb, hcs);
                break;
            }

            default: ssassert(false, "Unexpected stipple pattern element");
        }
        if(*(++si) == 0) si = patternSeq;
    } while(end &gt; 0.0);
}

//-----------------------------------------------------------------------------
// A canvas implemented using OpenGL 3 vertex buffer objects.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221236.110">void SBezierList::Clear() {
    l.Clear();
}

</t>
<t tx="leo1.20171224221236.111">void SBezierList::ScaleSelfBy(double s) {
    SBezier *sb;
    for(sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;ScaleSelfBy(s);
    }
}

//-----------------------------------------------------------------------------
// If our list contains multiple identical Beziers (in either forward or
// reverse order), then cull them.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.112">void SBezierList::CullIdenticalBeziers() {
    int i, j;

    l.ClearTags();
    for(i = 0; i &lt; l.n; i++) {
        SBezier *bi = &amp;(l.elem[i]), bir;
        bir = *bi;
        bir.Reverse();

        for(j = i + 1; j &lt; l.n; j++) {
            SBezier *bj = &amp;(l.elem[j]);
            if(bj-&gt;Equals(bi) ||
               bj-&gt;Equals(&amp;bir))
            {
                bi-&gt;tag = 1;
                bj-&gt;tag = 1;
            }
        }
    }
    l.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Find all the points where a list of Bezier curves intersects another list
// of Bezier curves. We do this by intersecting their piecewise linearizations,
// and then refining any intersections that we find to lie exactly on the
// curves. So this will screw up on tangencies and stuff, but otherwise should
// be fine.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.113">void SBezierList::AllIntersectionsWith(SBezierList *sblb, SPointList *spl) const {
    for(const SBezier *sba = l.First(); sba; sba = l.NextAfter(sba)) {
        for(const SBezier *sbb = sblb-&gt;l.First(); sbb; sbb = sblb-&gt;l.NextAfter(sbb)) {
            sbb-&gt;AllIntersectionsWith(sba, spl);
        }
    }
}
</t>
<t tx="leo1.20171224221236.114">void SBezier::AllIntersectionsWith(const SBezier *sbb, SPointList *spl) const {
    SPointList splRaw = {};
    SEdgeList sea, seb;
    sea = {};
    seb = {};
    this-&gt;MakePwlInto(&amp;sea);
    sbb -&gt;MakePwlInto(&amp;seb);
    SEdge *se;
    for(se = sea.l.First(); se; se = sea.l.NextAfter(se)) {
        // This isn't quite correct, since AnyEdgeCrossings doesn't count
        // the case where two pairs of line segments intersect at their
        // vertices. So this isn't robust, although that case isn't very
        // likely.
        seb.AnyEdgeCrossings(se-&gt;a, se-&gt;b, NULL, &amp;splRaw);
    }
    SPoint *sp;
    for(sp = splRaw.l.First(); sp; sp = splRaw.l.NextAfter(sp)) {
        Vector p = sp-&gt;p;
        if(PointOnThisAndCurve(sbb, &amp;p)) {
            if(!spl-&gt;ContainsPoint(p)) spl-&gt;Add(p);
        }
    }
    sea.Clear();
    seb.Clear();
    splRaw.Clear();
}

//-----------------------------------------------------------------------------
// Find a plane that contains all of the curves in this list. If the curves
// are all colinear (or coincident, or empty), then that plane is not exactly
// determined but we choose the additional degree(s) of freedom arbitrarily.
// Returns true if all the curves are coplanar, otherwise false.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.115">bool SBezierList::GetPlaneContainingBeziers(Vector *p, Vector *u, Vector *v,
                        Vector *notCoplanarAt) const
{
    Vector pt, ptFar, ptOffLine, dp, n;
    double farMax, offLineMax;
    int i;

    // Get any point on any Bezier; or an arbitrary point if list is empty.
    if(l.n &gt; 0) {
        pt = l.elem[0].Start();
    } else {
        pt = Vector::From(0, 0, 0);
    }
    ptFar = ptOffLine = pt;

    // Get the point farthest from our arbitrary point.
    farMax = VERY_NEGATIVE;
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            double m = (pt.Minus(sb-&gt;ctrl[i])).Magnitude();
            if(m &gt; farMax) {
                ptFar = sb-&gt;ctrl[i];
                farMax = m;
            }
        }
    }
    if(ptFar.Equals(pt)) {
        // The points are all coincident. So neither basis vector matters.
        *p = pt;
        *u = Vector::From(1, 0, 0);
        *v = Vector::From(0, 1, 0);
        return true;
    }

    // Get the point farthest from the line between pt and ptFar
    dp = ptFar.Minus(pt);
    offLineMax = VERY_NEGATIVE;
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            double m = (sb-&gt;ctrl[i]).DistanceToLine(pt, dp);
            if(m &gt; offLineMax) {
                ptOffLine = sb-&gt;ctrl[i];
                offLineMax = m;
            }
        }
    }

    *p = pt;
    if(offLineMax &lt; LENGTH_EPS) {
        // The points are all colinear; so choose the second basis vector
        // arbitrarily.
        *u = (ptFar.Minus(pt)).WithMagnitude(1);
        *v = (u-&gt;Normal(0)).WithMagnitude(1);
    } else {
        // The points actually define a plane.
        n = (ptFar.Minus(pt)).Cross(ptOffLine.Minus(pt));
        *u = (n.Normal(0)).WithMagnitude(1);
        *v = (n.Normal(1)).WithMagnitude(1);
    }

    // So we have a plane; but check whether all of the points lie in that
    // plane.
    n = u-&gt;Cross(*v);
    n = n.WithMagnitude(1);
    double d = p-&gt;Dot(n);
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            if(fabs(n.Dot(sb-&gt;ctrl[i]) - d) &gt; LENGTH_EPS) {
                if(notCoplanarAt) *notCoplanarAt = sb-&gt;ctrl[i];
                return false;
            }
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Assemble curves in sbl into a single loop. The curves may appear in any
// direction (start to finish, or finish to start), and will be reversed if
// necessary. The curves in the returned loop are removed from sbl, even if
// the loop cannot be closed.
//-----------------------------------------------------------------------------
SBezierLoop SBezierLoop::FromCurves(SBezierList *sbl,
                                    bool *allClosed, SEdge *errorAt)
{
    SBezierLoop loop = {};

    if(sbl-&gt;l.n &lt; 1) return loop;
    sbl-&gt;l.ClearTags();

    SBezier *first = &amp;(sbl-&gt;l.elem[0]);
    first-&gt;tag = 1;
    loop.l.Add(first);
    Vector start = first-&gt;Start();
    Vector hanging = first-&gt;Finish();
    int auxA = first-&gt;auxA;

    sbl-&gt;l.RemoveTagged();

    while(sbl-&gt;l.n &gt; 0 &amp;&amp; !hanging.Equals(start)) {
        int i;
        bool foundNext = false;
        for(i = 0; i &lt; sbl-&gt;l.n; i++) {
            SBezier *test = &amp;(sbl-&gt;l.elem[i]);

            if((test-&gt;Finish()).Equals(hanging) &amp;&amp; test-&gt;auxA == auxA) {
                test-&gt;Reverse();
                // and let the next test catch it
            }
            if((test-&gt;Start()).Equals(hanging) &amp;&amp; test-&gt;auxA == auxA) {
                test-&gt;tag = 1;
                loop.l.Add(test);
                hanging = test-&gt;Finish();
                sbl-&gt;l.RemoveTagged();
                foundNext = true;
                break;
            }
        }
        if(!foundNext) {
            // The loop completed without finding the hanging edge, so
            // it's an open loop
            errorAt-&gt;a = hanging;
            errorAt-&gt;b = start;
            *allClosed = false;
            return loop;
        }
    }
    if(hanging.Equals(start)) {
        *allClosed = true;
    } else {
        // We ran out of edges without forming a closed loop.
        errorAt-&gt;a = hanging;
        errorAt-&gt;b = start;
        *allClosed = false;
    }

    return loop;
}

</t>
<t tx="leo1.20171224221236.116">void SBezierLoop::Reverse() {
    l.Reverse();
    SBezier *sb;
    for(sb = l.First(); sb; sb = l.NextAfter(sb)) {
        // If we didn't reverse each curve, then the next curve in list would
        // share your start, not your finish.
        sb-&gt;Reverse();
    }
}

</t>
<t tx="leo1.20171224221236.117">void SBezierLoop::GetBoundingProjd(Vector u, Vector orig,
                                   double *umin, double *umax) const
{
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;GetBoundingProjd(u, orig, umin, umax);
    }
}

</t>
<t tx="leo1.20171224221236.118">void SBezierLoop::MakePwlInto(SContour *sc, double chordTol) const {
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;MakePwlInto(sc, chordTol);
        // Avoid double points at join between Beziers; except that
        // first and last points should be identical.
        if(l.NextAfter(sb) != NULL) {
            sc-&gt;l.RemoveLast(1);
        }
    }
    // Ensure that it's exactly closed, not just within a numerical tolerance.
    if((sc-&gt;l.elem[sc-&gt;l.n - 1].p).Equals(sc-&gt;l.elem[0].p)) {
        sc-&gt;l.elem[sc-&gt;l.n - 1] = sc-&gt;l.elem[0];
    }
}

</t>
<t tx="leo1.20171224221236.119">bool SBezierLoop::IsClosed() const {
    if(l.n &lt; 1) return false;
    Vector s = l.elem[0].Start(),
           f = l.elem[l.n-1].Finish();
    return s.Equals(f);
}


//-----------------------------------------------------------------------------
// Assemble the curves in sbl into multiple loops, and piecewise linearize the
// curves into poly. If we can't close a contour, then we add it to
// openContours (if that isn't NULL) and keep going; so this works even if the
// input contains a mix of open and closed curves.
//-----------------------------------------------------------------------------
SBezierLoopSet SBezierLoopSet::From(SBezierList *sbl, SPolygon *poly,
</t>
<t tx="leo1.20171224221236.12">void OpenGl2Renderer::Init() {
    atlas.Init();
    edgeRenderer.Init(&amp;atlas);
    outlineRenderer.Init(&amp;atlas);
    meshRenderer.Init();
    imeshRenderer.Init();

#if !defined(HAVE_GLES) &amp;&amp; !defined(__APPLE__)
    GLuint array;
    glGenVertexArrays(1, &amp;array);
    glBindVertexArray(array);
#endif
    UpdateProjection();
}

</t>
<t tx="leo1.20171224221236.120">                                    double chordTol,
                                    bool *allClosed, SEdge *errorAt,
                                    SBezierList *openContours)
{
    SBezierLoopSet ret = {};

    *allClosed = true;
    while(sbl-&gt;l.n &gt; 0) {
        bool thisClosed;
        SBezierLoop loop;
        loop = SBezierLoop::FromCurves(sbl, &amp;thisClosed, errorAt);
        if(!thisClosed) {
            // Record open loops in a separate list, if requested.
            *allClosed = false;
            if(openContours) {
                SBezier *sb;
                for(sb = loop.l.First(); sb; sb = loop.l.NextAfter(sb)) {
                    openContours-&gt;l.Add(sb);
                }
            }
            loop.Clear();
        } else {
            ret.l.Add(&amp;loop);
            poly-&gt;AddEmptyContour();
            loop.MakePwlInto(&amp;(poly-&gt;l.elem[poly-&gt;l.n-1]), chordTol);
        }
    }

    poly-&gt;normal = poly-&gt;ComputeNormal();
    ret.normal = poly-&gt;normal;
    if(poly-&gt;l.n &gt; 0) {
        ret.point = poly-&gt;AnyPoint();
    } else {
        ret.point = Vector::From(0, 0, 0);
    }

    return ret;
}

</t>
<t tx="leo1.20171224221236.121">void SBezierLoopSet::GetBoundingProjd(Vector u, Vector orig,
                                      double *umin, double *umax) const
{
    for(const SBezierLoop *sbl = l.First(); sbl; sbl = l.NextAfter(sbl)) {
        sbl-&gt;GetBoundingProjd(u, orig, umin, umax);
    }
}

double SBezierLoopSet::SignedArea() {
    if(EXACT(area == 0.0)) {
        SPolygon sp = {};
        MakePwlInto(&amp;sp);
        sp.normal = sp.ComputeNormal();
        area = sp.SignedArea();
        sp.Clear();
    }
    return area;
}

//-----------------------------------------------------------------------------
// Convert all the Beziers into piecewise linear form, and assemble that into
// a polygon, one contour per loop.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.122">void SBezierLoopSet::MakePwlInto(SPolygon *sp) const {
    for(const SBezierLoop *sbl = l.First(); sbl; sbl = l.NextAfter(sbl)) {
        sp-&gt;AddEmptyContour();
        sbl-&gt;MakePwlInto(&amp;(sp-&gt;l.elem[sp-&gt;l.n - 1]));
    }
}

</t>
<t tx="leo1.20171224221236.123">void SBezierLoopSet::Clear() {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l.elem[i]).Clear();
    }
    l.Clear();
}

//-----------------------------------------------------------------------------
// An export helper function. We start with a list of Bezier curves, and
// assemble them into loops. We find the outer loops, and find the outer loops'
// inner loops, and group them accordingly.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.124">void SBezierLoopSetSet::FindOuterFacesFrom(SBezierList *sbl, SPolygon *spxyz,
                                   SSurface *srfuv,
                                   double chordTol,
                                   bool *allClosed, SEdge *notClosedAt,
                                   bool *allCoplanar, Vector *notCoplanarAt,
                                   SBezierList *openContours)
{
    SSurface srfPlane;
    if(!srfuv) {
        Vector p, u, v;
        *allCoplanar =
            sbl-&gt;GetPlaneContainingBeziers(&amp;p, &amp;u, &amp;v, notCoplanarAt);
        if(!*allCoplanar) {
            // Don't even try to assemble them into loops if they're not
            // all coplanar.
            if(openContours) {
                SBezier *sb;
                for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
                    openContours-&gt;l.Add(sb);
                }
            }
            return;
        }
        // All the curves lie in a plane through p with basis vectors u and v.
        srfPlane = SSurface::FromPlane(p, u, v);
        srfuv = &amp;srfPlane;
    }

    int i, j;
    // Assemble the Bezier trim curves into closed loops; we also get the
    // piecewise linearization of the curves (in the SPolygon spxyz), as a
    // calculation aid for the loop direction.
    SBezierLoopSet sbls = SBezierLoopSet::From(sbl, spxyz, chordTol,
                                               allClosed, notClosedAt,
                                               openContours);
    if(sbls.l.n != spxyz-&gt;l.n) return;

    // Convert the xyz piecewise linear to uv piecewise linear.
    SPolygon spuv = {};
    SContour *sc;
    for(sc = spxyz-&gt;l.First(); sc; sc = spxyz-&gt;l.NextAfter(sc)) {
        spuv.AddEmptyContour();
        SPoint *pt;
        for(pt = sc-&gt;l.First(); pt; pt = sc-&gt;l.NextAfter(pt)) {
            double u, v;
            srfuv-&gt;ClosestPointTo(pt-&gt;p, &amp;u, &amp;v);
            spuv.l.elem[spuv.l.n - 1].AddPoint(Vector::From(u, v, 0));
        }
    }
    spuv.normal = Vector::From(0, 0, 1); // must be, since it's in xy plane now

    static const int OUTER_LOOP = 10;
    static const int INNER_LOOP = 20;
    static const int USED_LOOP  = 30;
    // Fix the contour directions; we do this properly, in uv space, so it
    // works for curved surfaces too (important for STEP export).
    spuv.FixContourDirections();
    for(i = 0; i &lt; spuv.l.n; i++) {
        SContour    *contour = &amp;(spuv.l.elem[i]);
        SBezierLoop *bl = &amp;(sbls.l.elem[i]);
        if(contour-&gt;tag) {
            // This contour got reversed in the polygon to make the directions
            // consistent, so the same must be necessary for the Bezier loop.
            bl-&gt;Reverse();
        }
        if(contour-&gt;IsClockwiseProjdToNormal(spuv.normal)) {
            bl-&gt;tag = INNER_LOOP;
        } else {
            bl-&gt;tag = OUTER_LOOP;
        }
    }

    bool loopsRemaining = true;
    while(loopsRemaining) {
        loopsRemaining = false;
        for(i = 0; i &lt; sbls.l.n; i++) {
            SBezierLoop *loop = &amp;(sbls.l.elem[i]);
            if(loop-&gt;tag != OUTER_LOOP) continue;

            // Check if this contour contains any outer loops; if it does, then
            // we should do those "inner outer loops" first; otherwise we
            // will steal their holes, since their holes also lie inside this
            // contour.
            for(j = 0; j &lt; sbls.l.n; j++) {
                SBezierLoop *outer = &amp;(sbls.l.elem[j]);
                if(i == j) continue;
                if(outer-&gt;tag != OUTER_LOOP) continue;

                Vector p = spuv.l.elem[j].AnyEdgeMidpoint();
                if(spuv.l.elem[i].ContainsPointProjdToNormal(spuv.normal, p)) {
                    break;
                }
            }
            if(j &lt; sbls.l.n) {
                // It does, can't do this one yet.
                continue;
            }

            SBezierLoopSet outerAndInners = {};
            loopsRemaining = true;
            loop-&gt;tag = USED_LOOP;
            outerAndInners.l.Add(loop);
            int auxA = 0;
            if(loop-&gt;l.n &gt; 0) auxA = loop-&gt;l.elem[0].auxA;

            for(j = 0; j &lt; sbls.l.n; j++) {
                SBezierLoop *inner = &amp;(sbls.l.elem[j]);
                if(inner-&gt;tag != INNER_LOOP) continue;
                if(inner-&gt;l.n &lt; 1) continue;
                if(inner-&gt;l.elem[0].auxA != auxA) continue;

                Vector p = spuv.l.elem[j].AnyEdgeMidpoint();
                if(spuv.l.elem[i].ContainsPointProjdToNormal(spuv.normal, p)) {
                    outerAndInners.l.Add(inner);
                    inner-&gt;tag = USED_LOOP;
                }
            }

            outerAndInners.point  = srfuv-&gt;PointAt(0, 0);
            outerAndInners.normal = srfuv-&gt;NormalAt(0, 0);
            l.Add(&amp;outerAndInners);
        }
    }

    // If we have poorly-formed loops--for example, overlapping zero-area
    // stuff--then we can end up with leftovers. We use this function to
    // group stuff into closed paths for export when possible, so it's bad
    // to screw up on that stuff. So just add them onto the open curve list.
    // Very ugly, but better than losing curves.
    for(i = 0; i &lt; sbls.l.n; i++) {
        SBezierLoop *loop = &amp;(sbls.l.elem[i]);
        if(loop-&gt;tag == USED_LOOP) continue;

        if(openContours) {
            SBezier *sb;
            for(sb = loop-&gt;l.First(); sb; sb = loop-&gt;l.NextAfter(sb)) {
                openContours-&gt;l.Add(sb);
            }
        }
        loop-&gt;Clear();
        // but don't free the used loops, since we shallow-copied them to
        // ourself
    }

    sbls.l.Clear(); // not sbls.Clear(), since that would deep-clear
    spuv.Clear();
}

</t>
<t tx="leo1.20171224221236.125">void SBezierLoopSetSet::AddOpenPath(SBezier *sb) {
    SBezierLoop sbl = {};
    sbl.l.Add(sb);

    SBezierLoopSet sbls = {};
    sbls.l.Add(&amp;sbl);

    l.Add(&amp;sbls);
}

</t>
<t tx="leo1.20171224221236.126">void SBezierLoopSetSet::Clear() {
    SBezierLoopSet *sbls;
    for(sbls = l.First(); sbls; sbls = l.NextAfter(sbls)) {
        sbls-&gt;Clear();
    }
    l.Clear();
}

SCurve SCurve::FromTransformationOf(SCurve *a, Vector t,
                                    Quaternion q, double scale)
{
    bool needRotate    = !EXACT(q.vx == 0.0 &amp;&amp; q.vy == 0.0 &amp;&amp; q.vz == 0.0 &amp;&amp; q.w == 1.0);
    bool needTranslate = !EXACT(t.x  == 0.0 &amp;&amp; t.y  == 0.0 &amp;&amp; t.z  == 0.0);
    bool needScale     = !EXACT(scale == 1.0);

    SCurve ret = {};
    ret.h = a-&gt;h;
    ret.isExact = a-&gt;isExact;
    ret.exact = (a-&gt;exact).TransformedBy(t, q, scale);
    ret.surfA = a-&gt;surfA;
    ret.surfB = a-&gt;surfB;

    SCurvePt *p;
    ret.pts.ReserveMore(a-&gt;pts.n);
    for(p = a-&gt;pts.First(); p; p = a-&gt;pts.NextAfter(p)) {
        SCurvePt pp = *p;
        if(needScale) {
            pp.p = (pp.p).ScaledBy(scale);
        }
        if(needRotate) {
            pp.p = q.Rotate(pp.p);
        }
        if(needTranslate) {
            pp.p = pp.p.Plus(t);
        }
        ret.pts.Add(&amp;pp);
    }
    return ret;
}

</t>
<t tx="leo1.20171224221236.127">void SCurve::Clear() {
    pts.Clear();
}

SSurface *SCurve::GetSurfaceA(SShell *a, SShell *b) const {
    if(source == Source::A) {
        return a-&gt;surface.FindById(surfA);
    } else if(source == Source::B) {
        return b-&gt;surface.FindById(surfA);
    } else if(source == Source::INTERSECTION) {
        return a-&gt;surface.FindById(surfA);
    } else ssassert(false, "Unexpected curve source");
}

SSurface *SCurve::GetSurfaceB(SShell *a, SShell *b) const {
    if(source == Source::A) {
        return a-&gt;surface.FindById(surfB);
    } else if(source == Source::B) {
        return b-&gt;surface.FindById(surfB);
    } else if(source == Source::INTERSECTION) {
        return b-&gt;surface.FindById(surfB);
    } else ssassert(false, "Unexpected curve source");
}

//-----------------------------------------------------------------------------
// When we split line segments wherever they intersect a surface, we introduce
// extra pwl points. This may create very short edges that could be removed
// without violating the chord tolerance. Those are ugly, and also break
// stuff in the Booleans. So remove them.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.128">void SCurve::RemoveShortSegments(SSurface *srfA, SSurface *srfB) {
    // Three, not two; curves are pwl'd to at least two edges (three points)
    // even if not necessary, to avoid square holes.
    if(pts.n &lt;= 3) return;
    pts.ClearTags();

    Vector prev = pts.elem[0].p;
    int i, a;
    for(i = 1; i &lt; pts.n - 1; i++) {
        SCurvePt *sct = &amp;(pts.elem[i]),
                 *scn = &amp;(pts.elem[i+1]);
        if(sct-&gt;vertex) {
            prev = sct-&gt;p;
            continue;
        }
        bool mustKeep = false;

        // We must check against both surfaces; the piecewise linear edge
        // may have a different chord tolerance in the two surfaces. (For
        // example, a circle in the surface of a cylinder is just a straight
        // line, so it always has perfect chord tol, but that circle in
        // a plane is a circle so it doesn't).
        for(a = 0; a &lt; 2; a++) {
            SSurface *srf = (a == 0) ? srfA : srfB;
            Vector puv, nuv;
            srf-&gt;ClosestPointTo(prev,   &amp;(puv.x), &amp;(puv.y));
            srf-&gt;ClosestPointTo(scn-&gt;p, &amp;(nuv.x), &amp;(nuv.y));

            if(srf-&gt;ChordToleranceForEdge(nuv, puv) &gt; SS.ChordTolMm()) {
                mustKeep = true;
            }
        }

        if(mustKeep) {
            prev = sct-&gt;p;
        } else {
            sct-&gt;tag = 1;
            // and prev is unchanged, since there's no longer any point
            // in between
        }
    }

    pts.RemoveTagged();
}

STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool backwards) {
    STrimBy stb = {};
    stb.curve = hsc;
    SCurve *sc = shell-&gt;curve.FindById(hsc);

    if(backwards) {
        stb.finish = sc-&gt;pts.elem[0].p;
        stb.start = sc-&gt;pts.elem[sc-&gt;pts.n - 1].p;
        stb.backwards = true;
    } else {
        stb.start = sc-&gt;pts.elem[0].p;
        stb.finish = sc-&gt;pts.elem[sc-&gt;pts.n - 1].p;
        stb.backwards = false;
    }

    return stb;
}

</t>
<t tx="leo1.20171224221236.129">//-----------------------------------------------------------------------------
// Routines to merge multiple coincident surfaces (each with their own trim
// curves) into a single surface, with all of the trim curves.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221236.13">void OpenGl2Renderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    DoStippledLine(a, b, hcs);
}

</t>
<t tx="leo1.20171224221236.130">void SShell::MergeCoincidentSurfaces() {
    surface.ClearTags();

    int i, j;
    SSurface *si, *sj;

    for(i = 0; i &lt; surface.n; i++) {
        si = &amp;(surface.elem[i]);
        if(si-&gt;tag) continue;
        // Let someone else clean up the empty surfaces; we can certainly merge
        // them, but we don't know how to calculate a reasonable bounding box.
        if(si-&gt;trim.n == 0) continue;
        // And for now we handle only coincident planes, so no sense wasting
        // time on other surfaces.
        if(si-&gt;degm != 1 || si-&gt;degn != 1) continue;

        SEdgeList sel = {};
        si-&gt;MakeEdgesInto(this, &amp;sel, SSurface::MakeAs::XYZ);

        bool mergedThisTime, merged = false;
        do {
            mergedThisTime = false;

            for(j = i + 1; j &lt; surface.n; j++) {
                sj = &amp;(surface.elem[j]);
                if(sj-&gt;tag) continue;
                if(!sj-&gt;CoincidentWith(si, /*sameNormal=*/true)) continue;
                if(!sj-&gt;color.Equals(si-&gt;color)) continue;
                // But we do merge surfaces with different face entities, since
                // otherwise we'd hardly ever merge anything.

                // This surface is coincident. But let's not merge coincident
                // surfaces if they contain disjoint contours; that just makes
                // the bounding box tests less effective, and possibly things
                // less robust.
                SEdgeList tel = {};
                sj-&gt;MakeEdgesInto(this, &amp;tel, SSurface::MakeAs::XYZ);
                if(!sel.ContainsEdgeFrom(&amp;tel)) {
                    tel.Clear();
                    continue;
                }
                tel.Clear();

                sj-&gt;tag = 1;
                merged = true;
                mergedThisTime = true;
                sj-&gt;MakeEdgesInto(this, &amp;sel, SSurface::MakeAs::XYZ);
                sj-&gt;trim.Clear();

                // All the references to this surface get replaced with the
                // new srf
                SCurve *sc;
                for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
                    if(sc-&gt;surfA.v == sj-&gt;h.v) sc-&gt;surfA = si-&gt;h;
                    if(sc-&gt;surfB.v == sj-&gt;h.v) sc-&gt;surfB = si-&gt;h;
                }
            }

            // If this iteration merged a contour onto ours, then we have to
            // go through the surfaces again; that might have made a new
            // surface touch us.
        } while(mergedThisTime);

        if(merged) {
            sel.CullExtraneousEdges();
            si-&gt;trim.Clear();
            si-&gt;TrimFromEdgeList(&amp;sel, /*asUv=*/false);

            // And we must choose control points such that all the trims lie
            // with u and v in [0, 1], so that the bbox tests work.
            Vector u, v, n;
            si-&gt;TangentsAt(0.5, 0.5, &amp;u, &amp;v);
            u = u.WithMagnitude(1);
            v = v.WithMagnitude(1);
            n = si-&gt;NormalAt(0.5, 0.5).WithMagnitude(1);
            v = (n.Cross(u)).WithMagnitude(1);

            @others
}

</t>
<t tx="leo1.20171224221236.131">        double umax = VERY_NEGATIVE, umin = VERY_POSITIVE,
               vmax = VERY_NEGATIVE, vmin = VERY_POSITIVE;
        SEdge *se;
        for(se = sel.l.First(); se; se = sel.l.NextAfter(se)) {
            double ut = (se-&gt;a).Dot(u), vt = (se-&gt;a).Dot(v);
            umax = max(umax, ut);
            vmax = max(vmax, vt);
            umin = min(umin, ut);
            vmin = min(vmin, vt);
        }

        // An interesting problem here; the real curve could extend
        // slightly beyond the bounding box of the piecewise linear
        // bits. Not a problem for us, but some apps won't import STEP
        // in that case. So give a bit of extra room; in theory just
        // a chord tolerance, but more can't hurt.
        double muv = max((umax - umin), (vmax - vmin));
        double tol = muv/50 + 3*SS.ChordTolMm();
        umax += tol;
        vmax += tol;
        umin -= tol;
        vmin -= tol;

        // We move in the +v direction as v goes from 0 to 1, and in the
        // +u direction as u goes from 0 to 1. So our normal ends up
        // pointed the same direction.
        double nt = (si-&gt;ctrl[0][0]).Dot(n);
        si-&gt;ctrl[0][0] =
            Vector::From(umin, vmin, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[0][1] =
            Vector::From(umin, vmax, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[1][1] =
            Vector::From(umax, vmax, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[1][0] =
            Vector::From(umax, vmin, nt).ScaleOutOfCsys(u, v, n);
    }
    sel.Clear();
}

surface.RemoveTagged();
</t>
<t tx="leo1.20171224221236.132">//-----------------------------------------------------------------------------
// Math on rational polynomial surfaces and curves, typically in Bezier
// form. Evaluate, root-find (by Newton's methods), evaluate derivatives,
// and so on.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

// Converge it to better than LENGTH_EPS; we want two points, each
// independently projected into uv and back, to end up equal with the
// LENGTH_EPS. Best case that requires LENGTH_EPS/2, but more is better
// and convergence should be fast by now.
#define RATPOLY_EPS (LENGTH_EPS/(1e2))

double SolveSpace::Bernstein(int k, int deg, double t)
{
    if(k &gt; deg || k &lt; 0) return 0;

    switch(deg) {
        case 0:
            return 1;

        case 1:
            if(k == 0) {
                return (1 - t);
            } else if(k == 1) {
                return t;
            }
            break;

        case 2:
            if(k == 0) {
                return (1 - t)*(1 - t);
            } else if(k == 1) {
                return 2*(1 - t)*t;
            } else if(k == 2) {
                return t*t;
            }
            break;

        case 3:
            if(k == 0) {
                return (1 - t)*(1 - t)*(1 - t);
            } else if(k == 1) {
                return 3*(1 - t)*(1 - t)*t;
            } else if(k == 2) {
                return 3*(1 - t)*t*t;
            } else if(k == 3) {
                return t*t*t;
            }
            break;
    }
    ssassert(false, "Unexpected degree of spline");
}

double SolveSpace::BernsteinDerivative(int k, int deg, double t)
{
    switch(deg) {
        case 0:
            return 0;

        case 1:
            if(k == 0) {
                return -1;
            } else if(k == 1) {
                return 1;
            }
            break;

        case 2:
            if(k == 0) {
                return -2 + 2*t;
            } else if(k == 1) {
                return 2 - 4*t;
            } else if(k == 2) {
                return 2*t;
            }
            break;

        case 3:
            if(k == 0) {
                return -3 + 6*t - 3*t*t;
            } else if(k == 1) {
                return 3 - 12*t + 9*t*t;
            } else if(k == 2) {
                return 6*t - 9*t*t;
            } else if(k == 3) {
                return 3*t*t;
            }
            break;
    }
    ssassert(false, "Unexpected degree of spline");
}

Vector SBezier::PointAt(double t) const {
    Vector pt = Vector::From(0, 0, 0);
    double d = 0;

    int i;
    for(i = 0; i &lt;= deg; i++) {
        double B = Bernstein(i, deg, t);
        pt = pt.Plus(ctrl[i].ScaledBy(B*weight[i]));
        d += weight[i]*B;
    }
    pt = pt.ScaledBy(1.0/d);
    return pt;
}

Vector SBezier::TangentAt(double t) const {
    Vector pt = Vector::From(0, 0, 0), pt_p = Vector::From(0, 0, 0);
    double d = 0, d_p = 0;

    int i;
    for(i = 0; i &lt;= deg; i++) {
        double B  = Bernstein(i, deg, t),
    Vector ret;
    ret = (pt_p.ScaledBy(d)).Minus(pt.ScaledBy(d_p));
    ret = ret.ScaledBy(1.0/(d*d));
    return ret;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221236.133">void SBezier::ClosestPointTo(Vector p, double *t, bool mustConverge) const {
    int i;
    double minDist = VERY_POSITIVE;
    *t = 0;
    double res = (deg &lt;= 2) ? 7.0 : 20.0;
    for(i = 0; i &lt; (int)res; i++) {
        double tryt = (i/res);

        Vector tryp = PointAt(tryt);
        double d = (tryp.Minus(p)).Magnitude();
        if(d &lt; minDist) {
            *t = tryt;
            minDist = d;
        }
    }

    Vector p0;
    for(i = 0; i &lt; (mustConverge ? 15 : 5); i++) {
        p0 = PointAt(*t);
        if(p0.Equals(p, RATPOLY_EPS)) {
            return;
        }

        Vector dp = TangentAt(*t);
        Vector pc = p.ClosestPointOnLine(p0, dp);
        *t += (pc.Minus(p0)).DivPivoting(dp);
    }
    if(mustConverge) {
        dbp("didn't converge (closest point on bezier curve)");
    }
}

</t>
<t tx="leo1.20171224221236.134">bool SBezier::PointOnThisAndCurve(const SBezier *sbb, Vector *p) const {
    double ta, tb;
    this-&gt;ClosestPointTo(*p, &amp;ta, /*mustConverge=*/false);
    sbb -&gt;ClosestPointTo(*p, &amp;tb, /*mustConverge=*/false);

    int i;
    for(i = 0; i &lt; 20; i++) {
        Vector pa = this-&gt;PointAt(ta),
               pb = sbb -&gt;PointAt(tb),
               da = this-&gt;TangentAt(ta),
               db = sbb -&gt;TangentAt(tb);

        if(pa.Equals(pb, RATPOLY_EPS)) {
            *p = pa;
            return true;
        }

        double tta, ttb;
        Vector::ClosestPointBetweenLines(pa, da, pb, db, &amp;tta, &amp;ttb);
        ta += tta;
        tb += ttb;
    }
    return false;
}

</t>
<t tx="leo1.20171224221236.135">void SBezier::SplitAt(double t, SBezier *bef, SBezier *aft) const {
    Vector4 ct[4];
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ct[i] = Vector4::From(weight[i], ctrl[i]);
    }

    switch(deg) {
        case 1: {
            Vector4 cts = Vector4::Blend(ct[0], ct[1], t);
            *bef = SBezier::From(ct[0], cts);
            *aft = SBezier::From(cts, ct[1]);
            break;
        }
        case 2: {
            Vector4 ct01 = Vector4::Blend(ct[0], ct[1], t),
                    ct12 = Vector4::Blend(ct[1], ct[2], t),
                    cts  = Vector4::Blend(ct01,  ct12,  t);

            *bef = SBezier::From(ct[0], ct01, cts);
            *aft = SBezier::From(cts, ct12, ct[2]);
            break;
        }
        case 3: {
            Vector4 ct01    = Vector4::Blend(ct[0], ct[1], t),
                    ct12    = Vector4::Blend(ct[1], ct[2], t),
                    ct23    = Vector4::Blend(ct[2], ct[3], t),
                    ct01_12 = Vector4::Blend(ct01,  ct12,  t),
                    ct12_23 = Vector4::Blend(ct12,  ct23,  t),
                    cts     = Vector4::Blend(ct01_12, ct12_23, t);

            *bef = SBezier::From(ct[0], ct01, ct01_12, cts);
            *aft = SBezier::From(cts, ct12_23, ct23, ct[3]);
            break;
        }
        default: ssassert(false, "Unexpected degree of spline");
    }
}

</t>
<t tx="leo1.20171224221236.136">void SBezier::MakePwlInto(SEdgeList *sel, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 1; i &lt; lv.n; i++) {
        sel-&gt;AddEdge(lv.elem[i-1], lv.elem[i]);
    }
    lv.Clear();
}
</t>
<t tx="leo1.20171224221236.137">void SBezier::MakePwlInto(List&lt;SCurvePt&gt; *l, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 0; i &lt; lv.n; i++) {
        SCurvePt scpt;
        scpt.tag    = 0;
        scpt.p      = lv.elem[i];
        scpt.vertex = (i == 0) || (i == (lv.n - 1));
        l-&gt;Add(&amp;scpt);
    }
    lv.Clear();
}
</t>
<t tx="leo1.20171224221236.138">void SBezier::MakePwlInto(SContour *sc, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 0; i &lt; lv.n; i++) {
        sc-&gt;AddPoint(lv.elem[i]);
    }
    lv.Clear();
}
</t>
<t tx="leo1.20171224221236.139">void SBezier::MakePwlInto(List&lt;Vector&gt; *l, double chordTol) const {
    if(EXACT(chordTol == 0)) {
        // Use the default chord tolerance.
        chordTol = SS.ChordTolMm();
    }
    l-&gt;Add(&amp;(ctrl[0]));
    if(deg == 1) {
        l-&gt;Add(&amp;(ctrl[1]));
    } else {
        // Never do fewer than one intermediate point; people seem to get
        // unhappy when their circles turn into squares, but maybe less
        // unhappy with octagons.
        MakePwlInitialWorker(l, 0.0, 0.5, chordTol);
        MakePwlInitialWorker(l, 0.5, 1.0, chordTol);
    }
}
</t>
<t tx="leo1.20171224221236.14">void OpenGl2Renderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    for(const SEdge &amp;e : el.l) {
        DoStippledLine(e.a, e.b, hcs);
    }
}

</t>
<t tx="leo1.20171224221236.140">void SBezier::MakePwlWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const
{
    Vector pa = PointAt(ta);
    Vector pb = PointAt(tb);

    Vector pm = PointAt((ta + tb) / 2.0);
    double d = pm.DistanceToLine(pa, pb.Minus(pa));

    double step = 1.0/SS.GetMaxSegments();
    if((tb - ta) &lt; step || d &lt; chordTol) {
        // A previous call has already added the beginning of our interval.
        l-&gt;Add(&amp;pb);
    } else {
        double tm = (ta + tb) / 2;
        MakePwlWorker(l, ta, tm, chordTol);
        MakePwlWorker(l, tm, tb, chordTol);
    }
}
</t>
<t tx="leo1.20171224221236.141">void SBezier::MakePwlInitialWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const
{
    Vector pa = PointAt(ta);
    Vector pb = PointAt(tb);

    double tm1 = ta + (tb - ta) * 0.25;
    double tm2 = ta + (tb - ta) * 0.5;
    double tm3 = ta + (tb - ta) * 0.75;

    Vector pm1 = PointAt(tm1);
    Vector pm2 = PointAt(tm2);
    Vector pm3 = PointAt(tm3);
    Vector dir = pb.Minus(pa);

    @others
}

</t>
<t tx="leo1.20171224221236.142">double d = max({
               pm1.DistanceToLine(pa, dir),
               pm2.DistanceToLine(pa, dir),
               pm3.DistanceToLine(pa, dir)
            });

double step = 1.0/SS.GetMaxSegments();
if((tb - ta) &lt; step || d &lt; chordTol) {
    // A previous call has already added the beginning of our interval.
    l-&gt;Add(&amp;pb);
} else {
    double tm = (ta + tb) / 2;
    MakePwlWorker(l, ta, tm, chordTol);
    MakePwlWorker(l, tm, tb, chordTol);
}
</t>
<t tx="leo1.20171224221236.143">void SBezier::MakeNonrationalCubicInto(SBezierList *bl, double tolerance, int depth) const {
    Vector t0 = TangentAt(0), t1 = TangentAt(1);
    // The curve is correct, and the first derivatives are correct, at the
    // endpoints.
    SBezier bnr = SBezier::From(
                        Start(),
                        Start().Plus(t0.ScaledBy(1.0/3)),
                        Finish().Minus(t1.ScaledBy(1.0/3)),
                        Finish());

    bool closeEnough = true;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        double t = i/4.0;
        Vector p0 = PointAt(t),
               pn = bnr.PointAt(t);
        double d = (p0.Minus(pn)).Magnitude();
        if(d &gt; tolerance) {
            closeEnough = false;
        }
    }

    if(closeEnough || depth &gt; 3) {
        bl-&gt;l.Add(this);
    } else {
        SBezier bef, aft;
        SplitAt(0.5, &amp;bef, &amp;aft);
        bef.MakeNonrationalCubicInto(bl, tolerance, depth+1);
        aft.MakeNonrationalCubicInto(bl, tolerance, depth+1);
    }
}

Vector SSurface::PointAt(Point2d puv) const {
    return PointAt(puv.x, puv.y);
}
Vector SSurface::PointAt(double u, double v) const {
    Vector num = Vector::From(0, 0, 0);
    double den = 0;

    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            double Bi = Bernstein(i, degm, u),
</t>
<t tx="leo1.20171224221236.144">void SSurface::TangentsAt(double u, double v, Vector *tu, Vector *tv) const {
    Vector num   = Vector::From(0, 0, 0),
           num_u = Vector::From(0, 0, 0),
           num_v = Vector::From(0, 0, 0);
    @others
}

Vector SSurface::NormalAt(Point2d puv) const {
    return NormalAt(puv.x, puv.y);
}

Vector SSurface::NormalAt(double u, double v) const {
    Vector tu, tv;
    TangentsAt(u, v, &amp;tu, &amp;tv);
    return tu.Cross(tv);
}

</t>
<t tx="leo1.20171224221236.145">double den   = 0,
       den_u = 0,
       den_v = 0;

int i, j;
for(i = 0; i &lt;= degm; i++) {
    for(j = 0; j &lt;= degn; j++) {
        double Bi  = Bernstein(i, degm, u),
        num_v = num_v.Plus(ctrl[i][j].ScaledBy(Bi*Bjp*weight[i][j]));
        den_v += weight[i][j]*Bi*Bjp;
    }
}
// quotient rule; f(t) = n(t)/d(t), so f' = (n'*d - n*d')/(d^2)
*tu = ((num_u.ScaledBy(den)).Minus(num.ScaledBy(den_u)));
*tu = tu-&gt;ScaledBy(1.0/(den*den));

*tv = ((num_v.ScaledBy(den)).Minus(num.ScaledBy(den_v)));
*tv = tv-&gt;ScaledBy(1.0/(den*den));
</t>
<t tx="leo1.20171224221236.146">void SSurface::ClosestPointTo(Vector p, Point2d *puv, bool mustConverge) {
    ClosestPointTo(p, &amp;(puv-&gt;x), &amp;(puv-&gt;y), mustConverge);
}

</t>
<t tx="leo1.20171224221236.147">void SSurface::ClosestPointTo(Vector p, double *u, double *v, bool mustConverge) {
    // A few special cases first; when control points are coincident the
    // derivative goes to zero at the conrol points, and would result in
    // nonconvergence. We avoid that here, and also guarantee a consistent
    // (u, v) (of the infinitely many possible in one parameter).
    if(p.Equals(ctrl[0]   [0]   )) { *u = 0; *v = 0; return; }
    if(p.Equals(ctrl[degm][0]   )) { *u = 1; *v = 0; return; }
    if(p.Equals(ctrl[degm][degn])) { *u = 1; *v = 1; return; }
    if(p.Equals(ctrl[0]   [degn])) { *u = 0; *v = 1; return; }

    // And planes are trivial, so don't waste time iterating over those.
    if(degm == 1 &amp;&amp; degn == 1) {
        Vector orig =  ctrl[0][0],
               bu   = (ctrl[1][0]).Minus(orig),
               bv   = (ctrl[0][1]).Minus(orig);
        if((ctrl[1][1]).Equals(orig.Plus(bu).Plus(bv))) {
            Vector dp = p.Minus(orig);
            *u = dp.Dot(bu) / bu.MagSquared();
            *v = dp.Dot(bv) / bv.MagSquared();
            return;
        }
    }

    // Try whatever the previous guess was. This is likely to do something
    // good if we're working our way along a curve or something else where
    // we project successive points that are close to each other; something
    // like a 20% speedup empirically.
    if(mustConverge) {
        double ut = cached.x, vt = cached.y;
        if(ClosestPointNewton(p, &amp;ut, &amp;vt, mustConverge)) {
            cached.x = *u = ut;
            cached.y = *v = vt;
            return;
        }
    }

    // Search for a reasonable initial guess
    int i, j;
    double minDist = VERY_POSITIVE;
    int res = (max(degm, degn) == 2) ? 7 : 20;
    for(i = 0; i &lt; res; i++) {
        for(j = 0; j &lt; res; j++) {
            double tryu = (i + 0.5)/res, tryv = (j + 0.5)/res;

            Vector tryp = PointAt(tryu, tryv);
            double d = (tryp.Minus(p)).Magnitude();
            if(d &lt; minDist) {
                *u = tryu;
                *v = tryv;
                minDist = d;
            }
        }
    }

    if(ClosestPointNewton(p, u, v, mustConverge)) {
        cached.x = *u;
        cached.y = *v;
        return;
    }

    // If we failed to converge, then at least don't return NaN.
    if(isnan(*u) || isnan(*v)) {
        *u = *v = 0;
    }
}

</t>
<t tx="leo1.20171224221236.148">bool SSurface::ClosestPointNewton(Vector p, double *u, double *v, bool mustConverge) const
{
    // Initial guess is in u, v; refine by Newton iteration.
    Vector p0 = Vector::From(0, 0, 0);
    for(int i = 0; i &lt; (mustConverge ? 25 : 5); i++) {
        p0 = PointAt(*u, *v);
        if(mustConverge) {
            if(p0.Equals(p, RATPOLY_EPS)) {
                return true;
            }
        }

        Vector tu, tv;
        TangentsAt(*u, *v, &amp;tu, &amp;tv);

        // Project the point into a plane through p0, with basis tu, tv; a
        // second-order thing would converge faster but needs second
        // derivatives.
        Vector dp = p.Minus(p0);
        double du = dp.Dot(tu), dv = dp.Dot(tv);
        *u += du / (tu.MagSquared());
        *v += dv / (tv.MagSquared());
    }

    if(mustConverge) {
        dbp("didn't converge");
        dbp("have %.3f %.3f %.3f", CO(p0));
        dbp("want %.3f %.3f %.3f", CO(p));
        dbp("distance = %g", (p.Minus(p0)).Magnitude());
    }
    return false;
}

</t>
<t tx="leo1.20171224221236.149">bool SSurface::PointIntersectingLine(Vector p0, Vector p1, double *u, double *v) const
{
    int i;
    for(i = 0; i &lt; 15; i++) {
        Vector pi, p, tu, tv;
        p = PointAt(*u, *v);
        TangentsAt(*u, *v, &amp;tu, &amp;tv);

        Vector n = (tu.Cross(tv)).WithMagnitude(1);
        double d = p.Dot(n);

        bool parallel;
        pi = Vector::AtIntersectionOfPlaneAndLine(n, d, p0, p1, &amp;parallel);
        if(parallel) break;

        // Check for convergence
        if(pi.Equals(p, RATPOLY_EPS)) return true;

        // Adjust our guess and iterate
        Vector dp = pi.Minus(p);
        double du = dp.Dot(tu), dv = dp.Dot(tv);
        *u += du / (tu.MagSquared());
        *v += dv / (tv.MagSquared());
    }
//    dbp("didn't converge (surface intersecting line)");
    return false;
}

Vector SSurface::ClosestPointOnThisAndSurface(SSurface *srf2, Vector p) {
    // This is untested.
    int i, j;
    Point2d puv[2];
    SSurface *srf[2] = { this, srf2 };

    for(j = 0; j &lt; 2; j++) {
        (srf[j])-&gt;ClosestPointTo(p, &amp;(puv[j]), /*mustConverge=*/false);
    }

    for(i = 0; i &lt; 10; i++) {
        Vector tu[2], tv[2], cp[2], n[2];
        double d[2];

        for(j = 0; j &lt; 2; j++) {
            (srf[j])-&gt;TangentsAt(puv[j].x, puv[j].y, &amp;(tu[j]), &amp;(tv[j]));

            cp[j] = (srf[j])-&gt;PointAt(puv[j]);

            n[j] = ((tu[j]).Cross(tv[j])).WithMagnitude(1);
            d[j] = (n[j]).Dot(cp[j]);
        }

        if((cp[0]).Equals(cp[1], RATPOLY_EPS)) break;

        Vector p0 = Vector::AtIntersectionOfPlanes(n[0], d[0], n[1], d[1]),
               dp = (n[0]).Cross(n[1]);

        Vector pc = p.ClosestPointOnLine(p0, dp);

        // Adjust our guess and iterate
        for(j = 0; j &lt; 2; j++) {
            Vector dc = pc.Minus(cp[j]);
            double du = dc.Dot(tu[j]), dv = dc.Dot(tv[j]);
            puv[j].x += du / ((tu[j]).MagSquared());
            puv[j].y += dv / ((tv[j]).MagSquared());
        }
    }
    if(i &gt;= 10) {
        dbp("this and srf, didn't converge, d=%g",
            (puv[0].Minus(puv[1])).Magnitude());
    }

    // If this converged, then the two points are actually equal.
    return ((srf[0])-&gt;PointAt(puv[0])).Plus(
           ((srf[1])-&gt;PointAt(puv[1]))).ScaledBy(0.5);
}

</t>
<t tx="leo1.20171224221236.15">void OpenGl2Renderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs mode) {
    if(ol.l.n == 0) return;

    Stroke *stroke = SelectStroke(hcs);
    ssassert(stroke-&gt;stipplePattern != StipplePattern::ZIGZAG &amp;&amp;
             stroke-&gt;stipplePattern != StipplePattern::FREEHAND,
             "ZIGZAG and FREEHAND not supported for outlines");

    outlineRenderer.SetStroke(*stroke, 1.0 / camera.scale);
    outlineRenderer.Draw(ol, mode);
}

</t>
<t tx="leo1.20171224221236.150">void SSurface::PointOnSurfaces(SSurface *s1, SSurface *s2, double *up, double *vp)
{
    double u[3] = { *up, 0, 0 }, v[3] = { *vp, 0, 0 };
    SSurface *srf[3] = { this, s1, s2 };

    // Get initial guesses for (u, v) in the other surfaces
    Vector p = PointAt(*u, *v);
    (srf[1])-&gt;ClosestPointTo(p, &amp;(u[1]), &amp;(v[1]), /*mustConverge=*/false);
    (srf[2])-&gt;ClosestPointTo(p, &amp;(u[2]), &amp;(v[2]), /*mustConverge=*/false);

    int i, j;
    for(i = 0; i &lt; 20; i++) {
        // Approximate each surface by a plane
        Vector p[3], tu[3], tv[3], n[3];
        double d[3];
        for(j = 0; j &lt; 3; j++) {
            p[j] = (srf[j])-&gt;PointAt(u[j], v[j]);
            (srf[j])-&gt;TangentsAt(u[j], v[j], &amp;(tu[j]), &amp;(tv[j]));
            n[j] = ((tu[j]).Cross(tv[j])).WithMagnitude(1);
            d[j] = (n[j]).Dot(p[j]);
        }

        // If a = b and b = c, then does a = c? No, it doesn't.
        if((p[0]).Equals(p[1], RATPOLY_EPS) &amp;&amp;
           (p[1]).Equals(p[2], RATPOLY_EPS) &amp;&amp;
           (p[2]).Equals(p[0], RATPOLY_EPS))
        {
            *up = u[0];
            *vp = v[0];
            return;
        }

        bool parallel;
        Vector pi = Vector::AtIntersectionOfPlanes(n[0], d[0],
                                                   n[1], d[1],
                                                   n[2], d[2], &amp;parallel);
        if(parallel) break;

        for(j = 0; j &lt; 3; j++) {
            Vector dp = pi.Minus(p[j]);
            double du = dp.Dot(tu[j]), dv = dp.Dot(tv[j]);
            u[j] += du / (tu[j]).MagSquared();
            v[j] += dv / (tv[j]).MagSquared();
        }
    }
    dbp("didn't converge (three surfaces intersecting)");
}

</t>
<t tx="leo1.20171224221236.151">//-----------------------------------------------------------------------------
// Routines for ray-casting: intersecting a line segment or an infinite line
// with a surface or shell. Ray-casting against a shell is used for point-in-
// shell testing, and the intersection of edge line segments against surfaces
// is used to get rough surface-curve intersections, which are later refined
// numerically.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// Dot product tolerance for perpendicular; this is on the direction cosine,
// so it's about 0.001 degrees.
const double SShell::DOTP_TOL = 1e-5;

extern int FLAG;


double SSurface::DepartureFromCoplanar() const {
    int i, j;
    int ia, ja, ib = 0, jb = 0, ic = 0, jc = 0;
    double best;

    // Grab three points to define a plane; first choose (0, 0) arbitrarily.
    ia = ja = 0;
    // Then the point farthest from pt a.
    best = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            if(i == ia &amp;&amp; j == ja) continue;

            double dist = (ctrl[i][j]).Minus(ctrl[ia][ja]).Magnitude();
            if(dist &gt; best) {
                best = dist;
                ib = i;
                jb = j;
            }
        }
    }
    // Then biggest magnitude of ab cross ac.
    best = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            if(i == ia &amp;&amp; j == ja) continue;
            if(i == ib &amp;&amp; j == jb) continue;

            @others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221236.152">            double mag =
                ((ctrl[ia][ja].Minus(ctrl[ib][jb]))).Cross(
                 (ctrl[ia][ja].Minus(ctrl[i ][j ]))).Magnitude();
            if(mag &gt; best) {
                best = mag;
                ic = i;
                jc = j;
            }
        }
    }

    Vector n = ((ctrl[ia][ja].Minus(ctrl[ib][jb]))).Cross(
                (ctrl[ia][ja].Minus(ctrl[ic][jc])));
    n = n.WithMagnitude(1);
    double d = (ctrl[ia][ja]).Dot(n);

    // Finally, calculate the deviation from each point to the plane.
    double farthest = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            double dist = fabs(n.Dot(ctrl[i][j]) - d);
            if(dist &gt; farthest) {
                farthest = dist;
            }
        }
    }
    return farthest;
}

</t>
<t tx="leo1.20171224221236.153">void SSurface::WeightControlPoints() {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = (ctrl[i][j]).ScaledBy(weight[i][j]);
        }
    }
}
</t>
<t tx="leo1.20171224221236.154">void SSurface::UnWeightControlPoints() {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = (ctrl[i][j]).ScaledBy(1.0/weight[i][j]);
        }
    }
}
</t>
<t tx="leo1.20171224221236.155">void SSurface::CopyRowOrCol(bool row, int this_ij, SSurface *src, int src_ij) {
    if(row) {
        int j;
        for(j = 0; j &lt;= degn; j++) {
            ctrl  [this_ij][j] = src-&gt;ctrl  [src_ij][j];
            weight[this_ij][j] = src-&gt;weight[src_ij][j];
        }
    } else {
        int i;
        for(i = 0; i &lt;= degm; i++) {
            ctrl  [i][this_ij] = src-&gt;ctrl  [i][src_ij];
            weight[i][this_ij] = src-&gt;weight[i][src_ij];
        }
    }
}
</t>
<t tx="leo1.20171224221236.156">void SSurface::BlendRowOrCol(bool row, int this_ij, SSurface *a, int a_ij,
                                                    SSurface *b, int b_ij)
{
    if(row) {
        int j;
        for(j = 0; j &lt;= degn; j++) {
            Vector c = (a-&gt;ctrl  [a_ij][j]).Plus(b-&gt;ctrl  [b_ij][j]);
            double w = (a-&gt;weight[a_ij][j]   +   b-&gt;weight[b_ij][j]);
            ctrl  [this_ij][j] = c.ScaledBy(0.5);
            weight[this_ij][j] = w / 2;
        }
    } else {
        int i;
        for(i = 0; i &lt;= degm; i++) {
            Vector c = (a-&gt;ctrl  [i][a_ij]).Plus(b-&gt;ctrl  [i][b_ij]);
            double w = (a-&gt;weight[i][a_ij]   +   b-&gt;weight[i][b_ij]);
            ctrl  [i][this_ij] = c.ScaledBy(0.5);
            weight[i][this_ij] = w / 2;
        }
    }
}
</t>
<t tx="leo1.20171224221236.157">void SSurface::SplitInHalf(bool byU, SSurface *sa, SSurface *sb) {
    sa-&gt;degm = sb-&gt;degm = degm;
    sa-&gt;degn = sb-&gt;degn = degn;

    // by de Casteljau's algorithm in a projective space; so we must work
    // on points (w*x, w*y, w*z, w)
    WeightControlPoints();

    switch(byU ? degm : degn) {
        case 1:
            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 1, this, 1);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 0, this, 0, this, 1);
            break;

        case 2:
            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 2, this, 2);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 1, this, 1, this, 2);

            sa-&gt;BlendRowOrCol(byU, 2, sa,   1, sb,   1);
            sb-&gt;BlendRowOrCol(byU, 0, sa,   1, sb,   1);
            break;

        case 3: {
            SSurface st;
            st.degm = degm; st.degn = degn;

            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 3, this, 3);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 2, this, 2, this, 3);
            st. BlendRowOrCol(byU, 0, this, 1, this, 2); // scratch var

            sa-&gt;BlendRowOrCol(byU, 2, sa,   1, &amp;st,  0);
            sb-&gt;BlendRowOrCol(byU, 1, sb,   2, &amp;st,  0);

            sa-&gt;BlendRowOrCol(byU, 3, sa,   2, sb,   1);
            sb-&gt;BlendRowOrCol(byU, 0, sa,   2, sb,   1);
            break;
        }

        default: ssassert(false, "Unexpected degree of spline");
    }

    sa-&gt;UnWeightControlPoints();
    sb-&gt;UnWeightControlPoints();
    UnWeightControlPoints();
}

//-----------------------------------------------------------------------------
// Find all points where the indicated finite (if segment) or infinite (if not
// segment) line intersects our surface. Report them in uv space in the list.
// We first do a bounding box check; if the line doesn't intersect, then we're
// done. If it does, then we check how small our surface is. If it's big,
// then we subdivide into quarters and recurse. If it's small, then we refine
// by Newton's method and record the point.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.158">void SSurface::AllPointsIntersectingUntrimmed(Vector a, Vector b,
                                              int *cnt, int *level,
                                              List&lt;Inter&gt; *l, bool asSegment,
                                              SSurface *sorig)
{
    // Test if the line intersects our axis-aligned bounding box; if no, then
    // no possibility of an intersection
    if(LineEntirelyOutsideBbox(a, b, asSegment)) return;

    if(*cnt &gt; 2000) {
        dbp("!!! too many subdivisions (level=%d)!", *level);
        dbp("degm = %d degn = %d", degm, degn);
        return;
    }
    (*cnt)++;

    // If we might intersect, and the surface is small, then switch to Newton
    // iterations.
    if(DepartureFromCoplanar() &lt; 0.2*SS.ChordTolMm()) {
        Vector p = (ctrl[0   ][0   ]).Plus(
                    ctrl[0   ][degn]).Plus(
                    ctrl[degm][0   ]).Plus(
                    ctrl[degm][degn]).ScaledBy(0.25);
        Inter inter;
        sorig-&gt;ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y), /*mustConverge=*/false);
        if(sorig-&gt;PointIntersectingLine(a, b, &amp;(inter.p.x), &amp;(inter.p.y))) {
            Vector p = sorig-&gt;PointAt(inter.p.x, inter.p.y);
            // Debug check, verify that the point lies in both surfaces
            // (which it ought to, since the surfaces should be coincident)
            double u, v;
            ClosestPointTo(p, &amp;u, &amp;v);
            l-&gt;Add(&amp;inter);
        } else {
            // Might not converge if line is almost tangent to surface...
        }
        return;
    }

    // But the surface is big, so split it, alternating by u and v
    SSurface surf0, surf1;
    SplitInHalf((*level &amp; 1) == 0, &amp;surf0, &amp;surf1);

    int nextLevel = (*level) + 1;
    (*level) = nextLevel;
    surf0.AllPointsIntersectingUntrimmed(a, b, cnt, level, l, asSegment, sorig);
    (*level) = nextLevel;
    surf1.AllPointsIntersectingUntrimmed(a, b, cnt, level, l, asSegment, sorig);
}

//-----------------------------------------------------------------------------
// Find all points where a line through a and b intersects our surface, and
// add them to the list. If seg is true then report only intersections that
// lie within the finite line segment (not including the endpoints); otherwise
// we work along the infinite line. And we report either just intersections
// inside the trim curve, or any intersection with u, v in [0, 1]. And we
// either disregard or report tangent points.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.159">void SSurface::AllPointsIntersecting(Vector a, Vector b,
                                     List&lt;SInter&gt; *l,
                                     bool asSegment, bool trimmed, bool inclTangent)
{
    if(LineEntirelyOutsideBbox(a, b, asSegment)) return;

    Vector ba = b.Minus(a);
    double bam = ba.Magnitude();

    List&lt;Inter&gt; inters = {};

    // All the intersections between the line and the surface; either special
    // cases that we can quickly solve in closed form, or general numerical.
    Vector center, axis, start, finish;
    double radius;
    if(degm == 1 &amp;&amp; degn == 1) {
        // Against a plane, easy.
        Vector n = NormalAt(0, 0).WithMagnitude(1);
        double d = n.Dot(PointAt(0, 0));
        // Trim to line segment now if requested, don't generate points that
        // would just get discarded later.
        if(!asSegment ||
           (n.Dot(a) &gt; d + LENGTH_EPS &amp;&amp; n.Dot(b) &lt; d - LENGTH_EPS) ||
           (n.Dot(b) &gt; d + LENGTH_EPS &amp;&amp; n.Dot(a) &lt; d - LENGTH_EPS))
        {
            Vector p = Vector::AtIntersectionOfPlaneAndLine(n, d, a, b, NULL);
            Inter inter;
            ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y));
            inters.Add(&amp;inter);
        }
    } else if(IsCylinder(&amp;axis, &amp;center, &amp;radius, &amp;start, &amp;finish)) {
        // This one can be solved in closed form too.
        Vector ab = b.Minus(a);
        if(axis.Cross(ab).Magnitude() &lt; LENGTH_EPS) {
            // edge is parallel to axis of cylinder, no intersection points
            return;
        }
        // A coordinate system centered at the center of the circle, with
        // the edge under test horizontal
        Vector u, v, n = axis.WithMagnitude(1);
        u = (ab.Minus(n.ScaledBy(ab.Dot(n)))).WithMagnitude(1);
        v = n.Cross(u);
        Point2d ap = (a.Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                bp = (b.Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                sp = (start. Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                fp = (finish.Minus(center)).DotInToCsys(u, v, n).ProjectXy();

        double thetas = atan2(sp.y, sp.x), thetaf = atan2(fp.y, fp.x);

        Point2d ip[2];
        int ip_n = 0;
        if(fabs(fabs(ap.y) - radius) &lt; LENGTH_EPS) {
            // tangent
            if(inclTangent) {
                ip[0] = Point2d::From(0, ap.y);
                ip_n = 1;
            }
        } else if(fabs(ap.y) &lt; radius) {
            // two intersections
            double xint = sqrt(radius*radius - ap.y*ap.y);
            ip[0] = Point2d::From(-xint, ap.y);
            ip[1] = Point2d::From( xint, ap.y);
            ip_n = 2;
        }
        int i;
        for(i = 0; i &lt; ip_n; i++) {
            double t = (ip[i].Minus(ap)).DivPivoting(bp.Minus(ap));
            // This is a point on the circle; but is it on the arc?
            Point2d pp = ap.Plus((bp.Minus(ap)).ScaledBy(t));
            double theta = atan2(pp.y, pp.x);
            @others
}

</t>
<t tx="leo1.20171224221236.16">void OpenGl2Renderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    SEdgeListItem *eli = lines.FindByIdNoOops(hcs);
    if(eli == NULL) {
        SEdgeListItem item = {};
        item.h = hcs;
        lines.Add(&amp;item);
        eli = lines.FindByIdNoOops(hcs);
    }
    SEdgeList &amp;lines = eli-&gt;lines;
    auto traceEdge = [&amp;](Vector a, Vector b) { lines.AddEdge(a, b); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo1.20171224221236.160">        double dp = WRAP_SYMMETRIC(theta  - thetas, 2*PI),
               df = WRAP_SYMMETRIC(thetaf - thetas, 2*PI);
        double tol = LENGTH_EPS/radius;

        if((df &gt; 0 &amp;&amp; ((dp &lt; -tol) || (dp &gt; df + tol))) ||
           (df &lt; 0 &amp;&amp; ((dp &gt;  tol) || (dp &lt; df - tol))))
        {
            continue;
        }

        Vector p = a.Plus((b.Minus(a)).ScaledBy(t));

        Inter inter;
        ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y));
        inters.Add(&amp;inter);
    }
} else {
    // General numerical solution by subdivision, fallback
    int cnt = 0, level = 0;
    AllPointsIntersectingUntrimmed(a, b, &amp;cnt, &amp;level, &amp;inters, asSegment, this);
}

// Remove duplicate intersection points
inters.ClearTags();
int i, j;
for(i = 0; i &lt; inters.n; i++) {
    for(j = i + 1; j &lt; inters.n; j++) {
        if(inters.elem[i].p.Equals(inters.elem[j].p)) {
            inters.elem[j].tag = 1;
        }
    }
}
inters.RemoveTagged();

for(i = 0; i &lt; inters.n; i++) {
    Point2d puv = inters.elem[i].p;

    // Make sure the point lies within the finite line segment
    Vector pxyz = PointAt(puv.x, puv.y);
    double t = (pxyz.Minus(a)).DivPivoting(ba);
    if(asSegment &amp;&amp; (t &gt; 1 - LENGTH_EPS/bam || t &lt; LENGTH_EPS/bam)) {
        continue;
    }

    // And that it lies inside our trim region
    Point2d dummy = { 0, 0 };
    SBspUv::Class c = (bsp) ? bsp-&gt;ClassifyPoint(puv, dummy, this) : SBspUv::Class::OUTSIDE;
    if(trimmed &amp;&amp; c == SBspUv::Class::OUTSIDE) {
        continue;
    }

    // It does, so generate the intersection
    SInter si;
    si.p = pxyz;
    si.surfNormal = NormalAt(puv.x, puv.y);
    si.pinter = puv;
    si.srf = this;
    si.onEdge = (c != SBspUv::Class::INSIDE);
    l-&gt;Add(&amp;si);
}

inters.Clear();
</t>
<t tx="leo1.20171224221236.161">void SShell::AllPointsIntersecting(Vector a, Vector b,
                                   List&lt;SInter&gt; *il,
                                   bool asSegment, bool trimmed, bool inclTangent)
{
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;AllPointsIntersecting(a, b, il,
            asSegment, trimmed, inclTangent);
    }
}



SShell::Class SShell::ClassifyRegion(Vector edge_n, Vector inter_surf_n,
                           Vector edge_surf_n) const
{
    double dot = inter_surf_n.DirectionCosineWith(edge_n);
    if(fabs(dot) &lt; DOTP_TOL) {
        // The edge's surface and the edge-on-face surface
        // are coincident. Test the edge's surface normal
        // to see if it's with same or opposite normals.
        if(inter_surf_n.Dot(edge_surf_n) &gt; 0) {
            return Class::COINC_SAME;
        } else {
            return Class::COINC_OPP;
        }
    } else if(dot &gt; 0) {
        return Class::OUTSIDE;
    } else {
        return Class::INSIDE;
    }
}

//-----------------------------------------------------------------------------
// Does the given point lie on our shell? There are many cases; inside and
// outside are obvious, but then there's all the edge-on-edge and edge-on-face
// possibilities.
//
// To calculate, we intersect a ray through p with our shell, and classify
// using the closest intersection point. If the ray hits a surface on edge,
// then just reattempt in a different random direction.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.162">bool SShell::ClassifyEdge(Class *indir, Class *outdir,
                          Vector ea, Vector eb,
                          Vector p,
                          Vector edge_n_in, Vector edge_n_out, Vector surf_n)
{
    List&lt;SInter&gt; l = {};

    srand(0);

    // First, check for edge-on-edge
    int edge_inters = 0;
    Vector inter_surf_n[2], inter_edge_n[2];
    SSurface *srf;
    for(srf = surface.First(); srf; srf = surface.NextAfter(srf)) {
        if(srf-&gt;LineEntirelyOutsideBbox(ea, eb, /*asSegment=*/true)) continue;

        SEdgeList *sel = &amp;(srf-&gt;edges);
        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            if((ea.Equals(se-&gt;a) &amp;&amp; eb.Equals(se-&gt;b)) ||
               (eb.Equals(se-&gt;a) &amp;&amp; ea.Equals(se-&gt;b)) ||
                p.OnLineSegment(se-&gt;a, se-&gt;b))
            {
                if(edge_inters &lt; 2) {
                    // Edge-on-edge case
                    Point2d pm;
                    srf-&gt;ClosestPointTo(p,  &amp;pm, /*mustConverge=*/false);
                    // A vector normal to the surface, at the intersection point
                    inter_surf_n[edge_inters] = srf-&gt;NormalAt(pm);
                    // A vector normal to the intersecting edge (but within the
                    // intersecting surface) at the intersection point, pointing
                    // out.
                    @others
}

</t>
<t tx="leo1.20171224221236.163">                inter_edge_n[edge_inters] =
                  (inter_surf_n[edge_inters]).Cross((se-&gt;b).Minus((se-&gt;a)));
            }

            edge_inters++;
        }
    }
}

if(edge_inters == 2) {
    // TODO, make this use the appropriate curved normals
    double dotp[2];
    for(int i = 0; i &lt; 2; i++) {
        dotp[i] = edge_n_out.DirectionCosineWith(inter_surf_n[i]);
    }

    if(fabs(dotp[1]) &lt; DOTP_TOL) {
        swap(dotp[0],         dotp[1]);
        swap(inter_surf_n[0], inter_surf_n[1]);
        swap(inter_edge_n[0], inter_edge_n[1]);
    }

    Class coinc = (surf_n.Dot(inter_surf_n[0])) &gt; 0 ? Class::COINC_SAME : Class::COINC_OPP;

    if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; fabs(dotp[1]) &lt; DOTP_TOL) {
        // This is actually an edge on face case, just that the face
        // is split into two pieces joining at our edge.
        *indir  = coinc;
        *outdir = coinc;
    } else if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; dotp[1] &gt; DOTP_TOL) {
        if(edge_n_out.Dot(inter_edge_n[0]) &gt; 0) {
            *indir  = coinc;
            *outdir = Class::OUTSIDE;
        } else {
            *indir  = Class::INSIDE;
            *outdir = coinc;
        }
    } else if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; dotp[1] &lt; -DOTP_TOL) {
        if(edge_n_out.Dot(inter_edge_n[0]) &gt; 0) {
            *indir  = coinc;
            *outdir = Class::INSIDE;
        } else {
            *indir  = Class::OUTSIDE;
            *outdir = coinc;
        }
    } else if(dotp[0] &gt; DOTP_TOL &amp;&amp; dotp[1] &gt; DOTP_TOL) {
        *indir  = Class::INSIDE;
        *outdir = Class::OUTSIDE;
    } else if(dotp[0] &lt; -DOTP_TOL &amp;&amp; dotp[1] &lt; -DOTP_TOL) {
        *indir  = Class::OUTSIDE;
        *outdir = Class::INSIDE;
    } else {
        // Edge is tangent to the shell at shell's edge, so can't be
        // a boundary of the surface.
        return false;
    }
    return true;
}

if(edge_inters != 0) dbp("bad, edge_inters=%d", edge_inters);

// Next, check for edge-on-surface. The ray-casting for edge-inside-shell
// would catch this too, but test separately, for speed (since many edges
// are on surface) and for numerical stability, so we don't pick up
// the additional error from the line intersection.

for(srf = surface.First(); srf; srf = surface.NextAfter(srf)) {
    if(srf-&gt;LineEntirelyOutsideBbox(ea, eb, /*asSegment=*/true)) continue;

    Point2d puv;
    srf-&gt;ClosestPointTo(p, &amp;(puv.x), &amp;(puv.y), /*mustConverge=*/false);
    Vector pp = srf-&gt;PointAt(puv);

    if((pp.Minus(p)).Magnitude() &gt; LENGTH_EPS) continue;
    Point2d dummy = { 0, 0 };
    SBspUv::Class c = (srf-&gt;bsp) ? srf-&gt;bsp-&gt;ClassifyPoint(puv, dummy, srf) : SBspUv::Class::OUTSIDE;
    if(c == SBspUv::Class::OUTSIDE) continue;

    // Edge-on-face (unless edge-on-edge above superceded)
    Point2d pin, pout;
    srf-&gt;ClosestPointTo(p.Plus(edge_n_in),  &amp;pin,  /*mustConverge=*/false);
    srf-&gt;ClosestPointTo(p.Plus(edge_n_out), &amp;pout, /*mustConverge=*/false);

    Vector surf_n_in  = srf-&gt;NormalAt(pin),
           surf_n_out = srf-&gt;NormalAt(pout);

    *indir  = ClassifyRegion(edge_n_in,  surf_n_in,  surf_n);
    *outdir = ClassifyRegion(edge_n_out, surf_n_out, surf_n);
    return true;
}

// Edge is not on face or on edge; so it's either inside or outside
// the shell, and we'll determine which by raycasting.
int cnt = 0;
for(;;) {
    // Cast a ray in a random direction (two-sided so that we test if
    // the point lies on a surface, but use only one side for in/out
    // testing)
    Vector ray = Vector::From(Random(1), Random(1), Random(1));

    AllPointsIntersecting(
        p.Minus(ray), p.Plus(ray), &amp;l,
            /*asSegment=*/false, /*trimmed=*/true, /*inclTangent=*/false);

    // no intersections means it's outside
    *indir  = Class::OUTSIDE;
    *outdir = Class::OUTSIDE;
    double dmin = VERY_POSITIVE;
    bool onEdge = false;
    edge_inters = 0;

    SInter *si;
    for(si = l.First(); si; si = l.NextAfter(si)) {
        double t = ((si-&gt;p).Minus(p)).DivPivoting(ray);
        if(t*ray.Magnitude() &lt; -LENGTH_EPS) {
            // wrong side, doesn't count
            continue;
        }

        double d = ((si-&gt;p).Minus(p)).Magnitude();

        // We actually should never hit this case; it should have been
        // handled above.
        if(d &lt; LENGTH_EPS &amp;&amp; si-&gt;onEdge) {
            edge_inters++;
        }

        if(d &lt; dmin) {
            dmin = d;
            // Edge does not lie on surface; either strictly inside
            // or strictly outside
            if((si-&gt;surfNormal).Dot(ray) &gt; 0) {
                *indir  = Class::INSIDE;
                *outdir = Class::INSIDE;
            } else {
                *indir  = Class::OUTSIDE;
                *outdir = Class::OUTSIDE;
            }
            onEdge = si-&gt;onEdge;
        }
    }
    l.Clear();

    // If the point being tested lies exactly on an edge of the shell,
    // then our ray always lies on edge, and that's okay. Otherwise
    // try again in a different random direction.
    if(!onEdge) break;
    if(cnt++ &gt; 5) {
        dbp("can't find a ray that doesn't hit on edge!");
        dbp("on edge = %d, edge_inters = %d", onEdge, edge_inters);
        SS.nakedEdges.AddEdge(ea, eb);
        break;
    }
}

return true;
</t>
<t tx="leo1.20171224221236.164">//-----------------------------------------------------------------------------
// Anything involving surfaces and sets of surfaces (i.e., shells); except
// for the real math, which is in ratpoly.cpp.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

SSurface SSurface::FromExtrusionOf(SBezier *sb, Vector t0, Vector t1) {
    SSurface ret = {};

    ret.degm = sb-&gt;deg;
    ret.degn = 1;

    int i;
    for(i = 0; i &lt;= ret.degm; i++) {
        ret.ctrl[i][0] = (sb-&gt;ctrl[i]).Plus(t0);
        ret.weight[i][0] = sb-&gt;weight[i];

        ret.ctrl[i][1] = (sb-&gt;ctrl[i]).Plus(t1);
        ret.weight[i][1] = sb-&gt;weight[i];
    }

    return ret;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221236.165">bool SSurface::IsExtrusion(SBezier *of, Vector *alongp) const {
    int i;

    if(degn != 1) return false;

    Vector along = (ctrl[0][1]).Minus(ctrl[0][0]);
    for(i = 0; i &lt;= degm; i++) {
        if((fabs(weight[i][1] - weight[i][0]) &lt; LENGTH_EPS) &amp;&amp;
           ((ctrl[i][1]).Minus(ctrl[i][0])).Equals(along))
        {
            continue;
        }
        return false;
    }

    // yes, we are a surface of extrusion; copy the original curve and return
    if(of) {
        for(i = 0; i &lt;= degm; i++) {
            of-&gt;weight[i] = weight[i][0];
            of-&gt;ctrl[i] = ctrl[i][0];
        }
        of-&gt;deg = degm;
        *alongp = along;
    }
    return true;
}

</t>
<t tx="leo1.20171224221236.166">bool SSurface::IsCylinder(Vector *axis, Vector *center, double *r,
                            Vector *start, Vector *finish) const
{
    SBezier sb;
    if(!IsExtrusion(&amp;sb, axis)) return false;
    if(!sb.IsCircle(*axis, center, r)) return false;

    *start = sb.ctrl[0];
    *finish = sb.ctrl[2];
    return true;
}

SSurface SSurface::FromRevolutionOf(SBezier *sb, Vector pt, Vector axis,
</t>
<t tx="leo1.20171224221236.167">                                    double thetas, double thetaf)
{
    SSurface ret = {};


    ret.degm = sb-&gt;deg;
    ret.degn = 2;

    double dtheta = fabs(WRAP_SYMMETRIC(thetaf - thetas, 2*PI));

    // We now wish to revolve the curve about the z axis
    int i;
    for(i = 0; i &lt;= ret.degm; i++) {
        Vector p = sb-&gt;ctrl[i];

        Vector ps = p.RotatedAbout(pt, axis, thetas),
               pf = p.RotatedAbout(pt, axis, thetaf);

        Vector ct;
        if(ps.Equals(pf)) {
            // Degenerate case: a control point lies on the axis of revolution,
            // so we get three coincident control points.
            ct = ps;
        } else {
            // Normal case, the control point sweeps out a circle.
            Vector c = ps.ClosestPointOnLine(pt, axis);

            Vector rs = ps.Minus(c),
                   rf = pf.Minus(c);

            Vector ts = axis.Cross(rs),
                   tf = axis.Cross(rf);

            ct = Vector::AtIntersectionOfLines(ps, ps.Plus(ts),
                                               pf, pf.Plus(tf),
                                               NULL, NULL, NULL);
        }

        ret.ctrl[i][0] = ps;
        ret.ctrl[i][1] = ct;
        ret.ctrl[i][2] = pf;

        ret.weight[i][0] = sb-&gt;weight[i];
        ret.weight[i][1] = sb-&gt;weight[i]*cos(dtheta/2);
        ret.weight[i][2] = sb-&gt;weight[i];
    }

    return ret;
}

SSurface SSurface::FromPlane(Vector pt, Vector u, Vector v) {
    SSurface ret = {};

    ret.degm = 1;
    ret.degn = 1;

    ret.weight[0][0] = ret.weight[0][1] = 1;
    ret.weight[1][0] = ret.weight[1][1] = 1;

    ret.ctrl[0][0] = pt;
    ret.ctrl[0][1] = pt.Plus(u);
    ret.ctrl[1][0] = pt.Plus(v);
    ret.ctrl[1][1] = pt.Plus(v).Plus(u);

    return ret;
}

SSurface SSurface::FromTransformationOf(SSurface *a, Vector t, Quaternion q, double scale,
</t>
<t tx="leo1.20171224221236.168">                                        bool includingTrims)
{
    bool needRotate    = !EXACT(q.vx == 0.0 &amp;&amp; q.vy == 0.0 &amp;&amp; q.vz == 0.0 &amp;&amp; q.w == 1.0);
    bool needTranslate = !EXACT(t.x  == 0.0 &amp;&amp; t.y  == 0.0 &amp;&amp; t.z  == 0.0);
    bool needScale     = !EXACT(scale == 1.0);

    SSurface ret = {};
    ret.h = a-&gt;h;
    ret.color = a-&gt;color;
    ret.face = a-&gt;face;

    ret.degm = a-&gt;degm;
    ret.degn = a-&gt;degn;
    int i, j;
    for(i = 0; i &lt;= 3; i++) {
        for(j = 0; j &lt;= 3; j++) {
            Vector ctrl = a-&gt;ctrl[i][j];
            if(needScale) {
                ctrl = ctrl.ScaledBy(scale);
            }
            if(needRotate) {
                ctrl = q.Rotate(ctrl);
            }
            if(needTranslate) {
                ctrl = ctrl.Plus(t);
            }
            ret.ctrl[i][j] = ctrl;
            ret.weight[i][j] = a-&gt;weight[i][j];
        }
    }

    if(includingTrims) {
        STrimBy *stb;
        ret.trim.ReserveMore(a-&gt;trim.n);
        for(stb = a-&gt;trim.First(); stb; stb = a-&gt;trim.NextAfter(stb)) {
            STrimBy n = *stb;
            if(needScale) {
                n.start  = n.start.ScaledBy(scale);
                n.finish = n.finish.ScaledBy(scale);
            }
            if(needRotate) {
                n.start  = q.Rotate(n.start);
                n.finish = q.Rotate(n.finish);
            }
            if(needTranslate) {
                n.start  = n.start.Plus(t);
                n.finish = n.finish.Plus(t);
            }
            ret.trim.Add(&amp;n);
        }
    }

    if(scale &lt; 0) {
        // If we mirror every surface of a shell, then it will end up inside
        // out. So fix that here.
        ret.Reverse();
    }

    return ret;
}

</t>
<t tx="leo1.20171224221236.169">void SSurface::GetAxisAlignedBounding(Vector *ptMax, Vector *ptMin) const {
    *ptMax = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);
    *ptMin = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);

    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            (ctrl[i][j]).MakeMaxMin(ptMax, ptMin);
        }
    }
}

</t>
<t tx="leo1.20171224221236.17">void OpenGl2Renderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    SMeshListItem *li = meshes.FindByIdNoOops(hcf);
    if(li == NULL) {
        SMeshListItem item = {};
        item.h = hcf;
        meshes.Add(&amp;item);
        li = meshes.FindByIdNoOops(hcf);
    }
    li-&gt;mesh.AddQuad(a, b, c, d);
}

</t>
<t tx="leo1.20171224221236.170">bool SSurface::LineEntirelyOutsideBbox(Vector a, Vector b, bool asSegment) const {
    Vector amax, amin;
    GetAxisAlignedBounding(&amp;amax, &amp;amin);
    if(!Vector::BoundingBoxIntersectsLine(amax, amin, a, b, asSegment)) {
        // The line segment could fail to intersect the bbox, but lie entirely
        // within it and intersect the surface.
        if(a.OutsideAndNotOn(amax, amin) &amp;&amp; b.OutsideAndNotOn(amax, amin)) {
            return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------
// Generate the piecewise linear approximation of the trim stb, which applies
// to the curve sc.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.171">void SSurface::MakeTrimEdgesInto(SEdgeList *sel, MakeAs flags,
                                 SCurve *sc, STrimBy *stb)
{
    Vector prev = Vector::From(0, 0, 0);
    bool inCurve = false, empty = true;
    double u = 0, v = 0;

    int i, first, last, increment;
    if(stb-&gt;backwards) {
        first = sc-&gt;pts.n - 1;
        last = 0;
        increment = -1;
    } else {
        first = 0;
        last = sc-&gt;pts.n - 1;
        increment = 1;
    }
    for(i = first; i != (last + increment); i += increment) {
        Vector tpt, *pt = &amp;(sc-&gt;pts.elem[i].p);

        if(flags == MakeAs::UV) {
            ClosestPointTo(*pt, &amp;u, &amp;v);
            tpt = Vector::From(u, v, 0);
        } else {
            tpt = *pt;
        }

        if(inCurve) {
            sel-&gt;AddEdge(prev, tpt, sc-&gt;h.v, stb-&gt;backwards);
            empty = false;
        }

        prev = tpt;     // either uv or xyz, depending on flags

        if(pt-&gt;Equals(stb-&gt;start)) inCurve = true;
        if(pt-&gt;Equals(stb-&gt;finish)) inCurve = false;
    }
    if(inCurve) dbp("trim was unterminated");
    if(empty)   dbp("trim was empty");
}

//-----------------------------------------------------------------------------
// Generate all of our trim curves, in piecewise linear form. We can do
// so in either uv or xyz coordinates. And if requested, then we can use
// the split curves from useCurvesFrom instead of the curves in our own
// shell.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.172">void SSurface::MakeEdgesInto(SShell *shell, SEdgeList *sel, MakeAs flags,
                             SShell *useCurvesFrom)
{
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        SCurve *sc = shell-&gt;curve.FindById(stb-&gt;curve);

        // We have the option to use the curves from another shell; this
        // is relevant when generating the coincident edges while doing the
        // Booleans, since the curves from the output shell will be split
        // against any intersecting surfaces (and the originals aren't).
        if(useCurvesFrom) {
            sc = useCurvesFrom-&gt;curve.FindById(sc-&gt;newH);
        }

        MakeTrimEdgesInto(sel, flags, sc, stb);
    }
}

//-----------------------------------------------------------------------------
// Compute the exact tangent to the intersection curve between two surfaces,
// by taking the cross product of the surface normals. We choose the direction
// of this tangent so that its dot product with dir is positive.
//-----------------------------------------------------------------------------
Vector SSurface::ExactSurfaceTangentAt(Vector p, SSurface *srfA, SSurface *srfB, Vector dir)
{
    Point2d puva, puvb;
    srfA-&gt;ClosestPointTo(p, &amp;puva);
    srfB-&gt;ClosestPointTo(p, &amp;puvb);
    Vector ts = (srfA-&gt;NormalAt(puva)).Cross(
                (srfB-&gt;NormalAt(puvb)));
    ts = ts.WithMagnitude(1);
    if(ts.Dot(dir) &lt; 0) {
        ts = ts.ScaledBy(-1);
    }
    return ts;
}

//-----------------------------------------------------------------------------
// Report our trim curves. If a trim curve is exact and sbl is not null, then
// add its exact form to sbl. Otherwise, add its piecewise linearization to
// sel.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.173">void SSurface::MakeSectionEdgesInto(SShell *shell, SEdgeList *sel, SBezierList *sbl)
{
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        SCurve *sc = shell-&gt;curve.FindById(stb-&gt;curve);
        SBezier *sb = &amp;(sc-&gt;exact);

        if(sbl &amp;&amp; sc-&gt;isExact &amp;&amp; (sb-&gt;deg != 1 || !sel)) {
            double ts, tf;
            if(stb-&gt;backwards) {
                sb-&gt;ClosestPointTo(stb-&gt;start,  &amp;tf);
                sb-&gt;ClosestPointTo(stb-&gt;finish, &amp;ts);
            } else {
                sb-&gt;ClosestPointTo(stb-&gt;start,  &amp;ts);
                sb-&gt;ClosestPointTo(stb-&gt;finish, &amp;tf);
            }
            SBezier junk_bef, keep_aft;
            sb-&gt;SplitAt(ts, &amp;junk_bef, &amp;keep_aft);
            // In the kept piece, the range that used to go from ts to 1
            // now goes from 0 to 1; so rescale tf appropriately.
            tf = (tf - ts)/(1 - ts);

            SBezier keep_bef, junk_aft;
            keep_aft.SplitAt(tf, &amp;keep_bef, &amp;junk_aft);

            sbl-&gt;l.Add(&amp;keep_bef);
        } else if(sbl &amp;&amp; !sel &amp;&amp; !sc-&gt;isExact) {
            // We must approximate this trim curve, as piecewise cubic sections.
            SSurface *srfA = shell-&gt;surface.FindById(sc-&gt;surfA);
            SSurface *srfB = shell-&gt;surface.FindById(sc-&gt;surfB);

            Vector s = stb-&gt;backwards ? stb-&gt;finish : stb-&gt;start,
                   f = stb-&gt;backwards ? stb-&gt;start : stb-&gt;finish;

            int sp, fp;
            for(sp = 0; sp &lt; sc-&gt;pts.n; sp++) {
                if(s.Equals(sc-&gt;pts.elem[sp].p)) break;
            }
            if(sp &gt;= sc-&gt;pts.n) return;
            for(fp = sp; fp &lt; sc-&gt;pts.n; fp++) {
                if(f.Equals(sc-&gt;pts.elem[fp].p)) break;
            }
            if(fp &gt;= sc-&gt;pts.n) return;
            // So now the curve we want goes from elem[sp] to elem[fp]

            while(sp &lt; fp) {
                // Initially, we'll try approximating the entire trim curve
                // as a single Bezier segment
                int fpt = fp;

                for(;;) {
                    // So construct a cubic Bezier with the correct endpoints
                    // and tangents for the current span.
                    Vector st = sc-&gt;pts.elem[sp].p,
                           ft = sc-&gt;pts.elem[fpt].p,
                           sf = ft.Minus(st);
                    double m = sf.Magnitude() / 3;

                    Vector stan = ExactSurfaceTangentAt(st, srfA, srfB, sf),
                           ftan = ExactSurfaceTangentAt(ft, srfA, srfB, sf);

                    SBezier sb = SBezier::From(st,
                                               st.Plus (stan.WithMagnitude(m)),
                                               ft.Minus(ftan.WithMagnitude(m)),
                                               ft);

                    // And test how much this curve deviates from the
                    // intermediate points (if any).
                    int i;
                    bool tooFar = false;
                    for(i = sp + 1; i &lt;= (fpt - 1); i++) {
                        Vector p = sc-&gt;pts.elem[i].p;
                        double t;
                        sb.ClosestPointTo(p, &amp;t, /*mustConverge=*/false);
                        Vector pp = sb.PointAt(t);
                        if((pp.Minus(p)).Magnitude() &gt; SS.ChordTolMm()/2) {
                            tooFar = true;
                            break;
                        }
                    }

                    if(tooFar) {
                        // Deviates by too much, so try a shorter span
                        fpt--;
                        continue;
                    } else {
                        // Okay, so use this piece and break.
                        sbl-&gt;l.Add(&amp;sb);
                        break;
                    }
                }

                // And continue interpolating, starting wherever the curve
                // we just generated finishes.
                sp = fpt;
            }
        } else {
            if(sel) MakeTrimEdgesInto(sel, MakeAs::XYZ, sc, stb);
        }
    }
}

</t>
<t tx="leo1.20171224221236.18">void OpenGl2Renderer::DrawPoint(const Vector &amp;o, hStroke hs) {
    DoPoint(o, hs);
}

</t>
<t tx="leo1.20171224221236.19">void OpenGl2Renderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    Fill *fill = SelectFill(hcf);

    SMesh m = {};
    p.TriangulateInto(&amp;m);
    meshRenderer.UseFilled(*fill);
    meshRenderer.Draw(m);
    m.Clear();
}

</t>
<t tx="leo1.20171224221236.2">bool Lookup(std::shared_ptr&lt;const Pixmap&gt; ptr, GLuint *result) {
    auto it = items.find(ptr);
    if(it == items.end()) {
        GLuint id;
        glGenTextures(1, &amp;id);
        items[ptr] = id;
        *result = id;
        return false;
    }

    *result = it-&gt;second;
    return true;
}

</t>
<t tx="leo1.20171224221236.20">void OpenGl2Renderer::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221236.21">void OpenGl2Renderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    if(faces.empty()) return;

    Fill *fill = SelectFill(hcf);

    SMesh facesMesh = {};
    for(uint32_t f : faces) {
        for(const STriangle &amp;t : m.l) {
            if(f != t.meta.face) continue;
            facesMesh.l.Add(&amp;t);
        }
    }

    meshRenderer.UseFilled(*fill);
    meshRenderer.Draw(facesMesh);
    facesMesh.Clear();
}

</t>
<t tx="leo1.20171224221236.22">void OpenGl2Renderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                                 const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                 const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    Fill fill = *fills.FindById(hcf);
    fill.texture = pm;
    hcf = GetFill(fill);

    SMeshListItem *mli = meshes.FindByIdNoOops(hcf);
    if(mli == NULL) {
        SMeshListItem item = {};
        item.h = hcf;
        meshes.Add(&amp;item);
        mli = meshes.FindByIdNoOops(hcf);
    }

    mli-&gt;mesh.AddPixmap(o, u, v, ta, tb);
}

</t>
<t tx="leo1.20171224221236.23">void OpenGl2Renderer::UpdateProjection() {
    glViewport(0, 0, camera.width, camera.height);

    double mat1[16];
    double mat2[16];

    double sx = camera.scale * 2.0 / camera.width;
    double sy = camera.scale * 2.0 / camera.height;
    double sz = camera.scale * 1.0 / 30000;

    MakeMatrix(mat1,
       sx,   0,   0,   0,
        0,  sy,   0,   0,
        0,   0,  sz,   0,
        0,   0,   0,   1
    );

    // Last thing before display is to apply the perspective
    double clp = camera.tangent * camera.scale;
    MakeMatrix(mat2,
        1,   0,   0,   0,
        0,   1,   0,   0,
        0,   0,   1,   0,
        0,   0,   clp, 1
    );

    double projection[16];
    MultMatrix(mat1, mat2, projection);

    // Before that, we apply the rotation
    Vector u = camera.projRight,
           v = camera.projUp,
           n = camera.projUp.Cross(camera.projRight);
    MakeMatrix(mat1,
        u.x, u.y, u.z,   0,
        v.x, v.y, v.z,   0,
        n.x, n.y, n.z,   0,
          0,   0,   0,   1
    );

    // And before that, the translation
    Vector o = camera.offset;
    MakeMatrix(mat2,
        1, 0, 0, o.x,
        0, 1, 0, o.y,
        0, 0, 1, o.z,
        0, 0, 0,   1
    );

    double modelview[16];
    MultMatrix(mat1, mat2, modelview);

    imeshRenderer.SetProjection(projection);
    imeshRenderer.SetModelview(modelview);
    meshRenderer.SetProjection(projection);
    meshRenderer.SetModelview(modelview);
    edgeRenderer.SetProjection(projection);
    edgeRenderer.SetModelview(modelview);
    outlineRenderer.SetProjection(projection);
    outlineRenderer.SetModelview(modelview);

    glClearDepthf(1.0f);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo1.20171224221236.24">void OpenGl2Renderer::NewFrame() {
    if(!initialized) {
        Init();
        initialized = true;
    }

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    RgbaColor backgroundColor = lighting.backgroundColor;
    glClearColor(backgroundColor.redF(),  backgroundColor.greenF(),
                 backgroundColor.blueF(), backgroundColor.alphaF());
    glClearDepthf(1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPolygonOffset(2.0, 1.0);
}

</t>
<t tx="leo1.20171224221236.25">void OpenGl2Renderer::FlushFrame() {
    for(SMeshListItem &amp;li : meshes) {
        Fill *fill = SelectFill(li.h);

        imeshRenderer.UseFilled(*fill);
        imeshRenderer.Draw(li.mesh);
        li.mesh.Clear();
    }
    meshes.Clear();

    for(SEdgeListItem &amp;eli : lines) {
        Stroke *stroke = SelectStroke(eli.h);

        edgeRenderer.SetStroke(*stroke, 1.0 / camera.scale);
        edgeRenderer.Draw(eli.lines);
        eli.lines.Clear();
    }
    lines.Clear();

    for(SPointListItem &amp;li : points) {
        Stroke *stroke = SelectStroke(li.h);

        imeshRenderer.UsePoint(*stroke, 1.0 / camera.scale);
        imeshRenderer.Draw(li.points);
        li.points.Clear();
    }
    points.Clear();

    glFinish();

    GLenum error = glGetError();
    if(error != GL_NO_ERROR) {
        dbp("glGetError() == 0x%X", error);
    }
}

</t>
<t tx="leo1.20171224221236.26">void OpenGl2Renderer::Clear() {
    ViewportCanvas::Clear();
    pixmapCache.CleanupUnused();
}

std::shared_ptr&lt;Pixmap&gt; OpenGl2Renderer::ReadFrame() {
    std::shared_ptr&lt;Pixmap&gt; pixmap =
        Pixmap::Create(Pixmap::Format::RGB, (size_t)camera.width, (size_t)camera.height);
    glReadPixels(0, 0, camera.width, camera.height, GL_RGB, GL_UNSIGNED_BYTE, &amp;pixmap-&gt;data[0]);
    return pixmap;
}

</t>
<t tx="leo1.20171224221236.27">void OpenGl2Renderer::GetIdent(const char **vendor, const char **renderer, const char **version) {
    *vendor   = (const char *)glGetString(GL_VENDOR);
    *renderer = (const char *)glGetString(GL_RENDERER);
    *version  = (const char *)glGetString(GL_VERSION);
}

</t>
<t tx="leo1.20171224221236.28">void OpenGl2Renderer::SetCamera(const Camera &amp;c) {
    camera = c;
    if(initialized) {
        UpdateProjection();
    }
}

</t>
<t tx="leo1.20171224221236.29">void OpenGl2Renderer::SetLighting(const Lighting &amp;l) {
    lighting = l;
}

//-----------------------------------------------------------------------------
// A batch canvas implemented using OpenGL 3 vertex buffer objects.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221236.3">void CleanupUnused() {
    for(auto it = items.begin(); it != items.end();) {
        if(it-&gt;first.expired()) {
            glDeleteTextures(1, &amp;it-&gt;second);
            it = items.erase(it);
            continue;
        }
        it++;
    }
}
</t>
<t tx="leo1.20171224221236.30">class DrawCall {
public:
    virtual Canvas::Layer GetLayer() const = 0;
    virtual int GetZIndex() const = 0;

    virtual void Draw(OpenGl2Renderer *renderer) = 0;
    virtual void Remove(OpenGl2Renderer *renderer) = 0;
};

</t>
<t tx="leo1.20171224221236.31">class EdgeDrawCall : public DrawCall {
public:
    // Key
    Canvas::Stroke              stroke;
    // Data
    EdgeRenderer::Handle        handle;

    virtual Canvas::Layer GetLayer() const override { return stroke.layer; };
    virtual int GetZIndex() const override { return stroke.zIndex; };

    @others
};

</t>
<t tx="leo1.20171224221236.32">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl2Renderer *renderer, const SEdgeList &amp;el,
                                        Canvas::Stroke *stroke) {
    EdgeDrawCall *dc = new EdgeDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;edgeRenderer.Add(el);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo1.20171224221236.33">void Draw(OpenGl2Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;edgeRenderer.SetStroke(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;edgeRenderer.Draw(handle);
}

</t>
<t tx="leo1.20171224221236.34">void Remove(OpenGl2Renderer *renderer) override {
    renderer-&gt;edgeRenderer.Remove(handle);
}
</t>
<t tx="leo1.20171224221236.35">class OutlineDrawCall : public DrawCall {
public:
    // Key
    Canvas::Stroke              stroke;
    // Data
    OutlineRenderer::Handle     handle;
    Canvas::DrawOutlinesAs      drawAs;

    virtual Canvas::Layer GetLayer() const override { return stroke.layer; };
    virtual int GetZIndex() const override { return stroke.zIndex; };

    @others
};

</t>
<t tx="leo1.20171224221236.36">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl2Renderer *renderer, const SOutlineList &amp;ol,
                                        Canvas::Stroke *stroke,
                                        Canvas::DrawOutlinesAs drawAs) {
    OutlineDrawCall *dc = new OutlineDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;outlineRenderer.Add(ol);
    dc-&gt;drawAs = drawAs;
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo1.20171224221236.37">void Draw(OpenGl2Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;outlineRenderer.SetStroke(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;outlineRenderer.Draw(handle, drawAs);
}

</t>
<t tx="leo1.20171224221236.38">void Remove(OpenGl2Renderer *renderer) override {
    renderer-&gt;outlineRenderer.Remove(handle);
}
</t>
<t tx="leo1.20171224221236.39">class PointDrawCall : public DrawCall {
public:
    // Key
    Canvas::Stroke               stroke;
    // Data
    IndexedMeshRenderer::Handle  handle;

    virtual Canvas::Layer GetLayer() const override { return stroke.layer; };
    virtual int GetZIndex() const override { return stroke.zIndex; };

    @others
};

</t>
<t tx="leo1.20171224221236.4">class OpenGl2Renderer : public ViewportCanvas {
public:
    struct SEdgeListItem {
        hStroke         h;
        SEdgeList       lines;

        void Clear() { lines.Clear(); }
    };

    struct SMeshListItem {
        hFill           h;
        SIndexedMesh    mesh;

        void Clear() { mesh.Clear(); }
    };

    struct SPointListItem {
        hStroke         h;
        SIndexedMesh    points;

        void Clear() { points.Clear(); }
    };

    IdList&lt;SEdgeListItem,  hStroke&gt; lines;
    IdList&lt;SMeshListItem,  hFill&gt;   meshes;
    IdList&lt;SPointListItem, hStroke&gt; points;

    TextureCache            pixmapCache;
    std::shared_ptr&lt;Pixmap&gt; masks[3];

    bool                initialized;
    StippleAtlas        atlas;
    MeshRenderer        meshRenderer;
    IndexedMeshRenderer imeshRenderer;
    EdgeRenderer        edgeRenderer;
    OutlineRenderer     outlineRenderer;

    Camera   camera;
    Lighting lighting;
    // Cached OpenGL state.
    struct {
        hStroke     hcs;
        Stroke     *stroke;
        hFill       hcf;
        Fill       *fill;
        std::weak_ptr&lt;const Pixmap&gt; texture;
    } current;

    OpenGl2Renderer() :
        lines(), meshes(), points(), pixmapCache(), masks(),
        initialized(), atlas(), meshRenderer(), imeshRenderer(),
        edgeRenderer(), outlineRenderer(), camera(), lighting(),
        current() {}

    void Init();

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs mode) override;
    void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
    void DoFatLine(const Vector &amp;a, const Vector &amp;b, double width);
    void DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);
    void DoPoint(Vector p, hStroke hs);
    void DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);

    void UpdateProjection();
    void SetCamera(const Camera &amp;c) override;
    void SetLighting(const Lighting &amp;l) override;

    void NewFrame() override;
    void FlushFrame() override;
    void Clear() override;
    std::shared_ptr&lt;Pixmap&gt; ReadFrame() override;

    void GetIdent(const char **vendor, const char **renderer, const char **version) override;
};

//-----------------------------------------------------------------------------
// Thin wrappers around OpenGL functions to fix bugs, adapt them to our
// data structures, etc.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221236.40">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl2Renderer *renderer, const SIndexedMesh &amp;mesh,
                                        Canvas::Stroke *stroke) {
    PointDrawCall *dc = new PointDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;imeshRenderer.Add(mesh);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo1.20171224221236.41">void Draw(OpenGl2Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;imeshRenderer.UsePoint(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;imeshRenderer.Draw(handle);
}

</t>
<t tx="leo1.20171224221236.42">void Remove(OpenGl2Renderer *renderer) override {
    renderer-&gt;imeshRenderer.Remove(handle);
}
</t>
<t tx="leo1.20171224221236.43">class PixmapDrawCall : public DrawCall {
public:
    // Key
    Canvas::Fill                 fill;
    // Data
    IndexedMeshRenderer::Handle  handle;

    virtual Canvas::Layer GetLayer() const override { return fill.layer; };
    virtual int GetZIndex() const override { return fill.zIndex; };

    @others
};

</t>
<t tx="leo1.20171224221236.44">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl2Renderer *renderer, const SIndexedMesh &amp;mesh,
                                        Canvas::Fill *fill) {
    PixmapDrawCall *dc = new PixmapDrawCall();
    dc-&gt;fill   = *fill;
    dc-&gt;handle = renderer-&gt;imeshRenderer.Add(mesh);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo1.20171224221236.45">void Draw(OpenGl2Renderer *renderer) override {
    ssglDepthRange(fill.layer, fill.zIndex);
    if(fill.pattern != Canvas::FillPattern::SOLID) {
        renderer-&gt;SelectMask(fill.pattern);
    } else if(fill.texture) {
        renderer-&gt;SelectTexture(fill.texture);
    } else {
        renderer-&gt;SelectMask(Canvas::FillPattern::SOLID);
    }
    renderer-&gt;imeshRenderer.UseFilled(fill);
    renderer-&gt;imeshRenderer.Draw(handle);
}

</t>
<t tx="leo1.20171224221236.46">void Remove(OpenGl2Renderer *renderer) override {
    renderer-&gt;imeshRenderer.Remove(handle);
}
</t>
<t tx="leo1.20171224221236.47">class MeshDrawCall : public DrawCall {
public:
    // Key
    Canvas::Fill            fillFront;
    // Data
    MeshRenderer::Handle    handle;
    Canvas::Fill            fillBack;
    bool                    hasFillBack;
    bool                    isShaded;

    virtual Canvas::Layer GetLayer() const override { return fillFront.layer; };
    virtual int GetZIndex() const override { return fillFront.zIndex; };

    @others
};

struct CompareDrawCall {
</t>
<t tx="leo1.20171224221236.48">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl2Renderer *renderer, const SMesh &amp;m,
                                        Canvas::Fill *fillFront, Canvas::Fill *fillBack = NULL,
                                        bool isShaded = false) {
    MeshDrawCall *dc = new MeshDrawCall();
    dc-&gt;fillFront       = *fillFront;
    dc-&gt;handle          = renderer-&gt;meshRenderer.Add(m);
    dc-&gt;fillBack        = *fillBack;
    dc-&gt;isShaded        = isShaded;
    dc-&gt;hasFillBack     = (fillBack != NULL);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo1.20171224221236.49">void DrawFace(OpenGl2Renderer *renderer, GLenum cullFace, const Canvas::Fill &amp;fill) {
    glCullFace(cullFace);
    ssglDepthRange(fill.layer, fill.zIndex);
    if(fill.pattern != Canvas::FillPattern::SOLID) {
        renderer-&gt;SelectMask(fill.pattern);
    } else if(fill.texture) {
        renderer-&gt;SelectTexture(fill.texture);
    } else {
        renderer-&gt;SelectMask(Canvas::FillPattern::SOLID);
    }
    if(isShaded) {
        renderer-&gt;meshRenderer.UseShaded(renderer-&gt;lighting);
    } else {
        renderer-&gt;meshRenderer.UseFilled(fill);
    }
    renderer-&gt;meshRenderer.Draw(handle, /*useColors=*/fill.color.IsEmpty(), fill.color);
}

</t>
<t tx="leo1.20171224221236.5">static void ssglDepthRange(Canvas::Layer layer, int zIndex) {
    switch(layer) {
        case Canvas::Layer::NORMAL:
        case Canvas::Layer::FRONT:
        case Canvas::Layer::BACK:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;

        case Canvas::Layer::DEPTH_ONLY:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
            break;

        case Canvas::Layer::OCCLUDED:
            glDepthFunc(GL_GREATER);
            glDepthMask(GL_FALSE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;
    }

    switch(layer) {
        case Canvas::Layer::FRONT:
            glDepthRangef(0.0f, 0.0f);
            break;

        case Canvas::Layer::BACK:
            glDepthRangef(1.0f, 1.0f);
            break;

        case Canvas::Layer::NORMAL:
        case Canvas::Layer::DEPTH_ONLY:
        case Canvas::Layer::OCCLUDED:
            // The size of this step depends on the resolution of the Z buffer; for
            // a 16-bit buffer, this should be fine.
            double offset = 1.0 / (65535 * 0.8) * zIndex;
            glDepthRangef((float)(0.1 - offset), (float)(1.0 - offset));
            break;
    }
}

//-----------------------------------------------------------------------------
// A simple OpenGL state tracker to group consecutive draw calls.
//-----------------------------------------------------------------------------

Canvas::Stroke *OpenGl2Renderer::SelectStroke(hStroke hcs) {
    if(current.hcs.v == hcs.v) return current.stroke;

    Stroke *stroke = strokes.FindById(hcs);
    ssglDepthRange(stroke-&gt;layer, stroke-&gt;zIndex);

    current.hcs    = hcs;
    current.stroke = stroke;
    current.hcf    = {};
    current.fill   = NULL;
    current.texture.reset();
    return stroke;
}

</t>
<t tx="leo1.20171224221236.50">void Draw(OpenGl2Renderer *renderer) override {
    glEnable(GL_POLYGON_OFFSET_FILL);
    glEnable(GL_CULL_FACE);

    if(hasFillBack)
        DrawFace(renderer, GL_FRONT, fillBack);
    DrawFace(renderer, GL_BACK, fillFront);

    glDisable(GL_POLYGON_OFFSET_FILL);
    glDisable(GL_CULL_FACE);
}

</t>
<t tx="leo1.20171224221236.51">void Remove(OpenGl2Renderer *renderer) override {
    renderer-&gt;meshRenderer.Remove(handle);
}
</t>
<t tx="leo1.20171224221236.52">    bool operator()(const std::shared_ptr&lt;DrawCall&gt; &amp;a, const std::shared_ptr&lt;DrawCall&gt; &amp;b) {
        @others
    }
};

</t>
<t tx="leo1.20171224221236.53">const Canvas::Layer stackup[] = {
    Canvas::Layer::BACK,
    Canvas::Layer::DEPTH_ONLY,
    Canvas::Layer::NORMAL,
    Canvas::Layer::OCCLUDED,
    Canvas::Layer::FRONT
};

</t>
<t tx="leo1.20171224221236.54">int aLayerIndex =
    std::find(std::begin(stackup), std::end(stackup), a-&gt;GetLayer()) - std::begin(stackup);
int bLayerIndex =
    std::find(std::begin(stackup), std::end(stackup), b-&gt;GetLayer()) - std::begin(stackup);
if(aLayerIndex == bLayerIndex) {
    return a-&gt;GetZIndex() &lt; b-&gt;GetZIndex();
} else {
    return aLayerIndex &lt; bLayerIndex;
}
</t>
<t tx="leo1.20171224221236.55">class OpenGl2RendererBatch : public BatchCanvas {
public:
    struct EdgeBuffer {
        hStroke         h;
        SEdgeList       edges;

        @others
};

//-----------------------------------------------------------------------------
// Factory functions.
//-----------------------------------------------------------------------------

std::shared_ptr&lt;BatchCanvas&gt; OpenGl2Renderer::CreateBatch() {
    OpenGl2RendererBatch *batch = new OpenGl2RendererBatch();
    batch-&gt;renderer = this;
    return std::shared_ptr&lt;BatchCanvas&gt;(batch);
}

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return std::shared_ptr&lt;ViewportCanvas&gt;(new OpenGl2Renderer());
}

}
</t>
<t tx="leo1.20171224221236.56">    void Clear() {
        edges.Clear();
    }
};

struct PointBuffer {
    hStroke         h;
    SIndexedMesh    points;

</t>
<t tx="leo1.20171224221236.57">    void Clear() {
        points.Clear();
    }
};

OpenGl2Renderer *renderer;

IdList&lt;EdgeBuffer,  hStroke&gt; edgeBuffer;
IdList&lt;PointBuffer, hStroke&gt; pointBuffer;

std::multiset&lt;std::shared_ptr&lt;DrawCall&gt;, CompareDrawCall&gt; drawCalls;

OpenGl2RendererBatch() : renderer(), edgeBuffer(), pointBuffer() {}

</t>
<t tx="leo1.20171224221236.58">void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override {
    EdgeBuffer *eb = edgeBuffer.FindByIdNoOops(hcs);
    if(!eb) {
        EdgeBuffer neb = {};
        neb.h = hcs;
        edgeBuffer.Add(&amp;neb);
        eb = edgeBuffer.FindById(hcs);
    }

    eb-&gt;edges.AddEdge(a, b);
}

</t>
<t tx="leo1.20171224221236.59">void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override {
    EdgeBuffer *eb = edgeBuffer.FindByIdNoOops(hcs);
    if(!eb) {
        EdgeBuffer neb = {};
        neb.h = hcs;
        edgeBuffer.Add(&amp;neb);
        eb = edgeBuffer.FindById(hcs);
    }

    for(const SEdge &amp;e : el.l) {
        eb-&gt;edges.AddEdge(e.a, e.b);
    }
}

</t>
<t tx="leo1.20171224221236.6">void OpenGl2Renderer::SelectMask(FillPattern pattern) {
    if(!masks[0]) {
        masks[0] = Pixmap::Create(Pixmap::Format::A, 32, 32);
        masks[1] = Pixmap::Create(Pixmap::Format::A, 32, 32);
        masks[2] = Pixmap::Create(Pixmap::Format::A, 32, 32);

        for(int x = 0; x &lt; 32; x++) {
            for(int y = 0; y &lt; 32; y++) {
                masks[0]-&gt;data[y * 32 + x] = ((x / 2) % 2 == 0 &amp;&amp; (y / 2) % 2 == 0) ? 0xFF : 0x00;
                masks[1]-&gt;data[y * 32 + x] = ((x / 2) % 2 == 1 &amp;&amp; (y / 2) % 2 == 1) ? 0xFF : 0x00;
                masks[2]-&gt;data[y * 32 + x] = 0xFF;
            }
        }
    }

    switch(pattern) {
        case Canvas::FillPattern::SOLID:
            SelectTexture(masks[2]);
            break;

        case Canvas::FillPattern::CHECKERED_A:
            SelectTexture(masks[0]);
            break;

        case Canvas::FillPattern::CHECKERED_B:
            SelectTexture(masks[1]);
            break;

        default: ssassert(false, "Unexpected fill pattern");
    }
}

Canvas::Fill *OpenGl2Renderer::SelectFill(hFill hcf) {
    if(current.hcf.v == hcf.v) return current.fill;

    Fill *fill = fills.FindById(hcf);
    ssglDepthRange(fill-&gt;layer, fill-&gt;zIndex);

    current.hcs    = {};
    current.stroke = NULL;
    current.hcf    = hcf;
    current.fill   = fill;
    if(fill-&gt;pattern != FillPattern::SOLID) {
        SelectMask(fill-&gt;pattern);
    } else if(fill-&gt;texture) {
        SelectTexture(fill-&gt;texture);
    } else {
        SelectMask(FillPattern::SOLID);
    }
    return fill;
}

</t>
<t tx="leo1.20171224221236.60">bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override {
    return false;
}

</t>
<t tx="leo1.20171224221236.61">void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override {
    drawCalls.emplace(OutlineDrawCall::Create(renderer, ol, strokes.FindById(hcs), drawAs));
}

</t>
<t tx="leo1.20171224221236.62">void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    hStroke hcs) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221236.63">void DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
              hFill hcf) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221236.64">void DrawPoint(const Vector &amp;o, hStroke hcs) override {
    PointBuffer *pb = pointBuffer.FindByIdNoOops(hcs);
    if(!pb) {
        PointBuffer npb = {};
        npb.h = hcs;
        pointBuffer.Add(&amp;npb);
        pb = pointBuffer.FindById(hcs);
    }

    pb-&gt;points.AddPoint(o);
}

</t>
<t tx="leo1.20171224221236.65">void DrawPolygon(const SPolygon &amp;p, hFill hcf) override {
    SMesh m = {};
    p.TriangulateInto(&amp;m);
    drawCalls.emplace(MeshDrawCall::Create(renderer, m, fills.FindById(hcf),
                                           fills.FindById(hcf)));
    m.Clear();
}

</t>
<t tx="leo1.20171224221236.66">void DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack = {}) override {
    drawCalls.emplace(MeshDrawCall::Create(renderer, m, fills.FindById(hcfFront),
                                           fills.FindByIdNoOops(hcfBack),
                                           /*lighting=*/true));
}

</t>
<t tx="leo1.20171224221236.67">void DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221236.68">void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) override {
    Fill fill = *fills.FindById(hcf);
    fill.texture = pm;
    hcf = GetFill(fill);

    SIndexedMesh mesh = {};
    mesh.AddPixmap(o, u, v, ta, tb);
    drawCalls.emplace(PixmapDrawCall::Create(renderer, mesh, fills.FindByIdNoOops(hcf)));
    mesh.Clear();
}

</t>
<t tx="leo1.20171224221236.69">void InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo1.20171224221236.7">void OpenGl2Renderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    GLuint id;
    pixmapCache.Lookup(pm, &amp;id);
    glBindTexture(GL_TEXTURE_2D, id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_REPEAT);

    GLenum format;
    switch(pm-&gt;format) {
        case Pixmap::Format::RGBA: format = GL_RGBA;  break;
        case Pixmap::Format::RGB:  format = GL_RGB;   break;
#if defined(HAVE_GLES)
        case Pixmap::Format::A:    format = GL_ALPHA; break;
#else
        case Pixmap::Format::A:    format = GL_RED;   break;
#endif
        case Pixmap::Format::BGRA:
        case Pixmap::Format::BGR:
            ssassert(false, "Unexpected pixmap format");
    }
    glTexImage2D(GL_TEXTURE_2D, 0, format, pm-&gt;width, pm-&gt;height, 0,
                 format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
}

</t>
<t tx="leo1.20171224221236.70">void Finalize() override {
    for(const EdgeBuffer &amp;eb : edgeBuffer) {
        drawCalls.emplace(EdgeDrawCall::Create(renderer, eb.edges, strokes.FindById(eb.h)));
    }
    edgeBuffer.Clear();

    for(const PointBuffer &amp;pb : pointBuffer) {
        drawCalls.emplace(PointDrawCall::Create(renderer, pb.points, strokes.FindById(pb.h)));
    }
    pointBuffer.Clear();
}

</t>
<t tx="leo1.20171224221236.71">void Draw() override {
    renderer-&gt;current = {};

    for(std::shared_ptr&lt;DrawCall&gt; dc : drawCalls) {
        dc-&gt;Draw(renderer);
    }
}

</t>
<t tx="leo1.20171224221236.72">void Clear() override {
    for(std::shared_ptr&lt;DrawCall&gt; dc : drawCalls) {
        dc-&gt;Remove(renderer);
    }
    drawCalls.clear();
}
</t>
<t tx="leo1.20171224221236.73"></t>
<t tx="leo1.20171224221236.74">//-----------------------------------------------------------------------------
// Top-level functions to compute the Boolean union or difference between
// two shells of rational polynomial surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

static int I;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221236.75">void SShell::MakeFromUnionOf(SShell *a, SShell *b) {
    MakeFromBoolean(a, b, SSurface::CombineAs::UNION);
}

</t>
<t tx="leo1.20171224221236.76">void SShell::MakeFromDifferenceOf(SShell *a, SShell *b) {
    MakeFromBoolean(a, b, SSurface::CombineAs::DIFFERENCE);
}

//-----------------------------------------------------------------------------
// Take our original pwl curve. Wherever an edge intersects a surface within
// either agnstA or agnstB, split the piecewise linear element. Then refine
// the intersection so that it lies on all three relevant surfaces: the
// intersecting surface, srfA, and srfB. (So the pwl curve should lie at
// the intersection of srfA and srfB.) Return a new pwl curve with everything
// split.
//-----------------------------------------------------------------------------
static Vector LineStart, LineDirection;
</t>
<t tx="leo1.20171224221236.77">static int ByTAlongLine(const void *av, const void *bv)
{
    SInter *a = (SInter *)av,
           *b = (SInter *)bv;

    @others
}

</t>
<t tx="leo1.20171224221236.78">    double ta = (a-&gt;p.Minus(LineStart)).DivPivoting(LineDirection),
           tb = (b-&gt;p.Minus(LineStart)).DivPivoting(LineDirection);

    return (ta &gt; tb) ? 1 : -1;
}
SCurve SCurve::MakeCopySplitAgainst(SShell *agnstA, SShell *agnstB,
                                    SSurface *srfA, SSurface *srfB) const
{
    SCurve ret;
    ret = *this;
    ret.pts = {};

    const SCurvePt *p = pts.First();
    ssassert(p != NULL, "Cannot split an empty curve");
    SCurvePt prev = *p;
    ret.pts.Add(p);
    p = pts.NextAfter(p);

    for(; p; p = pts.NextAfter(p)) {
        List&lt;SInter&gt; il = {};

        // Find all the intersections with the two passed shells
        if(agnstA)
            agnstA-&gt;AllPointsIntersecting(prev.p, p-&gt;p, &amp;il,
                /*asSegment=*/true, /*trimmed=*/false, /*inclTangent=*/true);
        if(agnstB)
            agnstB-&gt;AllPointsIntersecting(prev.p, p-&gt;p, &amp;il,
                /*asSegment=*/true, /*trimmed=*/false, /*inclTangent=*/true);

        if(il.n &gt; 0) {
            // The intersections were generated by intersecting the pwl
            // edge against a surface; so they must be refined to lie
            // exactly on the original curve.
            il.ClearTags();
            SInter *pi;
            for(pi = il.First(); pi; pi = il.NextAfter(pi)) {
                if(pi-&gt;srf == srfA || pi-&gt;srf == srfB) {
                    // The edge certainly intersects the surfaces that it
                    // trims (at its endpoints), but those ones don't count.
                    // They are culled later, but no sense calculating them
                    // and they will cause numerical problems (since two
                    // of the three surfaces they're refined to lie on will
                    // be identical, so the matrix will be singular).
                    pi-&gt;tag = 1;
                    continue;
                }

                Point2d puv;
                (pi-&gt;srf)-&gt;ClosestPointTo(pi-&gt;p, &amp;puv, /*mustConverge=*/false);

                // Split the edge if the intersection lies within the surface's
                // trim curves, or within the chord tol of the trim curve; want
                // some slop if points are close to edge and pwl is too coarse,
                // and it doesn't hurt to split unnecessarily.
                Point2d dummy = { 0, 0 };
                SBspUv::Class c = (pi-&gt;srf-&gt;bsp) ? pi-&gt;srf-&gt;bsp-&gt;ClassifyPoint(puv, dummy, pi-&gt;srf) : SBspUv::Class::OUTSIDE;
                if(c == SBspUv::Class::OUTSIDE) {
                    double d = VERY_POSITIVE;
                    if(pi-&gt;srf-&gt;bsp) d = pi-&gt;srf-&gt;bsp-&gt;MinimumDistanceToEdge(puv, pi-&gt;srf);
                    if(d &gt; SS.ChordTolMm()) {
                        pi-&gt;tag = 1;
                        continue;
                    }
                }

                // We're keeping the intersection, so actually refine it.
                (pi-&gt;srf)-&gt;PointOnSurfaces(srfA, srfB, &amp;(puv.x), &amp;(puv.y));
                pi-&gt;p = (pi-&gt;srf)-&gt;PointAt(puv);
            }
            il.RemoveTagged();

            // And now sort them in order along the line. Note that we must
            // do that after refining, in case the refining would make two
            // points switch places.
            LineStart = prev.p;
            LineDirection = (p-&gt;p).Minus(prev.p);
            qsort(il.elem, il.n, sizeof(il.elem[0]), ByTAlongLine);

            // And now uses the intersections to generate our split pwl edge(s)
            Vector prev = Vector::From(VERY_POSITIVE, 0, 0);
            for(pi = il.First(); pi; pi = il.NextAfter(pi)) {
                // On-edge intersection will generate same split point for
                // both surfaces, so don't create zero-length edge.
                if(!prev.Equals(pi-&gt;p)) {
                    SCurvePt scpt;
                    scpt.tag    = 0;
                    scpt.p      = pi-&gt;p;
                    scpt.vertex = true;
                    ret.pts.Add(&amp;scpt);
                }
                prev = pi-&gt;p;
            }
        }

        il.Clear();
        ret.pts.Add(p);
        prev = *p;
    }
    return ret;
</t>
<t tx="leo1.20171224221236.79">void SShell::CopyCurvesSplitAgainst(bool opA, SShell *agnst, SShell *into) {
    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        SCurve scn = sc-&gt;MakeCopySplitAgainst(agnst, NULL,
                                surface.FindById(sc-&gt;surfA),
                                surface.FindById(sc-&gt;surfB));
        scn.source = opA ? SCurve::Source::A : SCurve::Source::B;

        hSCurve hsc = into-&gt;curve.AddAndAssignId(&amp;scn);
        // And note the new ID so that we can rewrite the trims appropriately
        sc-&gt;newH = hsc;
    }
}

</t>
<t tx="leo1.20171224221236.8">void OpenGl2Renderer::SelectTexture(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) return;

    GLuint id;
    if(!pixmapCache.Lookup(pm, &amp;id)) {
        InvalidatePixmap(pm);
    }

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, id);
    current.texture = pm;
}

</t>
<t tx="leo1.20171224221236.80">void SSurface::TrimFromEdgeList(SEdgeList *el, bool asUv) {
    el-&gt;l.ClearTags();

    STrimBy stb = {};
    for(;;) {
        // Find an edge, any edge; we'll start from there.
        SEdge *se;
        for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
            if(se-&gt;tag) continue;
            break;
        }
        if(!se) break;
        se-&gt;tag = 1;
        stb.start = se-&gt;a;
        stb.finish = se-&gt;b;
        stb.curve.v = se-&gt;auxA;
        stb.backwards = se-&gt;auxB ? true : false;

        // Find adjoining edges from the same curve; those should be
        // merged into a single trim.
        bool merged;
        do {
            merged = false;
            for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
                if(se-&gt;tag)                         continue;
                if(se-&gt;auxA != (int)stb.curve.v)    continue;
                if(( se-&gt;auxB &amp;&amp; !stb.backwards) ||
                   (!se-&gt;auxB &amp;&amp;  stb.backwards))   continue;

                if((se-&gt;a).Equals(stb.finish)) {
                    stb.finish = se-&gt;b;
                    se-&gt;tag = 1;
                    merged = true;
                } else if((se-&gt;b).Equals(stb.start)) {
                    stb.start = se-&gt;a;
                    se-&gt;tag = 1;
                    merged = true;
                }
            }
        } while(merged);

        if(asUv) {
            stb.start  = PointAt(stb.start.x,  stb.start.y);
            stb.finish = PointAt(stb.finish.x, stb.finish.y);
        }

        // And add the merged trim, with xyz (not uv like the polygon) pts
        trim.Add(&amp;stb);
    }
}

</t>
<t tx="leo1.20171224221236.81">static bool KeepRegion(SSurface::CombineAs type, bool opA, SShell::Class shell, SShell::Class orig)
{
    bool inShell = (shell == SShell::Class::INSIDE),
        case SSurface::CombineAs::UNION:
            if(opA) {
                return (!inShell &amp;&amp; !inFace);
            } else {
                return (!inShell &amp;&amp; !inFace) || inSame;
            }

        case SSurface::CombineAs::DIFFERENCE:
            if(opA) {
                return (!inShell &amp;&amp; !inFace);
            } else {
                return (inShell &amp;&amp; !inFace) || inSame;
            }

        default: ssassert(false, "Unexpected combine type");
    }
}
</t>
<t tx="leo1.20171224221236.82">static bool KeepEdge(SSurface::CombineAs type, bool opA,
                     SShell::Class indir_shell, SShell::Class outdir_shell,
                     SShell::Class indir_orig, SShell::Class outdir_orig)
{
    bool keepIn  = KeepRegion(type, opA, indir_shell,  indir_orig),
    switch(bspclass) {
        case SBspUv::Class::INSIDE:
            *indir  = SShell::Class::INSIDE;
            *outdir = SShell::Class::INSIDE;
            break;

        case SBspUv::Class::OUTSIDE:
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;

        case SBspUv::Class::EDGE_PARALLEL:
            *indir  = SShell::Class::INSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;

        case SBspUv::Class::EDGE_ANTIPARALLEL:
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::INSIDE;
            break;

        default:
            dbp("TagByClassifiedEdge: fail!");
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;
    }
}

</t>
<t tx="leo1.20171224221236.83">static void DEBUGEDGELIST(SEdgeList *sel, SSurface *surf) {
    dbp("print %d edges", sel-&gt;l.n);
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        Vector mid = (se-&gt;a).Plus(se-&gt;b).ScaledBy(0.5);
        Vector arrow = (se-&gt;b).Minus(se-&gt;a);
        swap(arrow.x, arrow.y);
        arrow.x *= -1;
        arrow = arrow.WithMagnitude(0.01);
        arrow = arrow.Plus(mid);

        SS.nakedEdges.AddEdge(surf-&gt;PointAt(se-&gt;a.x, se-&gt;a.y),
                              surf-&gt;PointAt(se-&gt;b.x, se-&gt;b.y));
        SS.nakedEdges.AddEdge(surf-&gt;PointAt(mid.x, mid.y),
                              surf-&gt;PointAt(arrow.x, arrow.y));
    }
}

//-----------------------------------------------------------------------------
// We are given src, with at least one edge, and avoid, a list of points to
// avoid. We return a chain of edges (that share endpoints), such that no
// point within the avoid list ever occurs in the middle of a chain. And we
// delete the edges in that chain from our source list.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.84">void SSurface::FindChainAvoiding(SEdgeList *src, SEdgeList *dest,
                                 SPointList *avoid)
{
    ssassert(src-&gt;l.n &gt; 0, "Need at least one edge");
    // Start with an arbitrary edge.
    dest-&gt;l.Add(&amp;(src-&gt;l.elem[0]));
    src-&gt;l.ClearTags();
    src-&gt;l.elem[0].tag = 1;

    bool added;
    do {
        added = false;
        // The start and finish of the current edge chain
        Vector s = dest-&gt;l.elem[0].a,
               f = dest-&gt;l.elem[dest-&gt;l.n - 1].b;

        // We can attach a new edge at the start or finish, as long as that
        // start or finish point isn't in the list of points to avoid.
        @others
}

</t>
<t tx="leo1.20171224221236.85">    bool startOkay  = !avoid-&gt;ContainsPoint(s),
         finishOkay = !avoid-&gt;ContainsPoint(f);

    // Now look for an unused edge that joins at the start or finish of
    // our chain (if permitted by the avoid list).
    SEdge *se;
    for(se = src-&gt;l.First(); se; se = src-&gt;l.NextAfter(se)) {
        if(se-&gt;tag) continue;
        if(startOkay &amp;&amp; s.Equals(se-&gt;b)) {
            dest-&gt;l.AddToBeginning(se);
            s = se-&gt;a;
            se-&gt;tag = 1;
            startOkay = !avoid-&gt;ContainsPoint(s);
        } else if(finishOkay &amp;&amp; f.Equals(se-&gt;a)) {
            dest-&gt;l.Add(se);
            f = se-&gt;b;
            se-&gt;tag = 1;
            finishOkay = !avoid-&gt;ContainsPoint(f);
        } else {
            continue;
        }

        added = true;
    }
} while(added);

src-&gt;l.RemoveTagged();
</t>
<t tx="leo1.20171224221236.86">void SSurface::EdgeNormalsWithinSurface(Point2d auv, Point2d buv,
                                        Vector *pt,
                                        Vector *enin, Vector *enout,
                                        Vector *surfn,
                                        uint32_t auxA,
                                        SShell *shell, SShell *sha, SShell *shb)
{
    // the midpoint of the edge
    Point2d muv  = (auv.Plus(buv)).ScaledBy(0.5);

    *pt    = PointAt(muv);

    // If this edge just approximates a curve, then refine our midpoint so
    // so that it actually lies on that curve too. Otherwise stuff like
    // point-on-face tests will fail, since the point won't actually lie
    // on the other face.
    hSCurve hc = { auxA };
    SCurve *sc = shell-&gt;curve.FindById(hc);
    if(sc-&gt;isExact &amp;&amp; sc-&gt;exact.deg != 1) {
        double t;
        sc-&gt;exact.ClosestPointTo(*pt, &amp;t, /*mustConverge=*/false);
        *pt = sc-&gt;exact.PointAt(t);
        ClosestPointTo(*pt, &amp;muv);
    } else if(!sc-&gt;isExact) {
        SSurface *trimmedA = sc-&gt;GetSurfaceA(sha, shb),
                       *trimmedB = sc-&gt;GetSurfaceB(sha, shb);
        *pt = trimmedA-&gt;ClosestPointOnThisAndSurface(trimmedB, *pt);
        ClosestPointTo(*pt, &amp;muv);
    }

    *surfn = NormalAt(muv.x, muv.y);

    // Compute the edge's inner normal in xyz space.
    Vector ab    = (PointAt(auv)).Minus(PointAt(buv)),
           enxyz = (ab.Cross(*surfn)).WithMagnitude(SS.ChordTolMm());
    // And based on that, compute the edge's inner normal in uv space. This
    // vector is perpendicular to the edge in xyz, but not necessarily in uv.
    Vector tu, tv;
    TangentsAt(muv.x, muv.y, &amp;tu, &amp;tv);
    Point2d enuv;
    enuv.x = enxyz.Dot(tu) / tu.MagSquared();
    enuv.y = enxyz.Dot(tv) / tv.MagSquared();

    // Compute the inner and outer normals of this edge (within the srf),
    // in xyz space. These are not necessarily antiparallel, if the
    // surface is curved.
    Vector pin   = PointAt(muv.Minus(enuv)),
           pout  = PointAt(muv.Plus(enuv));
    *enin  = pin.Minus(*pt),
    *enout = pout.Minus(*pt);
}

//-----------------------------------------------------------------------------
// Trim this surface against the specified shell, in the way that's appropriate
// for the specified Boolean operation type (and which operand we are). We
// also need a pointer to the shell that contains our own surface, since that
// contains our original trim curves.
//-----------------------------------------------------------------------------
SSurface SSurface::MakeCopyTrimAgainst(SShell *parent,
                                       SShell *sha, SShell *shb,
                                       SShell *into,
                                       SSurface::CombineAs type)
{
    bool opA = (parent == sha);
    SShell *agnst = opA ? shb : sha;

    SSurface ret;
    // The returned surface is identical, just the trim curves change
    ret = *this;
    ret.trim = {};

    // First, build a list of the existing trim curves; update them to use
    // the split curves.
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        STrimBy stn = *stb;
        stn.curve = (parent-&gt;curve.FindById(stn.curve))-&gt;newH;
        ret.trim.Add(&amp;stn);
    }

    if(type == SSurface::CombineAs::DIFFERENCE &amp;&amp; !opA) {
        // The second operand of a Boolean difference gets turned inside out
        ret.Reverse();
    }

    // Build up our original trim polygon; remember the coordinates could
    // be changed if we just flipped the surface normal, and we are using
    // the split curves (not the original curves).
    SEdgeList orig = {};
    ret.MakeEdgesInto(into, &amp;orig, MakeAs::UV);
    ret.trim.Clear();
    // which means that we can't necessarily use the old BSP...
    SBspUv *origBsp = SBspUv::From(&amp;orig, &amp;ret);

    // And now intersect the other shell against us
    SEdgeList inter = {};

    SSurface *ss;
    for(ss = agnst-&gt;surface.First(); ss; ss = agnst-&gt;surface.NextAfter(ss)) {
        SCurve *sc;
        for(sc = into-&gt;curve.First(); sc; sc = into-&gt;curve.NextAfter(sc)) {
            if(sc-&gt;source != SCurve::Source::INTERSECTION) continue;
            if(opA) {
                if(sc-&gt;surfA.v != h.v || sc-&gt;surfB.v != ss-&gt;h.v) continue;
            } else {
                if(sc-&gt;surfB.v != h.v || sc-&gt;surfA.v != ss-&gt;h.v) continue;
            }

            int i;
            for(i = 1; i &lt; sc-&gt;pts.n; i++) {
                Vector a = sc-&gt;pts.elem[i-1].p,
                       b = sc-&gt;pts.elem[i].p;

                Point2d auv, buv;
                ss-&gt;ClosestPointTo(a, &amp;(auv.x), &amp;(auv.y));
                ss-&gt;ClosestPointTo(b, &amp;(buv.x), &amp;(buv.y));

                SBspUv::Class c = (ss-&gt;bsp) ? ss-&gt;bsp-&gt;ClassifyEdge(auv, buv, ss) : SBspUv::Class::OUTSIDE;
                if(c != SBspUv::Class::OUTSIDE) {
                    Vector ta = Vector::From(0, 0, 0);
                    Vector tb = Vector::From(0, 0, 0);
                    ret.ClosestPointTo(a, &amp;(ta.x), &amp;(ta.y));
                    ret.ClosestPointTo(b, &amp;(tb.x), &amp;(tb.y));

                    Vector tn = ret.NormalAt(ta.x, ta.y);
                    Vector sn = ss-&gt;NormalAt(auv.x, auv.y);

                    // We are subtracting the portion of our surface that
                    // lies in the shell, so the in-plane edge normal should
                    // point opposite to the surface normal.
                    bool bkwds = true;
                    if((tn.Cross(b.Minus(a))).Dot(sn) &lt; 0) bkwds = !bkwds;
                    if(type == SSurface::CombineAs::DIFFERENCE &amp;&amp; !opA) bkwds = !bkwds;
                    if(bkwds) {
                        inter.AddEdge(tb, ta, sc-&gt;h.v, 1);
                    } else {
                        inter.AddEdge(ta, tb, sc-&gt;h.v, 0);
                    }
                }
            }
        }
    }

    // Record all the points where more than two edges join, which I will call
    // the choosing points. If two edges join at a non-choosing point, then
    // they must either both be kept or both be discarded (since that would
    // otherwise create an open contour).
    SPointList choosing = {};
    SEdge *se;
    for(se = orig.l.First(); se; se = orig.l.NextAfter(se)) {
        choosing.IncrementTagFor(se-&gt;a);
        choosing.IncrementTagFor(se-&gt;b);
    }
    for(se = inter.l.First(); se; se = inter.l.NextAfter(se)) {
        choosing.IncrementTagFor(se-&gt;a);
        choosing.IncrementTagFor(se-&gt;b);
    }
    SPoint *sp;
    for(sp = choosing.l.First(); sp; sp = choosing.l.NextAfter(sp)) {
        if(sp-&gt;tag == 2) {
            sp-&gt;tag = 1;
        } else {
            sp-&gt;tag = 0;
        }
    }
    choosing.l.RemoveTagged();

    // The list of edges to trim our new surface, a combination of edges from
    // our original and intersecting edge lists.
    SEdgeList final = {};

    while(orig.l.n &gt; 0) {
        SEdgeList chain = {};
        FindChainAvoiding(&amp;orig, &amp;chain, &amp;choosing);

        // Arbitrarily choose an edge within the chain to classify; they
        // should all be the same, though.
        se = &amp;(chain.l.elem[chain.l.n/2]);

        Point2d auv  = (se-&gt;a).ProjectXy(),
                buv  = (se-&gt;b).ProjectXy();

        Vector pt, enin, enout, surfn;
        ret.EdgeNormalsWithinSurface(auv, buv, &amp;pt, &amp;enin, &amp;enout, &amp;surfn,
                                        se-&gt;auxA, into, sha, shb);

        SShell::Class indir_shell, outdir_shell, indir_orig, outdir_orig;

        indir_orig  = SShell::Class::INSIDE;
        outdir_orig = SShell::Class::OUTSIDE;

        agnst-&gt;ClassifyEdge(&amp;indir_shell, &amp;outdir_shell,
                            ret.PointAt(auv), ret.PointAt(buv), pt,
                            enin, enout, surfn);

        if(KeepEdge(type, opA, indir_shell, outdir_shell,
                               indir_orig,  outdir_orig))
        {
            for(se = chain.l.First(); se; se = chain.l.NextAfter(se)) {
                final.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
            }
        }
        chain.Clear();
    }

    while(inter.l.n &gt; 0) {
        SEdgeList chain = {};
        FindChainAvoiding(&amp;inter, &amp;chain, &amp;choosing);

        // Any edge in the chain, same as above.
        se = &amp;(chain.l.elem[chain.l.n/2]);

        Point2d auv = (se-&gt;a).ProjectXy(),
                buv = (se-&gt;b).ProjectXy();

        Vector pt, enin, enout, surfn;
        ret.EdgeNormalsWithinSurface(auv, buv, &amp;pt, &amp;enin, &amp;enout, &amp;surfn,
                                        se-&gt;auxA, into, sha, shb);

        SShell::Class indir_shell, outdir_shell, indir_orig, outdir_orig;

        SBspUv::Class c_this = (origBsp) ? origBsp-&gt;ClassifyEdge(auv, buv, &amp;ret) : SBspUv::Class::OUTSIDE;
        TagByClassifiedEdge(c_this, &amp;indir_orig, &amp;outdir_orig);

        agnst-&gt;ClassifyEdge(&amp;indir_shell, &amp;outdir_shell,
                            ret.PointAt(auv), ret.PointAt(buv), pt,
                            enin, enout, surfn);

        if(KeepEdge(type, opA, indir_shell, outdir_shell,
                               indir_orig,  outdir_orig))
        {
            for(se = chain.l.First(); se; se = chain.l.NextAfter(se)) {
                final.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
            }
        }
        chain.Clear();
    }

    // Cull extraneous edges; duplicates or anti-parallel pairs. In particular,
    // we can get duplicate edges if our surface intersects the other shell
    // at an edge, so that both surfaces intersect coincident (and both
    // generate an intersection edge).
    final.CullExtraneousEdges();

    // Use our reassembled edges to trim the new surface.
    ret.TrimFromEdgeList(&amp;final, /*asUv=*/true);

    SPolygon poly = {};
    final.l.ClearTags();
    if(!final.AssemblePolygon(&amp;poly, NULL, /*keepDir=*/true)) {
        into-&gt;booleanFailed = true;
        dbp("failed: I=%d, avoid=%d", I, choosing.l.n);
        DEBUGEDGELIST(&amp;final, &amp;ret);
    }
    poly.Clear();

    choosing.Clear();
    final.Clear();
    inter.Clear();
    orig.Clear();
    return ret;
}

</t>
<t tx="leo1.20171224221236.87">void SShell::CopySurfacesTrimAgainst(SShell *sha, SShell *shb, SShell *into, SSurface::CombineAs type) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        SSurface ssn;
        ssn = ss-&gt;MakeCopyTrimAgainst(this, sha, shb, into, type);
        ss-&gt;newH = into-&gt;surface.AddAndAssignId(&amp;ssn);
        I++;
    }
}

</t>
<t tx="leo1.20171224221236.88">void SShell::MakeIntersectionCurvesAgainst(SShell *agnst, SShell *into) {
    SSurface *sa;
    for(sa = surface.First(); sa; sa = surface.NextAfter(sa)) {
        SSurface *sb;
        for(sb = agnst-&gt;surface.First(); sb; sb = agnst-&gt;surface.NextAfter(sb)){
            // Intersect every surface from our shell against every surface
            // from agnst; this will add zero or more curves to the curve
            // list for into.
            sa-&gt;IntersectAgainst(sb, this, agnst, into);
        }
    }
}

</t>
<t tx="leo1.20171224221236.89">void SShell::CleanupAfterBoolean() {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;edges.Clear();
    }
}

//-----------------------------------------------------------------------------
// All curves contain handles to the two surfaces that they trim. After a
// Boolean or assembly, we must rewrite those handles to refer to the curves
// by their new IDs.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.9">void OpenGl2Renderer::DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    SEdgeListItem *eli = lines.FindByIdNoOops(hcs);
    if(eli == NULL) {
        SEdgeListItem item = {};
        item.h = hcs;
        lines.Add(&amp;item);
        eli = lines.FindByIdNoOops(hcs);
    }

    eli-&gt;lines.AddEdge(a, b);
}

</t>
<t tx="leo1.20171224221236.90">void SShell::RewriteSurfaceHandlesForCurves(SShell *a, SShell *b) {
    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        sc-&gt;surfA = sc-&gt;GetSurfaceA(a, b)-&gt;newH,
        sc-&gt;surfB = sc-&gt;GetSurfaceB(a, b)-&gt;newH;
    }
}

//-----------------------------------------------------------------------------
// Copy all the surfaces and curves from two different shells into a single
// shell. The only difficulty is to rewrite all of their handles; we don't
// look for any surface intersections, so if two objects interfere then the
// result is just self-intersecting. This is used for assembly, since it's
// much faster than merging as union.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.91">void SShell::MakeFromAssemblyOf(SShell *a, SShell *b) {
    booleanFailed = false;

    Vector t = Vector::From(0, 0, 0);
    Quaternion q = Quaternion::IDENTITY;
    int i = 0;
    SShell *ab;

    // First, copy over all the curves. Note which shell (a or b) each curve
    // came from, but assign it a new ID.
    curve.ReserveMore(a-&gt;curve.n + b-&gt;curve.n);
    SCurve *c, cn;
    for(i = 0; i &lt; 2; i++) {
        ab = (i == 0) ? a : b;
        for(c = ab-&gt;curve.First(); c; c = ab-&gt;curve.NextAfter(c)) {
            cn = SCurve::FromTransformationOf(c, t, q, 1.0);
            cn.source = (i == 0) ? SCurve::Source::A : SCurve::Source::B;
            // surfA and surfB are wrong now, and we can't fix them until
            // we've assigned IDs to the surfaces. So we'll get that later.
            c-&gt;newH = curve.AddAndAssignId(&amp;cn);
        }
    }

    // Likewise copy over all the surfaces.
    surface.ReserveMore(a-&gt;surface.n + b-&gt;surface.n);
    SSurface *s, sn;
    for(i = 0; i &lt; 2; i++) {
        ab = (i == 0) ? a : b;
        for(s = ab-&gt;surface.First(); s; s = ab-&gt;surface.NextAfter(s)) {
            sn = SSurface::FromTransformationOf(s, t, q, 1.0, /*includingTrims=*/true);
            // All the trim curve IDs get rewritten; we know the new handles
            // to the curves since we recorded them in the previous step.
            STrimBy *stb;
            for(stb = sn.trim.First(); stb; stb = sn.trim.NextAfter(stb)) {
                stb-&gt;curve = ab-&gt;curve.FindById(stb-&gt;curve)-&gt;newH;
            }
            s-&gt;newH = surface.AddAndAssignId(&amp;sn);
        }
    }

    // Finally, rewrite the surfaces associated with each curve to use the
    // new handles.
    RewriteSurfaceHandlesForCurves(a, b);
}

</t>
<t tx="leo1.20171224221236.92">void SShell::MakeFromBoolean(SShell *a, SShell *b, SSurface::CombineAs type) {
    booleanFailed = false;

    a-&gt;MakeClassifyingBsps(NULL);
    b-&gt;MakeClassifyingBsps(NULL);

    // Copy over all the original curves, splitting them so that a
    // piecwise linear segment never crosses a surface from the other
    // shell.
    a-&gt;CopyCurvesSplitAgainst(/*opA=*/true,  b, this);
    b-&gt;CopyCurvesSplitAgainst(/*opA=*/false, a, this);

    // Generate the intersection curves for each surface in A against all
    // the surfaces in B (which is all of the intersection curves).
    a-&gt;MakeIntersectionCurvesAgainst(b, this);

    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        SSurface *srfA = sc-&gt;GetSurfaceA(a, b),
                       *srfB = sc-&gt;GetSurfaceB(a, b);

        sc-&gt;RemoveShortSegments(srfA, srfB);
    }

    // And clean up the piecewise linear things we made as a calculation aid
    a-&gt;CleanupAfterBoolean();
    b-&gt;CleanupAfterBoolean();
    // Remake the classifying BSPs with the split (and short-segment-removed)
    // curves
    a-&gt;MakeClassifyingBsps(this);
    b-&gt;MakeClassifyingBsps(this);

    if(b-&gt;surface.n == 0 || a-&gt;surface.n == 0) {
        I = 1000000;
    } else {
        I = 0;
    }
    // Then trim and copy the surfaces
    a-&gt;CopySurfacesTrimAgainst(a, b, this, type);
    b-&gt;CopySurfacesTrimAgainst(a, b, this, type);

    // Now that we've copied the surfaces, we know their new hSurfaces, so
    // rewrite the curves to refer to the surfaces by their handles in the
    // result.
    RewriteSurfaceHandlesForCurves(a, b);

    // And clean up the piecewise linear things we made as a calculation aid
    a-&gt;CleanupAfterBoolean();
    b-&gt;CleanupAfterBoolean();
}

//-----------------------------------------------------------------------------
// All of the BSP routines that we use to perform and accelerate polygon ops.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221236.93">void SShell::MakeClassifyingBsps(SShell *useCurvesFrom) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;MakeClassifyingBsp(this, useCurvesFrom);
    }
}

</t>
<t tx="leo1.20171224221236.94">void SSurface::MakeClassifyingBsp(SShell *shell, SShell *useCurvesFrom) {
    SEdgeList el = {};

    MakeEdgesInto(shell, &amp;el, MakeAs::UV, useCurvesFrom);
    bsp = SBspUv::From(&amp;el, this);
    el.Clear();

    edges = {};
    MakeEdgesInto(shell, &amp;edges, MakeAs::XYZ, useCurvesFrom);
}

SBspUv *SBspUv::Alloc() {
    return (SBspUv *)AllocTemporary(sizeof(SBspUv));
}

</t>
<t tx="leo1.20171224221236.95">static int ByLength(const void *av, const void *bv)
{
    SEdge *a = (SEdge *)av,
          *b = (SEdge *)bv;

    @others
}

//-----------------------------------------------------------------------------
// The points in this BSP are in uv space, but we want to apply our tolerances
// consistently in xyz (i.e., we want to say a point is on-edge if its xyz
// distance to that edge is less than LENGTH_EPS, irrespective of its distance
// in uv). So we linearize the surface about the point we're considering and
// then do the test. That preserves point-on-line relationships, and the only
// time we care about exact correctness is when we're very close to the line,
// which is when the linearization is accurate.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221236.96">    double la = (a-&gt;a).Minus(a-&gt;b).Magnitude(),
           lb = (b-&gt;a).Minus(b-&gt;b).Magnitude();

    // Sort in descending order, longest first. This improves numerical
    // stability for the normals.
    return (la &lt; lb) ? 1 : -1;
}

SBspUv *SBspUv::From(SEdgeList *el, SSurface *srf) {
    SEdgeList work = {};

    SEdge *se;
    for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
        work.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
    }
    qsort(work.l.elem, work.l.n, sizeof(work.l.elem[0]), ByLength);

    SBspUv *bsp = NULL;
    for(se = work.l.First(); se; se = work.l.NextAfter(se)) {
        bsp = InsertOrCreateEdge(bsp, (se-&gt;a).ProjectXy(), (se-&gt;b).ProjectXy(), srf);
    }

    work.Clear();
    return bsp;
</t>
<t tx="leo1.20171224221236.97">void SBspUv::ScalePoints(Point2d *pt, Point2d *a, Point2d *b, SSurface *srf) const {
    Vector tu, tv;
    srf-&gt;TangentsAt(pt-&gt;x, pt-&gt;y, &amp;tu, &amp;tv);
    double mu = tu.Magnitude(), mv = tv.Magnitude();

    pt-&gt;x *= mu; pt-&gt;y *= mv;
    a -&gt;x *= mu; a -&gt;y *= mv;
    b -&gt;x *= mu; b -&gt;y *= mv;
}

double SBspUv::ScaledSignedDistanceToLine(Point2d pt, Point2d a, Point2d b,
                                          SSurface *srf) const
{
    ScalePoints(&amp;pt, &amp;a, &amp;b, srf);

    Point2d n = ((b.Minus(a)).Normal()).WithMagnitude(1);
    double d = a.Dot(n);

    return pt.Dot(n) - d;
}

double SBspUv::ScaledDistanceToLine(Point2d pt, Point2d a, Point2d b, bool asSegment,
                                    SSurface *srf) const
{
    ScalePoints(&amp;pt, &amp;a, &amp;b, srf);

    return pt.DistanceToLine(a, b, asSegment);
}

SBspUv *SBspUv::InsertOrCreateEdge(SBspUv *where, Point2d ea, Point2d eb, SSurface *srf) {
    if(where == NULL) {
        SBspUv *ret = Alloc();
        ret-&gt;a = ea;
        ret-&gt;b = eb;
        return ret;
    }
    where-&gt;InsertEdge(ea, eb, srf);
    return where;
}

</t>
<t tx="leo1.20171224221236.98">void SBspUv::InsertEdge(Point2d ea, Point2d eb, SSurface *srf) {
    @others
}

SBspUv::Class SBspUv::ClassifyPoint(Point2d p, Point2d eb, SSurface *srf) const {
    double dp = ScaledSignedDistanceToLine(p, a, b, srf);

    if(fabs(dp) &lt; LENGTH_EPS) {
        const SBspUv *f = this;
        while(f) {
            Point2d ba = (f-&gt;b).Minus(f-&gt;a);
            if(ScaledDistanceToLine(p, f-&gt;a, ba, /*asSegment=*/true, srf) &lt; LENGTH_EPS) {
                if(ScaledDistanceToLine(eb, f-&gt;a, ba, /*asSegment=*/false, srf) &lt; LENGTH_EPS){
                    if(ba.Dot(eb.Minus(p)) &gt; 0) {
                        return Class::EDGE_PARALLEL;
                    } else {
                        return Class::EDGE_ANTIPARALLEL;
                    }
                } else {
                    return Class::EDGE_OTHER;
                }
            }
            f = f-&gt;more;
        }
        // Pick arbitrarily which side to send it down, doesn't matter
        Class c1 =  neg ? neg-&gt;ClassifyPoint(p, eb, srf) : Class::OUTSIDE;
        Class c2 =  pos ? pos-&gt;ClassifyPoint(p, eb, srf) : Class::INSIDE;
        if(c1 != c2) {
            dbp("MISMATCH: %d %d %08x %08x", c1, c2, neg, pos);
        }
        return c1;
    } else if(dp &gt; 0) {
        return pos ? pos-&gt;ClassifyPoint(p, eb, srf) : Class::INSIDE;
    } else {
        return neg ? neg-&gt;ClassifyPoint(p, eb, srf) : Class::OUTSIDE;
    }
}

SBspUv::Class SBspUv::ClassifyEdge(Point2d ea, Point2d eb, SSurface *srf) const {
    SBspUv::Class ret = ClassifyPoint((ea.Plus(eb)).ScaledBy(0.5), eb, srf);
    if(ret == Class::EDGE_OTHER) {
        // Perhaps the edge is tangent at its midpoint (and we screwed up
        // somewhere earlier and failed to split it); try a different
        // point on the edge.
        ret = ClassifyPoint(ea.Plus((eb.Minus(ea)).ScaledBy(0.294)), eb, srf);
    }
    return ret;
}

double SBspUv::MinimumDistanceToEdge(Point2d p, SSurface *srf) const {

    double dn = (neg) ? neg-&gt;MinimumDistanceToEdge(p, srf) : VERY_POSITIVE;
    double dp = (pos) ? pos-&gt;MinimumDistanceToEdge(p, srf) : VERY_POSITIVE;

    Point2d as = a, bs = b;
    ScalePoints(&amp;p, &amp;as, &amp;bs, srf);
    double d = p.DistanceToLine(as, bs.Minus(as), /*asSegment=*/true);

    return min(d, min(dn, dp));
}

</t>
<t tx="leo1.20171224221236.99">double dea = ScaledSignedDistanceToLine(ea, a, b, srf),
       deb = ScaledSignedDistanceToLine(eb, a, b, srf);

if(fabs(dea) &lt; LENGTH_EPS &amp;&amp; fabs(deb) &lt; LENGTH_EPS) {
    // Line segment is coincident with this one, store in same node
    SBspUv *m = Alloc();
    m-&gt;a = ea;
    m-&gt;b = eb;
    m-&gt;more = more;
    more = m;
} else if(fabs(dea) &lt; LENGTH_EPS) {
    // Point A lies on this lie, but point B does not
    if(deb &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, eb, srf);
    }
} else if(fabs(deb) &lt; LENGTH_EPS) {
    // Point B lies on this lie, but point A does not
    if(dea &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, eb, srf);
    }
} else if(dea &gt; 0 &amp;&amp; deb &gt; 0) {
    pos = InsertOrCreateEdge(pos, ea, eb, srf);
} else if(dea &lt; 0 &amp;&amp; deb &lt; 0) {
    neg = InsertOrCreateEdge(neg, ea, eb, srf);
} else {
    // New edge crosses this one; we need to split.
    Point2d n = ((b.Minus(a)).Normal()).WithMagnitude(1);
    double d = a.Dot(n);
    double t = (d - n.Dot(ea)) / (n.Dot(eb.Minus(ea)));
    Point2d pi = ea.Plus((eb.Minus(ea)).ScaledBy(t));
    if(dea &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, pi, srf);
        neg = InsertOrCreateEdge(neg, pi, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, pi, srf);
        pos = InsertOrCreateEdge(pos, pi, eb, srf);
    }
}
return;
</t>
<t tx="leo1.20171224221237.1">void SSurface::TriangulateInto(SShell *shell, SMesh *sm) {
    SEdgeList el = {};

    MakeEdgesInto(shell, &amp;el, MakeAs::UV);

    SPolygon poly = {};
    if(el.AssemblePolygon(&amp;poly, NULL, /*keepDir=*/true)) {
        int i, start = sm-&gt;l.n;
        if(degm == 1 &amp;&amp; degn == 1) {
            // A surface with curvature along one direction only; so
            // choose the triangulation with chords that lie as much
            // as possible within the surface. And since the trim curves
            // have been pwl'd to within the desired chord tol, that will
            // produce a surface good to within roughly that tol.
            //
            // If this is just a plane (degree (1, 1)) then the triangulation
            // code will notice that, and not bother checking chord tols.
            poly.UvTriangulateInto(sm, this);
        } else {
            // A surface with compound curvature. So we must overlay a
            // two-dimensional grid, and triangulate around that.
            poly.UvGridTriangulateInto(sm, this);
        }

        STriMeta meta = { face, color };
        for(i = start; i &lt; sm-&gt;l.n; i++) {
            STriangle *st = &amp;(sm-&gt;l.elem[i]);
            st-&gt;meta = meta;
            st-&gt;an = NormalAt(st-&gt;a.x, st-&gt;a.y);
            st-&gt;bn = NormalAt(st-&gt;b.x, st-&gt;b.y);
            st-&gt;cn = NormalAt(st-&gt;c.x, st-&gt;c.y);
            st-&gt;a = PointAt(st-&gt;a.x, st-&gt;a.y);
            st-&gt;b = PointAt(st-&gt;b.x, st-&gt;b.y);
            st-&gt;c = PointAt(st-&gt;c.x, st-&gt;c.y);
            // Works out that my chosen contour direction is inconsistent with
            // the triangle direction, sigh.
            st-&gt;FlipNormal();
        }
    } else {
        dbp("failed to assemble polygon to trim nurbs surface in uv space");
    }

    el.Clear();
    poly.Clear();
}

//-----------------------------------------------------------------------------
// Reverse the parametrisation of one of our dimensions, which flips the
// normal. We therefore must reverse all our trim curves too. The uv
// coordinates change, but trim curves are stored as xyz so nothing happens
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221237.10">void SShell::MakeFromTransformationOf(SShell *a,
                                      Vector t, Quaternion q, double scale)
{
    booleanFailed = false;
    surface.ReserveMore(a-&gt;surface.n);
    SSurface *s;
    for(s = a-&gt;surface.First(); s; s = a-&gt;surface.NextAfter(s)) {
        SSurface n;
        n = SSurface::FromTransformationOf(s, t, q, scale, /*includingTrims=*/true);
        surface.Add(&amp;n); // keeping the old ID
    }

    curve.ReserveMore(a-&gt;curve.n);
    SCurve *c;
    for(c = a-&gt;curve.First(); c; c = a-&gt;curve.NextAfter(c)) {
        SCurve n;
        n = SCurve::FromTransformationOf(c, t, q, scale);
        curve.Add(&amp;n); // keeping the old ID
    }
}

</t>
<t tx="leo1.20171224221237.11">void SShell::MakeEdgesInto(SEdgeList *sel) {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;MakeEdgesInto(this, sel, SSurface::MakeAs::XYZ);
    }
}

</t>
<t tx="leo1.20171224221237.12">void SShell::MakeSectionEdgesInto(Vector n, double d, SEdgeList *sel, SBezierList *sbl)
{
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        if(s-&gt;CoincidentWithPlane(n, d)) {
            s-&gt;MakeSectionEdgesInto(this, sel, sbl);
        }
    }
}

</t>
<t tx="leo1.20171224221237.13">void SShell::TriangulateInto(SMesh *sm) {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;TriangulateInto(this, sm);
    }
}

</t>
<t tx="leo1.20171224221237.14">bool SShell::IsEmpty() const {
    return (surface.n == 0);
}

</t>
<t tx="leo1.20171224221237.15">void SShell::Clear() {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;Clear();
    }
    surface.Clear();

    SCurve *c;
    for(c = curve.First(); c; c = curve.NextAfter(c)) {
        c-&gt;Clear();
    }
    curve.Clear();
}

</t>
<t tx="leo1.20171224221237.16">//-----------------------------------------------------------------------------
// How to intersect two surfaces, to get some type of curve. This is either
// an exact special case (e.g., two planes to make a line), or a numerical
// thing.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

extern int FLAG;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221237.17">void SSurface::AddExactIntersectionCurve(SBezier *sb, SSurface *srfB,
                                         SShell *agnstA, SShell *agnstB, SShell *into)
{
    SCurve sc = {};
    // Important to keep the order of (surfA, surfB) consistent; when we later
    // rewrite the identifiers, we rewrite surfA from A and surfB from B.
    sc.surfA = h;
    sc.surfB = srfB-&gt;h;
    sc.exact = *sb;
    sc.isExact = true;

    // Now we have to piecewise linearize the curve. If there's already an
    // identical curve in the shell, then follow that pwl exactly, otherwise
    // calculate from scratch.
    SCurve split, *existing = NULL, *se;
    SBezier sbrev = *sb;
    sbrev.Reverse();
    bool backwards = false;
    for(se = into-&gt;curve.First(); se; se = into-&gt;curve.NextAfter(se)) {
        if(se-&gt;isExact) {
            if(sb-&gt;Equals(&amp;(se-&gt;exact))) {
                existing = se;
                break;
            }
            if(sbrev.Equals(&amp;(se-&gt;exact))) {
                existing = se;
                backwards = true;
                break;
            }
        }
    }
    if(existing) {
        SCurvePt *v;
        for(v = existing-&gt;pts.First(); v; v = existing-&gt;pts.NextAfter(v)) {
            sc.pts.Add(v);
        }
        if(backwards) sc.pts.Reverse();
        split = sc;
        sc = {};
    } else {
        sb-&gt;MakePwlInto(&amp;(sc.pts));
        // and split the line where it intersects our existing surfaces
        split = sc.MakeCopySplitAgainst(agnstA, agnstB, this, srfB);
        sc.Clear();
    }

    // Test if the curve lies entirely outside one of the
    SCurvePt *scpt;
    bool withinA = false, withinB = false;
    for(scpt = split.pts.First(); scpt; scpt = split.pts.NextAfter(scpt)) {
        double tol = 0.01;
        Point2d puv;
        ClosestPointTo(scpt-&gt;p, &amp;puv);
        if(puv.x &gt; -tol &amp;&amp; puv.x &lt; 1 + tol &amp;&amp;
           puv.y &gt; -tol &amp;&amp; puv.y &lt; 1 + tol)
        {
            withinA = true;
        }
        srfB-&gt;ClosestPointTo(scpt-&gt;p, &amp;puv);
        if(puv.x &gt; -tol &amp;&amp; puv.x &lt; 1 + tol &amp;&amp;
           puv.y &gt; -tol &amp;&amp; puv.y &lt; 1 + tol)
        {
            withinB = true;
        }
        // Break out early, no sense wasting time if we already have the answer.
        if(withinA &amp;&amp; withinB) break;
    }
    if(!(withinA &amp;&amp; withinB)) {
        // Intersection curve lies entirely outside one of the surfaces, so
        // it's fake.
        split.Clear();
        return;
    }

#if 0
    if(sb-&gt;deg == 2) {
        dbp(" ");
        SCurvePt *prev = NULL, *v;
        dbp("split.pts.n = %d", split.pts.n);
        for(v = split.pts.First(); v; v = split.pts.NextAfter(v)) {
            if(prev) {
                Vector e = (prev-&gt;p).Minus(v-&gt;p).WithMagnitude(0);
                SS.nakedEdges.AddEdge((prev-&gt;p).Plus(e), (v-&gt;p).Minus(e));
            }
            prev = v;
        }
    }
#endif // 0
    ssassert(!(sb-&gt;Start()).Equals(sb-&gt;Finish()),
             "Unexpected zero-length edge");

    split.source = SCurve::Source::INTERSECTION;
    into-&gt;curve.AddAndAssignId(&amp;split);
}

</t>
<t tx="leo1.20171224221237.18">void SSurface::IntersectAgainst(SSurface *b, SShell *agnstA, SShell *agnstB,
                                SShell *into)
{
    Vector amax, amin, bmax, bmin;
    GetAxisAlignedBounding(&amp;amax, &amp;amin);
    b-&gt;GetAxisAlignedBounding(&amp;bmax, &amp;bmin);

    if(Vector::BoundingBoxesDisjoint(amax, amin, bmax, bmin)) {
        // They cannot possibly intersect, no curves to generate
        return;
    }

    Vector alongt, alongb;
    SBezier oft, ofb;
    @others
}

//-----------------------------------------------------------------------------
// Are two surfaces coincident, with the same (or with opposite) normals?
// Currently handles planes only.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221237.19">bool isExtdt = this-&gt;IsExtrusion(&amp;oft, &amp;alongt),
     isExtdb =    b-&gt;IsExtrusion(&amp;ofb, &amp;alongb);

if(degm == 1 &amp;&amp; degn == 1 &amp;&amp; b-&gt;degm == 1 &amp;&amp; b-&gt;degn == 1) {
    // Line-line intersection; it's a plane or nothing.
    Vector na = NormalAt(0, 0).WithMagnitude(1),
           nb = b-&gt;NormalAt(0, 0).WithMagnitude(1);
    double da = na.Dot(PointAt(0, 0)),
    int i;
    double tmax = VERY_POSITIVE, tmin = VERY_NEGATIVE;
    for(i = 0; i &lt; 2; i++) {
        SSurface *s = (i == 0) ? this : b;
        Vector tu, tv;
        s-&gt;TangentsAt(0, 0, &amp;tu, &amp;tv);

        double up, vp, ud, vd;
        s-&gt;ClosestPointTo(p, &amp;up, &amp;vp);
        ud = (dl.Dot(tu)) / tu.MagSquared();
        vd = (dl.Dot(tv)) / tv.MagSquared();

        // so u = up + t*ud
        //    v = vp + t*vd
        if(ud &gt; LENGTH_EPS) {
            tmin = max(tmin, -up/ud);
            tmax = min(tmax, (1 - up)/ud);
        } else if(ud &lt; -LENGTH_EPS) {
            tmax = min(tmax, -up/ud);
            tmin = max(tmin, (1 - up)/ud);
        } else {
            if(up &lt; -LENGTH_EPS || up &gt; 1 + LENGTH_EPS) {
                // u is constant, and outside [0, 1]
                tmax = VERY_NEGATIVE;
            }
        }
        if(vd &gt; LENGTH_EPS) {
            tmin = max(tmin, -vp/vd);
            tmax = min(tmax, (1 - vp)/vd);
        } else if(vd &lt; -LENGTH_EPS) {
            tmax = min(tmax, -vp/vd);
            tmin = max(tmin, (1 - vp)/vd);
        } else {
            if(vp &lt; -LENGTH_EPS || vp &gt; 1 + LENGTH_EPS) {
                // v is constant, and outside [0, 1]
                tmax = VERY_NEGATIVE;
            }
        }
    }

    if(tmax &gt; tmin + LENGTH_EPS) {
        SBezier bezier = SBezier::From(p.Plus(dl.ScaledBy(tmin)),
                                       p.Plus(dl.ScaledBy(tmax)));
        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }
} else if((degm == 1 &amp;&amp; degn == 1 &amp;&amp; isExtdb) ||
          (b-&gt;degm == 1 &amp;&amp; b-&gt;degn == 1 &amp;&amp; isExtdt))
{
    // The intersection between a plane and a surface of extrusion
    SSurface *splane, *sext;
    if(degm == 1 &amp;&amp; degn == 1) {
        splane = this;
        sext = b;
    } else {
        splane = b;
        sext = this;
    }

    Vector n = splane-&gt;NormalAt(0, 0).WithMagnitude(1), along;
    double d = n.Dot(splane-&gt;PointAt(0, 0));
    SBezier bezier;
    (void)sext-&gt;IsExtrusion(&amp;bezier, &amp;along);

    if(fabs(n.Dot(along)) &lt; LENGTH_EPS) {
        // Direction of extrusion is parallel to plane; so intersection
        // is zero or more lines. Build a line within the plane, and
        // normal to the direction of extrusion, and intersect that line
        // against the surface; each intersection point corresponds to
        // a line.
        Vector pm, alu, p0, dp;
        // a point halfway along the extrusion
        pm = ((sext-&gt;ctrl[0][0]).Plus(sext-&gt;ctrl[0][1])).ScaledBy(0.5);
        alu = along.WithMagnitude(1);
        dp = (n.Cross(along)).WithMagnitude(1);
        // n, alu, and dp form an orthogonal csys; set n component to
        // place it on the plane, alu component to lie halfway along
        // extrusion, and dp component doesn't matter so zero
        p0 = n.ScaledBy(d).Plus(alu.ScaledBy(pm.Dot(alu)));

        List&lt;SInter&gt; inters = {};
        sext-&gt;AllPointsIntersecting(p0, p0.Plus(dp), &amp;inters,
            /*asSegment=*/false, /*trimmed=*/false, /*inclTangent=*/true);

        SInter *si;
        for(si = inters.First(); si; si = inters.NextAfter(si)) {
            Vector al = along.ScaledBy(0.5);
            SBezier bezier;
            bezier = SBezier::From((si-&gt;p).Minus(al), (si-&gt;p).Plus(al));
            AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
        }

        inters.Clear();
    } else {
        // Direction of extrusion is not parallel to plane; so
        // intersection is projection of extruded curve into our plane.
        int i;
        for(i = 0; i &lt;= bezier.deg; i++) {
            Vector p0 = bezier.ctrl[i],
                   p1 = p0.Plus(along);

            bezier.ctrl[i] =
                Vector::AtIntersectionOfPlaneAndLine(n, d, p0, p1, NULL);
        }

        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }
} else if(isExtdt &amp;&amp; isExtdb &amp;&amp;
            sqrt(fabs(alongt.Dot(alongb))) &gt;
            sqrt(alongt.Magnitude() * alongb.Magnitude()) - LENGTH_EPS)
{
    // Two surfaces of extrusion along the same axis. So they might
    // intersect along some number of lines parallel to the axis.
    Vector axis = alongt.WithMagnitude(1);

    List&lt;SInter&gt; inters = {};
    List&lt;Vector&gt; lv = {};

    double a_axis0 = (   ctrl[0][0]).Dot(axis),
    if(fabs(ab_axis0 - ab_axis1) &lt; LENGTH_EPS) {
        // The line would be zero-length
        return;
    }

    Vector axis0 = axis.ScaledBy(ab_axis0),
           axis1 = axis.ScaledBy(ab_axis1),
           axisc = (axis0.Plus(axis1)).ScaledBy(0.5);

    oft.MakePwlInto(&amp;lv);

    int i;
    for(i = 0; i &lt; lv.n - 1; i++) {
        Vector pa = lv.elem[i], pb = lv.elem[i+1];
        pa = pa.Minus(axis.ScaledBy(pa.Dot(axis)));
        pb = pb.Minus(axis.ScaledBy(pb.Dot(axis)));
        pa = pa.Plus(axisc);
        pb = pb.Plus(axisc);

        b-&gt;AllPointsIntersecting(pa, pb, &amp;inters,
            /*asSegment=*/true,/*trimmed=*/false, /*inclTangent=*/false);
    }

    SInter *si;
    for(si = inters.First(); si; si = inters.NextAfter(si)) {
        Vector p = (si-&gt;p).Minus(axis.ScaledBy((si-&gt;p).Dot(axis)));
        double ub, vb;
        b-&gt;ClosestPointTo(p, &amp;ub, &amp;vb, /*mustConverge=*/true);
        SSurface plane;
        plane = SSurface::FromPlane(p, axis.Normal(0), axis.Normal(1));

        b-&gt;PointOnSurfaces(this, &amp;plane, &amp;ub, &amp;vb);

        p = b-&gt;PointAt(ub, vb);

        SBezier bezier;
        bezier = SBezier::From(p.Plus(axis0), p.Plus(axis1));
        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }

    inters.Clear();
    lv.Clear();
} else {
    // Try intersecting the surfaces numerically, by a marching algorithm.
    // First, we find all the intersections between a surface and the
    // boundary of the other surface.
    SPointList spl = {};
    int a;
    for(a = 0; a &lt; 2; a++) {
        SShell   *shA  = (a == 0) ? agnstA : agnstB;
        SSurface *srfA = (a == 0) ? this : b,
                 *srfB = (a == 0) ? b : this;

        SEdgeList el = {};
        srfA-&gt;MakeEdgesInto(shA, &amp;el, MakeAs::XYZ, NULL);

        SEdge *se;
        for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
            List&lt;SInter&gt; lsi = {};

            srfB-&gt;AllPointsIntersecting(se-&gt;a, se-&gt;b, &amp;lsi,
                /*asSegment=*/true, /*trimmed=*/true, /*inclTangent=*/false);
            if(lsi.n == 0) continue;

            // Find the other surface that this curve trims.
            hSCurve hsc = { (uint32_t)se-&gt;auxA };
            SCurve *sc = shA-&gt;curve.FindById(hsc);
            hSSurface hother = (sc-&gt;surfA.v == srfA-&gt;h.v) ?
                                                sc-&gt;surfB : sc-&gt;surfA;
            SSurface *other = shA-&gt;surface.FindById(hother);

            SInter *si;
            for(si = lsi.First(); si; si = lsi.NextAfter(si)) {
                Vector p = si-&gt;p;
                double u, v;
                srfB-&gt;ClosestPointTo(p, &amp;u, &amp;v);
                srfB-&gt;PointOnSurfaces(srfA, other, &amp;u, &amp;v);
                p = srfB-&gt;PointAt(u, v);
                if(!spl.ContainsPoint(p)) {
                    SPoint sp;
                    sp.p = p;
                    // We also need the edge normal, so that we know in
                    // which direction to march.
                    srfA-&gt;ClosestPointTo(p, &amp;u, &amp;v);
                    Vector n = srfA-&gt;NormalAt(u, v);
                    sp.auxv = n.Cross((se-&gt;b).Minus(se-&gt;a));
                    sp.auxv = (sp.auxv).WithMagnitude(1);

                    spl.l.Add(&amp;sp);
                }
            }
            lsi.Clear();
        }

        el.Clear();
    }

    while(spl.l.n &gt;= 2) {
        SCurve sc = {};
        sc.surfA = h;
        sc.surfB = b-&gt;h;
        sc.isExact = false;
        sc.source = SCurve::Source::INTERSECTION;

        Vector start  = spl.l.elem[0].p,
               startv = spl.l.elem[0].auxv;
        spl.l.ClearTags();
        spl.l.elem[0].tag = 1;
        spl.l.RemoveTagged();

        // Our chord tolerance is whatever the user specified
        double maxtol = SS.ChordTolMm();
        int maxsteps = max(300, SS.GetMaxSegments()*3);

        // The curve starts at our starting point.
        SCurvePt padd = {};
        padd.vertex = true;
        padd.p = start;
        sc.pts.Add(&amp;padd);

        Point2d pa, pb;
        Vector np, npc = Vector::From(0, 0, 0);
        bool fwd = false;
        // Better to start with a too-small step, so that we don't miss
        // features of the curve entirely.
        double tol, step = maxtol;
        for(a = 0; a &lt; maxsteps; a++) {
            ClosestPointTo(start, &amp;pa);
            b-&gt;ClosestPointTo(start, &amp;pb);

            Vector na =    NormalAt(pa).WithMagnitude(1),
                   nb = b-&gt;NormalAt(pb).WithMagnitude(1);

            if(a == 0) {
                Vector dp = nb.Cross(na);
                if(dp.Dot(startv) &lt; 0) {
                    // We want to march in the more inward direction.
                    fwd = true;
                } else {
                    fwd = false;
                }
            }

            int i;
            for(i = 0; i &lt; 20; i++) {
                Vector dp = nb.Cross(na);
                if(!fwd) dp = dp.ScaledBy(-1);
                dp = dp.WithMagnitude(step);

                np = start.Plus(dp);
                npc = ClosestPointOnThisAndSurface(b, np);
                tol = (npc.Minus(np)).Magnitude();

                if(tol &gt; maxtol*0.8) {
                    step *= 0.90;
                } else {
                    step /= 0.90;
                }

                if((tol &lt; maxtol) &amp;&amp; (tol &gt; maxtol/2)) {
                    // If we meet the chord tolerance test, and we're
                    // not too fine, then we break out.
                    break;
                }
            }

            SPoint *sp;
            for(sp = spl.l.First(); sp; sp = spl.l.NextAfter(sp)) {
                if((sp-&gt;p).OnLineSegment(start, npc, 2*SS.ChordTolMm())) {
                    sp-&gt;tag = 1;
                    a = maxsteps;
                    npc = sp-&gt;p;
                }
            }

            padd.p = npc;
            padd.vertex = (a == maxsteps);
            sc.pts.Add(&amp;padd);

            start = npc;
        }

        spl.l.RemoveTagged();

        // And now we split and insert the curve
        SCurve split = sc.MakeCopySplitAgainst(agnstA, agnstB, this, b);
        sc.Clear();
        into-&gt;curve.AddAndAssignId(&amp;split);
    }
    spl.Clear();
}
</t>
<t tx="leo1.20171224221237.2">void SSurface::Reverse() {
    int i, j;
    for(i = 0; i &lt; (degm+1)/2; i++) {
        for(j = 0; j &lt;= degn; j++) {
            swap(ctrl[i][j], ctrl[degm-i][j]);
            swap(weight[i][j], weight[degm-i][j]);
        }
    }

    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        stb-&gt;backwards = !stb-&gt;backwards;
        swap(stb-&gt;start, stb-&gt;finish);
    }
}

</t>
<t tx="leo1.20171224221237.20">bool SSurface::CoincidentWith(SSurface *ss, bool sameNormal) const {
    if(degm != 1 || degn != 1) return false;
    if(ss-&gt;degm != 1 || ss-&gt;degn != 1) return false;

    Vector p = ctrl[0][0];
    Vector n = NormalAt(0, 0).WithMagnitude(1);
    double d = n.Dot(p);

    if(!ss-&gt;CoincidentWithPlane(n, d)) return false;

    Vector n2 = ss-&gt;NormalAt(0, 0);
    if(sameNormal) {
        if(n2.Dot(n) &lt; 0) return false;
    } else {
        if(n2.Dot(n) &gt; 0) return false;
    }

    return true;
}

</t>
<t tx="leo1.20171224221237.21">bool SSurface::CoincidentWithPlane(Vector n, double d) const {
    if(degm != 1 || degn != 1) return false;
    if(fabs(n.Dot(ctrl[0][0]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[0][1]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[1][0]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[1][1]) - d) &gt; LENGTH_EPS) return false;

    return true;
}

//-----------------------------------------------------------------------------
// In our shell, find all surfaces that are coincident with the prototype
// surface (with same or opposite normal, as specified), and copy all of
// their trim polygons into el. The edges are returned in uv coordinates for
// the prototype surface.
//-----------------------------------------------------------------------------
</t>
<t tx="leo1.20171224221237.22">void SShell::MakeCoincidentEdgesInto(SSurface *proto, bool sameNormal,
                                     SEdgeList *el, SShell *useCurvesFrom)
{
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        if(proto-&gt;CoincidentWith(ss, sameNormal)) {
            ss-&gt;MakeEdgesInto(this, el, SSurface::MakeAs::XYZ, useCurvesFrom);
        }
    }

    SEdge *se;
    for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
        double ua, va, ub, vb;
        proto-&gt;ClosestPointTo(se-&gt;a, &amp;ua, &amp;va);
        proto-&gt;ClosestPointTo(se-&gt;b, &amp;ub, &amp;vb);

        if(sameNormal) {
            se-&gt;a = Vector::From(ua, va, 0);
            se-&gt;b = Vector::From(ub, vb, 0);
        } else {
            // Flip normal, so flip all edge directions
            se-&gt;b = Vector::From(ua, va, 0);
            se-&gt;a = Vector::From(ub, vb, 0);
        }
    }
}

</t>
<t tx="leo1.20171224221237.23">//-----------------------------------------------------------------------------
// Triangulate a surface. If the surface is curved, then we first superimpose
// a grid of quads, with spacing to achieve our chord tolerance. We then
// proceed by ear-clipping; the resulting mesh should be watertight and not
// awful numerically, but has no special properties (Delaunay, etc.).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221237.24">void SPolygon::UvTriangulateInto(SMesh *m, SSurface *srf) {
    if(l.n &lt;= 0) return;

    //int64_t in = GetMilliseconds();

    normal = Vector::From(0, 0, 1);

    while(l.n &gt; 0) {
        FixContourDirections();
        l.ClearTags();

        // Find a top-level contour, and start with that. Then build bridges
        // in order to merge all its islands into a single contour.
        SContour *top;
        for(top = l.First(); top; top = l.NextAfter(top)) {
            if(top-&gt;timesEnclosed == 0) {
                break;
            }
        }
        if(!top) {
            dbp("polygon has no top-level contours?");
            return;
        }

        // Start with the outer contour
        SContour merged = {};
        top-&gt;tag = 1;
        top-&gt;CopyInto(&amp;merged);
        (merged.l.n)--;

        // List all of the edges, for testing whether bridges work.
        SEdgeList el = {};
        top-&gt;MakeEdgesInto(&amp;el);
        List&lt;Vector&gt; vl = {};

        // And now find all of its holes. Note that we will also find any
        // outer contours that lie entirely within this contour, and any
        // holes for those contours. But that's okay, because we can merge
        // those too.
        SContour *sc;
        for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
            if(sc-&gt;timesEnclosed != 1) continue;
            if(sc-&gt;l.n &lt; 2) continue;

            // Test the midpoint of an edge. Our polygon may not be self-
            // intersecting, but two contours may share a vertex; so a
            // vertex could be on the edge of another polygon, in which
            // case ContainsPointProjdToNormal returns indeterminate.
            Vector tp = sc-&gt;AnyEdgeMidpoint();
            if(top-&gt;ContainsPointProjdToNormal(normal, tp)) {
                sc-&gt;tag = 2;
                sc-&gt;MakeEdgesInto(&amp;el);
                sc-&gt;FindPointWithMinX();
            }
        }

//        dbp("finished finding holes: %d ms", (int)(GetMilliseconds() - in));
        for(;;) {
            double xmin = 1e10;
            SContour *scmin = NULL;

            for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
                if(sc-&gt;tag != 2) continue;

                if(sc-&gt;xminPt.x &lt; xmin) {
                    xmin = sc-&gt;xminPt.x;
                    scmin = sc;
                }
            }
            if(!scmin) break;

            if(!merged.BridgeToContour(scmin, &amp;el, &amp;vl)) {
                dbp("couldn't merge our hole");
                return;
            }
//            dbp("   bridged to contour: %d ms", (int)(GetMilliseconds() - in));
            scmin-&gt;tag = 3;
        }
//        dbp("finished merging holes: %d ms", (int)(GetMilliseconds() - in));

        merged.UvTriangulateInto(m, srf);
//        dbp("finished ear clippping: %d ms", (int)(GetMilliseconds() - in));
        merged.l.Clear();
        el.Clear();
        vl.Clear();

        // Careful, need to free the points within the contours, and not just
        // the contours themselves. This was a tricky memory leak.
        for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
            if(sc-&gt;tag) {
                sc-&gt;l.Clear();
            }
        }
        l.RemoveTagged();
    }
}

</t>
<t tx="leo1.20171224221237.25">bool SContour::BridgeToContour(SContour *sc,
                               SEdgeList *avoidEdges, List&lt;Vector&gt; *avoidPts)
{
    int i, j;

    // Start looking for a bridge on our new hole near its leftmost (min x)
    // point.
    int sco = 0;
    for(i = 0; i &lt; (sc-&gt;l.n - 1); i++) {
        if((sc-&gt;l.elem[i].p).EqualsExactly(sc-&gt;xminPt)) {
            sco = i;
        }
    }

    // And start looking on our merged contour at whichever point is nearest
    // to the leftmost point of the new segment.
    int thiso = 0;
    double dmin = 1e10;
    for(i = 0; i &lt; l.n; i++) {
        Vector p = l.elem[i].p;
        double d = (p.Minus(sc-&gt;xminPt)).MagSquared();
        if(d &lt; dmin) {
            dmin = d;
            thiso = i;
        }
    }

    int thisp, scp;

    Vector a, b, *f;

    // First check if the contours share a point; in that case we should
    // merge them there, without a bridge.
    for(i = 0; i &lt; l.n; i++) {
        thisp = WRAP(i+thiso, l.n);
        a = l.elem[thisp].p;

        for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
            if(f-&gt;Equals(a)) break;
        }
        if(f) continue;

        for(j = 0; j &lt; (sc-&gt;l.n - 1); j++) {
            scp = WRAP(j+sco, (sc-&gt;l.n - 1));
            b = sc-&gt;l.elem[scp].p;

            if(a.Equals(b)) {
                goto haveEdge;
            }
        }
    }

    // If that fails, look for a bridge that does not intersect any edges.
    for(i = 0; i &lt; l.n; i++) {
        thisp = WRAP(i+thiso, l.n);
        a = l.elem[thisp].p;

        for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
            if(f-&gt;Equals(a)) break;
        }
        if(f) continue;

        for(j = 0; j &lt; (sc-&gt;l.n - 1); j++) {
            scp = WRAP(j+sco, (sc-&gt;l.n - 1));
            b = sc-&gt;l.elem[scp].p;

            for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
                if(f-&gt;Equals(b)) break;
            }
            if(f) continue;

            if(avoidEdges-&gt;AnyEdgeCrossings(a, b) &gt; 0) {
                // doesn't work, bridge crosses an existing edge
            } else {
                goto haveEdge;
            }
        }
    }

    // Tried all the possibilities, didn't find an edge
    return false;

haveEdge:
    SContour merged = {};
    for(i = 0; i &lt; l.n; i++) {
        merged.AddPoint(l.elem[i].p);
        if(i == thisp) {
            // less than or equal; need to duplicate the join point
            for(j = 0; j &lt;= (sc-&gt;l.n - 1); j++) {
                int jp = WRAP(j + scp, (sc-&gt;l.n - 1));
                merged.AddPoint((sc-&gt;l.elem[jp]).p);
            }
            // and likewise duplicate join point for the outer curve
            merged.AddPoint(l.elem[i].p);
        }
    }

    // and future bridges mustn't cross our bridge, and it's tricky to get
    // things right if two bridges come from the same point
    avoidEdges-&gt;AddEdge(a, b);
    avoidPts-&gt;Add(&amp;a);
    avoidPts-&gt;Add(&amp;b);

    l.Clear();
    l = merged.l;
    return true;
}

</t>
<t tx="leo1.20171224221237.26">bool SContour::IsEar(int bp, double scaledEps) const {
    @others
}

</t>
<t tx="leo1.20171224221237.27">int ap = WRAP(bp-1, l.n),
    cp = WRAP(bp+1, l.n);

STriangle tr = {};
tr.a = l.elem[ap].p;
tr.b = l.elem[bp].p;
tr.c = l.elem[cp].p;

if((tr.a).Equals(tr.c)) {
    // This is two coincident and anti-parallel edges. Zero-area, so
    // won't generate a real triangle, but we certainly can clip it.
    return true;
}

Vector n = Vector::From(0, 0, -1);
if((tr.Normal()).Dot(n) &lt; scaledEps) {
    // This vertex is reflex, or between two collinear edges; either way,
    // it's not an ear.
    return false;
}

// Accelerate with an axis-aligned bounding box test
Vector maxv = tr.a, minv = tr.a;
(tr.b).MakeMaxMin(&amp;maxv, &amp;minv);
(tr.c).MakeMaxMin(&amp;maxv, &amp;minv);

int i;
for(i = 0; i &lt; l.n; i++) {
    if(i == ap || i == bp || i == cp) continue;

    Vector p = l.elem[i].p;
    if(p.OutsideAndNotOn(maxv, minv)) continue;

    // A point on the edge of the triangle is considered to be inside,
    // and therefore makes it a non-ear; but a point on the vertex is
    // "outside", since that's necessary to make bridges work.
    if(p.EqualsExactly(tr.a)) continue;
    if(p.EqualsExactly(tr.b)) continue;
    if(p.EqualsExactly(tr.c)) continue;

    if(tr.ContainsPointProjd(n, p)) {
        return false;
    }
}
return true;
</t>
<t tx="leo1.20171224221237.28">void SContour::ClipEarInto(SMesh *m, int bp, double scaledEps) {
    @others
}

</t>
<t tx="leo1.20171224221237.29">int ap = WRAP(bp-1, l.n),
    cp = WRAP(bp+1, l.n);

STriangle tr = {};
tr.a = l.elem[ap].p;
tr.b = l.elem[bp].p;
tr.c = l.elem[cp].p;
if(tr.Normal().MagSquared() &lt; scaledEps*scaledEps) {
    // A vertex with more than two edges will cause us to generate
    // zero-area triangles, which must be culled.
} else {
    m-&gt;AddTriangle(&amp;tr);
}

// By deleting the point at bp, we may change the ear-ness of the points
// on either side.
l.elem[ap].ear = EarType::UNKNOWN;
l.elem[cp].ear = EarType::UNKNOWN;

l.ClearTags();
l.elem[bp].tag = 1;
l.RemoveTagged();
</t>
<t tx="leo1.20171224221237.3">void SSurface::ScaleSelfBy(double s) {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = ctrl[i][j].ScaledBy(s);
        }
    }
}

</t>
<t tx="leo1.20171224221237.30">void SContour::UvTriangulateInto(SMesh *m, SSurface *srf) {
    Vector tu, tv;
    srf-&gt;TangentsAt(0.5, 0.5, &amp;tu, &amp;tv);
    double s = sqrt(tu.MagSquared() + tv.MagSquared());
    // We would like to apply our tolerances in xyz; but that would be a lot
    // of work, so at least scale the epsilon semi-reasonably. That's
    // perfect for square planes, less perfect for anything else.
    double scaledEps = LENGTH_EPS / s;

    int i;
    // Clean the original contour by removing any zero-length edges.
    l.ClearTags();
    for(i = 1; i &lt; l.n; i++) {
       if((l.elem[i].p).Equals(l.elem[i-1].p)) {
            l.elem[i].tag = 1;
        }
    }
    l.RemoveTagged();

    // Now calculate the ear-ness of each vertex
    for(i = 0; i &lt; l.n; i++) {
        (l.elem[i]).ear = IsEar(i, scaledEps) ? EarType::EAR : EarType::NOT_EAR;
    }

    bool toggle = false;
    while(l.n &gt; 3) {
        // Some points may have changed ear-ness, so recalculate
        for(i = 0; i &lt; l.n; i++) {
            if(l.elem[i].ear == EarType::UNKNOWN) {
                (l.elem[i]).ear = IsEar(i, scaledEps) ?
                                        EarType::EAR : EarType::NOT_EAR;
            }
        }

        int bestEar = -1;
        double bestChordTol = VERY_POSITIVE;
        // Alternate the starting position so we generate strip-like
        // triangulations instead of fan-like
        toggle = !toggle;
        int offset = toggle ? -1 : 0;
        for(i = 0; i &lt; l.n; i++) {
            int ear = WRAP(i+offset, l.n);
            if(l.elem[ear].ear == EarType::EAR) {
                if(srf-&gt;degm == 1 &amp;&amp; srf-&gt;degn == 1) {
                    // This is a plane; any ear is a good ear.
                    bestEar = ear;
                    break;
                }
                // If we are triangulating a curved surface, then try to
                // clip ears that have a small chord tolerance from the
                // surface.
                Vector prev = l.elem[WRAP((i+offset-1), l.n)].p,
                       next = l.elem[WRAP((i+offset+1), l.n)].p;
                double tol = srf-&gt;ChordToleranceForEdge(prev, next);
                if(tol &lt; bestChordTol - scaledEps) {
                    bestEar = ear;
                    bestChordTol = tol;
                }
                if(bestChordTol &lt; 0.1*SS.ChordTolMm()) {
                    break;
                }
            }
        }
        if(bestEar &lt; 0) {
            dbp("couldn't find an ear! fail");
            return;
        }
        ClipEarInto(m, bestEar, scaledEps);
    }

    ClipEarInto(m, 0, scaledEps); // add the last triangle
}

double SSurface::ChordToleranceForEdge(Vector a, Vector b) const {
    Vector as = PointAt(a.x, a.y), bs = PointAt(b.x, b.y);

    double worst = VERY_NEGATIVE;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        Vector p  = a. Plus((b. Minus(a )).ScaledBy(i/4.0)),
               ps = as.Plus((bs.Minus(as)).ScaledBy(i/4.0));

        Vector pps = PointAt(p.x, p.y);
        worst = max(worst, (pps.Minus(ps)).MagSquared());
    }
    return sqrt(worst);
}

Vector SSurface::PointAtMaybeSwapped(double u, double v, bool swapped) const {
    if(swapped) {
        return PointAt(v, u);
    } else {
        return PointAt(u, v);
    }
}

</t>
<t tx="leo1.20171224221237.31">void SSurface::MakeTriangulationGridInto(List&lt;double&gt; *l, double vs, double vf,
                                         bool swapped) const
{
    double worst = 0;

    // Try piecewise linearizing four curves, at u = 0, 1/3, 2/3, 1; choose
    // the worst chord tolerance of any of those.
    int i;
    for(i = 0; i &lt;= 3; i++) {
        double u = i/3.0;

        // This chord test should be identical to the one in SBezier::MakePwl
        // to make the piecewise linear edges line up with the grid more or
        // less.
        Vector ps = PointAtMaybeSwapped(u, vs, swapped),
               pf = PointAtMaybeSwapped(u, vf, swapped);

        double vm1 = (2*vs + vf) / 3,
    if((vf - vs) &lt; step || worst &lt; SS.ChordTolMm()) {
        l-&gt;Add(&amp;vf);
    } else {
        MakeTriangulationGridInto(l, vs, (vs+vf)/2, swapped);
        MakeTriangulationGridInto(l, (vs+vf)/2, vf, swapped);
    }
}

</t>
<t tx="leo1.20171224221237.32">void SPolygon::UvGridTriangulateInto(SMesh *mesh, SSurface *srf) {
    SEdgeList orig = {};
    MakeEdgesInto(&amp;orig);

    SEdgeList holes = {};

    normal = Vector::From(0, 0, 1);
    FixContourDirections();

    // Build a rectangular grid, with horizontal and vertical lines in the
    // uv plane. The spacing of these lines is adaptive, so calculate that.
    List&lt;double&gt; li, lj;
    li = {};
    lj = {};
    double v = 0;
    li.Add(&amp;v);
    srf-&gt;MakeTriangulationGridInto(&amp;li, 0, 1, /*swapped=*/true);
    lj.Add(&amp;v);
    srf-&gt;MakeTriangulationGridInto(&amp;lj, 0, 1, /*swapped=*/false);

    // Now iterate over each quad in the grid. If it's outside the polygon,
    // or if it intersects the polygon, then we discard it. Otherwise we
    // generate two triangles in the mesh, and cut it out of our polygon.
    int i, j;
    for(i = 0; i &lt; (li.n - 1); i++) {
        for(j = 0; j &lt; (lj.n - 1); j++) {
            double us = li.elem[i], uf = li.elem[i+1],
               orig.AnyEdgeCrossings(d, a, NULL))
            {
                continue;
            }

            // There's no intersections, so it doesn't matter which point
            // we decide to test.
            if(!this-&gt;ContainsPoint(a)) {
                continue;
            }

            // Add the quad to our mesh
            STriangle tr = {};
            tr.a = a;
            tr.b = b;
            tr.c = c;
            mesh-&gt;AddTriangle(&amp;tr);
            tr.a = a;
            tr.b = c;
            tr.c = d;
            mesh-&gt;AddTriangle(&amp;tr);

            holes.AddEdge(a, b);
            holes.AddEdge(b, c);
            holes.AddEdge(c, d);
            holes.AddEdge(d, a);
        }
    }

    holes.CullExtraneousEdges();
    SPolygon hp = {};
    holes.AssemblePolygon(&amp;hp, NULL, /*keepDir=*/true);

    SContour *sc;
    for(sc = hp.l.First(); sc; sc = hp.l.NextAfter(sc)) {
        l.Add(sc);
    }

    orig.Clear();
    holes.Clear();
    li.Clear();
    lj.Clear();
    hp.l.Clear();

    UvTriangulateInto(mesh, srf);
}

</t>
<t tx="leo1.20171224221237.33">void SPolygon::TriangulateInto(SMesh *m) const {
    Vector n = normal;
    if(n.Equals(Vector::From(0.0, 0.0, 0.0))) {
       n = ComputeNormal();
    }
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    SPolygon p = {};
    this-&gt;InverseTransformInto(&amp;p, u, v, n);

    SSurface srf = SSurface::FromPlane(Vector::From(0.0, 0.0, 0.0),
                                       Vector::From(1.0, 0.0, 0.0),
                                       Vector::From(0.0, 1.0, 0.0));
    SMesh pm = {};
    p.UvTriangulateInto(&amp;pm, &amp;srf);
    for(STriangle st : pm.l) {
        st = st.Transform(u, v, n);
        m-&gt;AddTriangle(&amp;st);
    }

    p.Clear();
    pm.Clear();
}
</t>
<t tx="leo1.20171224221237.4">void SSurface::Clear() {
    trim.Clear();
}

</t>
<t tx="leo1.20171224221237.5">typedef struct {
    hSCurve     hc;
    hSSurface   hs;
} TrimLine;

</t>
<t tx="leo1.20171224221237.6">void SShell::MakeFromExtrusionOf(SBezierLoopSet *sbls, Vector t0, Vector t1, RgbaColor color)
{
    // Make the extrusion direction consistent with respect to the normal
    // of the sketch we're extruding.
    if((t0.Minus(t1)).Dot(sbls-&gt;normal) &lt; 0) {
        swap(t0, t1);
    }

    // Define a coordinate system to contain the original sketch, and get
    // a bounding box in that csys
    Vector n = sbls-&gt;normal.ScaledBy(-1);
    Vector u = n.Normal(0), v = n.Normal(1);
    Vector orig = sbls-&gt;point;
    double umax = 1e-10, umin = 1e10;
    sbls-&gt;GetBoundingProjd(u, orig, &amp;umin, &amp;umax);
    double vmax = 1e-10, vmin = 1e10;
    sbls-&gt;GetBoundingProjd(v, orig, &amp;vmin, &amp;vmax);
    // and now fix things up so that all u and v lie between 0 and 1
    orig = orig.Plus(u.ScaledBy(umin));
    orig = orig.Plus(v.ScaledBy(vmin));
    u = u.ScaledBy(umax - umin);
    v = v.ScaledBy(vmax - vmin);

    // So we can now generate the top and bottom surfaces of the extrusion,
    // planes within a translated (and maybe mirrored) version of that csys.
    SSurface s0, s1;
    s0 = SSurface::FromPlane(orig.Plus(t0), u, v);
    s0.color = color;
    s1 = SSurface::FromPlane(orig.Plus(t1).Plus(u), u.ScaledBy(-1), v);
    s1.color = color;
    hSSurface hs0 = surface.AddAndAssignId(&amp;s0),
              hs1 = surface.AddAndAssignId(&amp;s1);

    // Now go through the input curves. For each one, generate its surface
    // of extrusion, its two translated trim curves, and one trim line. We
    // go through by loops so that we can assign the lines correctly.
    SBezierLoop *sbl;
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        SBezier *sb;
        List&lt;TrimLine&gt; trimLines = {};

        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            // Generate the surface of extrusion of this curve, and add
            // it to the list
            SSurface ss = SSurface::FromExtrusionOf(sb, t0, t1);
            ss.color = color;
            hSSurface hsext = surface.AddAndAssignId(&amp;ss);

            // Translate the curve by t0 and t1 to produce two trim curves
            SCurve sc = {};
            sc.isExact = true;
            sc.exact = sb-&gt;TransformedBy(t0, Quaternion::IDENTITY, 1.0);
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            sc.surfA = hs0;
            sc.surfB = hsext;
            hSCurve hc0 = curve.AddAndAssignId(&amp;sc);

            sc = {};
            sc.isExact = true;
            sc.exact = sb-&gt;TransformedBy(t1, Quaternion::IDENTITY, 1.0);
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            sc.surfA = hs1;
            sc.surfB = hsext;
            hSCurve hc1 = curve.AddAndAssignId(&amp;sc);

            STrimBy stb0, stb1;
            // The translated curves trim the flat top and bottom surfaces.
            stb0 = STrimBy::EntireCurve(this, hc0, /*backwards=*/false);
            stb1 = STrimBy::EntireCurve(this, hc1, /*backwards=*/true);
            (surface.FindById(hs0))-&gt;trim.Add(&amp;stb0);
            (surface.FindById(hs1))-&gt;trim.Add(&amp;stb1);

            // The translated curves also trim the surface of extrusion.
            stb0 = STrimBy::EntireCurve(this, hc0, /*backwards=*/true);
            stb1 = STrimBy::EntireCurve(this, hc1, /*backwards=*/false);
            (surface.FindById(hsext))-&gt;trim.Add(&amp;stb0);
            (surface.FindById(hsext))-&gt;trim.Add(&amp;stb1);

            // And form the trim line
            Vector pt = sb-&gt;Finish();
            sc = {};
            sc.isExact = true;
            sc.exact = SBezier::From(pt.Plus(t0), pt.Plus(t1));
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            hSCurve hl = curve.AddAndAssignId(&amp;sc);
            // save this for later
            TrimLine tl;
            tl.hc = hl;
            tl.hs = hsext;
            trimLines.Add(&amp;tl);
        }

        int i;
        for(i = 0; i &lt; trimLines.n; i++) {
            TrimLine *tl = &amp;(trimLines.elem[i]);
            SSurface *ss = surface.FindById(tl-&gt;hs);

            TrimLine *tlp = &amp;(trimLines.elem[WRAP(i-1, trimLines.n)]);

            STrimBy stb;
            stb = STrimBy::EntireCurve(this, tl-&gt;hc, /*backwards=*/true);
            ss-&gt;trim.Add(&amp;stb);
            stb = STrimBy::EntireCurve(this, tlp-&gt;hc, /*backwards=*/false);
            ss-&gt;trim.Add(&amp;stb);

            (curve.FindById(tl-&gt;hc))-&gt;surfA = ss-&gt;h;
            (curve.FindById(tlp-&gt;hc))-&gt;surfB = ss-&gt;h;
        }
        trimLines.Clear();
    }
}


</t>
<t tx="leo1.20171224221237.7">typedef struct {
    hSSurface   d[4];
} Revolved;

</t>
<t tx="leo1.20171224221237.8">void SShell::MakeFromRevolutionOf(SBezierLoopSet *sbls, Vector pt, Vector axis, RgbaColor color, Group *group)
{
    SBezierLoop *sbl;

    int i0 = surface.n, i;

    // Normalize the axis direction so that the direction of revolution
    // ends up parallel to the normal of the sketch, on the side of the
    // axis where the sketch is.
    Vector pto;
    double md = VERY_NEGATIVE;
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        SBezier *sb;
        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            // Choose the point farthest from the axis; we'll get garbage
            // if we choose a point that lies on the axis, for example.
            // (And our surface will be self-intersecting if the sketch
            // spans the axis, so don't worry about that.)
            Vector p = sb-&gt;Start();
            double d = p.DistanceToLine(pt, axis);
            if(d &gt; md) {
                md = d;
                pto = p;
            }
        }
    }
    Vector ptc = pto.ClosestPointOnLine(pt, axis),
           up  = (pto.Minus(ptc)).WithMagnitude(1),
           vp  = (sbls-&gt;normal).Cross(up);
    if(vp.Dot(axis) &lt; 0) {
        axis = axis.ScaledBy(-1);
    }

    // Now we actually build and trim the surfaces.
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        int i, j;
        SBezier *sb;
        List&lt;Revolved&gt; hsl = {};

        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            Revolved revs;
            for(j = 0; j &lt; 4; j++) {
                if(sb-&gt;deg == 1 &amp;&amp;
                    (sb-&gt;ctrl[0]).DistanceToLine(pt, axis) &lt; LENGTH_EPS &amp;&amp;
                    (sb-&gt;ctrl[1]).DistanceToLine(pt, axis) &lt; LENGTH_EPS)
                {
                    // This is a line on the axis of revolution; it does
                    // not contribute a surface.
                    revs.d[j].v = 0;
                } else {
                    SSurface ss = SSurface::FromRevolutionOf(sb, pt, axis,
                                                             (PI/2)*j,
                                                             (PI/2)*(j+1));
                    ss.color = color;
                    if(sb-&gt;entity != 0) {
                        hEntity he;
                        he.v = sb-&gt;entity;
                        hEntity hface = group-&gt;Remap(he, Group::REMAP_LINE_TO_FACE);
                        if(SK.entity.FindByIdNoOops(hface) != NULL) {
                            ss.face = hface.v;
                        }
                    }
                    revs.d[j] = surface.AddAndAssignId(&amp;ss);
                }
            }
            hsl.Add(&amp;revs);
        }

        for(i = 0; i &lt; sbl-&gt;l.n; i++) {
            Revolved revs  = hsl.elem[i],
                     revsp = hsl.elem[WRAP(i-1, sbl-&gt;l.n)];

            sb   = &amp;(sbl-&gt;l.elem[i]);

            for(j = 0; j &lt; 4; j++) {
                SCurve sc;
                Quaternion qs = Quaternion::From(axis, (PI/2)*j);
                // we want Q*(x - p) + p = Q*x + (p - Q*p)
                Vector ts = pt.Minus(qs.Rotate(pt));

                // If this input curve generate a surface, then trim that
                // surface with the rotated version of the input curve.
                if(revs.d[j].v) {
                    sc = {};
                    sc.isExact = true;
                    sc.exact = sb-&gt;TransformedBy(ts, qs, 1.0);
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA = revs.d[j];
                    sc.surfB = revs.d[WRAP(j-1, 4)];

                    hSCurve hcb = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/true);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/false);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }

                // And if this input curve and the one after it both generated
                // surfaces, then trim both of those by the appropriate
                // circle.
                if(revs.d[j].v &amp;&amp; revsp.d[j].v) {
                    SSurface *ss = surface.FindById(revs.d[j]);

                    sc = {};
                    sc.isExact = true;
                    sc.exact = SBezier::From(ss-&gt;ctrl[0][0],
                                             ss-&gt;ctrl[0][1],
                                             ss-&gt;ctrl[0][2]);
                    sc.exact.weight[1] = ss-&gt;weight[0][1];
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA = revs.d[j];
                    sc.surfB = revsp.d[j];

                    hSCurve hcc = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/false);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/true);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }
            }
        }

        hsl.Clear();
    }

    for(i = i0; i &lt; surface.n; i++) {
        SSurface *srf = &amp;(surface.elem[i]);

        // Revolution of a line; this is potentially a plane, which we can
        // rewrite to have degree (1, 1).
        if(srf-&gt;degm == 1 &amp;&amp; srf-&gt;degn == 2) {
            // close start, far start, far finish
            Vector cs, fs, ff;
            double d0, d1;
            d0 = (srf-&gt;ctrl[0][0]).DistanceToLine(pt, axis);
            d1 = (srf-&gt;ctrl[1][0]).DistanceToLine(pt, axis);

            if(d0 &gt; d1) {
                cs = srf-&gt;ctrl[1][0];
                fs = srf-&gt;ctrl[0][0];
                ff = srf-&gt;ctrl[0][2];
            } else {
                cs = srf-&gt;ctrl[0][0];
                fs = srf-&gt;ctrl[1][0];
                ff = srf-&gt;ctrl[1][2];
            }

            // origin close, origin far
            Vector oc = cs.ClosestPointOnLine(pt, axis),
                   of = fs.ClosestPointOnLine(pt, axis);

            if(oc.Equals(of)) {
                // This is a plane, not a (non-degenerate) cone.
                Vector oldn = srf-&gt;NormalAt(0.5, 0.5);

                Vector u = fs.Minus(of), v;

                v = (axis.Cross(u)).WithMagnitude(1);

                double vm = (ff.Minus(of)).Dot(v);
                v = v.ScaledBy(vm);

                srf-&gt;degm = 1;
                srf-&gt;degn = 1;
                srf-&gt;ctrl[0][0] = of;
                srf-&gt;ctrl[0][1] = of.Plus(u);
                srf-&gt;ctrl[1][0] = of.Plus(v);
                srf-&gt;ctrl[1][1] = of.Plus(u).Plus(v);
                srf-&gt;weight[0][0] = 1;
                srf-&gt;weight[0][1] = 1;
                srf-&gt;weight[1][0] = 1;
                srf-&gt;weight[1][1] = 1;

                if(oldn.Dot(srf-&gt;NormalAt(0.5, 0.5)) &lt; 0) {
                    swap(srf-&gt;ctrl[0][0], srf-&gt;ctrl[1][0]);
                    swap(srf-&gt;ctrl[0][1], srf-&gt;ctrl[1][1]);
                }
                continue;
            }

            if(fabs(d0 - d1) &lt; LENGTH_EPS) {
                // This is a cylinder; so transpose it so that we'll recognize
                // it as a surface of extrusion.
                SSurface sn = *srf;

                // Transposing u and v flips the normal, so reverse u to
                // flip it again and put it back where we started.
                sn.degm = 2;
                sn.degn = 1;
                int dm, dn;
                for(dm = 0; dm &lt;= 1; dm++) {
                    for(dn = 0; dn &lt;= 2; dn++) {
                        sn.ctrl  [dn][dm] = srf-&gt;ctrl  [1-dm][dn];
                        sn.weight[dn][dm] = srf-&gt;weight[1-dm][dn];
                    }
                }

                *srf = sn;
                continue;
            }
        }

    }

}

</t>
<t tx="leo1.20171224221237.9">void SShell::MakeFromCopyOf(SShell *a) {
    MakeFromTransformationOf(a,
        Vector::From(0, 0, 0), Quaternion::IDENTITY, 1.0);
}

</t>
<t tx="leo1.20171224221326.1">imported bsp.cpp
imported clipboard.cpp
imported confscreen.cpp
imported constraint.cpp
imported constrainteq.cpp
imported describescreen.cpp
@auto failed: draw.cpp
inserting @ignore
imported draw.cpp
@auto failed: drawconstraint.cpp
inserting @ignore
imported drawconstraint.cpp
imported drawentity.cpp
imported entity.cpp
@auto failed: export.cpp
inserting @ignore
imported export.cpp
tabs found with @tabwidth -4 in exportstep.cpp
changed leading tabs to blanks in 14 lines in exportstep.cpp
Exception running C_Importer
Traceback (most recent call last):

  File "y:\python36\lib\site-packages\leo\core\leoApp.py", line 1483, in scanner_for_ext_cb
    return scanner.run(s, parent)

  File "y:\python36\lib\site-packages\leo\plugins\importers\linescanner.py", line 463, in run
    self.generate_nodes(s, parent)

  File "y:\python36\lib\site-packages\leo\plugins\importers\linescanner.py", line 530, in generate_nodes
    self.gen_lines(s, parent)

  File "y:\python36\lib\site-packages\leo\plugins\importers\linescanner.py", line 599, in gen_lines
    tail_p = self.end_block(line, new_state, stack)

  File "y:\python36\lib\site-packages\leo\plugins\importers\linescanner.py", line 649, in end_block
    self.cut_stack(new_state, stack)

  File "y:\python36\lib\site-packages\leo\plugins\importers\linescanner.py", line 626, in cut_stack
    assert len(stack) &gt; 1, stack # &lt;

AssertionError: [Target: C_ScanState context: '' curlies: 0 @others: 1 refs: 0 p: exportstep.cpp]

imported exportstep.cpp
@auto failed: exportvector.cpp
inserting @ignore
imported exportvector.cpp
imported expr.cpp
imported file.cpp
imported generate.cpp
imported graphicswin.cpp
imported group.cpp
@auto failed: groupmesh.cpp
inserting @ignore
imported groupmesh.cpp
imported importdxf.cpp
imported lib.cpp
@auto failed: mesh.cpp
inserting @ignore
imported mesh.cpp
imported modify.cpp
@auto failed: mouse.cpp
inserting @ignore
imported mouse.cpp
imported polygon.cpp
imported polyline.cpp
imported request.cpp
imported resource.cpp
@auto failed: solvespace.cpp
inserting @ignore
imported solvespace.cpp
imported style.cpp
imported system.cpp
imported textscreens.cpp
@auto failed: textwin.cpp
inserting @ignore
imported textwin.cpp
@auto failed: toolbar.cpp
inserting @ignore
imported toolbar.cpp
imported ttf.cpp
imported undoredo.cpp
@auto failed: util.cpp
inserting @ignore
imported util.cpp
imported view.cpp
importing directory: ./../src\platform
imported climain.cpp
@auto failed: gtkmain.cpp
inserting @ignore
imported gtkmain.cpp
imported headless.cpp
imported platform.cpp
imported unixutil.cpp
@auto failed: w32main.cpp
inserting @ignore
imported w32main.cpp
imported w32util.cpp
importing directory: ./../src\render
imported gl3shader.cpp
@auto failed: render.cpp
inserting @ignore
imported render.cpp
@auto failed: render2d.cpp
inserting @ignore
imported render2d.cpp
imported rendercairo.cpp
imported rendergl.cpp
@auto failed: rendergl1.cpp
inserting @ignore
imported rendergl1.cpp
@auto failed: rendergl3.cpp
inserting @ignore
imported rendergl3.cpp
importing directory: ./../src\srf
@auto failed: boolean.cpp
inserting @ignore
imported boolean.cpp
imported curve.cpp
imported merge.cpp
@auto failed: ratpoly.cpp
inserting @ignore
imported ratpoly.cpp
imported raycast.cpp
imported surface.cpp
@auto failed: surfinter.cpp
inserting @ignore
imported surfinter.cpp
@auto failed: triangulate.cpp
inserting @ignore
imported triangulate.cpp
imported 1446 nodes in 60 files in 17.59 seconds</t>
<t tx="leo1.20171224221534.1">'''Recursively import all ['.cpp'] files in a directory and clean the result.'''

# Latest change: use c.recursiveImport.

c.recursiveImport(
    dir_ = r'./../src',
    kind = '@clean',
    safe_at_file = True,
    theTypes = ['.h']
)</t>
<t tx="leo1.20171224221604.1"></t>
<t tx="leo1.20171224221605.1"></t>
<t tx="leo1.20171224221605.10">void Add(const T *t) {
    AllocForOneMore();
    new(&amp;elem[n++]) T(*t);
}

</t>
<t tx="leo1.20171224221605.11">void AddToBeginning(const T *t) {
    AllocForOneMore();
    new(&amp;elem[n]) T();
    std::move_backward(elem, elem + 1, elem + n + 1);
    elem[0] = *t;
    n++;
}

T *First() {
    return (n == 0) ? NULL : &amp;(elem[0]);
}
</t>
<t tx="leo1.20171224221605.12">const T *First() const {
    return (n == 0) ? NULL : &amp;(elem[0]);
}
T *NextAfter(T *prev) {
    if(!prev) return NULL;
    if(prev - elem == (n - 1)) return NULL;
    return prev + 1;
}
</t>
<t tx="leo1.20171224221605.13">const T *NextAfter(const T *prev) const {
    if(!prev) return NULL;
    if(prev - elem == (n - 1)) return NULL;
    return prev + 1;
}

T *begin() { return &amp;elem[0]; }
T *end() { return &amp;elem[n]; }
const T *begin() const { return &amp;elem[0]; }
const T *end() const { return &amp;elem[n]; }

</t>
<t tx="leo1.20171224221605.14">void ClearTags() {
    int i;
    for(i = 0; i &lt; n; i++) {
        elem[i].tag = 0;
    }
}

</t>
<t tx="leo1.20171224221605.15">void Clear() {
    for(int i = 0; i &lt; n; i++)
        elem[i].~T();
    if(elem) MemFree(elem);
    elem = NULL;
    n = elemsAllocated = 0;
}

</t>
<t tx="leo1.20171224221605.16">void RemoveTagged() {
    int src, dest;
    dest = 0;
    for(src = 0; src &lt; n; src++) {
        if(elem[src].tag) {
            // this item should be deleted
        } else {
            if(src != dest) {
                elem[dest] = elem[src];
            }
            dest++;
        }
    }
    for(int i = dest; i &lt; n; i++)
        elem[i].~T();
    n = dest;
    // and elemsAllocated is untouched, because we didn't resize
}

</t>
<t tx="leo1.20171224221605.17">void RemoveLast(int cnt) {
    ssassert(n &gt;= cnt, "Removing more elements than the list contains");
    for(int i = n - cnt; i &lt; n; i++)
        elem[i].~T();
    n -= cnt;
    // and elemsAllocated is untouched, same as in RemoveTagged
}

</t>
<t tx="leo1.20171224221605.18">void Reverse() {
    int i;
    for(i = 0; i &lt; (n/2); i++) {
        swap(elem[i], elem[(n-1)-i]);
    }
}
</t>
<t tx="leo1.20171224221605.19">class IdList {
public:
    T     *elem;
    int   n;
    int   elemsAllocated;

    uint32_t MaximumId() {
        if(n == 0) {
            return 0;
        } else {
            return elem[n - 1].h.v;
        }
    }

    H AddAndAssignId(T *t) {
        t-&gt;h.v = (MaximumId() + 1);
        Add(t);

        return t-&gt;h;
    }

    @others
};

</t>
<t tx="leo1.20171224221605.2">//-----------------------------------------------------------------------------
// Data structures used frequently in the program, various kinds of vectors
// (of real numbers, not symbolic algebra stuff) and our templated lists.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#ifndef __DSC_H
#define __DSC_H

#include "solvespace.h"

class Vector;
class Vector4;
class Point2d;
class hEntity;
class hParam;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221605.20">void ReserveMore(int howMuch) {
    if(n + howMuch &gt; elemsAllocated) {
        elemsAllocated = n + howMuch;
        T *newElem = (T *)MemAlloc((size_t)elemsAllocated*sizeof(elem[0]));
        for(int i = 0; i &lt; n; i++) {
            new(&amp;newElem[i]) T(std::move(elem[i]));
            elem[i].~T();
        }
        MemFree(elem);
        elem = newElem;
    }
}

</t>
<t tx="leo1.20171224221605.21">void Add(T *t) {
    if(n &gt;= elemsAllocated) {
        ReserveMore((elemsAllocated + 32)*2 - n);
    }

    int first = 0, last = n;
    // We know that we must insert within the closed interval [first,last]
    while(first != last) {
        int mid = (first + last)/2;
        H hm = elem[mid].h;
        ssassert(hm.v != t-&gt;h.v, "Handle isn't unique");
        if(hm.v &gt; t-&gt;h.v) {
            last = mid;
        } else if(hm.v &lt; t-&gt;h.v) {
            first = mid + 1;
        }
    }

    int i = first;
    new(&amp;elem[n]) T();
    std::move_backward(elem + i, elem + n, elem + n + 1);
    elem[i] = *t;
    n++;
}

T *FindById(H h) {
    T *t = FindByIdNoOops(h);
    ssassert(t != NULL, "Cannot find handle");
    return t;
}

</t>
<t tx="leo1.20171224221605.22">int IndexOf(H h) {
    int first = 0, last = n-1;
    while(first &lt;= last) {
        int mid = (first + last)/2;
        H hm = elem[mid].h;
        if(hm.v &gt; h.v) {
            last = mid-1; // and first stays the same
        } else if(hm.v &lt; h.v) {
            first = mid+1; // and last stays the same
        } else {
            return mid;
        }
    }
    return -1;
}

T *FindByIdNoOops(H h) {
    int first = 0, last = n-1;
    while(first &lt;= last) {
        int mid = (first + last)/2;
        H hm = elem[mid].h;
        if(hm.v &gt; h.v) {
            last = mid-1; // and first stays the same
        } else if(hm.v &lt; h.v) {
            first = mid+1; // and last stays the same
        } else {
            return &amp;(elem[mid]);
        }
    }
    return NULL;
}

T *First() {
    return (n == 0) ? NULL : &amp;(elem[0]);
}
T *NextAfter(T *prev) {
    if(!prev) return NULL;
    if(prev - elem == (n - 1)) return NULL;
    return prev + 1;
}

T *begin() { return &amp;elem[0]; }
T *end() { return &amp;elem[n]; }
const T *begin() const { return &amp;elem[0]; }
const T *end() const { return &amp;elem[n]; }

</t>
<t tx="leo1.20171224221605.23">void ClearTags() {
    int i;
    for(i = 0; i &lt; n; i++) {
        elem[i].tag = 0;
    }
}

</t>
<t tx="leo1.20171224221605.24">void Tag(H h, int tag) {
    int i;
    for(i = 0; i &lt; n; i++) {
        if(elem[i].h.v == h.v) {
            elem[i].tag = tag;
        }
    }
}

</t>
<t tx="leo1.20171224221605.25">void RemoveTagged() {
    int src, dest;
    dest = 0;
    for(src = 0; src &lt; n; src++) {
        if(elem[src].tag) {
            // this item should be deleted
            elem[src].Clear();
        } else {
            if(src != dest) {
                elem[dest] = elem[src];
            }
            dest++;
        }
    }
    for(int i = dest; i &lt; n; i++)
        elem[i].~T();
    n = dest;
    // and elemsAllocated is untouched, because we didn't resize
}
</t>
<t tx="leo1.20171224221605.26">void RemoveById(H h) {
    ClearTags();
    FindById(h)-&gt;tag = 1;
    RemoveTagged();
}

</t>
<t tx="leo1.20171224221605.27">void MoveSelfInto(IdList&lt;T,H&gt; *l) {
    l-&gt;Clear();
    *l = *this;
    elemsAllocated = n = 0;
    elem = NULL;
}

</t>
<t tx="leo1.20171224221605.28">void DeepCopyInto(IdList&lt;T,H&gt; *l) {
    l-&gt;Clear();
    l-&gt;elem = (T *)MemAlloc(elemsAllocated * sizeof(elem[0]));
    for(int i = 0; i &lt; n; i++)
        new(&amp;l-&gt;elem[i]) T(elem[i]);
    l-&gt;elemsAllocated = elemsAllocated;
    l-&gt;n = n;
}

</t>
<t tx="leo1.20171224221605.29">void Clear() {
    for(int i = 0; i &lt; n; i++) {
        elem[i].Clear();
        elem[i].~T();
    }
    elemsAllocated = n = 0;
    if(elem) MemFree(elem);
    elem = NULL;
}

</t>
<t tx="leo1.20171224221605.3">class Quaternion {
public:
    // a + (vx)*i + (vy)*j + (vz)*k
    double w, vx, vy, vz;

    static const Quaternion IDENTITY;

    static Quaternion From(double w, double vx, double vy, double vz);
    static Quaternion From(hParam w, hParam vx, hParam vy, hParam vz);
    static Quaternion From(Vector u, Vector v);
    static Quaternion From(Vector axis, double dtheta);

    Quaternion Plus(Quaternion b) const;
    Quaternion Minus(Quaternion b) const;
    Quaternion ScaledBy(double s) const;
    double Magnitude() const;
    Quaternion WithMagnitude(double s) const;

    // Call a rotation matrix [ u' v' n' ]'; this returns the first and
    // second rows, where that matrix is generated by this quaternion
    Vector RotationU() const;
    Vector RotationV() const;
    Vector RotationN() const;
    Vector Rotate(Vector p) const;

    Quaternion ToThe(double p) const;
    Quaternion Inverse() const;
    Quaternion Times(Quaternion b) const;
    Quaternion Mirror() const;
};

</t>
<t tx="leo1.20171224221605.30">class BandedMatrix {
public:
    enum {
        MAX_UNKNOWNS   = 16,
        RIGHT_OF_DIAG  = 1,
        LEFT_OF_DIAG   = 2
    };

    double A[MAX_UNKNOWNS][MAX_UNKNOWNS];
    double B[MAX_UNKNOWNS];
    double X[MAX_UNKNOWNS];
    int n;

    void Solve();
};

#define RGBi(r, g, b) RgbaColor::From((r), (g), (b))
#define RGBf(r, g, b) RgbaColor::FromFloat((float)(r), (float)(g), (float)(b))

// Note: sizeof(class RgbaColor) should be exactly 4
//
</t>
<t tx="leo1.20171224221605.31">class RgbaColor {
public:
    uint8_t red, green, blue, alpha;

    float redF()   const { return (float)red   / 255.0f; }
    float greenF() const { return (float)green / 255.0f; }
    float blueF()  const { return (float)blue  / 255.0f; }
    float alphaF() const { return (float)alpha / 255.0f; }

    bool IsEmpty() const { return alpha == 0; }

    @others
};

struct RgbaColorCompare {
</t>
<t tx="leo1.20171224221605.32">bool Equals(RgbaColor c) const {
    return
        c.red   == red   &amp;&amp;
        c.green == green &amp;&amp;
        c.blue  == blue  &amp;&amp;
        c.alpha == alpha;
}

RgbaColor WithAlpha(uint8_t newAlpha) const {
    RgbaColor color = *this;
    color.alpha = newAlpha;
    return color;
}

uint32_t ToPackedIntBGRA() const {
    return
        blue |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(red &lt;&lt; 16) |
        (uint32_t)((255 - alpha) &lt;&lt; 24);
}

uint32_t ToPackedInt() const {
    return
        red |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(blue &lt;&lt; 16) |
        (uint32_t)((255 - alpha) &lt;&lt; 24);
}

uint32_t ToARGB32() const {
    return
        blue |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(red &lt;&lt; 16) |
        (uint32_t)(alpha &lt;&lt; 24);
}

</t>
<t tx="leo1.20171224221605.33">static RgbaColor From(int r, int g, int b, int a = 255) {
    RgbaColor c;
    c.red   = (uint8_t)r;
    c.green = (uint8_t)g;
    c.blue  = (uint8_t)b;
    c.alpha = (uint8_t)a;
    return c;
}

</t>
<t tx="leo1.20171224221605.34">static RgbaColor FromFloat(float r, float g, float b, float a = 1.0) {
    return From(
        (int)(255.1f * r),
        (int)(255.1f * g),
        (int)(255.1f * b),
        (int)(255.1f * a));
}

</t>
<t tx="leo1.20171224221605.35">static RgbaColor FromPackedInt(uint32_t rgba) {
    return From(
        (int)((rgba)       &amp; 0xff),
        (int)((rgba &gt;&gt; 8)  &amp; 0xff),
        (int)((rgba &gt;&gt; 16) &amp; 0xff),
        (int)(255 - ((rgba &gt;&gt; 24) &amp; 0xff)));
}

</t>
<t tx="leo1.20171224221605.36">static RgbaColor FromPackedIntBGRA(uint32_t bgra) {
    return From(
        (int)((bgra &gt;&gt; 16) &amp; 0xff),
        (int)((bgra &gt;&gt; 8)  &amp; 0xff),
        (int)((bgra)       &amp; 0xff),
        (int)(255 - ((bgra &gt;&gt; 24) &amp; 0xff)));
}
</t>
<t tx="leo1.20171224221605.37">    bool operator()(RgbaColor a, RgbaColor b) const {
        return a.ToARGB32() &lt; b.ToARGB32();
    }
};

</t>
<t tx="leo1.20171224221605.38">class BBox {
public:
    Vector minp;
    Vector maxp;

    static BBox From(const Vector &amp;p0, const Vector &amp;p1);

    Vector GetOrigin() const;
    Vector GetExtents() const;

    void Include(const Vector &amp;v, double r = 0.0);
    bool Overlaps(const BBox &amp;b1) const;
    bool Contains(const Point2d &amp;p, double r = 0.0) const;
};

#endif
</t>
<t tx="leo1.20171224221605.39">//-----------------------------------------------------------------------------
// An expression in our symbolic algebra system, used to write, linearize,
// and solve our constraint equations.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#ifndef __EXPR_H
#define __EXPR_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221605.4">class Vector {
public:
    double x, y, z;

    static Vector From(double x, double y, double z);
    static Vector From(hParam x, hParam y, hParam z);
    static Vector AtIntersectionOfPlanes(Vector n1, double d1,
                                         Vector nc, double dc, bool *parallel);
    static void ClosestPointBetweenLines(Vector pa, Vector da,
    double DirectionCosineWith(Vector b) const;
    double Dot(Vector b) const;
    Vector Normal(int which) const;
    Vector RotatedAbout(Vector orig, Vector axis, double theta) const;
    Vector RotatedAbout(Vector axis, double theta) const;
    Vector DotInToCsys(Vector u, Vector v, Vector n) const;
    Vector ScaleOutOfCsys(Vector u, Vector v, Vector n) const;
    double DistanceToLine(Vector p0, Vector dp) const;
    double DistanceToPlane(Vector normal, Vector origin) const;
    bool OnLineSegment(Vector a, Vector b, double tol=LENGTH_EPS) const;
    Vector ClosestPointOnLine(Vector p0, Vector deltal) const;
    double Magnitude() const;
    double MagSquared() const;
    Vector WithMagnitude(double s) const;
    Vector ScaledBy(double s) const;
    Vector ProjectInto(hEntity wrkpl) const;
    Vector ProjectVectorInto(hEntity wrkpl) const;
    double DivPivoting(Vector delta) const;
    Vector ClosestOrtho() const;
    void MakeMaxMin(Vector *maxv, Vector *minv) const;
    Vector ClampWithin(double minv, double maxv) const;
    static bool BoundingBoxesDisjoint(Vector amax, Vector amin,

struct VectorHash {
    size_t operator()(const Vector &amp;v) const;
};

struct VectorPred {
    bool operator()(Vector a, Vector b) const;
};

</t>
<t tx="leo1.20171224221605.40">class Expr {
public:

    enum class Op : uint32_t {
        // A parameter, by the hParam handle
        PARAM          =  0,
        // A parameter, by a pointer straight in to the param table (faster,
        // if we know that the param table won't move around)
        PARAM_PTR      =  1,

        // Operands
        CONSTANT       = 20,
        VARIABLE       = 21,

        // Binary ops
        PLUS           = 100,
        MINUS          = 101,
        TIMES          = 102,
        DIV            = 103,
        // Unary ops
        NEGATE         = 104,
        SQRT           = 105,
        SQUARE         = 106,
        SIN            = 107,
        COS            = 108,
        ASIN           = 109,
        ACOS           = 110,
    };

    Op      op;
    Expr    *a;
    union {
        double  v;
        hParam  parh;
        Param  *parp;
        Expr    *b;
    };

    Expr() { }
    Expr(double val) : op(Op::CONSTANT) { v = val; }

    static inline Expr *AllocExpr()

    inline Expr *Negate() { return AnyOp(Op::NEGATE, NULL); }
    inline Expr *Sqrt  () { return AnyOp(Op::SQRT,   NULL); }
    inline Expr *Square() { return AnyOp(Op::SQUARE, NULL); }
    inline Expr *Sin   () { return AnyOp(Op::SIN,    NULL); }
    inline Expr *Cos   () { return AnyOp(Op::COS,    NULL); }
    inline Expr *ASin  () { return AnyOp(Op::ASIN,   NULL); }
    inline Expr *ACos  () { return AnyOp(Op::ACOS,   NULL); }

    Expr *PartialWrt(hParam p) const;
    double Eval() const;
    uint64_t ParamsUsed() const;
    bool DependsOn(hParam p) const;
    static bool Tol(double a, double b);
    Expr *FoldConstants();
    void Substitute(hParam oldh, hParam newh);

    static const hParam NO_PARAMS, MULTIPLE_PARAMS;
    hParam ReferencedParams(ParamList *pl) const;

    void ParamsToPointers();

    std::string Print() const;

    // number of child nodes: 0 (e.g. constant), 1 (sqrt), or 2 (+)
    int Children() const;
    // total number of nodes in the tree
    int Nodes() const;

    // Make a simple copy
    Expr *DeepCopy() const;
    // Make a copy, with the parameters (usually referenced by hParam)
    // resolved to pointers to the actual value. This speeds things up
    // considerably.
    Expr *DeepCopyWithParamsAsPointers(IdList&lt;Param,hParam&gt; *firstTry,
                                       IdList&lt;Param,hParam&gt; *thenTry) const;

    static Expr *Parse(const char *input, std::string *error);
    static Expr *From(const char *in, bool popUpError);
};

</t>
<t tx="leo1.20171224221605.41">class ExprVector {
public:
    Expr *x, *y, *z;

    static ExprVector From(Expr *x, Expr *y, Expr *z);
    static ExprVector From(Vector vn);
    static ExprVector From(hParam x, hParam y, hParam z);
    static ExprVector From(double x, double y, double z);

    ExprVector Plus(ExprVector b) const;
    ExprVector Minus(ExprVector b) const;
    Expr *Dot(ExprVector b) const;
    ExprVector Cross(ExprVector b) const;
    ExprVector ScaledBy(Expr *s) const;
    ExprVector WithMagnitude(Expr *s) const;
    Expr *Magnitude() const;

    Vector Eval() const;
};

</t>
<t tx="leo1.20171224221605.42">class ExprQuaternion {
public:
    Expr *w, *vx, *vy, *vz;

    static ExprQuaternion From(Expr *w, Expr *vx, Expr *vy, Expr *vz);
    static ExprQuaternion From(Quaternion qn);
    static ExprQuaternion From(hParam w, hParam vx, hParam vy, hParam vz);

    ExprVector RotationU() const;
    ExprVector RotationV() const;
    ExprVector RotationN() const;

    ExprVector Rotate(ExprVector p) const;
    ExprQuaternion Times(ExprQuaternion b) const;

    Expr *Magnitude() const;
};
#endif
</t>
<t tx="leo1.20171224221605.43">//-----------------------------------------------------------------------------
// Anything relating to plane polygons and triangles, and (generally, non-
// planar) meshes thereof.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef __POLYGON_H
#define __POLYGON_H

class SPointList;
class SPolygon;
class SContour;
class SMesh;
class SBsp3;
class SOutlineList;

enum class EarType : uint32_t {
    UNKNOWN = 0,
    NOT_EAR = 1,
    EAR     = 2
};

enum class BspClass : uint32_t {
    POS         = 100,
    NEG         = 101,
    COPLANAR    = 200
};

enum class EdgeKind : uint32_t {
    NAKED_OR_SELF_INTER  = 100,
    SELF_INTER           = 200,
    TURNING              = 300,
    EMPHASIZED           = 400,
    SHARP                = 500,
};

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221605.44">class SEdge {
public:
    int    tag;
    int    auxA, auxB;
    Vector a, b;

    static SEdge From(Vector a, Vector b);
    bool EdgeCrosses(Vector a, Vector b, Vector *pi=NULL, SPointList *spl=NULL) const;
};

</t>
<t tx="leo1.20171224221605.45">class SEdgeList {
public:
    List&lt;SEdge&gt;     l;

    void Clear();
    void AddEdge(Vector a, Vector b, int auxA=0, int auxB=0, int tag=0);
    bool AssemblePolygon(SPolygon *dest, SEdge *errorAt, bool keepDir=false) const;
    bool AssembleContour(Vector first, Vector last, SContour *dest,
// of the boundary. So increasing this number never breaks anything, but may
// result in more duplicated elements. So it's conservative to be sloppy here.
#define KDTREE_EPS (20*LENGTH_EPS)

</t>
<t tx="leo1.20171224221605.46">class SEdgeLl {
public:
    SEdge       *se;
    SEdgeLl     *next;

    static SEdgeLl *Alloc();
};

</t>
<t tx="leo1.20171224221605.47">class SKdNodeEdges {
public:
    int which; // whether c is x, y, or z
    double c;
    SKdNodeEdges    *gt;
    SKdNodeEdges    *lt;

    SEdgeLl         *edges;

    static SKdNodeEdges *From(SEdgeList *sel);
    static SKdNodeEdges *From(SEdgeLl *sell);
    static SKdNodeEdges *Alloc();
    @others
};

</t>
<t tx="leo1.20171224221605.48">    int AnyEdgeCrossings(Vector a, Vector b, int cnt,
        Vector *pi=NULL, SPointList *spl=NULL) const;
};

class SPoint {
public:
    int     tag;

    EarType ear;

    Vector  p;
    Vector  auxv;
</t>
<t tx="leo1.20171224221605.49">class SPointList {
public:
    List&lt;SPoint&gt;    l;

    void Clear();
    bool ContainsPoint(Vector pt) const;
    int IndexForPoint(Vector pt) const;
    void IncrementTagFor(Vector pt);
    void Add(Vector pt);
};

</t>
<t tx="leo1.20171224221605.5">class Vector4 {
public:
    double w, x, y, z;

    static Vector4 From(double w, double x, double y, double z);
    static Vector4 From(double w, Vector v3);
    static Vector4 Blend(Vector4 a, Vector4 b, double t);

    Vector4 Plus(Vector4 b) const;
    Vector4 Minus(Vector4 b) const;
    Vector4 ScaledBy(double s) const;
    Vector PerspectiveProject() const;
};

</t>
<t tx="leo1.20171224221605.50">class SContour {
public:
    int             tag;
    int             timesEnclosed;
    Vector          xminPt;
    List&lt;SPoint&gt;    l;

    void AddPoint(Vector p);
    void MakeEdgesInto(SEdgeList *el) const;
    void Reverse();
    Vector ComputeNormal() const;
    double SignedAreaProjdToNormal(Vector n) const;
    bool IsClockwiseProjdToNormal(Vector n) const;
    bool ContainsPointProjdToNormal(Vector n, Vector p) const;
    void OffsetInto(SContour *dest, double r) const;
    void CopyInto(SContour *dest) const;
    void FindPointWithMinX();
    Vector AnyEdgeMidpoint() const;

    bool IsEar(int bp, double scaledEps) const;
    bool BridgeToContour(SContour *sc, SEdgeList *el, List&lt;Vector&gt; *vl);
    void ClipEarInto(SMesh *m, int bp, double scaledEps);
    void UvTriangulateInto(SMesh *m, SSurface *srf);
};

</t>
<t tx="leo1.20171224221605.51">typedef struct {
    uint32_t face;
    RgbaColor color;
} STriMeta;

</t>
<t tx="leo1.20171224221605.52">class SPolygon {
public:
    List&lt;SContour&gt;  l;
    Vector          normal;

    Vector ComputeNormal() const;
    void AddEmptyContour();
    int WindingNumberForPoint(Vector p) const;
    double SignedArea() const;
    bool ContainsPoint(Vector p) const;
    void MakeEdgesInto(SEdgeList *el) const;
    void FixContourDirections();
    void Clear();
    bool SelfIntersecting(Vector *intersectsAt) const;
    bool IsEmpty() const;
    Vector AnyPoint() const;
    void OffsetInto(SPolygon *dest, double r) const;
    void UvTriangulateInto(SMesh *m, SSurface *srf);
    void UvGridTriangulateInto(SMesh *m, SSurface *srf);
    void TriangulateInto(SMesh *m) const;
    void InverseTransformInto(SPolygon *sp, Vector u, Vector v, Vector n) const;
};

</t>
<t tx="leo1.20171224221605.53">class STriangle {
public:
    int         tag;
    STriMeta    meta;

    union {
        struct { Vector a, b, c; };
        Vector vertices[3];
    };

    union {
        struct { Vector an, bn, cn; };
        Vector normals[3];
    };

    static STriangle From(STriMeta meta, Vector a, Vector b, Vector c);
    Vector Normal() const;
    void FlipNormal();
    double MinAltitude() const;
    int WindingNumberForPoint(Vector p) const;
    bool ContainsPoint(Vector p) const;
    bool ContainsPointProjd(Vector n, Vector p) const;
    STriangle Transform(Vector o, Vector u, Vector v) const;
    @others
};

// A linked list of triangles
</t>
<t tx="leo1.20171224221605.54">    bool Raytrace(const Vector &amp;rayPoint, const Vector &amp;rayDir,
                  double *t, Vector *inters) const;
    double SignedVolume() const;
};

class SBsp2 {
public:
    Vector      np;     // normal to the plane

    Vector      no;     // outer normal to the edge
    double      d;
    SEdge       edge;

    SBsp2       *pos;
    SBsp2       *neg;

    SBsp2       *more;

    void InsertTriangleHow(BspClass how, STriangle *tr, SMesh *m, SBsp3 *bsp3);
    void InsertTriangle(STriangle *tr, SMesh *m, SBsp3 *bsp3);
    Vector IntersectionWith(Vector a, Vector b) const;
    void InsertEdge(SEdge *nedge, Vector nnp, Vector out);
</t>
<t tx="leo1.20171224221605.55">    static SBsp2 *InsertOrCreateEdge(SBsp2 *where, SEdge *nedge,
                                     Vector nnp, Vector out);
    static SBsp2 *Alloc();
};

class SBsp3 {
public:
    Vector      n;
    double      d;

    STriangle   tri;
    SBsp3       *pos;
    SBsp3       *neg;

    SBsp3       *more;

    SBsp2       *edges;

    static SBsp3 *Alloc();
    static SBsp3 *FromMesh(const SMesh *m);

    Vector IntersectionWith(Vector a, Vector b) const;

    void InsertHow(BspClass how, STriangle *str, SMesh *instead);
    void Insert(STriangle *str, SMesh *instead);
    static SBsp3 *InsertOrCreate(SBsp3 *where, STriangle *str, SMesh *instead);

</t>
<t tx="leo1.20171224221605.56">    void InsertConvexHow(BspClass how, STriMeta meta, Vector *vertex, size_t n,
                                SMesh *instead);
    SBsp3 *InsertConvex(STriMeta meta, Vector *vertex, size_t n, SMesh *instead);

    void InsertInPlane(bool pos2, STriangle *tr, SMesh *m);

    void GenerateInPaintOrder(SMesh *m) const;
};

class SMesh {
public:
    List&lt;STriangle&gt;     l;

    bool    flipNormal;
    bool    keepCoplanar;
    bool    atLeastOneDiscarded;
    bool    isTransparent;

    void Clear();
    void AddTriangle(const STriangle *st);
    void AddTriangle(STriMeta meta, Vector a, Vector b, Vector c);
    void AddTriangle(STriMeta meta, Vector n,
    void MakeFromCopyOf(SMesh *a);
    void MakeFromTransformationOf(SMesh *a, Vector trans,
    void RemapFaces(Group *g, int remap);

    uint32_t FirstIntersectionWith(Point2d mp) const;

    Vector GetCenterOfMass() const;
</t>
<t tx="leo1.20171224221605.57">class STriangleLl {
public:
    STriangle       *tri;

    STriangleLl     *next;

    static STriangleLl *Alloc();
};

</t>
<t tx="leo1.20171224221605.58">class SOutline {
public:
    int    tag;
    Vector a, b, nl, nr;

    bool IsVisible(Vector projDir) const;
};

</t>
<t tx="leo1.20171224221605.59">class SOutlineList {
public:
    List&lt;SOutline&gt; l;

    void Clear();
    void AddEdge(Vector a, Vector b, Vector nl, Vector nr, int tag = 0);
    void ListTaggedInto(SEdgeList *el, int auxA = 0, int auxB = 0);

    void MakeFromCopyOf(SOutlineList *ol);
};

</t>
<t tx="leo1.20171224221605.6">class Point2d {
public:
    double x, y;

    static Point2d From(double x, double y);
    static Point2d FromPolar(double r, double a);

    Point2d Plus(const Point2d &amp;b) const;
    Point2d Minus(const Point2d &amp;b) const;
    Point2d ScaledBy(double s) const;
    double DivPivoting(Point2d delta) const;
    double Dot(Point2d p) const;
    double DistanceTo(const Point2d &amp;p) const;
    double DistanceToLine(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const;
    double DistanceToLineSigned(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const;
    double Angle() const;
    double AngleTo(const Point2d &amp;p) const;
    double Magnitude() const;
    double MagSquared() const;
    Point2d WithMagnitude(double v) const;
    Point2d Normal() const;
    bool Equals(Point2d v, double tol=LENGTH_EPS) const;
};

// A simple list
template &lt;class T&gt;
</t>
<t tx="leo1.20171224221605.60">class SKdNode {
public:
    struct EdgeOnInfo {
        int        count;
        bool       frontFacing;
        bool       intersectsMesh;
        STriangle *tr;
        int        ai;
        int        bi;
    };

    int which;  // whether c is x, y, or z
    double c;

    SKdNode      *gt;
    SKdNode      *lt;

    STriangleLl  *tris;

    static SKdNode *Alloc();
    static SKdNode *From(SMesh *m);
    static SKdNode *From(STriangleLl *tll);

    void AddTriangle(STriangle *tr);
    void MakeMeshInto(SMesh *m) const;
    void ListTrianglesInto(std::vector&lt;STriangle *&gt; *tl) const;
    void ClearTags() const;

    void FindEdgeOn(Vector a, Vector b, int cnt, bool coplanarIsInter, EdgeOnInfo *info) const;
    void MakeCertainEdgesInto(SEdgeList *sel, EdgeKind how, bool coplanarIsInter,
@others
</t>
<t tx="leo1.20171224221605.61">class PolylineBuilder {
public:
    struct Edge;

    struct Vertex {
        Vector              pos;
        std::vector&lt;Edge *&gt; edges;

        bool GetNext(uint32_t kind, Vertex **next, Edge **nextEdge);
        bool GetNext(uint32_t kind, Vector plane, double d, Vertex **next, Edge **nextEdge);
        size_t CountEdgesWithTagAndKind(int tag, uint32_t kind) const;
    };

    struct VertexPairHash {
        size_t operator()(const std::pair&lt;Vertex *, Vertex *&gt; &amp;v) const;
    };

    struct Edge {
        Vertex   *a;
        Vertex   *b;
        uint32_t  kind;
        int       tag;

        union {
            uintptr_t  data;
            SOutline  *outline;
            SEdge     *edge;
        };

        Vertex *GetOtherVertex(Vertex *v) const;
        bool GetStartAndNext(Vertex **start, Vertex **next, bool loop) const;
    };

    std::unordered_map&lt;Vector, Vertex *, VectorHash, VectorPred&gt; vertices;
    std::unordered_map&lt;std::pair&lt;Vertex *, Vertex *&gt;, Edge *, VertexPairHash&gt; edgeMap;
    std::vector&lt;Edge *&gt; edges;

    ~PolylineBuilder();
    void Clear();

    Vertex *AddVertex(const Vector &amp;pos);
    Edge *AddEdge(const Vector &amp;p0, const Vector &amp;p1, uint32_t kind, uintptr_t data = 0);
    void Generate(

#endif

</t>
<t tx="leo1.20171224221605.62">//-----------------------------------------------------------------------------
// Discovery and loading of our resources (icons, fonts, templates, etc).
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------

#ifndef __RESOURCE_H
#define __RESOURCE_H

class Camera;
class Point2d;
class Pixmap;
class Vector;

std::string LoadString(const std::string &amp;name);
std::string LoadStringFromGzip(const std::string &amp;name);
std::shared_ptr&lt;Pixmap&gt; LoadPng(const std::string &amp;name);

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221605.63">class Pixmap {
public:
    enum class Format { BGRA, RGBA, BGR, RGB, A };

    Format                     format;
    size_t                     width;
    size_t                     height;
    size_t                     stride;
    std::vector&lt;uint8_t&gt;       data;

    static std::shared_ptr&lt;Pixmap&gt; Create(Format format, size_t width, size_t height);
    static std::shared_ptr&lt;Pixmap&gt; FromPng(const uint8_t *data, size_t size, bool flip = false);

    static std::shared_ptr&lt;Pixmap&gt; ReadPng(FILE *f, bool flip = false);
    static std::shared_ptr&lt;Pixmap&gt; ReadPng(const Platform::Path &amp;filename, bool flip = false);
    bool WritePng(FILE *f, bool flip = false);
    bool WritePng(const Platform::Path &amp;filename, bool flip = false);

    size_t GetBytesPerPixel() const;
    RgbaColor GetPixel(size_t x, size_t y) const;
    bool Equals(const Pixmap &amp;other) const;

    void ConvertTo(Format newFormat);
    void SetPixel(size_t x, size_t y, RgbaColor color);
};

</t>
<t tx="leo1.20171224221605.64">class BitmapFont {
public:
    struct Glyph {
        uint8_t  advanceCells;
        uint16_t position;
    };

    std::string                unifontData;
    std::map&lt;char32_t, Glyph&gt;  glyphs;
    std::shared_ptr&lt;Pixmap&gt;    texture;
    bool                       textureUpdated;
    uint16_t                   nextPosition;

    static BitmapFont From(std::string &amp;&amp;unifontData);
    static BitmapFont Create();

    bool IsEmpty() const { return unifontData.empty(); }
    const Glyph &amp;GetGlyph(char32_t codepoint);
    @others
</t>
<t tx="leo1.20171224221605.65">    void LocateGlyph(char32_t codepoint, double *s0, double *t0, double *s1, double *t1,
                     size_t *advanceWidth, size_t *boundingHeight);

    void AddGlyph(char32_t codepoint, std::shared_ptr&lt;const Pixmap&gt; pixmap);

    size_t GetWidth(char32_t codepoint);
    size_t GetWidth(const std::string &amp;str);
};

class VectorFont {
public:
    struct Contour {
        std::vector&lt;Point2d&gt;   points;
    };

    struct Glyph {
        std::vector&lt;Contour&gt;   contours;
        double                 leftSideBearing;
        double                 boundingWidth;
        double                 advanceWidth;
    };

    std::string                lffData;
    std::map&lt;char32_t, Glyph&gt;  glyphs;
    double                     rightSideBearing;
    double                     capHeight;
    double                     ascender;
    double                     descender;

    static VectorFont From(std::string &amp;&amp;lffData);
    static VectorFont *Builtin();

    bool IsEmpty() const { return lffData.empty(); }
    const Glyph &amp;GetGlyph(char32_t codepoint);

    double GetCapHeight(double forCapHeight) const;
    double GetHeight(double forCapHeight) const;
    double GetWidth(double forCapHeight, const std::string &amp;str);
    Vector GetExtents(double forCapHeight, const std::string &amp;str);

    void Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
</t>
<t tx="leo1.20171224221605.66">//-----------------------------------------------------------------------------
// The parametric structure of our sketch, in multiple groups, that generate
// geometric entities and surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef __SKETCH_H
#define __SKETCH_H

class hGroup;
class hRequest;
class hEntity;
class hParam;
class hStyle;
class hConstraint;
class hEquation;

class Entity;
class Param;
class Equation;
class Style;

enum class PolyError : uint32_t {
    GOOD              = 0,
    NOT_CLOSED        = 1,
    NOT_COPLANAR      = 2,
    SELF_INTERSECTING = 3,
    ZERO_LEN_EDGE     = 4
};

enum class StipplePattern : uint32_t {
    CONTINUOUS     = 0,
    SHORT_DASH     = 1,
    DASH           = 2,
    LONG_DASH      = 3,
    DASH_DOT       = 4,
    DASH_DOT_DOT   = 5,
    DOT            = 6,
    FREEHAND       = 7,
    ZIGZAG         = 8,

    LAST           = ZIGZAG
};

const std::vector&lt;double&gt; &amp;StipplePatternDashes(StipplePattern pattern);
double StipplePatternLength(StipplePattern pattern);

enum class Command : uint32_t;

// All of the hWhatever handles are a 32-bit ID, that is used to represent
// some data structure in the sketch.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221605.67">class hGroup {
public:
    // bits 15: 0   -- group index
    uint32_t v;

    inline hEntity entity(int i) const;
    inline hParam param(int i) const;
    inline hEquation equation(int i) const;
};
</t>
<t tx="leo1.20171224221605.68">class hRequest {
public:
    // bits 15: 0   -- request index
    uint32_t v;

    inline hEntity entity(int i) const;
    inline hParam param(int i) const;

    inline bool IsFromReferences() const;
};
</t>
<t tx="leo1.20171224221605.69">class hEntity {
public:
    // bits 15: 0   -- entity index
    //      31:16   -- request index
    uint32_t v;

    inline bool isFromRequest() const;
    inline hRequest request() const;
    inline hGroup group() const;
    inline hEquation equation(int i) const;
};
</t>
<t tx="leo1.20171224221605.7">class List {
public:
    T   *elem;
    int  n;
    int  elemsAllocated;

    @others
};

// A list, where each element has an integer identifier. The list is kept
// sorted by that identifier, and items can be looked up in log n time by
// id.
template &lt;class T, class H&gt;
</t>
<t tx="leo1.20171224221605.70">class hParam {
public:
    // bits 15: 0   -- param index
    //      31:16   -- request index
    uint32_t v;

    inline hRequest request() const;
};

</t>
<t tx="leo1.20171224221605.71">class hStyle {
public:
    uint32_t v;
};

</t>
<t tx="leo1.20171224221605.72">class EntityId {
public:
    uint32_t v;     // entity ID, starting from 0
};
</t>
<t tx="leo1.20171224221605.73">class EntityMap {
public:
    int         tag;

    EntityId    h;
    hEntity     input;
    int         copyNumber;
    // (input, copyNumber) gets mapped to ((Request)xxx).entity(h.v)

    @others
};

// A user request for some primitive or derived operation; for example a
// line, or a step and repeat.
</t>
<t tx="leo1.20171224221605.74">    void Clear() {}
};

// A set of requests. Every request must have an associated group.
class Group {
public:
    static const hGroup     HGROUP_REFERENCES;

    int         tag;
    hGroup      h;

    enum class CopyAs {
        NUMERIC,
        N_TRANS,
        N_ROT_AA,
        N_ROT_TRANS,
    };

    enum class Type : uint32_t {
        DRAWING_3D                    = 5000,
        DRAWING_WORKPLANE             = 5001,
        EXTRUDE                       = 5100,
        LATHE                         = 5101,
        ROTATE                        = 5200,
        TRANSLATE                     = 5201,
        LINKED                        = 5300
    };
    Group::Type type;

    int order;

    hGroup      opA;
    hGroup      opB;
    bool        visible;
    bool        suppress;
    bool        relaxConstraints;
    bool        allowRedundant;
    bool        allDimsReference;
    double      scale;

    bool        clean;
    bool        dofCheckOk;
    hEntity     activeWorkplane;
    double      valA;
    double      valB;
    double      valC;
    RgbaColor   color;

    struct {
        SolveResult         how;
        int                 dof;
        List&lt;hConstraint&gt;   remove;
    } solved;

    enum class Subtype : uint32_t {
        // For drawings in 2d
        WORKPLANE_BY_POINT_ORTHO   = 6000,
        WORKPLANE_BY_LINE_SEGMENTS = 6001,
        // For extrudes, translates, and rotates
        ONE_SIDED                  = 7000,
        TWO_SIDED                  = 7001
    };
    Group::Subtype subtype;

    bool skipFirst; // for step and repeat ops

    struct {
        Quaternion  q;
        hEntity     origin;
        hEntity     entityB;
        hEntity     entityC;
        bool        swapUV;
        bool        negateU;
        bool        negateV;
    } predef;

    SPolygon                polyLoops;
    SBezierLoopSetSet       bezierLoops;
    SBezierList             bezierOpens;

    struct {
        PolyError       how;
        SEdge           notClosedAt;
        Vector          errorPointAt;
    }               polyError;

    bool            booleanFailed;

    SShell          thisShell;
    SShell          runningShell;

    SMesh           thisMesh;
    SMesh           runningMesh;

    bool            displayDirty;
    SMesh           displayMesh;
    SOutlineList    displayOutlines;

    enum class CombineAs : uint32_t {
        UNION           = 0,
        DIFFERENCE      = 1,
        ASSEMBLE        = 2
    };
    CombineAs meshCombine;

    bool forceToMesh;

    IdList&lt;EntityMap,EntityId&gt; remap;
    enum { REMAP_PRIME = 19477 };
    int remapCache[REMAP_PRIME];

    Platform::Path linkFile;
    SMesh       impMesh;
    SShell      impShell;
    EntityList  impEntity;

    std::string     name;


    void Activate();
    std::string DescriptionString();
    void Clear();

    static void AddParam(ParamList *param, hParam hp, double v);
    void Generate(EntityList *entity, ParamList *param);
    bool IsSolvedOkay();
    void TransformImportedBy(Vector t, Quaternion q);
    bool IsForcedToMeshBySource() const;
    bool IsForcedToMesh() const;
    // When a request generates entities from entities, and the source
    // entities may have come from multiple requests, it's necessary to
    // remap the entity ID so that it's still unique. We do this with a
    // mapping list.
    enum {
        REMAP_LAST         = 1000,
        REMAP_TOP          = 1001,
        REMAP_BOTTOM       = 1002,
        REMAP_PT_TO_LINE   = 1003,
        REMAP_LINE_TO_FACE = 1004,
        REMAP_LATHE_START  = 1006,
        REMAP_LATHE_END    = 1007,
        REMAP_PT_TO_ARC    = 1008,
        REMAP_PT_TO_NORMAL = 1009,
    };
    hEntity Remap(hEntity in, int copyNumber);
    void MakeExtrusionLines(EntityList *el, hEntity in);
    void MakeLatheCircles(IdList&lt;Entity,hEntity&gt; *el, IdList&lt;Param,hParam&gt; *param, hEntity in, Vector pt, Vector axis, int ai);
    void MakeExtrusionTopBottomFaces(EntityList *el, hEntity pt);
    void CopyEntity(EntityList *el,
    void ExtrusionForceVectorTo(const Vector &amp;v);

    // Assembling the curves into loops, and into a piecewise linear polygon
    // at the same time.
    void AssembleLoops(bool *allClosed, bool *allCoplanar, bool *allNonZeroLen);
    void GenerateLoops();
    // And the mesh stuff
    Group *PreviousGroup() const;
    Group *RunningMeshGroup() const;
    bool IsMeshGroup();

    void GenerateShellAndMesh();
    template&lt;class T&gt; void GenerateForStepAndRepeat(T *steps, T *outs, Group::CombineAs forWhat);
    template&lt;class T&gt; void GenerateForBoolean(T *a, T *b, T *o, Group::CombineAs how);
    void GenerateDisplayItems();

    enum class DrawMeshAs { DEFAULT, HOVERED, SELECTED };
    void DrawMesh(DrawMeshAs how, Canvas *canvas);
    void Draw(Canvas *canvas);
    void DrawPolyError(Canvas *canvas);
    void DrawFilledPaths(Canvas *canvas);
    void DrawContourAreaLabels(Canvas *canvas);

    SPolygon GetPolygon();

    static void MenuGroup(Command id);
</t>
<t tx="leo1.20171224221605.75">class Request {
public:
    // Some predefined requests, that are present in every sketch.
    static const hRequest   HREQUEST_REFERENCE_XY;
    static const hRequest   HREQUEST_REFERENCE_YZ;
    static const hRequest   HREQUEST_REFERENCE_ZX;

    int         tag;
    hRequest    h;

    // Types of requests
    enum class Type : uint32_t {
        WORKPLANE              = 100,
        DATUM_POINT            = 101,
        LINE_SEGMENT           = 200,
        CUBIC                  = 300,
        CUBIC_PERIODIC         = 301,
        CIRCLE                 = 400,
        ARC_OF_CIRCLE          = 500,
        TTF_TEXT               = 600,
        IMAGE                  = 700
    };

    Request::Type type;
    int         extraPoints;

    hEntity     workplane; // or Entity::FREE_IN_3D
    hGroup      group;
    hStyle      style;

    bool        construction;

    std::string str;
    std::string font;
    Platform::Path file;
    double      aspectRatio;

    static hParam AddParam(ParamList *param, hParam hp);
    void Generate(EntityList *entity, ParamList *param);

    std::string DescriptionString() const;
    int IndexOfPoint(hEntity he) const;

    @others
};

</t>
<t tx="leo1.20171224221605.8">void ReserveMore(int howMuch) {
    if(n + howMuch &gt; elemsAllocated) {
        elemsAllocated = n + howMuch;
        T *newElem = (T *)MemAlloc((size_t)elemsAllocated*sizeof(elem[0]));
        for(int i = 0; i &lt; n; i++) {
            new(&amp;newElem[i]) T(std::move(elem[i]));
            elem[i].~T();
        }
        MemFree(elem);
        elem = newElem;
    }
}

</t>
<t tx="leo1.20171224221605.9">void AllocForOneMore() {
    if(n &gt;= elemsAllocated) {
        ReserveMore((elemsAllocated + 32)*2 - n);
    }
}

</t>
<t tx="leo1.20171224221606.1">    void Clear() {}
};

#define MAX_POINTS_IN_ENTITY (12)
class EntityBase {
public:
    int         tag;
    hEntity     h;

    static const hEntity    FREE_IN_3D;
    static const hEntity    NO_ENTITY;

    enum class Type : uint32_t {
        POINT_IN_3D            =  2000,
        POINT_IN_2D            =  2001,
        POINT_N_TRANS          =  2010,
        POINT_N_ROT_TRANS      =  2011,
        POINT_N_COPY           =  2012,
        POINT_N_ROT_AA         =  2013,

        NORMAL_IN_3D           =  3000,
        NORMAL_IN_2D           =  3001,
        NORMAL_N_COPY          =  3010,
        NORMAL_N_ROT           =  3011,
        NORMAL_N_ROT_AA        =  3012,

        DISTANCE               =  4000,
        DISTANCE_N_COPY        =  4001,

        FACE_NORMAL_PT         =  5000,
        FACE_XPROD             =  5001,
        FACE_N_ROT_TRANS       =  5002,
        FACE_N_TRANS           =  5003,
        FACE_N_ROT_AA          =  5004,

        WORKPLANE              = 10000,
        LINE_SEGMENT           = 11000,
        CUBIC                  = 12000,
        CUBIC_PERIODIC         = 12001,
        CIRCLE                 = 13000,
        ARC_OF_CIRCLE          = 14000,
        TTF_TEXT               = 15000,
        IMAGE                  = 16000
    };

    Type        type;

    hGroup      group;
    hEntity     workplane;   // or Entity::FREE_IN_3D

    // When it comes time to draw an entity, we look here to get the
    // defining variables.
    hEntity     point[MAX_POINTS_IN_ENTITY];
    int         extraPoints;
    hEntity     normal;
    hEntity     distance;
    // The only types that have their own params are points, normals,
    // and directions.
    hParam      param[7];

    // Transformed points/normals/distances have their numerical base
    Vector      numPoint;
    Quaternion  numNormal;
    double      numDistance;

    std::string str;
    std::string font;
    Platform::Path file;
    double      aspectRatio;

    // For entities that are derived by a transformation, the number of
    // times to apply the transformation.
    int timesApplied;

    Quaternion GetAxisAngleQuaternion(int param0) const;
    ExprQuaternion GetAxisAngleQuaternionExprs(int param0) const;

    bool IsCircle() const;
    Expr *CircleGetRadiusExpr() const;
    double CircleGetRadiusNum() const;
    void ArcGetAngles(double *thetaa, double *thetab, double *dtheta) const;

    bool HasVector() const;
    ExprVector VectorGetExprs() const;
    ExprVector VectorGetExprsInWorkplane(hEntity wrkpl) const;
    Vector VectorGetNum() const;
    Vector VectorGetRefPoint() const;
    Vector VectorGetStartPoint() const;

    // For distances
    bool IsDistance() const;
    double DistanceGetNum() const;
    Expr *DistanceGetExpr() const;
    void DistanceForceTo(double v);

    bool IsWorkplane() const;
    // The plane is points P such that P dot (xn, yn, zn) - d = 0
    void WorkplaneGetPlaneExprs(ExprVector *n, Expr **d) const;
    ExprVector WorkplaneGetOffsetExprs() const;
    Vector WorkplaneGetOffset() const;
    EntityBase *Normal() const;

    bool IsFace() const;
    ExprVector FaceGetNormalExprs() const;
    Vector FaceGetNormalNum() const;
    ExprVector FaceGetPointExprs() const;
    Vector FaceGetPointNum() const;

    bool IsPoint() const;
    // Applies for any of the point types
    Vector PointGetNum() const;
    ExprVector PointGetExprs() const;
    void PointGetExprsInWorkplane(hEntity wrkpl, Expr **u, Expr **v) const;
    ExprVector PointGetExprsInWorkplane(hEntity wrkpl) const;
    void PointForceTo(Vector v);
    void PointForceParamTo(Vector v);
    // These apply only the POINT_N_ROT_TRANS, which has an assoc rotation
    Quaternion PointGetQuaternion() const;
    void PointForceQuaternionTo(Quaternion q);

    bool IsNormal() const;
    // Applies for any of the normal types
    Quaternion NormalGetNum() const;
    ExprQuaternion NormalGetExprs() const;
    void NormalForceTo(Quaternion q);

    Vector NormalU() const;
    Vector NormalV() const;
    Vector NormalN() const;
    ExprVector NormalExprsU() const;
    ExprVector NormalExprsV() const;
    ExprVector NormalExprsN() const;

    Vector CubicGetStartNum() const;
    Vector CubicGetFinishNum() const;
    ExprVector CubicGetStartTangentExprs() const;
    ExprVector CubicGetFinishTangentExprs() const;
    Vector CubicGetStartTangentNum() const;
    Vector CubicGetFinishTangentNum() const;

    bool HasEndpoints() const;
    Vector EndpointStart() const;
    Vector EndpointFinish() const;

    void RectGetPointsExprs(ExprVector *eap, ExprVector *ebp) const;

    void AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const;
    void GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) const;

</t>
<t tx="leo1.20171224221606.10">class Equation {
public:
    int         tag;
    hEquation   h;

    Expr        *e;

    @others
}
inline hEntity hRequest::entity(int i) const
    { hEntity r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }
inline hParam hRequest::param(int i) const
    { hParam r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }

inline bool hEntity::isFromRequest() const
    { if(v &amp; 0x80000000) return false; else return true; }
inline hRequest hEntity::request() const
    { hRequest r; r.v = (v &gt;&gt; 16); return r; }
inline hGroup hEntity::group() const
    { hGroup r; r.v = (v &gt;&gt; 16) &amp; 0x3fff; return r; }
inline hEquation hEntity::equation(int i) const
    { hEquation r; r.v = v | 0x40000000 | (uint32_t)i; return r; }

inline hRequest hParam::request() const
    { hRequest r; r.v = (v &gt;&gt; 16); return r; }


inline hEquation hConstraint::equation(int i) const
    { hEquation r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }
inline hParam hConstraint::param(int i) const
    { hParam r; r.v = v | 0x40000000 | (uint32_t)i; return r; }

inline bool hEquation::isFromConstraint() const
    { if(v &amp; 0xc0000000) return false; else return true; }
inline hConstraint hEquation::constraint() const
    { hConstraint r; r.v = (v &gt;&gt; 16); return r; }

// The format for entities stored on the clipboard.
</t>
<t tx="leo1.20171224221606.100">class SSurface {
public:

    enum class CombineAs : uint32_t {
        UNION      = 10,
        DIFFERENCE = 11,
        INTERSECT  = 12
    };

    int             tag;
    hSSurface       h;

    // Same as newH for the curves; record what a surface gets renamed to
    // when I copy things over.
    hSSurface       newH;

    RgbaColor       color;
    uint32_t        face;

    int             degm, degn;
    Vector          ctrl[4][4];
    double          weight[4][4];

    List&lt;STrimBy&gt;   trim;

    // For testing whether a point (u, v) on the surface lies inside the trim
    SBspUv          *bsp;
    SEdgeList       edges;

    // For caching our initial (u, v) when doing Newton iterations to project
    // a point into our surface.
    Point2d         cached;

    static SSurface FromExtrusionOf(SBezier *spc, Vector t0, Vector t1);
    static SSurface FromRevolutionOf(SBezier *sb, Vector pt, Vector axis,
                                  uint32_t auxA,
                                  SShell *shell, SShell *sha, SShell *shb);
    void FindChainAvoiding(SEdgeList *src, SEdgeList *dest, SPointList *avoid);
    SSurface MakeCopyTrimAgainst(SShell *parent, SShell *a, SShell *b,
                                    SShell *into, SSurface::CombineAs type);
    void TrimFromEdgeList(SEdgeList *el, bool asUv);
    @others
};

</t>
<t tx="leo1.20171224221606.101">void IntersectAgainst(SSurface *b, SShell *agnstA, SShell *agnstB,
                      SShell *into);
void AddExactIntersectionCurve(SBezier *sb, SSurface *srfB,
                      SShell *agnstA, SShell *agnstB, SShell *into);

typedef struct {
    int     tag;
    Point2d p;
} Inter;
void WeightControlPoints();
void UnWeightControlPoints();
void CopyRowOrCol(bool row, int this_ij, SSurface *src, int src_ij);
void BlendRowOrCol(bool row, int this_ij, SSurface *a, int a_ij,

void ClosestPointTo(Vector p, Point2d *puv, bool mustConverge=true);
void ClosestPointTo(Vector p, double *u, double *v, bool mustConverge=true);
bool ClosestPointNewton(Vector p, double *u, double *v, bool mustConverge=true) const;

bool PointIntersectingLine(Vector p0, Vector p1, double *u, double *v) const;
Vector ClosestPointOnThisAndSurface(SSurface *srf2, Vector p);
void PointOnSurfaces(SSurface *s1, SSurface *s2, double *u, double *v);
Vector PointAt(double u, double v) const;
Vector PointAt(Point2d puv) const;
void TangentsAt(double u, double v, Vector *tu, Vector *tv) const;
Vector NormalAt(Point2d puv) const;
Vector NormalAt(double u, double v) const;
bool LineEntirelyOutsideBbox(Vector a, Vector b, bool asSegment) const;
void GetAxisAlignedBounding(Vector *ptMax, Vector *ptMin) const;
bool CoincidentWithPlane(Vector n, double d) const;
bool CoincidentWith(SSurface *ss, bool sameNormal) const;
bool IsExtrusion(SBezier *of, Vector *along) const;
</t>
<t tx="leo1.20171224221606.102">bool IsCylinder(Vector *axis, Vector *center, double *r,
                    Vector *start, Vector *finish) const;

void TriangulateInto(SShell *shell, SMesh *sm);

// these are intended as bitmasks, even though there's just one now
enum class MakeAs : uint32_t {
   UV  = 0x01,
   XYZ = 0x00
};
void MakeTrimEdgesInto(SEdgeList *sel, MakeAs flags, SCurve *sc, STrimBy *stb);
void MakeEdgesInto(SShell *shell, SEdgeList *sel, MakeAs flags,

void Reverse();
void Clear();
</t>
<t tx="leo1.20171224221606.11">    void Clear() {}
};


class Style {
public:
    int         tag;
    hStyle      h;

    enum {
        // If an entity has no style, then it will be colored according to
        // whether the group that it's in is active or not, whether it's
        // construction or not, and so on.
        NO_STYLE       = 0,

        ACTIVE_GRP     = 1,
        CONSTRUCTION   = 2,
        INACTIVE_GRP   = 3,
        DATUM          = 4,
        SOLID_EDGE     = 5,
        CONSTRAINT     = 6,
        SELECTED       = 7,
        HOVERED        = 8,
        CONTOUR_FILL   = 9,
        NORMALS        = 10,
        ANALYZE        = 11,
        DRAW_ERROR     = 12,
        DIM_SOLID      = 13,
        HIDDEN_EDGE    = 14,
        OUTLINE        = 15,

        FIRST_CUSTOM   = 0x100
    };

    std::string name;

    enum class UnitsAs : uint32_t {
        PIXELS   = 0,
        MM       = 1
    };
    double      width;
    UnitsAs     widthAs;
    double      textHeight;
    UnitsAs     textHeightAs;
    enum class TextOrigin : uint32_t {
        NONE    = 0x00,
        LEFT    = 0x01,
        RIGHT   = 0x02,
        BOT     = 0x04,
        TOP     = 0x08
    };
    TextOrigin  textOrigin;
    double      textAngle;
    RgbaColor   color;
    bool        filled;
    RgbaColor   fillColor;
    bool        visible;
    bool        exportable;
    StipplePattern stippleType;
    double      stippleScale;
    int         zIndex;

    // The default styles, for entities that don't have a style assigned yet,
    // and for datums and such.
</t>
<t tx="leo1.20171224221606.12">    typedef struct {
        hStyle      h;
        const char *cnfPrefix;
        RgbaColor   color;
        double      width;
        int         zIndex;
    } Default;
    static const Default Defaults[];

    static std::string CnfColor(const std::string &amp;prefix);
    static std::string CnfWidth(const std::string &amp;prefix);
    static std::string CnfTextHeight(const std::string &amp;prefix);
    static std::string CnfPrefixToName(const std::string &amp;prefix);

    static void CreateAllDefaultStyles();
    static void CreateDefaultStyle(hStyle h);
    static void FillDefaultStyle(Style *s, const Default *d = NULL, bool factory = false);
    static void FreezeDefaultStyles();
    static void LoadFactoryDefaults();

    static void AssignSelectionToStyle(uint32_t v);
    static uint32_t CreateCustomStyle(bool rememberForUndo = true);

    static RgbaColor RewriteColor(RgbaColor rgb);

    static Style *Get(hStyle hs);
    static RgbaColor Color(hStyle hs, bool forExport=false);
    static RgbaColor Color(int hs, bool forExport=false);
    static RgbaColor FillColor(hStyle hs, bool forExport=false);
    static double Width(hStyle hs);
    static double Width(int hs);
    static double WidthMm(int hs);
    static double TextHeight(hStyle hs);
    static double DefaultTextHeight();
    static Canvas::Stroke Stroke(hStyle hs);
    static Canvas::Stroke Stroke(int hs);
    static bool Exportable(int hs);
    static hStyle ForEntity(hEntity he);
    static StipplePattern PatternType(hStyle hs);
    static double StippleScaleMm(hStyle hs);

    std::string DescriptionString() const;

    void Clear() {}
inline bool hRequest::IsFromReferences() const {
    if(v == Request::HREQUEST_REFERENCE_XY.v) return true;
    if(v == Request::HREQUEST_REFERENCE_YZ.v) return true;
    if(v == Request::HREQUEST_REFERENCE_ZX.v) return true;
    return false;
</t>
<t tx="leo1.20171224221606.13">class ClipboardRequest {
public:
    Request::Type type;
    int         extraPoints;
    hStyle      style;
    std::string str;
    std::string font;
    Platform::Path file;
    bool        construction;

    Vector      point[MAX_POINTS_IN_ENTITY];
    double      distance;

    hEntity     oldEnt;
    hEntity     oldPointEnt[MAX_POINTS_IN_ENTITY];
    hRequest    newReq;
};

#endif
</t>
<t tx="leo1.20171224221606.14">//-----------------------------------------------------------------------------
// All declarations not grouped specially elsewhere.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef __SOLVESPACE_H
#define __SOLVESPACE_H

#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;math.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;limits.h&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;locale&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;chrono&gt;
#include &lt;sstream&gt;

// We declare these in advance instead of simply using FT_Library
// (defined as typedef FT_LibraryRec_* FT_Library) because including
// freetype.h invokes indescribable horrors and we would like to avoid
// doing that every time we include solvespace.h.
struct FT_LibraryRec_;
struct FT_FaceRec_;

typedef struct _cairo cairo_t;

// The few floating-point equality comparisons in SolveSpace have been
// carefully considered, so we disable the -Wfloat-equal warning for them
#ifdef __clang__
#   define EXACT(expr) \
        (_Pragma("clang diagnostic push") \
         _Pragma("clang diagnostic ignored \"-Wfloat-equal\"") \
         (expr) \
         _Pragma("clang diagnostic pop"))
#else
#   define EXACT(expr) (expr)
#endif

// Debugging functions
#if defined(__GNUC__)
#define ssassert(condition, message) \
    do { \
        if(__builtin_expect((condition), true) == false) { \
            SolveSpace::assert_failure(__FILE__, __LINE__, __func__, #condition, message); \
            __builtin_unreachable(); \
        } \
    } while(0)
#else
#define ssassert(condition, message) \
    do { \
        if((condition) == false) { \
            SolveSpace::assert_failure(__FILE__, __LINE__, __func__, #condition, message); \
            abort(); \
        } \
    } while(0)
#endif

#ifndef isnan
#   define isnan(x) (((x) != (x)) || (x &gt; 1e11) || (x &lt; -1e11))
#endif

namespace SolveSpace {

using std::min;
using std::max;
using std::swap;

#if defined(__GNUC__)
__attribute__((noreturn))
#endif
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.15">void assert_failure(const char *file, unsigned line, const char *function,
                    const char *condition, const char *message);

#if defined(__GNUC__)
__attribute__((__format__ (__printf__, 1, 2)))
#endif
std::string ssprintf(const char *fmt, ...);

inline int WRAP(int v, int n) {
    // Clamp it to the range [0, n)
    while(v &gt;= n) v -= n;
    while(v &lt; 0) v += n;
    return v;
}
inline double WRAP_NOT_0(double v, double n) {
    // Clamp it to the range (0, n]
    while(v &gt; n) v -= n;
    while(v &lt;= 0) v += n;
    return v;
}
inline double WRAP_SYMMETRIC(double v, double n) {
    // Clamp it to the range (-n/2, n/2]
    while(v &gt;   n/2) v -= n;
    while(v &lt;= -n/2) v += n;
    return v;
}

// Why is this faster than the library function?
inline double ffabs(double v) { return (v &gt; 0) ? v : (-v); }

#define CO(v) (v).x, (v).y, (v).z

#define ANGLE_COS_EPS   (1e-6)
#define LENGTH_EPS      (1e-6)
#define VERY_POSITIVE   (1e10)
#define VERY_NEGATIVE   (-1e10)

inline double Random(double vmax) {
    return (vmax*rand()) / RAND_MAX;
}

class Expr;
class ExprVector;
class ExprQuaternion;
class RgbaColor;
enum class Command : uint32_t;
enum class ContextCommand : uint32_t;

//================
// From the platform-specific code.

#include "platform/platform.h"

const size_t MAX_RECENT = 8;
extern Platform::Path RecentFile[MAX_RECENT];
void RefreshRecentMenus();

enum DialogChoice { DIALOG_YES = 1, DIALOG_NO = -1, DIALOG_CANCEL = 0 };
DialogChoice SaveFileYesNoCancel();
DialogChoice LoadAutosaveYesNo();
DialogChoice LocateImportedFileYesNoCancel(const Platform::Path &amp;filename,
                                           bool canCancel);

#define AUTOSAVE_EXT "slvs~"

enum class Unit : uint32_t {
    MM = 0,
    INCHES
};

struct FileFilter;

bool GetSaveFile(Platform::Path *filename, const std::string &amp;defExtension,
void RadioMenuByCmd(Command id, bool selected);
void EnableMenuByCmd(Command id, bool enabled);

void ShowGraphicsEditControl(int x, int y, int fontHeight, int minWidthChars,
ContextCommand ShowContextMenu();

void ShowTextWindow(bool visible);
void InvalidateText();
void InvalidateGraphics();
void PaintGraphics();
void ToggleFullScreen();
bool FullScreenIsActive();
void GetGraphicsWindowSize(int *w, int *h);
void GetTextWindowSize(int *w, int *h);
double GetScreenDpi();
int64_t GetMilliseconds();

void dbp(const char *str, ...);
#define DBPTRI(tri) \
    dbp("tri: (%.3f %.3f %.3f) (%.3f %.3f %.3f) (%.3f %.3f %.3f)", \
        CO((tri).a), CO((tri).b), CO((tri).c))

void SetCurrentFilename(const Platform::Path &amp;filename);
void SetMousePointerToHand(bool yes);
void DoMessageBox(const char *str, int rows, int cols, bool error);
void SetTimerFor(int milliseconds);
void SetAutosaveTimerFor(int minutes);
void ScheduleLater();
void ExitNow();

void CnfFreezeInt(uint32_t val, const std::string &amp;name);
void CnfFreezeFloat(float val, const std::string &amp;name);
void CnfFreezeString(const std::string &amp;val, const std::string &amp;name);
std::string CnfThawString(const std::string &amp;val, const std::string &amp;name);
uint32_t CnfThawInt(uint32_t val, const std::string &amp;name);
float CnfThawFloat(float val, const std::string &amp;name);

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv);

void *AllocTemporary(size_t n);
void FreeTemporary(void *p);
void FreeAllTemporary();
void *MemAlloc(size_t n);
void MemFree(void *p);
void vl(); // debug function to validate heaps

#include "resource.h"

// End of platform-specific functions
//================

template&lt;class T&gt;
struct CompareHandle {
    bool operator()(T lhs, T rhs) const { return lhs.v &lt; rhs.v; }
};

template&lt;class Key, class T&gt;
using handle_map = std::map&lt;Key, T, CompareHandle&lt;Key&gt;&gt;;

class Group;
class SSurface;
#include "dsc.h"
#include "polygon.h"
#include "srf/surface.h"
#include "render/render.h"

class Entity;
class hEntity;
class Param;
class hParam;
typedef IdList&lt;Entity,hEntity&gt; EntityList;
typedef IdList&lt;Param,hParam&gt; ParamList;

enum class SolveResult : uint32_t {
    OKAY                     = 0,
    DIDNT_CONVERGE           = 10,
    REDUNDANT_OKAY           = 11,
    REDUNDANT_DIDNT_CONVERGE = 12,
    TOO_MANY_UNKNOWNS        = 20
};


#include "sketch.h"
#include "ui.h"
#include "expr.h"


// Utility functions that are provided in the platform-independent code.
</t>
<t tx="leo1.20171224221606.16">class utf8_iterator : std::iterator&lt;std::forward_iterator_tag, char32_t&gt; {
    const char *p, *n;
public:
    utf8_iterator(const char *p) : p(p), n(NULL) {}
    bool           operator==(const utf8_iterator &amp;i) const { return p==i.p; }
    bool           operator!=(const utf8_iterator &amp;i) const { return p!=i.p; }
    ptrdiff_t      operator- (const utf8_iterator &amp;i) const { return p -i.p; }
    utf8_iterator&amp; operator++()    { **this; p=n; n=NULL; return *this; }
    utf8_iterator  operator++(int) { utf8_iterator t(*this); operator++(); return t; }
    char32_t       operator*();
};
</t>
<t tx="leo1.20171224221606.17">class ReadUTF8 {
    const std::string &amp;str;
public:
    ReadUTF8(const std::string &amp;str) : str(str) {}
    utf8_iterator begin() const { return utf8_iterator(&amp;str[0]); }
    utf8_iterator end()   const { return utf8_iterator(&amp;str[str.length()]); }
};


#define arraylen(x) (sizeof((x))/sizeof((x)[0]))
#define PI (3.1415926535897931)
void MakeMatrix(double *mat, double a11, double a12, double a13, double a14,
bool CnfThawBool(bool v, const std::string &amp;name);
RgbaColor CnfThawColor(RgbaColor v, const std::string &amp;name);

</t>
<t tx="leo1.20171224221606.18">class System {
public:
    enum { MAX_UNKNOWNS = 1024 };

    EntityList                      entity;
    ParamList                       param;
    IdList&lt;Equation,hEquation&gt;      eq;

    // A list of parameters that are being dragged; these are the ones that
    // we should put as close as possible to their initial positions.
    List&lt;hParam&gt;                    dragged;

    enum {
        // In general, the tag indicates the subsys that a variable/equation
        // has been assigned to; these are exceptions for variables:
        VAR_SUBSTITUTED      = 10000,
        VAR_DOF_TEST         = 10001,
        // and for equations:
        EQ_SUBSTITUTED       = 20000
    };

    // The system Jacobian matrix
    struct {
        // The corresponding equation for each row
        hEquation   eq[MAX_UNKNOWNS];

        // The corresponding parameter for each column
        hParam      param[MAX_UNKNOWNS];

        // We're solving AX = B
        int m, n;
        struct {
            Expr        *sym[MAX_UNKNOWNS][MAX_UNKNOWNS];
            double       num[MAX_UNKNOWNS][MAX_UNKNOWNS];
        }           A;

        double      scale[MAX_UNKNOWNS];

        // Some helpers for the least squares solve
        double AAt[MAX_UNKNOWNS][MAX_UNKNOWNS];
        double Z[MAX_UNKNOWNS];

        double      X[MAX_UNKNOWNS];

        struct {
            Expr        *sym[MAX_UNKNOWNS];
            double       num[MAX_UNKNOWNS];
        }           B;
    } mat;

    static const double RANK_MAG_TOLERANCE, CONVERGE_TOLERANCE;
    int CalculateRank();
    bool TestRank();
    static bool SolveLinearSystem(double X[], double A[][MAX_UNKNOWNS],
    bool IsDragged(hParam p);

    bool NewtonSolve(int tag);

    void MarkParamsFree(bool findFree);
    int CalculateDof();

    SolveResult Solve(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
                      bool andFindBad, bool andFindFree, bool forceDofCheck = false);

    SolveResult SolveRank(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
                          bool andFindBad, bool andFindFree, bool forceDofCheck = false);

    void Clear();
};

#include "ttf.h"

</t>
<t tx="leo1.20171224221606.19">class StepFileWriter {
public:
    void ExportSurfacesTo(const Platform::Path &amp;filename);
    void WriteHeader();
    void WriteProductHeader();
    int ExportCurve(SBezier *sb);
    int ExportCurveLoop(SBezierLoop *loop, bool inner);
    void ExportSurface(SSurface *ss, SBezierList *sbl);
    void WriteWireframe();
    void WriteFooter();

    List&lt;int&gt; curves;
    List&lt;int&gt; advancedFaces;
    FILE *f;
    int id;
};

</t>
<t tx="leo1.20171224221606.2">    void Clear() {}
};

class Entity : public EntityBase {
public:
    // Necessary for Entity e = {} to zero-initialize, since
    // classes with base classes are not aggregates and
    // the default constructor does not initialize members.
    //
    // Note EntityBase({}); without explicitly value-initializing
    // the base class, MSVC2013 will default-initialize it, leaving
    // POD members with indeterminate value.
    Entity() : EntityBase({}), forceHidden(), actPoint(), actNormal(),
        actDistance(), actVisible(), style(), construction(),
        beziers(), edges(), edgesChordTol(), screenBBox(), screenBBoxValid() {};

    // A linked entity that was hidden in the source file ends up hidden
    // here too.
    bool        forceHidden;

    // All points/normals/distances have their numerical value; this is
    // a convenience, to simplify the link/assembly code, so that the
    // part is entirely described by the entities.
    Vector      actPoint;
    Quaternion  actNormal;
    double      actDistance;
    // and the shown state also gets saved here, for later import
    bool        actVisible;

    hStyle      style;
    bool        construction;

    SBezierList beziers;
    SEdgeList   edges;
    double      edgesChordTol;
    BBox        screenBBox;
    bool        screenBBoxValid;

    bool IsStylable() const;
    bool IsVisible() const;

    enum class DrawAs { DEFAULT, OVERLAY, HIDDEN, HOVERED, SELECTED };
    void Draw(DrawAs how, Canvas *canvas);
    void GetReferencePoints(std::vector&lt;Vector&gt; *refs);
    int GetPositionOfPoint(const Camera &amp;camera, Point2d p);

    void ComputeInterpolatingSpline(SBezierList *sbl, bool periodic) const;
    void GenerateBezierCurves(SBezierList *sbl) const;
    void GenerateEdges(SEdgeList *el);

    SBezierList *GetOrGenerateBezierCurves();
    SEdgeList *GetOrGenerateEdges();
    BBox GetOrGenerateScreenBBox(bool *hasBBox);

    void CalculateNumerical(bool forExport);

    std::string DescriptionString() const;

</t>
<t tx="leo1.20171224221606.20">class VectorFileWriter {
protected:
    Vector u, v, n, origin;
    double cameraTan, scale;

public:
    FILE *f;
    Platform::Path filename;
    Vector ptMin, ptMax;

    static double MmToPts(double mm);

    static VectorFileWriter *ForFile(const Platform::Path &amp;filename);

    void SetModelviewProjection(const Vector &amp;u, const Vector &amp;v, const Vector &amp;n,
    virtual void FinishPath(RgbaColor strokeRgb, double lineWidth,
                            bool filled, RgbaColor fillRgb, hStyle hs) = 0;
    virtual void Bezier(SBezier *sb) = 0;
    virtual void Triangle(STriangle *tr) = 0;
    virtual bool OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *) { return false; }
    virtual void StartFile() = 0;
    virtual void FinishAndCloseFile() = 0;
    virtual bool HasCanvasSize() const = 0;
    virtual bool CanOutputMesh() const = 0;
};
</t>
<t tx="leo1.20171224221606.21">class DxfFileWriter : public VectorFileWriter {
public:
    struct BezierPath {
        std::vector&lt;SBezier *&gt; beziers;
    };

    std::vector&lt;BezierPath&gt;         paths;
    IdList&lt;Constraint,hConstraint&gt; *constraint;

    static const char *lineTypeName(StipplePattern stippleType);

    bool OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *constraint) override;

    void StartPath( RgbaColor strokeRgb, double lineWidth,
};
</t>
<t tx="leo1.20171224221606.22">class EpsFileWriter : public VectorFileWriter {
public:
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo1.20171224221606.23">class PdfFileWriter : public VectorFileWriter {
public:
    uint32_t xref[10];
    uint32_t bodyStart;
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo1.20171224221606.24">class SvgFileWriter : public VectorFileWriter {
public:
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo1.20171224221606.25">class HpglFileWriter : public VectorFileWriter {
public:
    static double MmToHpglUnits(double mm);
    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo1.20171224221606.26">class Step2dFileWriter : public VectorFileWriter {
    StepFileWriter sfw;
    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo1.20171224221606.27">class GCodeFileWriter : public VectorFileWriter {
public:
    SEdgeList sel;
    void StartPath( RgbaColor strokeRgb, double lineWidth,

#ifdef LIBRARY
#   define ENTITY EntityBase
#   define CONSTRAINT ConstraintBase
#else
#   define ENTITY Entity
#   define CONSTRAINT Constraint
#endif
</t>
<t tx="leo1.20171224221606.28">class Sketch {
public:
    // These are user-editable, and define the sketch.
    IdList&lt;Group,hGroup&gt;            group;
    List&lt;hGroup&gt;                    groupOrder;
    IdList&lt;CONSTRAINT,hConstraint&gt;  constraint;
    IdList&lt;Request,hRequest&gt;        request;
    IdList&lt;Style,hStyle&gt;            style;

    // These are generated from the above.
    IdList&lt;ENTITY,hEntity&gt;          entity;
    IdList&lt;Param,hParam&gt;            param;

    inline CONSTRAINT *GetConstraint(hConstraint h)
        { return constraint.FindById(h); }
    inline ENTITY  *GetEntity (hEntity  h) { return entity. FindById(h); }
    inline Param   *GetParam  (hParam   h) { return param.  FindById(h); }
    inline Request *GetRequest(hRequest h) { return request.FindById(h); }
    inline Group   *GetGroup  (hGroup   h) { return group.  FindById(h); }
    // Styles are handled a bit differently.

    void Clear();

    BBox CalculateEntityBBox(bool includingInvisible);
    Group *GetRunningMeshGroupFor(hGroup h);
};
#undef ENTITY
#undef CONSTRAINT

</t>
<t tx="leo1.20171224221606.29">class SolveSpaceUI {
public:
    TextWindow                 *pTW;
    TextWindow                 &amp;TW;
    GraphicsWindow              GW;

    // The state for undo/redo
    @others
};

void ImportDxf(const Platform::Path &amp;file);
void ImportDwg(const Platform::Path &amp;file);

extern SolveSpaceUI SS;
extern Sketch SK;

}

#ifndef __OBJC__
using namespace SolveSpace;
#endif

#endif
</t>
<t tx="leo1.20171224221606.3">void Clear() {
    beziers.l.Clear();
    edges.l.Clear();
}
</t>
<t tx="leo1.20171224221606.30">typedef struct {
    IdList&lt;Group,hGroup&gt;            group;
    List&lt;hGroup&gt;                    groupOrder;
    IdList&lt;Request,hRequest&gt;        request;
    IdList&lt;Constraint,hConstraint&gt;  constraint;
    IdList&lt;Param,hParam&gt;            param;
    IdList&lt;Style,hStyle&gt;            style;
    hGroup                          activeGroup;

    @others
} UndoState;
enum { MAX_UNDO = 16 };
</t>
<t tx="leo1.20171224221606.31">void Clear() {
    group.Clear();
    request.Clear();
    constraint.Clear();
    param.Clear();
    style.Clear();
}
</t>
<t tx="leo1.20171224221606.32">typedef struct {
    UndoState   d[MAX_UNDO];
    int         cnt;
    int         write;
} UndoStack;
UndoStack   undo;
UndoStack   redo;

std::map&lt;Platform::Path, std::shared_ptr&lt;Pixmap&gt;, Platform::PathLess&gt; images;
bool ReloadLinkedImage(const Platform::Path &amp;saveFile, Platform::Path *filename,

// Little bits of extra configuration state
enum { MODEL_COLORS = 8 };
RgbaColor modelColor[MODEL_COLORS];
Vector   lightDir[2];
double   lightIntensity[2];
double   ambientIntensity;
double   chordTol;
double   chordTolCalculated;
int      maxSegments;
double   exportChordTol;
int      exportMaxSegments;
double   cameraTangent;
float    gridSpacing;
float    exportScale;
float    exportOffset;
bool     fixExportColors;
bool     drawBackFaces;
bool     showContourAreas;
bool     checkClosedContour;
bool     showToolbar;
Platform::Path screenshotFile;
RgbaColor backgroundColor;
bool     exportShadedTriangles;
bool     exportPwlCurves;
bool     exportCanvasSizeAuto;
bool     exportMode;
struct {
    float   left;
    float   right;
    float   bottom;
    float   top;
}        exportMargin;
struct {
    float   width;
    float   height;
    float   dx;
    float   dy;
}        exportCanvas;
struct {
    float   depth;
    int     passes;
    float   feed;
    float   plungeFeed;
}        gCode;

Unit     viewUnits;
int      afterDecimalMm;
int      afterDecimalInch;
int      autosaveInterval; // in minutes

std::string MmToString(double v);
double ExprToMm(Expr *e);
double StringToMm(const std::string &amp;s);
const char *UnitName();
double MmPerUnit();
int UnitDigitsAfterDecimal();
void SetUnitDigitsAfterDecimal(int v);
double ChordTolMm();
double ExportChordTolMm();
int GetMaxSegments();
bool usePerspectiveProj;
double CameraTangent();

// Some stuff relating to the tangent arcs created non-parametrically
// as special requests.
double tangentArcRadius;
bool tangentArcManual;
bool tangentArcDeleteOld;

// The platform-dependent code calls this before entering the msg loop
void Init();
bool Load(const Platform::Path &amp;filename);
void Exit();

// File load/save routines, including the additional files that get
// loaded when we have link groups.
FILE        *fh;
void AfterNewFile();
static void RemoveFromRecentList(const Platform::Path &amp;filename);
static void AddToRecentList(const Platform::Path &amp;filename);
Platform::Path saveFile;
bool        fileLoadError;
bool        unsaved;
</t>
<t tx="leo1.20171224221606.33">typedef struct {
    char        type;
    const char *desc;
    char        fmt;
    void       *ptr;
} SaveTable;
static const SaveTable SAVED[];
void SaveUsingTable(const Platform::Path &amp;filename, int type);
void LoadUsingTable(const Platform::Path &amp;filename, char *key, char *val);
struct {
    Group        g;
    Request      r;
    Entity       e;
    Param        p;
    Constraint   c;
    Style        s;
} sv;
static void MenuFile(Command id);
bool Autosave();
void RemoveAutosave();
bool GetFilenameAndSave(bool saveAs);
bool OkayToStartNewFile();
hGroup CreateDefaultDrawingGroup();
void UpdateWindowTitle();
void ClearExisting();
void NewFile();
bool SaveToFile(const Platform::Path &amp;filename);
bool LoadAutosaveFor(const Platform::Path &amp;filename);
bool LoadFromFile(const Platform::Path &amp;filename, bool canCancel = false);
void UpgradeLegacyData();
bool LoadEntitiesFromFile(const Platform::Path &amp;filename, EntityList *le,
void ExportSectionTo(const Platform::Path &amp;filename);
void ExportWireframeCurves(SEdgeList *sel, SBezierList *sbl,
struct {
    SContour    path;
    hEntity     point;
} traced;
SEdgeList nakedEdges;
struct {
    bool        draw;
    Vector      ptA;
    Vector      ptB;
} extraLine;
struct {
    bool        draw, showOrigin;
    Vector      pt, u, v;
} justExportedInfo;
struct {
    bool   draw;
    bool   dirty;
    Vector position;
} centerOfMass;

</t>
<t tx="leo1.20171224221606.34">class Clipboard {
public:
    List&lt;ClipboardRequest&gt;  r;
    List&lt;Constraint&gt;        c;

    void Clear();
    bool ContainsEntity(hEntity old);
    hEntity NewEntityFor(hEntity old);
};
Clipboard clipboard;

void MarkGroupDirty(hGroup hg, bool onlyThis = false);
void MarkGroupDirtyByEntity(hEntity he);

// Consistency checking on the sketch: stuff with missing dependencies
// will get deleted automatically.
struct {
    int     requests;
    int     groups;
    int     constraints;
    int     nonTrivialConstraints;
} deleted;
bool GroupExists(hGroup hg);
bool PruneOrphans();
bool EntityExists(hEntity he);
bool GroupsInOrder(hGroup before, hGroup after);
bool PruneGroups(hGroup hg);
bool PruneRequests(hGroup hg);
bool PruneConstraints(hGroup hg);
static void ShowNakedEdges(bool reportOnlyWhenNotOkay);

enum class Generate : uint32_t {
    DIRTY,
    ALL,
    REGEN,
    UNTIL_ACTIVE,
};

void GenerateAll(Generate type = Generate::DIRTY, bool andFindFree = false,

// The system to be solved.
System     *pSys;
System     &amp;sys;

// All the TrueType fonts in memory
TtfFontList fonts;

// Everything has been pruned, so we know there's no dangling references
// to entities that don't exist. Before that, we mustn't try to display
// the sketch!
bool allConsistent;

struct {
    bool    scheduled;
    bool    showTW;
    bool    generateAll;
} later;
void ScheduleShowTW();
void ScheduleGenerateAll();
void DoLater();

static void MenuHelp(Command id);

void Clear();

// We allocate TW and sys on the heap to work around an MSVC problem
// where it puts zero-initialized global data in the binary (~30M of zeroes)
// in release builds.
SolveSpaceUI()
    : pTW(new TextWindow({})), TW(*pTW),
      pSys(new System({})), sys(*pSys) {}

~SolveSpaceUI() {
    delete pTW;
    delete pSys;
}
</t>
<t tx="leo1.20171224221606.35">//-----------------------------------------------------------------------------
// Routines to read a TrueType font as vector outlines, and generate them
// as entities, since they're always representable as either lines or
// quadratic Bezier curves.
//
// Copyright 2016 whitequark, Peter Barfuss.
//-----------------------------------------------------------------------------

#ifndef __TTF_H
#define __TTF_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.36">class TtfFont {
public:
    Platform::Path  fontFile;
    std::string     name;
    FT_FaceRec_    *fontFace;
    double          capHeight;

    std::string FontFileBaseName() const;
    bool LoadFromFile(FT_LibraryRec_ *fontLibrary, bool nameOnly = true);

    @others
</t>
<t tx="leo1.20171224221606.37">    void PlotString(const std::string &amp;str,
                    SBezierList *sbl, Vector origin, Vector u, Vector v);
    double AspectRatio(const std::string &amp;str);
};

class TtfFontList {
public:
    FT_LibraryRec_ *fontLibrary;
    bool            loaded;
    List&lt;TtfFont&gt;   l;

    TtfFontList();
    ~TtfFontList();

    void LoadAll();
    TtfFont *LoadFont(const std::string &amp;font);

    void PlotString(const std::string &amp;font, const std::string &amp;str,
</t>
<t tx="leo1.20171224221606.38">//-----------------------------------------------------------------------------
// Declarations relating to our user interface, in both the graphics and
// text browser window.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef __UI_H
#define __UI_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.39">class Locale {
public:
    std::string language;
    std::string region;
    uint16_t    lcid;
    std::string displayName;

    std::string Culture() const {
        return language + "-" + region;
    }
};

struct LocaleLess {
</t>
<t tx="leo1.20171224221606.4">class EntReqTable {
public:
    @others
};

</t>
<t tx="leo1.20171224221606.40">    bool operator()(const Locale &amp;a, const Locale &amp;b) const {
        return a.language &lt; b.language ||
            (a.language == b.language &amp;&amp; a.region &lt; b.region);
    }
};

const std::set&lt;Locale, LocaleLess&gt; &amp;Locales();
bool SetLocale(const std::string &amp;name);
bool SetLocale(uint16_t lcid);

const std::string &amp;Translate(const char *msgid);
const std::string &amp;Translate(const char *msgctxt, const char *msgid);
const std::string &amp;TranslatePlural(const char *msgid, unsigned n);
const std::string &amp;TranslatePlural(const char *msgctxt, const char *msgid, unsigned n);

inline const char *N_(const char *msgid) {
    return msgid;
}
inline const char *CN_(const char *msgctxt, const char *msgid) {
    return msgid;
}
#if defined(LIBRARY)
inline const char *_(const char *msgid) {
    return msgid;
}
inline const char *C_(const char *msgctxt, const char *msgid) {
    return msgid;
}
#else
inline const char *_(const char *msgid) {
    return Translate(msgid).c_str();
}
inline const char *C_(const char *msgctxt, const char *msgid) {
    return Translate(msgctxt, msgid).c_str();
}
#endif

// Filters for the file formats that we support.
struct FileFilter {
    const char *name;
    const char *patterns[3];
};

// SolveSpace native file format
</t>
<t tx="leo1.20171224221606.41">const FileFilter SlvsFileFilter[] = {
    { N_("SolveSpace models"),          { "slvs" } },
    { NULL, {} }
};
// PNG format bitmap
</t>
<t tx="leo1.20171224221606.42">const FileFilter RasterFileFilter[] = {
    { N_("PNG file"),                   { "png" } },
    { NULL, {} }
};
// Triangle mesh
</t>
<t tx="leo1.20171224221606.43">const FileFilter MeshFileFilter[] = {
    { N_("STL mesh"),                   { "stl" } },
    { N_("Wavefront OBJ mesh"),         { "obj" } },
    { N_("Three.js-compatible mesh, with viewer"),  { "html" } },
    { N_("Three.js-compatible mesh, mesh only"),    { "js" } },
    { NULL, {} }
};
// NURBS surfaces
</t>
<t tx="leo1.20171224221606.44">const FileFilter SurfaceFileFilter[] = {
    { N_("STEP file"),                  { "step", "stp" } },
    { NULL, {} }
};
// 2d vector (lines and curves) format
</t>
<t tx="leo1.20171224221606.45">const FileFilter VectorFileFilter[] = {
    { N_("PDF file"),                   { "pdf" } },
    { N_("Encapsulated PostScript"),    { "eps",  "ps" } },
    { N_("Scalable Vector Graphics"),   { "svg" } },
    { N_("STEP file"),                  { "step", "stp" } },
    { N_("DXF file (AutoCAD 2007)"),    { "dxf" } },
    { N_("HPGL file"),                  { "plt",  "hpgl" } },
    { N_("G Code"),                     { "ngc",  "txt" } },
    { NULL, {} }
};
// 3d vector (wireframe lines and curves) format
</t>
<t tx="leo1.20171224221606.46">const FileFilter Vector3dFileFilter[] = {
    { N_("STEP file"),                  { "step", "stp" } },
    { N_("DXF file (AutoCAD 2007)"),    { "dxf" } },
    { NULL, {} }
};
// All Importable formats
</t>
<t tx="leo1.20171224221606.47">const FileFilter ImportableFileFilter[] = {
    { N_("AutoCAD DXF and DWG files"),  { "dxf", "dwg" } },
    { NULL, {} }
};
// Comma-separated value, like a spreadsheet would use
</t>
<t tx="leo1.20171224221606.48">const FileFilter CsvFileFilter[] = {
    { N_("Comma-separated values"),     { "csv" } },
    { NULL, {} }
};

// This table describes the top-level menus in the graphics winodw.
enum class Command : uint32_t {
    NONE = 0,
    // File
    NEW = 100,
    OPEN,
    OPEN_RECENT,
    SAVE,
    SAVE_AS,
    EXPORT_PNG,
    EXPORT_MESH,
    EXPORT_SURFACES,
    EXPORT_VIEW,
    EXPORT_SECTION,
    EXPORT_WIREFRAME,
    IMPORT,
    EXIT,
    // View
    ZOOM_IN,
    ZOOM_OUT,
    ZOOM_TO_FIT,
    SHOW_GRID,
    PERSPECTIVE_PROJ,
    ONTO_WORKPLANE,
    NEAREST_ORTHO,
    NEAREST_ISO,
    CENTER_VIEW,
    SHOW_TOOLBAR,
    SHOW_TEXT_WND,
    UNITS_INCHES,
    UNITS_MM,
    FULL_SCREEN,
    // Edit
    UNDO,
    REDO,
    CUT,
    COPY,
    PASTE,
    PASTE_TRANSFORM,
    DELETE,
    SELECT_CHAIN,
    SELECT_ALL,
    SNAP_TO_GRID,
    ROTATE_90,
    UNSELECT_ALL,
    REGEN_ALL,
    // Request
    SEL_WORKPLANE,
    FREE_IN_3D,
    DATUM_POINT,
    WORKPLANE,
    LINE_SEGMENT,
    CONSTR_SEGMENT,
    CIRCLE,
    ARC,
    RECTANGLE,
    CUBIC,
    TTF_TEXT,
    IMAGE,
    SPLIT_CURVES,
    TANGENT_ARC,
    CONSTRUCTION,
    // Group
    GROUP_3D,
    GROUP_WRKPL,
    GROUP_EXTRUDE,
    GROUP_LATHE,
    GROUP_ROT,
    GROUP_TRANS,
    GROUP_LINK,
    GROUP_RECENT,
    // Constrain
    DISTANCE_DIA,
    REF_DISTANCE,
    ANGLE,
    REF_ANGLE,
    OTHER_ANGLE,
    REFERENCE,
    EQUAL,
    RATIO,
    DIFFERENCE,
    ON_ENTITY,
    SYMMETRIC,
    AT_MIDPOINT,
    HORIZONTAL,
    VERTICAL,
    PARALLEL,
    PERPENDICULAR,
    ORIENTED_SAME,
    WHERE_DRAGGED,
    COMMENT,
    // Analyze
    VOLUME,
    AREA,
    PERIMETER,
    INTERFERENCE,
    NAKED_EDGES,
    SHOW_DOF,
    CENTER_OF_MASS,
    TRACE_PT,
    STOP_TRACING,
    STEP_DIM,
    // Help
    WEBSITE,
    ABOUT,
    // Recent
    RECENT_OPEN = 0xf000,
    RECENT_LINK = 0xf100,
    // Locale
    LOCALE = 0xf200,
};

enum class ContextCommand : uint32_t {
    CANCELLED,
    SUBMENU,
    SEPARATOR,
    UNSELECT_ALL,
    UNSELECT_HOVERED,
    CUT_SEL,
    COPY_SEL,
    PASTE,
    PASTE_XFRM,
    DELETE_SEL,
    SELECT_CHAIN,
    NEW_CUSTOM_STYLE,
    NO_STYLE,
    GROUP_INFO,
    STYLE_INFO,
    REFERENCE_DIM,
    OTHER_ANGLE,
    DEL_COINCIDENT,
    SNAP_TO_GRID,
    REMOVE_SPLINE_PT,
    ADD_SPLINE_PT,
    CONSTRUCTION,
    ZOOM_TO_FIT,
    SELECT_ALL,
    FIRST_STYLE      = 0x40000000
};

class Button;

</t>
<t tx="leo1.20171224221606.49">class TextWindow {
public:
    enum {
        MAX_COLS = 100,
        MIN_COLS = 45,
        MAX_ROWS = 2000
    };

    @others
};

</t>
<t tx="leo1.20171224221606.5">    static bool GetRequestInfo(Request::Type req, int extraPoints,
                               EntityBase::Type *ent, int *pts, bool *hasNormal, bool *hasDistance);
    static bool GetEntityInfo(EntityBase::Type ent, int extraPoints,
                              Request::Type *req, int *pts, bool *hasNormal, bool *hasDistance);
    static Request::Type GetRequestForEntity(EntityBase::Type ent);
};

class Param {
public:
    int         tag;
    hParam      h;

    double      val;
    bool        known;
    bool        free;

    // Used only in the solver
    hParam      substd;

    static const hParam NO_PARAM;

</t>
<t tx="leo1.20171224221606.50">    typedef struct {
        char      c;
        RgbaColor color;
    } Color;
    static const Color fgColors[];
    static const Color bgColors[];

    float bgColorTable[256*3];
    float fgColorTable[256*3];

    enum {
        CHAR_WIDTH_    = 9,
        CHAR_HEIGHT    = 16,
        LINE_HEIGHT    = 20,
        LEFT_MARGIN    = 6,
    };

#define CHECK_FALSE "\xEE\x80\x80" // U+E000
#define CHECK_TRUE  "\xEE\x80\x81"
#define RADIO_FALSE "\xEE\x80\x82"
#define RADIO_TRUE  "\xEE\x80\x83"

    int scrollPos;      // The scrollbar position, in half-row units
    int halfRows;       // The height of our window, in half-row units

    uint32_t text[MAX_ROWS][MAX_COLS];
    typedef void LinkFunction(int link, uint32_t v);
    enum { NOT_A_LINK = 0 };
    struct {
        char            fg;
        char            bg;
        RgbaColor       bgRgb;
        int             link;
        uint32_t        data;
        LinkFunction   *f;
        LinkFunction   *h;
    }       meta[MAX_ROWS][MAX_COLS];
    int hoveredRow, hoveredCol;

    int top[MAX_ROWS]; // in half-line units, or -1 for unused
    int rows;

    std::shared_ptr&lt;ViewportCanvas&gt; canvas;

    void Draw(Canvas *canvas);

    // These are called by the platform-specific code.
    void Paint();
    void MouseEvent(bool isClick, bool leftDown, double x, double y);
    void MouseScroll(double x, double y, int delta);
    void MouseLeave();
    void ScrollbarEvent(int newPos);

    enum DrawOrHitHow : uint32_t {
        PAINT = 0,
        HOVER = 1,
        CLICK = 2
    };
    void DrawOrHitTestIcons(UiCanvas *canvas, DrawOrHitHow how,
                                  bool leftDown, double x, double y);

    void Init();
    void MakeColorTable(const Color *in, float *out);
    void Printf(bool half, const char *fmt, ...);
    void ClearScreen();

    void Show();

    // State for the screen that we are showing in the text window.
    enum class Screen : uint32_t {
        LIST_OF_GROUPS      = 0,
        GROUP_INFO          = 1,
        GROUP_SOLVE_INFO    = 2,
        CONFIGURATION       = 3,
        STEP_DIMENSION      = 4,
        LIST_OF_STYLES      = 5,
        STYLE_INFO          = 6,
        PASTE_TRANSFORMED   = 7,
        EDIT_VIEW           = 8,
        TANGENT_ARC         = 9
    };
</t>
<t tx="leo1.20171224221606.51">typedef struct {
    Screen  screen;

    hGroup      group;
    hStyle      style;

    hConstraint constraint;
    bool        dimIsDistance;
    double      dimFinish;
    int         dimSteps;

    struct {
        int         times;
        Vector      trans;
        double      theta;
        Vector      origin;
        double      scale;
    }           paste;
} ShownState;
ShownState shown;

enum class Edit : uint32_t {
    NOTHING               = 0,
    // For multiple groups
    TIMES_REPEATED        = 1,
    GROUP_NAME            = 2,
    GROUP_SCALE           = 3,
    GROUP_COLOR           = 4,
    GROUP_OPACITY         = 5,
    // For the configuraiton screen
    LIGHT_DIRECTION       = 100,
    LIGHT_INTENSITY       = 101,
    COLOR                 = 102,
    CHORD_TOLERANCE       = 103,
    MAX_SEGMENTS          = 104,
    CAMERA_TANGENT        = 105,
    GRID_SPACING          = 106,
    DIGITS_AFTER_DECIMAL  = 107,
    EXPORT_SCALE          = 108,
    EXPORT_OFFSET         = 109,
    CANVAS_SIZE           = 110,
    G_CODE_DEPTH          = 120,
    G_CODE_PASSES         = 121,
    G_CODE_FEED           = 122,
    G_CODE_PLUNGE_FEED    = 123,
    AUTOSAVE_INTERVAL     = 124,
    // For TTF text
    TTF_TEXT              = 300,
    // For the step dimension screen
    STEP_DIM_FINISH       = 400,
    STEP_DIM_STEPS        = 401,
    // For the styles stuff
    STYLE_WIDTH           = 500,
    STYLE_TEXT_HEIGHT     = 501,
    STYLE_TEXT_ANGLE      = 502,
    STYLE_COLOR           = 503,
    STYLE_FILL_COLOR      = 504,
    STYLE_NAME            = 505,
    BACKGROUND_COLOR      = 506,
    STYLE_STIPPLE_PERIOD  = 508,
    // For paste transforming
    PASTE_TIMES_REPEATED  = 600,
    PASTE_ANGLE           = 601,
    PASTE_SCALE           = 602,
    // For view
    VIEW_SCALE            = 700,
    VIEW_ORIGIN           = 701,
    VIEW_PROJ_RIGHT       = 702,
    VIEW_PROJ_UP          = 703,
    // For tangent arc
    TANGENT_ARC_RADIUS    = 800
};
struct {
    bool        showAgain;
    Edit        meaning;
    int         i;
    hGroup      group;
    hRequest    request;
    hStyle      style;
} edit;

static void ReportHowGroupSolved(hGroup hg);

struct {
    int     halfRow;
    int     col;

    struct {
        RgbaColor rgb;
        double    h, s, v;
        bool      show;
        bool      picker1dActive;
        bool      picker2dActive;
    }       colorPicker;
} editControl;

void HideEditControl();
void ShowEditControl(int col, const std::string &amp;str, int halfRow = -1);
void ShowEditControlWithColorPicker(int col, RgbaColor rgb);

void ClearSuper();

void ShowHeader(bool withNav);
// These are self-contained screens, that show some information about
// the sketch.
void ShowListOfGroups();
void ShowGroupInfo();
void ShowGroupSolveInfo();
void ShowConfiguration();
void ShowListOfStyles();
void ShowStyleInfo();
void ShowStepDimension();
void ShowPasteTransformed();
void ShowEditView();
void ShowTangentArc();
// Special screen, based on selection
void DescribeSelection();

void GoToScreen(Screen screen);

// All of these are callbacks from the GUI code; first from when
// we're describing an entity
static void ScreenEditTtfText(int link, uint32_t v);
static void ScreenSetTtfFont(int link, uint32_t v);
static void ScreenUnselectAll(int link, uint32_t v);

// when we're describing a constraint
static void ScreenConstraintShowAsRadius(int link, uint32_t v);

// and the rest from the stuff in textscreens.cpp
static void ScreenSelectGroup(int link, uint32_t v);
static void ScreenActivateGroup(int link, uint32_t v);
static void ScreenToggleGroupShown(int link, uint32_t v);
static void ScreenHowGroupSolved(int link, uint32_t v);
static void ScreenShowGroupsSpecial(int link, uint32_t v);
static void ScreenDeleteGroup(int link, uint32_t v);

static void ScreenHoverConstraint(int link, uint32_t v);
static void ScreenHoverRequest(int link, uint32_t v);
static void ScreenSelectRequest(int link, uint32_t v);
static void ScreenSelectConstraint(int link, uint32_t v);

static void ScreenChangeGroupOption(int link, uint32_t v);
static void ScreenColor(int link, uint32_t v);
static void ScreenOpacity(int link, uint32_t v);

static void ScreenShowListOfStyles(int link, uint32_t v);
static void ScreenShowStyleInfo(int link, uint32_t v);
static void ScreenDeleteStyle(int link, uint32_t v);
static void ScreenChangeStylePatternType(int link, uint32_t v);
static void ScreenChangeStyleYesNo(int link, uint32_t v);
static void ScreenCreateCustomStyle(int link, uint32_t v);
static void ScreenLoadFactoryDefaultStyles(int link, uint32_t v);
static void ScreenAssignSelectionToStyle(int link, uint32_t v);

static void ScreenShowConfiguration(int link, uint32_t v);
static void ScreenShowEditView(int link, uint32_t v);
static void ScreenGoToWebsite(int link, uint32_t v);

static void ScreenChangeFixExportColors(int link, uint32_t v);
static void ScreenChangeBackFaces(int link, uint32_t v);
static void ScreenChangeShowContourAreas(int link, uint32_t v);
static void ScreenChangeCheckClosedContour(int link, uint32_t v);
static void ScreenChangePwlCurves(int link, uint32_t v);
static void ScreenChangeCanvasSizeAuto(int link, uint32_t v);
static void ScreenChangeCanvasSize(int link, uint32_t v);
static void ScreenChangeShadedTriangles(int link, uint32_t v);

static void ScreenAllowRedundant(int link, uint32_t v);

static void ScreenStepDimSteps(int link, uint32_t v);
static void ScreenStepDimFinish(int link, uint32_t v);
static void ScreenStepDimGo(int link, uint32_t v);

static void ScreenChangeTangentArc(int link, uint32_t v);

static void ScreenPasteTransformed(int link, uint32_t v);

static void ScreenHome(int link, uint32_t v);

// These ones do stuff with the edit control
static void ScreenChangeExprA(int link, uint32_t v);
static void ScreenChangeGroupName(int link, uint32_t v);
static void ScreenChangeGroupScale(int link, uint32_t v);
static void ScreenChangeLightDirection(int link, uint32_t v);
static void ScreenChangeLightIntensity(int link, uint32_t v);
static void ScreenChangeColor(int link, uint32_t v);
static void ScreenChangeChordTolerance(int link, uint32_t v);
static void ScreenChangeMaxSegments(int link, uint32_t v);
static void ScreenChangeExportChordTolerance(int link, uint32_t v);
static void ScreenChangeExportMaxSegments(int link, uint32_t v);
static void ScreenChangeCameraTangent(int link, uint32_t v);
static void ScreenChangeGridSpacing(int link, uint32_t v);
static void ScreenChangeDigitsAfterDecimal(int link, uint32_t v);
static void ScreenChangeExportScale(int link, uint32_t v);
static void ScreenChangeExportOffset(int link, uint32_t v);
static void ScreenChangeGCodeParameter(int link, uint32_t v);
static void ScreenChangeAutosaveInterval(int link, uint32_t v);
static void ScreenChangeStyleName(int link, uint32_t v);
static void ScreenChangeStyleMetric(int link, uint32_t v);
static void ScreenChangeStyleTextAngle(int link, uint32_t v);
static void ScreenChangeStyleColor(int link, uint32_t v);
static void ScreenChangeBackgroundColor(int link, uint32_t v);
static void ScreenChangePasteTransformed(int link, uint32_t v);
static void ScreenChangeViewScale(int link, uint32_t v);
static void ScreenChangeViewToFullScale(int link, uint32_t v);
static void ScreenChangeViewOrigin(int link, uint32_t v);
static void ScreenChangeViewProjection(int link, uint32_t v);

bool EditControlDoneForStyles(const char *s);
bool EditControlDoneForConfiguration(const char *s);
bool EditControlDoneForPaste(const char *s);
bool EditControlDoneForView(const char *s);
void EditControlDone(const char *s);
</t>
<t tx="leo1.20171224221606.52">class GraphicsWindow {
public:
    void Init();

    typedef void MenuHandler(Command id);
    enum {
        ESCAPE_KEY = 27,
        DELETE_KEY = 127,
        FUNCTION_KEY_BASE = 0xf0
    };
    enum {
        SHIFT_MASK = 0x100,
        CTRL_MASK  = 0x200
    };
    enum class MenuKind : uint32_t {
        NORMAL = 0,
        CHECK,
        RADIO
    };
    @others
</t>
<t tx="leo1.20171224221606.53">typedef struct {
    int          level;          // 0 == on menu bar, 1 == one level down
    const char  *label;          // or NULL for a separator
    Command      id;             // unique ID
    int          accel;          // keyboard accelerator
    MenuKind     kind;
    MenuHandler  *fn;
} MenuEntry;
static const MenuEntry menu[];
static void MenuView(Command id);
static void MenuEdit(Command id);
static void MenuRequest(Command id);
void DeleteSelection();
void CopySelection();
void PasteClipboard(Vector trans, double theta, double scale);
static void MenuClipboard(Command id);

std::shared_ptr&lt;ViewportCanvas&gt; canvas;
std::shared_ptr&lt;BatchCanvas&gt;    persistentCanvas;
bool persistentDirty;

// The width and height (in pixels) of the window.
double width, height;
// These parameters define the map from 2d screen coordinates to the
// coordinates of the 3d sketch points. We will use an axonometric
// projection.
Vector  offset;
Vector  projRight;
Vector  projUp;
double  scale;
struct {
    bool    mouseDown;
    Vector  offset;
    Vector  projRight;
    Vector  projUp;
    Point2d mouse;
    Point2d mouseOnButtonDown;
    Vector  marqueePoint;
    bool    startedMoving;
}       orig;
// We need to detect when the projection is changed to invalidate
// caches for drawn items.
struct {
    Vector  offset;
    Vector  projRight;
    Vector  projUp;
    double  scale;
}       cached;

// Most recent mouse position, updated every time the mouse moves.
Point2d currentMousePosition;

// When the user is dragging a point, don't solve multiple times without
// allowing a paint in between. The extra solves are wasted if they're
// not displayed.
bool    havePainted;

// Some state for the context menu.
struct {
    bool        active;
}       context;

Camera GetCamera() const;
Lighting GetLighting() const;

void NormalizeProjectionVectors();
Point2d ProjectPoint(Vector p);
Vector ProjectPoint3(Vector p);
Vector ProjectPoint4(Vector p, double *w);
Vector UnProjectPoint(Point2d p);
Vector UnProjectPoint3(Vector p);
void AnimateOnto(Quaternion quatf, Vector offsetf);
void AnimateOntoWorkplane();
Vector VectorFromProjs(Vector rightUpForward);
void HandlePointForZoomToFit(Vector p, Point2d *pmax, Point2d *pmin,
bool LockedInWorkplane();
void SetWorkplaneFreeIn3d();
hEntity ActiveWorkplane();
void ForceTextWindowShown();

// Operations that must be completed by doing something with the mouse
// are noted here.
enum class Pending : uint32_t {
    NONE                        = 0,
    COMMAND                     = 1,
    DRAGGING_POINTS             = 2,
    DRAGGING_NEW_POINT          = 3,
    DRAGGING_NEW_LINE_POINT     = 4,
    DRAGGING_NEW_CUBIC_POINT    = 5,
    DRAGGING_NEW_ARC_POINT      = 6,
    DRAGGING_CONSTRAINT         = 7,
    DRAGGING_RADIUS             = 8,
    DRAGGING_NORMAL             = 9,
    DRAGGING_NEW_RADIUS         = 10,
    DRAGGING_MARQUEE            = 11,
};

struct {
    Pending              operation;
    Command              command;

    hRequest             request;
    hEntity              point;
    List&lt;hEntity&gt;        points;
    List&lt;hRequest&gt;       requests;
    hEntity              circle;
    hEntity              normal;
    hConstraint          constraint;

    const char          *description;
    Platform::Path       filename;

    bool                 hasSuggestion;
    Constraint::Type     suggestion;
} pending;
void ClearPending();
bool IsFromPending(hRequest r);
void AddToPending(hRequest r);
void ReplacePending(hRequest before, hRequest after);

// The constraint that is being edited with the on-screen textbox.
hConstraint constraintBeingEdited;

bool SuggestLineConstraint(hRequest lineSegment, ConstraintBase::Type *type);

Vector SnapToGrid(Vector p);
Vector SnapToEntityByScreenPoint(Point2d pp, hEntity he);
bool ConstrainPointByHovered(hEntity pt, const Point2d *projected = NULL);
void DeleteTaggedRequests();
hRequest AddRequest(Request::Type type, bool rememberForUndo);
hRequest AddRequest(Request::Type type);

</t>
<t tx="leo1.20171224221606.54">class ParametricCurve {
public:
    bool isLine; // else circle
    Vector p0, p1;
    Vector u, v;
    double r, theta0, theta1, dtheta;

    void MakeFromEntity(hEntity he, bool reverse);
    Vector PointAt(double t);
    Vector TangentAt(double t);
    double LengthForAuto();

    hRequest CreateRequestTrimmedTo(double t, bool extraConstraints,
        hEntity orig, hEntity arc, bool arcFinish);
    void ConstrainPointIfCoincident(hEntity hpt);
};
void MakeTangentArc();
void SplitLinesOrCurves();
hEntity SplitEntity(hEntity he, Vector pinter);
hEntity SplitLine(hEntity he, Vector pinter);
hEntity SplitCircle(hEntity he, Vector pinter);
hEntity SplitCubic(hEntity he, Vector pinter);
void ReplacePointInConstraints(hEntity oldpt, hEntity newpt);
void RemoveConstraintsForPointBeingDeleted(hEntity hpt);
void FixConstraintsForRequestBeingDeleted(hRequest hr);
void FixConstraintsForPointBeingDeleted(hEntity hpt);

// A selected entity.
</t>
<t tx="leo1.20171224221606.55">class Selection {
public:
    int         tag;

    hEntity     entity;
    hConstraint constraint;
    bool        emphasized;

    void Draw(bool isHovered, Canvas *canvas);

    void Clear();
    bool IsEmpty();
    bool Equals(Selection *b);
    bool HasEndpoints();
};

// A hovered entity, with its location relative to the cursor.
</t>
<t tx="leo1.20171224221606.56">class Hover {
public:
    int         zIndex;
    double      distance;
    Selection   selection;
};

List&lt;Hover&gt; hoverList;
Selection hover;
bool hoverWasSelectedOnMousedown;
List&lt;Selection&gt; selection;

Selection ChooseFromHoverToSelect();
Selection ChooseFromHoverToDrag();
void HitTestMakeSelection(Point2d mp);
void ClearSelection();
void ClearNonexistentSelectionItems();
struct {
    std::vector&lt;hEntity&gt;     point;
    std::vector&lt;hEntity&gt;     entity;
    std::vector&lt;hEntity&gt;     anyNormal;
    std::vector&lt;hEntity&gt;     vector;
    std::vector&lt;hEntity&gt;     face;
    std::vector&lt;hConstraint&gt; constraint;
    int         points;
    int         entities;
    int         workplanes;
    int         faces;
    int         lineSegments;
    int         circlesOrArcs;
    int         arcs;
    int         cubics;
    int         periodicCubics;
    int         anyNormals;
    int         vectors;
    int         constraints;
    int         stylables;
    int         constraintLabels;
    int         withEndpoints;
    int         n;
} gs;
void GroupSelection();
bool IsSelected(Selection *s);
bool IsSelected(hEntity he);
void MakeSelected(hEntity he);
void MakeSelected(hConstraint hc);
void MakeSelected(Selection *s);
void MakeUnselected(hEntity he, bool coincidentPointTrick);
void MakeUnselected(Selection *s, bool coincidentPointTrick);
void SelectByMarquee();
void ClearSuper();

void ContextMenuListStyles();
int64_t contextMenuCancelTime;

// The toolbar, in toolbar.cpp
bool ToolbarDrawOrHitTest(int x, int y, UiCanvas *canvas, Command *menuHit);
void ToolbarDraw(UiCanvas *canvas);
bool ToolbarMouseMoved(int x, int y);
bool ToolbarMouseDown(int x, int y);
static void TimerCallback();
Command toolbarHovered;
Command toolbarTooltipped;
int toolbarMouseX, toolbarMouseY;

// This sets what gets displayed.
bool    showWorkplanes;
bool    showNormals;
bool    showPoints;
bool    showConstraints;
bool    showTextWindow;
bool    showShaded;
bool    showEdges;
bool    showOutlines;
bool    showFaces;
bool    showMesh;
void ToggleBool(bool *v);

enum class DrawOccludedAs { INVISIBLE, STIPPLED, VISIBLE };
DrawOccludedAs drawOccludedAs;

bool    showSnapGrid;
void DrawSnapGrid(Canvas *canvas);

void AddPointToDraggedList(hEntity hp);
void StartDraggingByEntity(hEntity he);
void StartDraggingBySelection();
void UpdateDraggedNum(Vector *pos, double mx, double my);
void UpdateDraggedPoint(hEntity hp, double mx, double my);

void DrawEntities(Canvas *canvas, bool persistent);
void DrawPersistent(Canvas *canvas);
void Draw(Canvas *canvas);

// These are called by the platform-specific code.
void Paint();
void MouseMoved(double x, double y, bool leftDown, bool middleDown,

int64_t lastSpaceNavigatorTime;
hGroup lastSpaceNavigatorGroup;
void SpaceNavigatorMoved(double tx, double ty, double tz,
</t>
<t tx="leo1.20171224221606.57"></t>
<t tx="leo1.20171224221606.58">//-----------------------------------------------------------------------------
// Platform-dependent functionality.
//
// Copyright 2017 whitequark
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_PLATFORM_H
#define SOLVESPACE_PLATFORM_H

namespace Platform {

// UTF-8  UTF-16 conversion, for Windows.
#if defined(WIN32)
std::string Narrow(const wchar_t *s);
std::wstring Widen(const char *s);
std::string Narrow(const std::wstring &amp;s);
std::wstring Widen(const std::string &amp;s);
#endif

// A filesystem path, respecting the conventions of the current platform.
// Transformation functions return an empty path on error.
@others
@language c
@tabwidth -4
</t>
<t tx="leo1.20171224221606.59">class Path {
public:
    std::string raw;

    static Path From(std::string raw);
    static Path CurrentDirectory();

    void Clear() { raw.clear(); }

    bool Equals(const Path &amp;other) const;
    bool IsEmpty() const { return raw.empty(); }
    bool IsAbsolute() const;
    bool HasExtension(std::string ext) const;

    std::string FileName() const;
    std::string FileStem() const;
    std::string Extension() const;

    Path WithExtension(std::string ext) const;
    Path Parent() const;
    Path Join(const std::string &amp;component) const;
    Path Join(const Path &amp;other) const;
    Path Expand(bool fromCurrentDirectory = false) const;
    Path RelativeTo(const Path &amp;base) const;

    // Converting to and from a platform-independent representation
    // (conventionally, the Unix one).
    static Path FromPortable(const std::string &amp;repr);
    std::string ToPortable() const;
};

struct PathLess {
    bool operator()(const Path &amp;a, const Path &amp;b) const { return a.raw &lt; b.raw; }
};

// File manipulation functions.
FILE *OpenFile(const Platform::Path &amp;filename, const char *mode);
bool ReadFile(const Platform::Path &amp;filename, std::string *data);
bool WriteFile(const Platform::Path &amp;filename, const std::string &amp;data);
void RemoveFile(const Platform::Path &amp;filename);

// Resource loading function.
const void *LoadResource(const std::string &amp;name, size_t *size);

}

#endif
</t>
<t tx="leo1.20171224221606.6">    void Clear() {}
};


class hConstraint {
public:
    uint32_t v;

    inline hEquation equation(int i) const;
    inline hParam param(int i) const;
</t>
<t tx="leo1.20171224221606.60"></t>
<t tx="leo1.20171224221606.61">//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 shader interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#ifndef SOLVESPACE_GL3SHADER_H
#define SOLVESPACE_GL3SHADER_H

#ifdef WIN32
#   define GL_APICALL /*static linkage*/
#   define GL_GLEXT_PROTOTYPES
#   include &lt;GLES2/gl2.h&gt;
#   include &lt;GLES2/gl2ext.h&gt;
#   define HAVE_GLES
#elif __APPLE__
#   include &lt;OpenGL/gl.h&gt;
#else
#   define GL_GLEXT_PROTOTYPES
#   include &lt;GL/gl.h&gt;
#   include &lt;GL/glext.h&gt;
#endif

#if !defined(HAVE_GLES)
// glDepthRange is in GL1+ but not GLES2, glDepthRangef is in GL4.1+ and GLES2.
// Consistency!
#   define glClearDepthf glClearDepth
#   define glDepthRangef glDepthRange
#endif

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Floating-point data structures; the layout of these must match shaders
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.62">class Vector2f {
public:
    float x, y;

    static Vector2f From(float x, float y);
    static Vector2f From(double x, double y);
    static Vector2f FromInt(uint32_t x, uint32_t y);
};

</t>
<t tx="leo1.20171224221606.63">class Vector3f {
public:
    float x, y, z;

    static Vector3f From(float x, float y, float z);
    static Vector3f From(const Vector &amp;v);
    static Vector3f From(const RgbaColor &amp;c);
};

</t>
<t tx="leo1.20171224221606.64">class Vector4f {
public:
    float x, y, z, w;

    static Vector4f From(float x, float y, float z, float w);
    static Vector4f From(const Vector &amp;v, float w);
    static Vector4f FromInt(uint32_t x, uint32_t y, uint32_t z, uint32_t w);
    static Vector4f From(const RgbaColor &amp;c);
};

//-----------------------------------------------------------------------------
// Wrappers for our shaders
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221606.65">class Shader {
public:
    GLuint program;

    void Init(const std::string &amp;vertexRes,
    void SetUniformTextureUnit(const char *name, GLint index);
    void Enable() const;
    void Disable() const;
};

</t>
<t tx="leo1.20171224221606.66">class MeshRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_NOR = 1;
    const GLint ATTRIB_COL = 2;

    struct MeshVertex {
        Vector3f    pos;
        Vector3f    nor;
        Vector4f    col;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLsizei     size;
    };

    Shader  lightShader;
    Shader  fillShader;
    Shader *selectedShader;

    void Init();
    void Clear();

    Handle Add(const SMesh &amp;m, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle, bool useColors = true, RgbaColor overrideColor = {});
    void Draw(const SMesh &amp;mesh, bool useColors = true, RgbaColor overrideColor = {});

    void SetModelview(double *matrix);
    void SetProjection(double *matrix);

    void UseShaded(const Lighting &amp;lighting);
    void UseFilled(const Canvas::Fill &amp;fill);
};

</t>
<t tx="leo1.20171224221606.67">class StippleAtlas {
public:
    std::vector&lt;GLint&gt; patterns;

    void Init();
    void Clear();

    GLint GetTexture(StipplePattern pattern) const;
    double GetLength(StipplePattern pattern) const;
};

</t>
<t tx="leo1.20171224221606.68">class EdgeRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_LOC = 1;
    const GLint ATTRIB_TAN = 2;

    struct EdgeVertex {
        Vector3f    pos;
        Vector3f    loc;
        Vector3f    tan;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader              shader;

    const StippleAtlas  *atlas;
    StipplePattern      pattern;

    void Init(const StippleAtlas *atlas);
    void Clear();

    Handle Add(const SEdgeList &amp;edges, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle);
    void Draw(const SEdgeList &amp;edges);

    void SetModelview(double *matrix);
    void SetProjection(double *matrix);
    void SetStroke(const Canvas::Stroke &amp;stroke, double pixel);
};

</t>
<t tx="leo1.20171224221606.69">class OutlineRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_LOC = 1;
    const GLint ATTRIB_TAN = 2;
    const GLint ATTRIB_NOL = 3;
    const GLint ATTRIB_NOR = 4;

    struct OutlineVertex {
        Vector3f    pos;
        Vector4f    loc;
        Vector3f    tan;
        Vector3f    nol;
        Vector3f    nor;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader              shader;

    const StippleAtlas  *atlas;
    StipplePattern      pattern;

    void Init(const StippleAtlas *atlas);
    void Clear();

    Handle Add(const SOutlineList &amp;outlines, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle, Canvas::DrawOutlinesAs mode);
    void Draw(const SOutlineList &amp;outlines, Canvas::DrawOutlinesAs mode);

    void SetModelview(double *matrix);
    void SetProjection(double *matrix);
    void SetStroke(const Canvas::Stroke &amp;stroke, double pixel);
};

</t>
<t tx="leo1.20171224221606.7">class ConstraintBase {
public:
    int         tag;
    hConstraint h;

    static const hConstraint NO_CONSTRAINT;

    enum class Type : uint32_t {
        POINTS_COINCIDENT      =  20,
        PT_PT_DISTANCE         =  30,
        PT_PLANE_DISTANCE      =  31,
        PT_LINE_DISTANCE       =  32,
        PT_FACE_DISTANCE       =  33,
        PROJ_PT_DISTANCE       =  34,
        PT_IN_PLANE            =  41,
        PT_ON_LINE             =  42,
        PT_ON_FACE             =  43,
        EQUAL_LENGTH_LINES     =  50,
        LENGTH_RATIO           =  51,
        EQ_LEN_PT_LINE_D       =  52,
        EQ_PT_LN_DISTANCES     =  53,
        EQUAL_ANGLE            =  54,
        EQUAL_LINE_ARC_LEN     =  55,
        LENGTH_DIFFERENCE      =  56,
        SYMMETRIC              =  60,
        SYMMETRIC_HORIZ        =  61,
        SYMMETRIC_VERT         =  62,
        SYMMETRIC_LINE         =  63,
        AT_MIDPOINT            =  70,
        HORIZONTAL             =  80,
        VERTICAL               =  81,
        DIAMETER               =  90,
        PT_ON_CIRCLE           = 100,
        SAME_ORIENTATION       = 110,
        ANGLE                  = 120,
        PARALLEL               = 121,
        PERPENDICULAR          = 122,
        ARC_LINE_TANGENT       = 123,
        CUBIC_LINE_TANGENT     = 124,
        CURVE_CURVE_TANGENT    = 125,
        EQUAL_RADIUS           = 130,
        WHERE_DRAGGED          = 200,

        COMMENT                = 1000
    };

    Type        type;

    hGroup      group;
    hEntity     workplane;

    // These are the parameters for the constraint.
    double      valA;
    hParam      valP;
    hEntity     ptA;
    hEntity     ptB;
    hEntity     entityA;
    hEntity     entityB;
    hEntity     entityC;
    hEntity     entityD;
    bool        other;
    bool        other2;

    bool        reference;  // a ref dimension, that generates no eqs
    std::string comment;    // since comments are represented as constraints

    bool HasLabel() const;

    void Generate(IdList&lt;Param, hParam&gt; *param);

    void GenerateEquations(IdList&lt;Equation,hEquation&gt; *entity,
    static ExprVector PointInThreeSpace(hEntity workplane, Expr *u, Expr *v);

    @others
};

</t>
<t tx="leo1.20171224221606.70">class SIndexedMesh {
public:
    struct Vertex {
        Vector3f    pos;
        Vector2f    tex;
    };

    std::vector&lt;Vertex&gt;   vertices;
    std::vector&lt;uint32_t&gt; indices;

    void AddPoint(const Vector &amp;p);
    void AddQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d);
    @others
};

}

#endif
</t>
<t tx="leo1.20171224221606.71">    void AddPixmap(const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                   const Point2d &amp;ta, const Point2d &amp;tb);

    void Clear();
};

class IndexedMeshRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_TEX = 1;

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader  texShader;
    Shader  texaShader;
    Shader  colShader;
    Shader  pointShader;

    Shader  *selectedShader;

    void Init();
    void Clear();

    Handle Add(const SIndexedMesh &amp;m, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle);
    void Draw(const SIndexedMesh &amp;mesh);

    void SetModelview(double *matrix);
    void SetProjection(double *matrix);

    bool NeedsTexture() const;

    void UseFilled(const Canvas::Fill &amp;fill);
    void UsePoint(const Canvas::Stroke &amp;stroke, double pixel);
</t>
<t tx="leo1.20171224221606.72">//-----------------------------------------------------------------------------
// Backend-agnostic rendering interface, and various backends we use.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_RENDER_H
#define SOLVESPACE_RENDER_H

//-----------------------------------------------------------------------------
// Interfaces and utilities common for all renderers.
//-----------------------------------------------------------------------------

enum class StipplePattern : uint32_t;

// A mapping from 3d sketch coordinates to 2d screen coordinates, using
// an axonometric projection.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.73">class Camera {
public:
    size_t      width, height;
    Vector      offset;
    Vector      projRight;
    Vector      projUp;
    double      scale;
    double      tangent;
    bool        hasPixels;

    bool IsPerspective() const { return tangent != 0.0; }

    Point2d ProjectPoint(Vector p) const;
    Vector ProjectPoint3(Vector p) const;
    Vector ProjectPoint4(Vector p, double *w) const;
    Vector UnProjectPoint(Point2d p) const;
    Vector UnProjectPoint3(Vector p) const;
    Vector VectorFromProjs(Vector rightUpForward) const;
    Vector AlignToPixelGrid(Vector v) const;

    SBezier ProjectBezier(SBezier b) const;

    void LoadIdentity();
    void NormalizeProjectionVectors();
};

// A description of scene lighting.
</t>
<t tx="leo1.20171224221606.74">class Lighting {
public:
    RgbaColor   backgroundColor;
    double      ambientIntensity;
    double      lightIntensity[2];
    Vector      lightDirection[2];
};

class BatchCanvas;

// An interface for populating a drawing area with geometry.
</t>
<t tx="leo1.20171224221606.75">class Canvas {
public:
    // Stroke and fill styles are addressed with handles to be able to quickly
    // group geometry into indexed draw calls.
    @others
};

// An interface for view-independent visualization.
</t>
<t tx="leo1.20171224221606.76">class hStroke {
public:
    uint32_t v;
};

</t>
<t tx="leo1.20171224221606.77">class hFill {
public:
    uint32_t v;
};

// The layer of a geometry describes how it occludes other geometry.
// Within a layer, geometry with higher z-index occludes geometry with lower z-index,
// or geometry drawn earlier if z-indexes match.
enum class Layer {
    NORMAL,     // Occluded by geometry with lower Z coordinate
    OCCLUDED,   // Only drawn over geometry with lower Z coordinate
    DEPTH_ONLY, // Like NORMAL, but only affects future occlusion, not color
    BACK,       // Always drawn below all other geometry
    FRONT,      // Always drawn above all other geometry
    LAST = FRONT
};

// The outlines are the collection of all edges that may be drawn.
// Outlines can be classified as emphasized or not; emphasized outlines indicate an abrupt
// change in the surface curvature. These are indicated by the SOutline tag.
// Outlines can also be classified as contour or not; contour outlines indicate the boundary
// of the filled mesh. Whether an outline is a part of contour or not depends on point of view.
enum class DrawOutlinesAs {
    EMPHASIZED_AND_CONTOUR      = 0, // Both emphasized and contour outlines
    EMPHASIZED_WITHOUT_CONTOUR  = 1, // Emphasized outlines except those also belonging to contour
    CONTOUR_ONLY                = 2  // Contour outlines only
};

// Stroke widths, etc, can be scale-invariant (in pixels) or scale-dependent (in millimeters).
enum class Unit {
    MM,
    PX
};

</t>
<t tx="leo1.20171224221606.78">class Stroke {
public:
    hStroke         h;

    Layer           layer;
    int             zIndex;
    RgbaColor       color;
    double          width;
    Unit            unit;
    StipplePattern  stipplePattern;
    double          stippleScale;

    void Clear() { *this = {}; }
    bool Equals(const Stroke &amp;other) const;

    double WidthMm(const Camera &amp;camera) const;
    double WidthPx(const Camera &amp;camera) const;
    double StippleScaleMm(const Camera &amp;camera) const;
    double StippleScalePx(const Camera &amp;camera) const;
};

enum class FillPattern {
    SOLID, CHECKERED_A, CHECKERED_B
};

</t>
<t tx="leo1.20171224221606.79">class Fill {
public:
    hFill           h;

    Layer           layer;
    int             zIndex;
    RgbaColor       color;
    FillPattern     pattern;
    std::shared_ptr&lt;const Pixmap&gt; texture;

    void Clear() { *this = {}; }
    bool Equals(const Fill &amp;other) const;
};

IdList&lt;Stroke, hStroke&gt; strokes;
IdList&lt;Fill,   hFill&gt;   fills;
BitmapFont bitmapFont;

Canvas() : strokes(), fills(), bitmapFont() {}
virtual void Clear();

hStroke GetStroke(const Stroke &amp;stroke);
hFill GetFill(const Fill &amp;fill);
BitmapFont *GetBitmapFont();

virtual const Camera &amp;GetCamera() const = 0;

virtual void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) = 0;
virtual void DrawEdges(const SEdgeList &amp;el, hStroke hcs) = 0;
virtual bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) = 0;
virtual void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) = 0;
virtual void DrawVectorText(const std::string &amp;text, double height,
                            const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
</t>
<t tx="leo1.20171224221606.8">    void Clear() {}
};

class Constraint : public ConstraintBase {
public:
    // See Entity::Entity().
    Constraint() : ConstraintBase({}), disp() {}

    // These define how the constraint is drawn on-screen.
    struct {
        Vector      offset;
        hStyle      style;
    } disp;

    bool IsVisible() const;
    bool IsStylable() const;
    hStyle GetStyle() const;
    bool HasLabel() const;
    std::string Label() const;

    enum class DrawAs { DEFAULT, HOVERED, SELECTED };
    void Draw(DrawAs how, Canvas *canvas);
    Vector GetLabelPos(const Camera &amp;camera);
    void GetReferencePoints(const Camera &amp;camera, std::vector&lt;Vector&gt; *refs);

    void DoLayout(DrawAs how, Canvas *canvas,
    void DoLineWithArrows(Canvas *canvas, Canvas::hStroke hcs,

    void DoEqualLenTicks(Canvas *canvas, Canvas::hStroke hcs,

    static hConstraint ConstrainCoincident(hEntity ptA, hEntity ptB);
    static hConstraint Constrain(Constraint::Type type, hEntity ptA, hEntity ptB, hEntity entityA);
</t>
<t tx="leo1.20171224221606.80">                            const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                            const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) = 0;
    virtual void InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) = 0;

    virtual std::shared_ptr&lt;BatchCanvas&gt; CreateBatch();
};

// An interface for view-dependent visualization.
class ViewportCanvas : public Canvas {
public:
    virtual void SetCamera(const Camera &amp;camera) = 0;
    virtual void SetLighting(const Lighting &amp;lighting) = 0;

    virtual void NewFrame() = 0;
    virtual void FlushFrame() = 0;
    virtual std::shared_ptr&lt;Pixmap&gt; ReadFrame() = 0;

    virtual void GetIdent(const char **vendor, const char **renderer, const char **version) = 0;
</t>
<t tx="leo1.20171224221606.81">class BatchCanvas : public Canvas {
public:
    const Camera &amp;GetCamera() const override;

    virtual void Finalize() = 0;
    virtual void Draw() = 0;
};

// A wrapper around Canvas that simplifies drawing UI in screen coordinates.
</t>
<t tx="leo1.20171224221606.82">class UiCanvas {
public:
    std::shared_ptr&lt;Canvas&gt; canvas;
    bool                    flip;

    void DrawLine(int x1, int y1, int x2, int y2, RgbaColor color, int width = 1,
    int Flip(int y) const { return flip ? (int)canvas-&gt;GetCamera().height - y : y; }
};

// A canvas that performs picking against drawn geometry.
</t>
<t tx="leo1.20171224221606.83">class ObjectPicker : public Canvas {
public:
    Camera      camera;
    // Configuration.
    Point2d     point;
    double      selRadius;
    // Picking state.
    double      minDistance;
    int         maxZIndex;
    uint32_t    position;

    ObjectPicker() : camera(), point(), selRadius(),
                     minDistance(), maxZIndex(), position() {}

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
    void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,

// A canvas that renders onto a 2d surface, performing z-index sorting, occlusion testing, etc,
// on the CPU.
@others
</t>
<t tx="leo1.20171224221606.84">class SurfaceRenderer : public Canvas {
public:
    Camera      camera;
    Lighting    lighting;
    // Chord tolerance, for converting beziers to pwl.
    double      chordTolerance;
    // Render lists.
    handle_map&lt;hStroke, SEdgeList&gt;   edges;
    handle_map&lt;hStroke, SBezierList&gt; beziers;
    SMesh       mesh;
    // State.
    BBox        bbox;

    SurfaceRenderer() : camera(), lighting(), chordTolerance(), mesh(), bbox() {}
    void Clear() override;

    // Canvas interface.
    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override;
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
    void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
    void OutputInPaintOrder();

    virtual bool CanOutputCurves() const = 0;
    virtual bool CanOutputTriangles() const = 0;

    virtual void OutputStart() = 0;
    virtual void OutputBezier(const SBezier &amp;b, hStroke hcs) = 0;
    virtual void OutputTriangle(const STriangle &amp;tr) = 0;
    virtual void OutputEnd() = 0;

    void OutputBezierAsNonrationalCubic(const SBezier &amp;b, hStroke hcs);
};

//-----------------------------------------------------------------------------
// 2d renderers.
//-----------------------------------------------------------------------------

</t>
<t tx="leo1.20171224221606.85">class CairoRenderer : public SurfaceRenderer {
public:
    cairo_t     *context;
    // Renderer configuration.
    bool        antialias;
    // Renderer state.
    struct {
        hStroke     hcs;
    } current;

    CairoRenderer() : context(), current() {}

    void SelectStroke(hStroke hcs);
    void MoveTo(Vector p);
    void FinishPath();

    bool CanOutputCurves() const override { return true; }
    bool CanOutputTriangles() const override { return true; }

    void OutputStart() override;
    void OutputBezier(const SBezier &amp;b, hStroke hcs) override;
    void OutputTriangle(const STriangle &amp;tr) override;
    void OutputEnd() override;
};

//-----------------------------------------------------------------------------
// 3d renderers.
//-----------------------------------------------------------------------------

// An offscreen renderer based on OpenGL framebuffers.
</t>
<t tx="leo1.20171224221606.86">class GlOffscreen {
public:
    unsigned int          framebuffer;
    unsigned int          colorRenderbuffer, depthRenderbuffer;
    std::vector&lt;uint8_t&gt;  data;

    bool Render(int width, int height, std::function&lt;void()&gt; renderFn);
    void Clear();
};

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer();

#endif
</t>
<t tx="leo1.20171224221606.87"></t>
<t tx="leo1.20171224221606.88">//-----------------------------------------------------------------------------
// Functions relating to rational polynomial surfaces, which are trimmed by
// curves (either rational polynomial curves, or piecewise linear
// approximations to curves of intersection that can't be represented
// exactly in ratpoly form), and assembled into watertight shells.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef __SURFACE_H
#define __SURFACE_H

// Utility functions, Bernstein polynomials of order 1-3 and their derivatives.
double Bernstein(int k, int deg, double t);
double BernsteinDerivative(int k, int deg, double t);

class SBezierList;
class SSurface;
class SCurvePt;

// Utility data structure, a two-dimensional BSP to accelerate polygon
// operations.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo1.20171224221606.89">class SBspUv {
public:
    Point2d  a, b;

    SBspUv  *pos;
    SBspUv  *neg;

    SBspUv  *more;

    enum class Class : uint32_t {
        INSIDE            = 100,
        OUTSIDE           = 200,
        EDGE_PARALLEL     = 300,
        EDGE_ANTIPARALLEL = 400,
        EDGE_OTHER        = 500
    };

    static SBspUv *Alloc();
    static SBspUv *From(SEdgeList *el, SSurface *srf);

    void ScalePoints(Point2d *pt, Point2d *a, Point2d *b, SSurface *srf) const;
    double ScaledSignedDistanceToLine(Point2d pt, Point2d a, Point2d b,

// Now the data structures to represent a shell of trimmed rational polynomial
// surfaces.

class SShell;

</t>
<t tx="leo1.20171224221606.9">    static hConstraint Constrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                    hEntity entityA, hEntity entityB,
                                    bool other, bool other2);
};

class hEquation {
public:
    uint32_t v;

    inline bool isFromConstraint() const;
    inline hConstraint constraint() const;
</t>
<t tx="leo1.20171224221606.90">class hSSurface {
public:
    uint32_t v;
};

</t>
<t tx="leo1.20171224221606.91">class hSCurve {
public:
    uint32_t v;
};

// Stuff for rational polynomial curves, of degree one to three. These are
// our inputs, and are also calculated for certain exact surface-surface
// intersections.
</t>
<t tx="leo1.20171224221606.92">class SBezier {
public:
    int             tag;
    int             auxA, auxB;

    int             deg;
    Vector          ctrl[4];
    double          weight[4];
    uint32_t        entity;

    Vector PointAt(double t) const;
    Vector TangentAt(double t) const;
    void ClosestPointTo(Vector p, double *t, bool mustConverge=true) const;
    void SplitAt(double t, SBezier *bef, SBezier *aft) const;
    bool PointOnThisAndCurve(const SBezier *sbb, Vector *p) const;

    Vector Start() const;
    Vector Finish() const;
    bool Equals(SBezier *b) const;
    void MakePwlInto(SEdgeList *sel, double chordTol=0) const;
    void MakePwlInto(List&lt;SCurvePt&gt; *l, double chordTol=0) const;
    void MakePwlInto(SContour *sc, double chordTol=0) const;
    void MakePwlInto(List&lt;Vector&gt; *l, double chordTol=0) const;
    void MakePwlWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const;
    void MakePwlInitialWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const;
    void MakeNonrationalCubicInto(SBezierList *bl, double tolerance, int depth = 0) const;

    void AllIntersectionsWith(const SBezier *sbb, SPointList *spl) const;
    void GetBoundingProjd(Vector u, Vector orig, double *umin, double *umax) const;
    void Reverse();

    bool IsInPlane(Vector n, double d) const;
    bool IsCircle(Vector axis, Vector *center, double *r) const;
    bool IsRational() const;

    SBezier TransformedBy(Vector t, Quaternion q, double scale) const;
    SBezier InPerspective(Vector u, Vector v, Vector n,
                          Vector origin, double cameraTan) const;
    void ScaleSelfBy(double s);

    static SBezier From(Vector p0, Vector p1, Vector p2, Vector p3);
    static SBezier From(Vector p0, Vector p1, Vector p2);
    static SBezier From(Vector p0, Vector p1);
    static SBezier From(Vector4 p0, Vector4 p1, Vector4 p2, Vector4 p3);
    static SBezier From(Vector4 p0, Vector4 p1, Vector4 p2);
    static SBezier From(Vector4 p0, Vector4 p1);
};

</t>
<t tx="leo1.20171224221606.93">class SBezierList {
public:
    List&lt;SBezier&gt;   l;

    void Clear();
    void ScaleSelfBy(double s);
    void CullIdenticalBeziers();
    void AllIntersectionsWith(SBezierList *sblb, SPointList *spl) const;
    @others
</t>
<t tx="leo1.20171224221606.94">    bool GetPlaneContainingBeziers(Vector *p, Vector *u, Vector *v,
                                        Vector *notCoplanarAt) const;
};

class SBezierLoop {
public:
    int             tag;
    List&lt;SBezier&gt;   l;

    inline void Clear() { l.Clear(); }
    bool IsClosed() const;
    void Reverse();
    void MakePwlInto(SContour *sc, double chordTol=0) const;
    void GetBoundingProjd(Vector u, Vector orig, double *umin, double *umax) const;

</t>
<t tx="leo1.20171224221606.95">    static SBezierLoop FromCurves(SBezierList *spcl,
                                  bool *allClosed, SEdge *errorAt);
};

class SBezierLoopSet {
public:
    List&lt;SBezierLoop&gt; l;
    Vector normal;
    Vector point;
    double area;

    static SBezierLoopSet From(SBezierList *spcl, SPolygon *poly,
</t>
<t tx="leo1.20171224221606.96">class SBezierLoopSetSet {
public:
    List&lt;SBezierLoopSet&gt;    l;

    void FindOuterFacesFrom(SBezierList *sbl, SPolygon *spxyz, SSurface *srfuv,
public:
    int         tag;
    Vector      p;
    bool        vertex;
};

</t>
<t tx="leo1.20171224221606.97">class SCurve {
public:
    hSCurve         h;

    // In a Boolean, C = A op B. The curves in A and B get copied into C, and
    // therefore must get new hSCurves assigned. For the curves in A and B,
    // we use newH to record their new handle in C.
    hSCurve         newH;
    enum class Source : uint32_t {
        A             = 100,
        B             = 200,
        INTERSECTION  = 300
    };
    Source          source;

    bool            isExact;
    SBezier         exact;

    List&lt;SCurvePt&gt;  pts;

    hSSurface       surfA;
    hSSurface       surfB;

    static SCurve FromTransformationOf(SCurve *a, Vector t,
// A segment of a curve by which a surface is trimmed: indicates which curve,
// by its handle, and the starting and ending points of our segment of it.
// The vector out points out of the surface; it, the surface outer normal,
// and a tangent to the beginning of the curve are all orthogonal.
@others
</t>
<t tx="leo1.20171224221606.98">class STrimBy {
public:
    hSCurve     curve;
    bool        backwards;
    // If a trim runs backwards, then start and finish still correspond to
    // the actual start and finish, but they appear in reverse order in
    // the referenced curve.
    Vector      start;
    Vector      finish;

    static STrimBy EntireCurve(SShell *shell, hSCurve hsc, bool backwards);
};

// An intersection point between a line and a surface
</t>
<t tx="leo1.20171224221606.99">class SInter {
public:
    int         tag;
    Vector      p;
    SSurface    *srf;
    Point2d     pinter;
    Vector      surfNormal;     // of the intersecting surface, at pinter
    bool        onEdge;         // pinter is on edge of trim poly
};

// A rational polynomial surface in Bezier form.
</t>
<t tx="leo1.20171224221607.1">class SShell {
public:
    IdList&lt;SCurve,hSCurve&gt;      curve;
    IdList&lt;SSurface,hSSurface&gt;  surface;

    bool                        booleanFailed;

    void MakeFromExtrusionOf(SBezierLoopSet *sbls, Vector t0, Vector t1,
    void MakeClassifyingBsps(SShell *useCurvesFrom);
    void AllPointsIntersecting(Vector a, Vector b, List&lt;SInter&gt; *il,
        INSIDE     = 100,
        OUTSIDE    = 200,
        COINC_SAME = 300,
        COINC_OPP  = 400
    };
    static const double DOTP_TOL;
    Class ClassifyRegion(Vector edge_n, Vector inter_surf_n,
                       Vector edge_surf_n) const;

    bool ClassifyEdge(Class *indir, Class *outdir,
    void TriangulateInto(SMesh *sm);
    void MakeEdgesInto(SEdgeList *sel);
    void MakeSectionEdgesInto(Vector n, double d, SEdgeList *sel, SBezierList *sbl);
    bool IsEmpty() const;
    void RemapFaces(Group *g, int remap);
    void Clear();
};

#endif

</t>
<t tx="leo1.20171224221636.1">@auto failed: dsc.h
inserting @ignore
imported dsc.h
@auto failed: expr.h
inserting @ignore
imported expr.h
@auto failed: polygon.h
inserting @ignore
imported polygon.h
@auto failed: resource.h
inserting @ignore
imported resource.h
@auto failed: sketch.h
inserting @ignore
imported sketch.h
tabs found with @tabwidth -4 in solvespace.h
changed leading tabs to blanks in 2 lines in solvespace.h
@auto failed: solvespace.h
inserting @ignore
imported solvespace.h
@auto failed: ttf.h
inserting @ignore
imported ttf.h
@auto failed: ui.h
inserting @ignore
imported ui.h
importing directory: ./../src\platform
imported platform.h
importing directory: ./../src\render
@auto failed: gl3shader.h
inserting @ignore
imported gl3shader.h
@auto failed: render.h
inserting @ignore
imported render.h
importing directory: ./../src\srf
@auto failed: surface.h
inserting @ignore
imported surface.h
imported 179 nodes in 12 files in 2.51 seconds</t>
<t tx="leo1.20171224221913.1">https://en.wikipedia.org/wiki/Binary_space_partitioning</t>
</tnodes>
</leo_file>
